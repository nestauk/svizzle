import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, r as create_slot, v as validate_slots, ax as validate_store, aJ as component_subscribe, bw as setContext, K as makeStyleVars, by as writable, bx as set_store_value, e as element, f as claim_element, g as children, b as detach_dev, k as attr_dev, m as add_location, n as insert_hydration_dev, o as append_hydration_dev, y as update_slot_base, z as get_all_dirty_from_scope, A as get_slot_changes, u as transition_in, B as transition_out } from './client.c3033a77.js';

/* ../../components/ui/src/viewports/ViewsSlider.svelte generated by Svelte v3.59.2 */
const file = "../../components/ui/src/viewports/ViewsSlider.svelte";
function create_fragment(ctx) {
  let div1;
  let div0;
  let current;
  const default_slot_template = /*#slots*/ctx[8].default;
  const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ctx[7], null);
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {
        class: true
      });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {
        style: true,
        class: true
      });
      var div0_nodes = children(div0);
      if (default_slot) default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "style", /*style*/ctx[0]);
      attr_dev(div0, "class", "views svelte-3q15vl");
      add_location(div0, file, 27, 1, 550);
      attr_dev(div1, "class", "ViewsSlider svelte-3q15vl");
      add_location(div1, file, 26, 0, 523);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
    },
    p: function update(ctx, _ref) {
      let [dirty] = _ref;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/128)) {
          update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ctx[7], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[7]) : get_slot_changes(default_slot_template, /*$$scope*/ctx[7], dirty, null), null);
        }
      }
      if (!current || dirty & /*style*/1) {
        attr_dev(div0, "style", /*style*/ctx[0]);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(div1);
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let currentViewIndex;
  let style;
  let $_viewId;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ViewsSlider', slots, ['default']);
  let {
    viewId
  } = $$props;
  let viewsCount = 0;
  let indexByIdsMap = {};
  const _viewId = writable();
  validate_store(_viewId, '_viewId');
  component_subscribe($$self, _viewId, value => $$invalidate(6, $_viewId = value));
  const registerView = id => {
    $$invalidate(4, indexByIdsMap = {
      ...indexByIdsMap,
      [id]: $$invalidate(3, viewsCount++, viewsCount)
    });
  };
  setContext('viewport', {
    _viewId,
    registerView
  });
  $$self.$$.on_mount.push(function () {
    if (viewId === undefined && !('viewId' in $$props || $$self.$$.bound[$$self.$$.props['viewId']])) {
      console.warn("<ViewsSlider> was created without expected prop 'viewId'");
    }
  });
  const writable_props = ['viewId'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ViewsSlider> was created with unknown prop '${key}'`);
  });
  $$self.$$set = $$props => {
    if ('viewId' in $$props) $$invalidate(2, viewId = $$props.viewId);
    if ('$$scope' in $$props) $$invalidate(7, $$scope = $$props.$$scope);
  };
  $$self.$capture_state = () => ({
    makeStyleVars,
    setContext,
    writable,
    viewId,
    viewsCount,
    indexByIdsMap,
    _viewId,
    registerView,
    currentViewIndex,
    style,
    $_viewId
  });
  $$self.$inject_state = $$props => {
    if ('viewId' in $$props) $$invalidate(2, viewId = $$props.viewId);
    if ('viewsCount' in $$props) $$invalidate(3, viewsCount = $$props.viewsCount);
    if ('indexByIdsMap' in $$props) $$invalidate(4, indexByIdsMap = $$props.indexByIdsMap);
    if ('currentViewIndex' in $$props) $$invalidate(5, currentViewIndex = $$props.currentViewIndex);
    if ('style' in $$props) $$invalidate(0, style = $$props.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*viewId*/4) {
      set_store_value(_viewId, $_viewId = viewId, $_viewId);
    }
    if ($$self.$$.dirty & /*indexByIdsMap, $_viewId*/80) {
      $$invalidate(5, currentViewIndex = indexByIdsMap[$_viewId] ?? 1);
    }
    if ($$self.$$.dirty & /*currentViewIndex, viewsCount*/40) {
      $$invalidate(0, style = makeStyleVars({
        currentViewIndex,
        viewsCount
      }));
    }
  };
  return [style, _viewId, viewId, viewsCount, indexByIdsMap, currentViewIndex, $_viewId, $$scope, slots];
}
class ViewsSlider extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      viewId: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ViewsSlider",
      options,
      id: create_fragment.name
    });
  }
  get viewId() {
    throw new Error("<ViewsSlider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set viewId(value) {
    throw new Error("<ViewsSlider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
var ViewsSlider$1 = ViewsSlider;

export { ViewsSlider$1 as V };
