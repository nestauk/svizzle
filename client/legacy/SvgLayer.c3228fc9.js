import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, r as create_slot, v as validate_slots, bc as getContext, am as validate_store, av as component_subscribe, I as svg_element, J as claim_svg_element, g as children, b as detach_dev, k as attr_dev, bW as set_style, H as toggle_class, m as add_location, n as insert_hydration_dev, ax as action_destroyer, y as update_slot_base, z as get_all_dirty_from_scope, A as get_slot_changes, u as transition_in, B as transition_out, ay as binding_callbacks } from './client.fb549d0a.js';

/* ../../components/mapbox/src/SvgLayer.svelte generated by Svelte v3.59.2 */
const file = "../../components/mapbox/src/SvgLayer.svelte";
function create_fragment(ctx) {
  let svg;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = /*#slots*/ctx[6].default;
  const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ctx[5], null);
  const block = {
    c: function create() {
      svg = svg_element("svg");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        class: true,
        style: true
      });
      var svg_nodes = children(svg);
      if (default_slot) default_slot.l(svg_nodes);
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "class", "SvgLayers svelte-epk80b");
      set_style(svg, "z-index", /*order*/ctx[1]);
      toggle_class(svg, "disabled", ! /*isInteractive*/ctx[0]);
      add_location(svg, file, 20, 0, 345);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      if (default_slot) {
        default_slot.m(svg, null);
      }

      /*svg_binding*/
      ctx[7](svg);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(/*mapglLayer*/ctx[4].call(null, svg));
        mounted = true;
      }
    },
    p: function update(ctx, _ref) {
      let [dirty] = _ref;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/32)) {
          update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ctx[5], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[5]) : get_slot_changes(default_slot_template, /*$$scope*/ctx[5], dirty, null), null);
        }
      }
      if (!current || dirty & /*order*/2) {
        set_style(svg, "z-index", /*order*/ctx[1]);
      }
      if (!current || dirty & /*isInteractive*/1) {
        toggle_class(svg, "disabled", ! /*isInteractive*/ctx[0]);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(svg);
      if (default_slot) default_slot.d(detaching);
      /*svg_binding*/
      ctx[7](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let $_map;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('SvgLayer', slots, ['default']);
  let {
    isInteractive = true
  } = $$props;
  let {
    order
  } = $$props;
  const {
    _map
  } = getContext('mapBox');
  validate_store(_map, '_map');
  component_subscribe($$self, _map, value => $$invalidate(8, $_map = value));
  let customLayer;
  const mapglLayer = node => {
    const canvasContainer = $_map.getCanvasContainer();
    canvasContainer.append(node);
    return () => {
      canvasContainer.remove(node);
    };
  };
  $$self.$$.on_mount.push(function () {
    if (order === undefined && !('order' in $$props || $$self.$$.bound[$$self.$$.props['order']])) {
      console.warn("<SvgLayer> was created without expected prop 'order'");
    }
  });
  const writable_props = ['isInteractive', 'order'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<SvgLayer> was created with unknown prop '".concat(key, "'"));
  });
  function svg_binding($$value) {
    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
      customLayer = $$value;
      $$invalidate(2, customLayer);
    });
  }
  $$self.$$set = $$props => {
    if ('isInteractive' in $$props) $$invalidate(0, isInteractive = $$props.isInteractive);
    if ('order' in $$props) $$invalidate(1, order = $$props.order);
    if ('$$scope' in $$props) $$invalidate(5, $$scope = $$props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    isInteractive,
    order,
    _map,
    customLayer,
    mapglLayer,
    $_map
  });
  $$self.$inject_state = $$props => {
    if ('isInteractive' in $$props) $$invalidate(0, isInteractive = $$props.isInteractive);
    if ('order' in $$props) $$invalidate(1, order = $$props.order);
    if ('customLayer' in $$props) $$invalidate(2, customLayer = $$props.customLayer);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [isInteractive, order, customLayer, _map, mapglLayer, $$scope, slots, svg_binding];
}
class SvgLayer extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      isInteractive: 0,
      order: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SvgLayer",
      options,
      id: create_fragment.name
    });
  }
  get isInteractive() {
    throw new Error("<SvgLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isInteractive(value) {
    throw new Error("<SvgLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get order() {
    throw new Error("<SvgLayer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set order(value) {
    throw new Error("<SvgLayer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
var SvgLayer$1 = SvgLayer;

export { SvgLayer$1 as S };
