import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, r as create_slot, v as validate_slots, a as space, e as element, D as create_component, h as head_selector, b as detach_dev, c as claim_space, f as claim_element, g as children, E as claim_component, k as attr_dev, m as add_location, n as insert_hydration_dev, o as append_hydration_dev, F as mount_component, y as update_slot_base, z as get_all_dirty_from_scope, A as get_slot_changes, u as transition_in, B as transition_out, G as destroy_component, t as text, j as claim_text, p as noop } from './client.c3033a77.js';
import { H as HyperLink } from './HyperLink.47b34ea4.js';

/* src/routes/compounds/_layout.svelte generated by Svelte v3.59.2 */
const file = "src/routes/compounds/_layout.svelte";

// (11:2) <HyperLink    href='/svizzle/compounds/mapbox/empty'    rel='prefetch'   >
function create_default_slot_2(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text("@svizzle/mapbox");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t = claim_text(span_nodes, "@svizzle/mapbox");
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file, 14, 3, 222);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(11:2) <HyperLink    href='/svizzle/compounds/mapbox/empty'    rel='prefetch'   >",
    ctx
  });
  return block;
}

// (17:2) <HyperLink    href='/svizzle/compounds/time_region_value'    rel='prefetch'   >
function create_default_slot_1(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text("@svizzle/time_region_value");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t = claim_text(span_nodes, "@svizzle/time_region_value");
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file, 20, 3, 351);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(17:2) <HyperLink    href='/svizzle/compounds/time_region_value'    rel='prefetch'   >",
    ctx
  });
  return block;
}

// (23:2) <HyperLink    href='/svizzle/compounds/viewports/ViewsSlider'    rel='prefetch'   >
function create_default_slot(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text("@svizzle/ui: viewports");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      t = claim_text(span_nodes, "@svizzle/ui: viewports");
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file, 26, 3, 495);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(23:2) <HyperLink    href='/svizzle/compounds/viewports/ViewsSlider'    rel='prefetch'   >",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let t0;
  let section;
  let nav;
  let hyperlink0;
  let t1;
  let hyperlink1;
  let t2;
  let hyperlink2;
  let t3;
  let main;
  let current;
  hyperlink0 = new HyperLink({
    props: {
      href: "/svizzle/compounds/mapbox/empty",
      rel: "prefetch",
      $$slots: {
        default: [create_default_slot_2]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  hyperlink1 = new HyperLink({
    props: {
      href: "/svizzle/compounds/time_region_value",
      rel: "prefetch",
      $$slots: {
        default: [create_default_slot_1]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  hyperlink2 = new HyperLink({
    props: {
      href: "/svizzle/compounds/viewports/ViewsSlider",
      rel: "prefetch",
      $$slots: {
        default: [create_default_slot]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const default_slot_template = /*#slots*/ctx[0].default;
  const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ctx[1], null);
  const block = {
    c: function create() {
      t0 = space();
      section = element("section");
      nav = element("nav");
      create_component(hyperlink0.$$.fragment);
      t1 = space();
      create_component(hyperlink1.$$.fragment);
      t2 = space();
      create_component(hyperlink2.$$.fragment);
      t3 = space();
      main = element("main");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      const head_nodes = head_selector('svelte-1ea3act', document.head);
      head_nodes.forEach(detach_dev);
      t0 = claim_space(nodes);
      section = claim_element(nodes, "SECTION", {
        class: true
      });
      var section_nodes = children(section);
      nav = claim_element(section_nodes, "NAV", {
        class: true
      });
      var nav_nodes = children(nav);
      claim_component(hyperlink0.$$.fragment, nav_nodes);
      t1 = claim_space(nav_nodes);
      claim_component(hyperlink1.$$.fragment, nav_nodes);
      t2 = claim_space(nav_nodes);
      claim_component(hyperlink2.$$.fragment, nav_nodes);
      nav_nodes.forEach(detach_dev);
      t3 = claim_space(section_nodes);
      main = claim_element(section_nodes, "MAIN", {
        class: true
      });
      var main_nodes = children(main);
      if (default_slot) default_slot.l(main_nodes);
      main_nodes.forEach(detach_dev);
      section_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      document.title = "@svizzle compounds";
      attr_dev(nav, "class", "svelte-1fphwp9");
      add_location(nav, file, 9, 1, 136);
      attr_dev(main, "class", "svelte-1fphwp9");
      add_location(main, file, 29, 1, 555);
      attr_dev(section, "class", "svelte-1fphwp9");
      add_location(section, file, 8, 0, 125);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, section, anchor);
      append_hydration_dev(section, nav);
      mount_component(hyperlink0, nav, null);
      append_hydration_dev(nav, t1);
      mount_component(hyperlink1, nav, null);
      append_hydration_dev(nav, t2);
      mount_component(hyperlink2, nav, null);
      append_hydration_dev(section, t3);
      append_hydration_dev(section, main);
      if (default_slot) {
        default_slot.m(main, null);
      }
      current = true;
    },
    p: function update(ctx, _ref) {
      let [dirty] = _ref;
      const hyperlink0_changes = {};
      if (dirty & /*$$scope*/2) {
        hyperlink0_changes.$$scope = {
          dirty,
          ctx
        };
      }
      hyperlink0.$set(hyperlink0_changes);
      const hyperlink1_changes = {};
      if (dirty & /*$$scope*/2) {
        hyperlink1_changes.$$scope = {
          dirty,
          ctx
        };
      }
      hyperlink1.$set(hyperlink1_changes);
      const hyperlink2_changes = {};
      if (dirty & /*$$scope*/2) {
        hyperlink2_changes.$$scope = {
          dirty,
          ctx
        };
      }
      hyperlink2.$set(hyperlink2_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/2)) {
          update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ctx[1], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[1]) : get_slot_changes(default_slot_template, /*$$scope*/ctx[1], dirty, null), null);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(hyperlink0.$$.fragment, local);
      transition_in(hyperlink1.$$.fragment, local);
      transition_in(hyperlink2.$$.fragment, local);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(hyperlink0.$$.fragment, local);
      transition_out(hyperlink1.$$.fragment, local);
      transition_out(hyperlink2.$$.fragment, local);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(t0);
      if (detaching) detach_dev(section);
      destroy_component(hyperlink0);
      destroy_component(hyperlink1);
      destroy_component(hyperlink2);
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Layout', slots, ['default']);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Layout> was created with unknown prop '${key}'`);
  });
  $$self.$$set = $$props => {
    if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
  };
  $$self.$capture_state = () => ({
    HyperLink
  });
  return [slots, $$scope];
}
class Layout extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Layout",
      options,
      id: create_fragment.name
    });
  }
}

export { Layout as default };
