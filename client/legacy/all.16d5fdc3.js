import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, e as element, D as create_component, f as claim_element, g as children, E as claim_component, b as detach_dev, k as attr_dev, m as add_location, n as insert_hydration_dev, F as mount_component, u as transition_in, B as transition_out, G as destroy_component, bz as binding_callbacks, bT as bind, a as space, at as empty, c as claim_space, w as group_outros, x as check_outros, bU as add_flush_callback, t as text, j as claim_text, o as append_hydration_dev, M as listen_dev, p as noop } from './client.9324a931.js';
import { C as CustomControl } from './CustomControl.a28f5549.js';
import { M as Mapbox } from './Mapbox.e1515b65.js';
import { S as SvgLayer } from './SvgLayer.5fe648ca.js';
import Layer1 from './Layer1.d4e82fd8.js';
import Layer2 from './Layer2.fe8175c6.js';
import ToggleControl from './ToggleControl.b457691d.js';

/* src/routes/compounds/mapbox/all.svelte generated by Svelte v3.59.2 */
const file = "src/routes/compounds/mapbox/all.svelte";

// (33:2) <CustomControl position='top-left'>
function create_default_slot_5(ctx) {
  let togglecontrol;
  let updating_checked;
  let current;
  function togglecontrol_checked_binding(value) {
    /*togglecontrol_checked_binding*/ctx[5](value);
  }
  let togglecontrol_props = {
    title: "Show custom controls"
  };
  if ( /*isCustomControlVisible*/ctx[0] !== void 0) {
    togglecontrol_props.checked = /*isCustomControlVisible*/ctx[0];
  }
  togglecontrol = new ToggleControl({
    props: togglecontrol_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(togglecontrol, 'checked', togglecontrol_checked_binding));
  const block = {
    c: function create() {
      create_component(togglecontrol.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(togglecontrol.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(togglecontrol, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const togglecontrol_changes = {};
      if (!updating_checked && dirty & /*isCustomControlVisible*/1) {
        updating_checked = true;
        togglecontrol_changes.checked = /*isCustomControlVisible*/ctx[0];
        add_flush_callback(() => updating_checked = false);
      }
      togglecontrol.$set(togglecontrol_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(togglecontrol.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(togglecontrol.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(togglecontrol, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5.name,
    type: "slot",
    source: "(33:2) <CustomControl position='top-left'>",
    ctx
  });
  return block;
}

// (39:2) {#if isCustomControlVisible}
function create_if_block_2(ctx) {
  let customcontrol;
  let current;
  customcontrol = new CustomControl({
    props: {
      position: "top-left",
      $$slots: {
        default: [create_default_slot_4]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(customcontrol.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(customcontrol.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(customcontrol, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const customcontrol_changes = {};
      if (dirty & /*$$scope, isCustomLayer2Visible, isCustomLayer1Visible*/262) {
        customcontrol_changes.$$scope = {
          dirty,
          ctx
        };
      }
      customcontrol.$set(customcontrol_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(customcontrol.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(customcontrol.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(customcontrol, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(39:2) {#if isCustomControlVisible}",
    ctx
  });
  return block;
}

// (40:3) <CustomControl position='top-left'>
function create_default_slot_4(ctx) {
  let togglecontrol0;
  let updating_checked;
  let t;
  let togglecontrol1;
  let updating_checked_1;
  let current;
  function togglecontrol0_checked_binding(value) {
    /*togglecontrol0_checked_binding*/ctx[6](value);
  }
  let togglecontrol0_props = {
    title: "Show first custom layer"
  };
  if ( /*isCustomLayer1Visible*/ctx[1] !== void 0) {
    togglecontrol0_props.checked = /*isCustomLayer1Visible*/ctx[1];
  }
  togglecontrol0 = new ToggleControl({
    props: togglecontrol0_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(togglecontrol0, 'checked', togglecontrol0_checked_binding));
  function togglecontrol1_checked_binding(value) {
    /*togglecontrol1_checked_binding*/ctx[7](value);
  }
  let togglecontrol1_props = {
    title: "Show second custom layer"
  };
  if ( /*isCustomLayer2Visible*/ctx[2] !== void 0) {
    togglecontrol1_props.checked = /*isCustomLayer2Visible*/ctx[2];
  }
  togglecontrol1 = new ToggleControl({
    props: togglecontrol1_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(togglecontrol1, 'checked', togglecontrol1_checked_binding));
  const block = {
    c: function create() {
      create_component(togglecontrol0.$$.fragment);
      t = space();
      create_component(togglecontrol1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(togglecontrol0.$$.fragment, nodes);
      t = claim_space(nodes);
      claim_component(togglecontrol1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(togglecontrol0, target, anchor);
      insert_hydration_dev(target, t, anchor);
      mount_component(togglecontrol1, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const togglecontrol0_changes = {};
      if (!updating_checked && dirty & /*isCustomLayer1Visible*/2) {
        updating_checked = true;
        togglecontrol0_changes.checked = /*isCustomLayer1Visible*/ctx[1];
        add_flush_callback(() => updating_checked = false);
      }
      togglecontrol0.$set(togglecontrol0_changes);
      const togglecontrol1_changes = {};
      if (!updating_checked_1 && dirty & /*isCustomLayer2Visible*/4) {
        updating_checked_1 = true;
        togglecontrol1_changes.checked = /*isCustomLayer2Visible*/ctx[2];
        add_flush_callback(() => updating_checked_1 = false);
      }
      togglecontrol1.$set(togglecontrol1_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(togglecontrol0.$$.fragment, local);
      transition_in(togglecontrol1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(togglecontrol0.$$.fragment, local);
      transition_out(togglecontrol1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(togglecontrol0, detaching);
      if (detaching) detach_dev(t);
      destroy_component(togglecontrol1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: "(40:3) <CustomControl position='top-left'>",
    ctx
  });
  return block;
}

// (52:2) <CustomControl position='bottom-left'>
function create_default_slot_3(ctx) {
  let button;
  let t;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      button = element("button");
      t = text("Zoom to England");
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        class: true
      });
      var button_nodes = children(button);
      t = claim_text(button_nodes, "Zoom to England");
      button_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(button, "class", "svelte-6jdc4d");
      add_location(button, file, 52, 3, 1302);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, t);
      if (!mounted) {
        dispose = listen_dev(button, "click", /*zoomToEngland*/ctx[4], false, false, false, false);
        mounted = true;
      }
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(button);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(52:2) <CustomControl position='bottom-left'>",
    ctx
  });
  return block;
}

// (58:2) {#if isCustomLayer1Visible}
function create_if_block_1(ctx) {
  let svglayer;
  let current;
  svglayer = new SvgLayer({
    props: {
      isInteractive: false,
      order: 1,
      $$slots: {
        default: [create_default_slot_2]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svglayer.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svglayer.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svglayer, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(svglayer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svglayer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svglayer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(58:2) {#if isCustomLayer1Visible}",
    ctx
  });
  return block;
}

// (59:3) <SvgLayer     isInteractive={false}     order={1}    >
function create_default_slot_2(ctx) {
  let layer1;
  let current;
  layer1 = new Layer1({
    props: {
      wsen: [[-140, 0], [-50, 70]]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(layer1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(layer1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(layer1, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current) return;
      transition_in(layer1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layer1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(layer1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(59:3) <SvgLayer     isInteractive={false}     order={1}    >",
    ctx
  });
  return block;
}

// (67:2) {#if isCustomLayer2Visible}
function create_if_block(ctx) {
  let svglayer;
  let current;
  svglayer = new SvgLayer({
    props: {
      isInteractive: false,
      order: 2,
      $$slots: {
        default: [create_default_slot_1]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(svglayer.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(svglayer.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(svglayer, target, anchor);
      current = true;
    },
    i: function intro(local) {
      if (current) return;
      transition_in(svglayer.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(svglayer.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(svglayer, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(67:2) {#if isCustomLayer2Visible}",
    ctx
  });
  return block;
}

// (68:3) <SvgLayer     isInteractive={false}     order={2}    >
function create_default_slot_1(ctx) {
  let layer2;
  let current;
  layer2 = new Layer2({
    props: {
      wsen: [[50, 0], [140, 70]]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(layer2.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(layer2.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(layer2, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current) return;
      transition_in(layer2.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layer2.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(layer2, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(68:3) <SvgLayer     isInteractive={false}     order={2}    >",
    ctx
  });
  return block;
}

// (26:1) <Mapbox   {accessToken}   {bounds}   {styleURL}   withScaleControl={true}   withZoomControl={true}  >
function create_default_slot(ctx) {
  let customcontrol0;
  let t0;
  let t1;
  let customcontrol1;
  let t2;
  let t3;
  let if_block2_anchor;
  let current;
  customcontrol0 = new CustomControl({
    props: {
      position: "top-left",
      $$slots: {
        default: [create_default_slot_5]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  let if_block0 = /*isCustomControlVisible*/ctx[0] && create_if_block_2(ctx);
  customcontrol1 = new CustomControl({
    props: {
      position: "bottom-left",
      $$slots: {
        default: [create_default_slot_3]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  let if_block1 = /*isCustomLayer1Visible*/ctx[1] && create_if_block_1(ctx);
  let if_block2 = /*isCustomLayer2Visible*/ctx[2] && create_if_block(ctx);
  const block = {
    c: function create() {
      create_component(customcontrol0.$$.fragment);
      t0 = space();
      if (if_block0) if_block0.c();
      t1 = space();
      create_component(customcontrol1.$$.fragment);
      t2 = space();
      if (if_block1) if_block1.c();
      t3 = space();
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
    },
    l: function claim(nodes) {
      claim_component(customcontrol0.$$.fragment, nodes);
      t0 = claim_space(nodes);
      if (if_block0) if_block0.l(nodes);
      t1 = claim_space(nodes);
      claim_component(customcontrol1.$$.fragment, nodes);
      t2 = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      t3 = claim_space(nodes);
      if (if_block2) if_block2.l(nodes);
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      mount_component(customcontrol0, target, anchor);
      insert_hydration_dev(target, t0, anchor);
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, t1, anchor);
      mount_component(customcontrol1, target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, t3, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert_hydration_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const customcontrol0_changes = {};
      if (dirty & /*$$scope, isCustomControlVisible*/257) {
        customcontrol0_changes.$$scope = {
          dirty,
          ctx
        };
      }
      customcontrol0.$set(customcontrol0_changes);
      if ( /*isCustomControlVisible*/ctx[0]) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty & /*isCustomControlVisible*/1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_2(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(t1.parentNode, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const customcontrol1_changes = {};
      if (dirty & /*$$scope*/256) {
        customcontrol1_changes.$$scope = {
          dirty,
          ctx
        };
      }
      customcontrol1.$set(customcontrol1_changes);
      if ( /*isCustomLayer1Visible*/ctx[1]) {
        if (if_block1) {
          if (dirty & /*isCustomLayer1Visible*/2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t3.parentNode, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if ( /*isCustomLayer2Visible*/ctx[2]) {
        if (if_block2) {
          if (dirty & /*isCustomLayer2Visible*/4) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block(ctx);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(customcontrol0.$$.fragment, local);
      transition_in(if_block0);
      transition_in(customcontrol1.$$.fragment, local);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(customcontrol0.$$.fragment, local);
      transition_out(if_block0);
      transition_out(customcontrol1.$$.fragment, local);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(customcontrol0, detaching);
      if (detaching) detach_dev(t0);
      if (if_block0) if_block0.d(detaching);
      if (detaching) detach_dev(t1);
      destroy_component(customcontrol1, detaching);
      if (detaching) detach_dev(t2);
      if (if_block1) if_block1.d(detaching);
      if (detaching) detach_dev(t3);
      if (if_block2) if_block2.d(detaching);
      if (detaching) detach_dev(if_block2_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(26:1) <Mapbox   {accessToken}   {bounds}   {styleURL}   withScaleControl={true}   withZoomControl={true}  >",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div;
  let mapbox;
  let current;
  mapbox = new Mapbox({
    props: {
      accessToken,
      bounds: /*bounds*/ctx[3],
      styleURL,
      withScaleControl: true,
      withZoomControl: true,
      $$slots: {
        default: [create_default_slot]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(mapbox.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true
      });
      var div_nodes = children(div);
      claim_component(mapbox.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "map-container svelte-6jdc4d");
      add_location(div, file, 24, 0, 661);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(mapbox, div, null);
      current = true;
    },
    p: function update(ctx, _ref) {
      let [dirty] = _ref;
      const mapbox_changes = {};
      if (dirty & /*bounds*/8) mapbox_changes.bounds = /*bounds*/ctx[3];
      if (dirty & /*$$scope, isCustomLayer2Visible, isCustomLayer1Visible, isCustomControlVisible*/263) {
        mapbox_changes.$$scope = {
          dirty,
          ctx
        };
      }
      mapbox.$set(mapbox_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(mapbox.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(mapbox.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(div);
      destroy_component(mapbox);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
const accessToken = 'pk.eyJ1IjoibmVzdGEtdWsiLCJhIjoiY2ozbjUzY2drMDAwNzJxbnl6a21uM253cSJ9.3RTMySEVk0LC4gQvGoG-Zw';
const styleURL = 'mapbox://styles/nesta-uk/cl8olrzo200ci16pim0h4c1pn';
function instance($$self, $$props, $$invalidate) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('All', slots, []);
  let isCustomControlVisible = false;
  let isCustomLayer1Visible = false;
  let isCustomLayer2Visible = false;
  let bounds;
  const zoomToEngland = () => {
    $$invalidate(3, bounds = [[-8.61752, 49.90774], [1.76229, 60.84585]]);
  };
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<All> was created with unknown prop '".concat(key, "'"));
  });
  function togglecontrol_checked_binding(value) {
    isCustomControlVisible = value;
    $$invalidate(0, isCustomControlVisible);
  }
  function togglecontrol0_checked_binding(value) {
    isCustomLayer1Visible = value;
    $$invalidate(1, isCustomLayer1Visible);
  }
  function togglecontrol1_checked_binding(value) {
    isCustomLayer2Visible = value;
    $$invalidate(2, isCustomLayer2Visible);
  }
  $$self.$capture_state = () => ({
    Mapbox,
    CustomControl,
    SvgLayer,
    Layer1,
    Layer2,
    ToggleControl,
    accessToken,
    styleURL,
    isCustomControlVisible,
    isCustomLayer1Visible,
    isCustomLayer2Visible,
    bounds,
    zoomToEngland
  });
  $$self.$inject_state = $$props => {
    if ('isCustomControlVisible' in $$props) $$invalidate(0, isCustomControlVisible = $$props.isCustomControlVisible);
    if ('isCustomLayer1Visible' in $$props) $$invalidate(1, isCustomLayer1Visible = $$props.isCustomLayer1Visible);
    if ('isCustomLayer2Visible' in $$props) $$invalidate(2, isCustomLayer2Visible = $$props.isCustomLayer2Visible);
    if ('bounds' in $$props) $$invalidate(3, bounds = $$props.bounds);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [isCustomControlVisible, isCustomLayer1Visible, isCustomLayer2Visible, bounds, zoomToEngland, togglecontrol_checked_binding, togglecontrol0_checked_binding, togglecontrol1_checked_binding];
}
class All extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "All",
      options,
      id: create_fragment.name
    });
  }
}

export { All as default };
