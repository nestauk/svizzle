import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, q as validate_each_argument, am as validate_store, aw as component_subscribe, v as validate_slots, bf as onMount, b8 as isServerSide, ar as _, bO as identity, e as element, t as text, a as space, f as claim_element, g as children, j as claim_text, b as detach_dev, c as claim_space, m as add_location, k as attr_dev, bl as add_render_callback, n as insert_hydration_dev, o as append_hydration_dev, bm as add_iframe_resize_listener, p as noop, C as destroy_each, ap as subscribe, a5 as set_data_dev, I as svg_element, at as empty, J as claim_svg_element, D as create_component, E as claim_component, F as mount_component, u as transition_in, B as transition_out, G as destroy_component } from './client.9324a931.js';
import { e as _isSmallScreen, a as _timelineLayout, _ as _hrefBase, r as resetSelectedYear, t as setRoute, n as showView, c as shortenYear, o as _groups, u as _yearRange } from './stores.a1f53498.js';
import { m as makeURL, h as hrefBase } from './_config.4130d961.js';
import './linear.f307c541.js';
import './defaultLocale.a39c0f65.js';

/* ../../components/time_region_value/src/routes/index.svelte generated by Svelte v3.59.2 */
const file = "../../components/time_region_value/src/routes/index.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i].description;
  child_ctx[13] = list[i].indicators;
  child_ctx[14] = list[i].label;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i].availableYears;
  child_ctx[18] = list[i].title;
  child_ctx[19] = list[i].schema;
  child_ctx[20] = list[i].year_extent;
  child_ctx[22] = i;
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  return child_ctx;
}

// (57:5) {#if width || isServerSide}
function create_if_block(ctx) {
  let svg;
  let each0_anchor;
  let svg_height_value;
  let each_value_3 = /*$_yearRange*/ctx[7];
  validate_each_argument(each_value_3);
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks_1[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  let each_value_1 = /*indicators*/ctx[13];
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const block = {
    c: function create() {
      svg = svg_element("svg");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      each0_anchor = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      svg = claim_svg_element(nodes, "svg", {
        width: true,
        height: true,
        class: true
      });
      var svg_nodes = children(svg);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].l(svg_nodes);
      }
      each0_anchor = empty();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(svg_nodes);
      }
      svg_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "width", /*width*/ctx[3]);
      attr_dev(svg, "height", svg_height_value = 4 * gap + /*layout*/ctx[2].fontSize + /*vStep*/ctx[5] * /*indicators*/ctx[13].length);
      attr_dev(svg, "class", "svelte-yz4j7q");
      add_location(svg, file, 57, 6, 1192);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svg, anchor);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(svg, null);
        }
      }
      append_hydration_dev(svg, each0_anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(svg, null);
        }
      }
    },
    p: function update(ctx, dirty) {
      if (dirty & /*layout, $_yearRange, gap, vStep, $_groups, shortenYearFn*/244) {
        each_value_3 = /*$_yearRange*/ctx[7];
        validate_each_argument(each_value_3);
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx, each_value_3, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_3(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(svg, each0_anchor);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_3.length;
      }
      if (dirty & /*vStep, $_groups, makeURL, $_hrefBase, layout, gap*/356) {
        each_value_1 = /*indicators*/ctx[13];
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(svg, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty & /*width*/8) {
        attr_dev(svg, "width", /*width*/ctx[3]);
      }
      if (dirty & /*layout, vStep, $_groups*/100 && svg_height_value !== (svg_height_value = 4 * gap + /*layout*/ctx[2].fontSize + /*vStep*/ctx[5] * /*indicators*/ctx[13].length)) {
        attr_dev(svg, "height", svg_height_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(svg);
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(57:5) {#if width || isServerSide}",
    ctx
  });
  return block;
}

// (70:9) {#if indicators.length > 1}
function create_if_block_1(ctx) {
  let line;
  let line_y__value;
  const block = {
    c: function create() {
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      line = claim_svg_element(nodes, "line", {
        y1: true,
        y2: true,
        class: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "y1", gap);
      attr_dev(line, "y2", line_y__value = gap + /*vStep*/ctx[5] * /*indicators*/ctx[13].length);
      attr_dev(line, "class", "svelte-yz4j7q");
      add_location(line, file, 70, 10, 1518);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line, anchor);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*vStep, $_groups*/96 && line_y__value !== (line_y__value = gap + /*vStep*/ctx[5] * /*indicators*/ctx[13].length)) {
        attr_dev(line, "y2", line_y__value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(70:9) {#if indicators.length > 1}",
    ctx
  });
  return block;
}

// (64:7) {#each $_yearRange as year}
function create_each_block_3(ctx) {
  let g;
  let text_1;
  let t_value = /*shortenYearFn*/ctx[4]( /*year*/ctx[23]) + "";
  let t;
  let text_1_font_size_value;
  let text_1_y_value;
  let g_transform_value;
  let if_block = /*indicators*/ctx[13].length > 1 && create_if_block_1(ctx);
  const block = {
    c: function create() {
      g = svg_element("g");
      if (if_block) if_block.c();
      text_1 = svg_element("text");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      g = claim_svg_element(nodes, "g", {
        class: true,
        transform: true
      });
      var g_nodes = children(g);
      if (if_block) if_block.l(g_nodes);
      text_1 = claim_svg_element(g_nodes, "text", {
        "font-size": true,
        y: true,
        class: true
      });
      var text_1_nodes = children(text_1);
      t = claim_text(text_1_nodes, t_value);
      text_1_nodes.forEach(detach_dev);
      g_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(text_1, "font-size", text_1_font_size_value = /*layout*/ctx[2].fontSize);
      attr_dev(text_1, "y", text_1_y_value = 2 * gap + /*vStep*/ctx[5] * /*indicators*/ctx[13].length + /*layout*/ctx[2].fontSize / 2);
      attr_dev(text_1, "class", "svelte-yz4j7q");
      add_location(text_1, file, 77, 9, 1657);
      attr_dev(g, "class", "xref");
      attr_dev(g, "transform", g_transform_value = "translate(" + /*layout*/ctx[2].scaleX( /*year*/ctx[23]) + ",0)");
      add_location(g, file, 64, 8, 1357);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, g, anchor);
      if (if_block) if_block.m(g, null);
      append_hydration_dev(g, text_1);
      append_hydration_dev(text_1, t);
    },
    p: function update(ctx, dirty) {
      if ( /*indicators*/ctx[13].length > 1) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_1(ctx);
          if_block.c();
          if_block.m(g, text_1);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*shortenYearFn, $_yearRange*/144 && t_value !== (t_value = /*shortenYearFn*/ctx[4]( /*year*/ctx[23]) + "")) set_data_dev(t, t_value);
      if (dirty & /*layout*/4 && text_1_font_size_value !== (text_1_font_size_value = /*layout*/ctx[2].fontSize)) {
        attr_dev(text_1, "font-size", text_1_font_size_value);
      }
      if (dirty & /*vStep, $_groups, layout*/100 && text_1_y_value !== (text_1_y_value = 2 * gap + /*vStep*/ctx[5] * /*indicators*/ctx[13].length + /*layout*/ctx[2].fontSize / 2)) {
        attr_dev(text_1, "y", text_1_y_value);
      }
      if (dirty & /*layout, $_yearRange*/132 && g_transform_value !== (g_transform_value = "translate(" + /*layout*/ctx[2].scaleX( /*year*/ctx[23]) + ",0)")) {
        attr_dev(g, "transform", g_transform_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(g);
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_3.name,
    type: "each",
    source: "(64:7) {#each $_yearRange as year}",
    ctx
  });
  return block;
}

// (113:9) {#each availableYears as year}
function create_each_block_2(ctx) {
  let a;
  let circle;
  let circle_cx_value;
  let circle_r_value;
  let a_aria_label_value;
  let a_href_value;
  const block = {
    c: function create() {
      a = svg_element("a");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      a = claim_svg_element(nodes, "a", {
        "aria-label": true,
        href: true,
        rel: true
      });
      var a_nodes = children(a);
      circle = claim_svg_element(a_nodes, "circle", {
        cx: true,
        r: true,
        class: true
      });
      children(circle).forEach(detach_dev);
      a_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", circle_cx_value = /*layout*/ctx[2].scaleX( /*year*/ctx[23]));
      attr_dev(circle, "r", circle_r_value = /*layout*/ctx[2].radius);
      attr_dev(circle, "class", "svelte-yz4j7q");
      add_location(circle, file, 118, 11, 2919);
      attr_dev(a, "aria-label", a_aria_label_value = /*year*/ctx[23]);
      attr_dev(a, "href", a_href_value = makeURL( /*$_hrefBase*/ctx[8], /*schema*/ctx[19].value.id, /*year*/ctx[23]));
      attr_dev(a, "rel", "prefetch");
      add_location(a, file, 113, 10, 2777);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, a, anchor);
      append_hydration_dev(a, circle);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*layout, $_groups*/68 && circle_cx_value !== (circle_cx_value = /*layout*/ctx[2].scaleX( /*year*/ctx[23]))) {
        attr_dev(circle, "cx", circle_cx_value);
      }
      if (dirty & /*layout*/4 && circle_r_value !== (circle_r_value = /*layout*/ctx[2].radius)) {
        attr_dev(circle, "r", circle_r_value);
      }
      if (dirty & /*$_groups*/64 && a_aria_label_value !== (a_aria_label_value = /*year*/ctx[23])) {
        attr_dev(a, "aria-label", a_aria_label_value);
      }
      if (dirty & /*$_hrefBase, $_groups*/320 && a_href_value !== (a_href_value = makeURL( /*$_hrefBase*/ctx[8], /*schema*/ctx[19].value.id, /*year*/ctx[23]))) {
        attr_dev(a, "href", a_href_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(a);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(113:9) {#each availableYears as year}",
    ctx
  });
  return block;
}

// (88:7) {#each indicators as {availableYears, title, schema, year_extent}
function create_each_block_1(ctx) {
  let g;
  let text0;
  let t0_value = /*title*/ctx[18] + "";
  let t0;
  let text0_x_value;
  let text0_dy_value;
  let text0_font_size_value;
  let text1;
  let t1_value = /*title*/ctx[18] + "";
  let t1;
  let text1_x_value;
  let text1_dy_value;
  let text1_font_size_value;
  let line;
  let line_x__value;
  let line_x__value_1;
  let g_transform_value;
  let each_value_2 = /*availableYears*/ctx[17];
  validate_each_argument(each_value_2);
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  const block = {
    c: function create() {
      g = svg_element("g");
      text0 = svg_element("text");
      t0 = text(t0_value);
      text1 = svg_element("text");
      t1 = text(t1_value);
      line = svg_element("line");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      g = claim_svg_element(nodes, "g", {
        class: true,
        transform: true
      });
      var g_nodes = children(g);
      text0 = claim_svg_element(g_nodes, "text", {
        class: true,
        x: true,
        dy: true,
        "font-size": true
      });
      var text0_nodes = children(text0);
      t0 = claim_text(text0_nodes, t0_value);
      text0_nodes.forEach(detach_dev);
      text1 = claim_svg_element(g_nodes, "text", {
        x: true,
        dy: true,
        "font-size": true,
        class: true
      });
      var text1_nodes = children(text1);
      t1 = claim_text(text1_nodes, t1_value);
      text1_nodes.forEach(detach_dev);
      line = claim_svg_element(g_nodes, "line", {
        x1: true,
        x2: true,
        class: true
      });
      children(line).forEach(detach_dev);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(g_nodes);
      }
      g_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(text0, "class", "bkg svelte-yz4j7q");
      attr_dev(text0, "x", text0_x_value = ( /*layout*/ctx[2].scaleX( /*year_extent*/ctx[20][0]) + /*layout*/ctx[2].scaleX( /*year_extent*/ctx[20][1])) / 2);
      attr_dev(text0, "dy", text0_dy_value = -( /*layout*/ctx[2].fontSize + gap));
      attr_dev(text0, "font-size", text0_font_size_value = /*layout*/ctx[2].fontSize);
      add_location(text0, file, 93, 9, 2097);
      attr_dev(text1, "x", text1_x_value = ( /*layout*/ctx[2].scaleX( /*year_extent*/ctx[20][0]) + /*layout*/ctx[2].scaleX( /*year_extent*/ctx[20][1])) / 2);
      attr_dev(text1, "dy", text1_dy_value = -( /*layout*/ctx[2].fontSize + gap));
      attr_dev(text1, "font-size", text1_font_size_value = /*layout*/ctx[2].fontSize);
      attr_dev(text1, "class", "svelte-yz4j7q");
      add_location(text1, file, 99, 9, 2323);
      attr_dev(line, "x1", line_x__value = /*layout*/ctx[2].scaleX( /*year_extent*/ctx[20][0]) + /*layout*/ctx[2].radius);
      attr_dev(line, "x2", line_x__value_1 = /*layout*/ctx[2].scaleX( /*year_extent*/ctx[20][1]) - /*layout*/ctx[2].radius);
      attr_dev(line, "class", "svelte-yz4j7q");
      add_location(line, file, 106, 9, 2559);
      attr_dev(g, "class", "indicatorsrange");
      attr_dev(g, "transform", g_transform_value = "translate(0," + /*vStep*/ctx[5] * ( /*y*/ctx[22] + 1) + ")");
      add_location(g, file, 88, 8, 1966);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, g, anchor);
      append_hydration_dev(g, text0);
      append_hydration_dev(text0, t0);
      append_hydration_dev(g, text1);
      append_hydration_dev(text1, t1);
      append_hydration_dev(g, line);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(g, null);
        }
      }
    },
    p: function update(ctx, dirty) {
      if (dirty & /*$_groups*/64 && t0_value !== (t0_value = /*title*/ctx[18] + "")) set_data_dev(t0, t0_value);
      if (dirty & /*layout, $_groups*/68 && text0_x_value !== (text0_x_value = ( /*layout*/ctx[2].scaleX( /*year_extent*/ctx[20][0]) + /*layout*/ctx[2].scaleX( /*year_extent*/ctx[20][1])) / 2)) {
        attr_dev(text0, "x", text0_x_value);
      }
      if (dirty & /*layout*/4 && text0_dy_value !== (text0_dy_value = -( /*layout*/ctx[2].fontSize + gap))) {
        attr_dev(text0, "dy", text0_dy_value);
      }
      if (dirty & /*layout*/4 && text0_font_size_value !== (text0_font_size_value = /*layout*/ctx[2].fontSize)) {
        attr_dev(text0, "font-size", text0_font_size_value);
      }
      if (dirty & /*$_groups*/64 && t1_value !== (t1_value = /*title*/ctx[18] + "")) set_data_dev(t1, t1_value);
      if (dirty & /*layout, $_groups*/68 && text1_x_value !== (text1_x_value = ( /*layout*/ctx[2].scaleX( /*year_extent*/ctx[20][0]) + /*layout*/ctx[2].scaleX( /*year_extent*/ctx[20][1])) / 2)) {
        attr_dev(text1, "x", text1_x_value);
      }
      if (dirty & /*layout*/4 && text1_dy_value !== (text1_dy_value = -( /*layout*/ctx[2].fontSize + gap))) {
        attr_dev(text1, "dy", text1_dy_value);
      }
      if (dirty & /*layout*/4 && text1_font_size_value !== (text1_font_size_value = /*layout*/ctx[2].fontSize)) {
        attr_dev(text1, "font-size", text1_font_size_value);
      }
      if (dirty & /*layout, $_groups*/68 && line_x__value !== (line_x__value = /*layout*/ctx[2].scaleX( /*year_extent*/ctx[20][0]) + /*layout*/ctx[2].radius)) {
        attr_dev(line, "x1", line_x__value);
      }
      if (dirty & /*layout, $_groups*/68 && line_x__value_1 !== (line_x__value_1 = /*layout*/ctx[2].scaleX( /*year_extent*/ctx[20][1]) - /*layout*/ctx[2].radius)) {
        attr_dev(line, "x2", line_x__value_1);
      }
      if (dirty & /*$_groups, makeURL, $_hrefBase, layout*/324) {
        each_value_2 = /*availableYears*/ctx[17];
        validate_each_argument(each_value_2);
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(g, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
      if (dirty & /*vStep*/32 && g_transform_value !== (g_transform_value = "translate(0," + /*vStep*/ctx[5] * ( /*y*/ctx[22] + 1) + ")")) {
        attr_dev(g, "transform", g_transform_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(g);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(88:7) {#each indicators as {availableYears, title, schema, year_extent}",
    ctx
  });
  return block;
}

// (52:3) {#each $_groups as {description, indicators, label}}
function create_each_block(ctx) {
  let li;
  let h2;
  let t0_value = /*label*/ctx[14] + "";
  let t0;
  let t1;
  let p;
  let t2_value = /*description*/ctx[12] + "";
  let t2;
  let t3;
  let t4;
  let if_block = ( /*width*/ctx[3] || isServerSide) && create_if_block(ctx);
  const block = {
    c: function create() {
      li = element("li");
      h2 = element("h2");
      t0 = text(t0_value);
      t1 = space();
      p = element("p");
      t2 = text(t2_value);
      t3 = space();
      if (if_block) if_block.c();
      t4 = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {
        class: true
      });
      var li_nodes = children(li);
      h2 = claim_element(li_nodes, "H2", {});
      var h2_nodes = children(h2);
      t0 = claim_text(h2_nodes, t0_value);
      h2_nodes.forEach(detach_dev);
      t1 = claim_space(li_nodes);
      p = claim_element(li_nodes, "P", {});
      var p_nodes = children(p);
      t2 = claim_text(p_nodes, t2_value);
      p_nodes.forEach(detach_dev);
      t3 = claim_space(li_nodes);
      if (if_block) if_block.l(li_nodes);
      t4 = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(h2, file, 53, 5, 1109);
      add_location(p, file, 54, 5, 1131);
      attr_dev(li, "class", "group svelte-yz4j7q");
      add_location(li, file, 52, 4, 1085);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      append_hydration_dev(li, h2);
      append_hydration_dev(h2, t0);
      append_hydration_dev(li, t1);
      append_hydration_dev(li, p);
      append_hydration_dev(p, t2);
      append_hydration_dev(li, t3);
      if (if_block) if_block.m(li, null);
      append_hydration_dev(li, t4);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*$_groups*/64 && t0_value !== (t0_value = /*label*/ctx[14] + "")) set_data_dev(t0, t0_value);
      if (dirty & /*$_groups*/64 && t2_value !== (t2_value = /*description*/ctx[12] + "")) set_data_dev(t2, t2_value);
      if ( /*width*/ctx[3] || isServerSide) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block(ctx);
          if_block.c();
          if_block.m(li, t4);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(li);
      if (if_block) if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(52:3) {#each $_groups as {description, indicators, label}}",
    ctx
  });
  return block;
}
function create_fragment$1(ctx) {
  let div1;
  let header;
  let h1;
  let t0;
  let t1;
  let div0;
  let ul;
  let div0_resize_listener;
  let each_value = /*$_groups*/ctx[6];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div1 = element("div");
      header = element("header");
      h1 = element("h1");
      t0 = text("Indicators");
      t1 = space();
      div0 = element("div");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {
        class: true
      });
      var div1_nodes = children(div1);
      header = claim_element(div1_nodes, "HEADER", {
        class: true
      });
      var header_nodes = children(header);
      h1 = claim_element(header_nodes, "H1", {});
      var h1_nodes = children(h1);
      t0 = claim_text(h1_nodes, "Indicators");
      h1_nodes.forEach(detach_dev);
      header_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", {
        class: true
      });
      var div0_nodes = children(div0);
      ul = claim_element(div0_nodes, "UL", {});
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(h1, file, 43, 2, 931);
      attr_dev(header, "class", "svelte-yz4j7q");
      add_location(header, file, 42, 1, 920);
      add_location(ul, file, 50, 2, 1020);
      attr_dev(div0, "class", "timedist svelte-yz4j7q");
      add_render_callback(() => /*div0_elementresize_handler*/ctx[11].call(div0));
      add_location(div0, file, 46, 1, 964);
      attr_dev(div1, "class", "time_region_value_Index svelte-yz4j7q");
      add_location(div1, file, 41, 0, 881);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, header);
      append_hydration_dev(header, h1);
      append_hydration_dev(h1, t0);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      div0_resize_listener = add_iframe_resize_listener(div0, /*div0_elementresize_handler*/ctx[11].bind(div0));
    },
    p: function update(ctx, _ref) {
      let [dirty] = _ref;
      if (dirty & /*width, gap, layout, vStep, $_groups, makeURL, $_hrefBase, $_yearRange, shortenYearFn, isServerSide*/508) {
        each_value = /*$_groups*/ctx[6];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(div1);
      destroy_each(each_blocks, detaching);
      div0_resize_listener();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
const gap = 7;
function instance$1($$self, $$props, $$invalidate) {
  let layout;
  let vStep;
  let shortenYearFn;
  let $_isSmallScreen;
  let $_timelineLayout;
  let $_groups,
    $$unsubscribe__groups = noop,
    $$subscribe__groups = () => ($$unsubscribe__groups(), $$unsubscribe__groups = subscribe(_groups, $$value => $$invalidate(6, $_groups = $$value)), _groups);
  let $_yearRange,
    $$unsubscribe__yearRange = noop,
    $$subscribe__yearRange = () => ($$unsubscribe__yearRange(), $$unsubscribe__yearRange = subscribe(_yearRange, $$value => $$invalidate(7, $_yearRange = $$value)), _yearRange);
  let $_hrefBase;
  validate_store(_isSmallScreen, '_isSmallScreen');
  component_subscribe($$self, _isSmallScreen, $$value => $$invalidate(9, $_isSmallScreen = $$value));
  validate_store(_timelineLayout, '_timelineLayout');
  component_subscribe($$self, _timelineLayout, $$value => $$invalidate(10, $_timelineLayout = $$value));
  validate_store(_hrefBase, '_hrefBase');
  component_subscribe($$self, _hrefBase, $$value => $$invalidate(8, $_hrefBase = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe__groups());
  $$self.$$.on_destroy.push(() => $$unsubscribe__yearRange());
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Routes', slots, []);
  let {
    _groups = null
  } = $$props;
  validate_store(_groups, '_groups');
  $$subscribe__groups();
  let {
    _yearRange = null
  } = $$props;
  validate_store(_yearRange, '_yearRange');
  $$subscribe__yearRange();

  /* init */
  onMount(() => {
    resetSelectedYear();
    setRoute('Index');
    showView('distribution');
  });

  /* local vars */
  // bound
  let width;
  const writable_props = ['_groups', '_yearRange'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Routes> was created with unknown prop '".concat(key, "'"));
  });
  function div0_elementresize_handler() {
    width = this.clientWidth;
    $$invalidate(3, width);
  }
  $$self.$$set = $$props => {
    if ('_groups' in $$props) $$subscribe__groups($$invalidate(0, _groups = $$props._groups));
    if ('_yearRange' in $$props) $$subscribe__yearRange($$invalidate(1, _yearRange = $$props._yearRange));
  };
  $$self.$capture_state = () => ({
    isServerSide,
    _,
    onMount,
    _isSmallScreen,
    _timelineLayout,
    _hrefBase,
    setRoute,
    showView,
    resetSelectedYear,
    shortenYear,
    makeURL,
    gap,
    _groups,
    _yearRange,
    width,
    shortenYearFn,
    layout,
    vStep,
    $_isSmallScreen,
    $_timelineLayout,
    $_groups,
    $_yearRange,
    $_hrefBase
  });
  $$self.$inject_state = $$props => {
    if ('_groups' in $$props) $$subscribe__groups($$invalidate(0, _groups = $$props._groups));
    if ('_yearRange' in $$props) $$subscribe__yearRange($$invalidate(1, _yearRange = $$props._yearRange));
    if ('width' in $$props) $$invalidate(3, width = $$props.width);
    if ('shortenYearFn' in $$props) $$invalidate(4, shortenYearFn = $$props.shortenYearFn);
    if ('layout' in $$props) $$invalidate(2, layout = $$props.layout);
    if ('vStep' in $$props) $$invalidate(5, vStep = $$props.vStep);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$_timelineLayout*/1024) {
      $$invalidate(2, layout = $_timelineLayout);
    }
    if ($$self.$$.dirty & /*layout*/4) {
      $$invalidate(5, vStep = 2 * layout.radius + 3 * gap + layout.fontSize);
    }
    if ($$self.$$.dirty & /*$_isSmallScreen*/512) {
      $$invalidate(4, shortenYearFn = $_isSmallScreen ? shortenYear : identity);
    }
  };
  return [_groups, _yearRange, layout, width, shortenYearFn, vStep, $_groups, $_yearRange, $_hrefBase, $_isSmallScreen, $_timelineLayout, div0_elementresize_handler];
}
class Routes extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1, create_fragment$1, safe_not_equal, {
      _groups: 0,
      _yearRange: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Routes",
      options,
      id: create_fragment$1.name
    });
  }
  get _groups() {
    throw new Error("<Routes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set _groups(value) {
    throw new Error("<Routes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get _yearRange() {
    throw new Error("<Routes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set _yearRange(value) {
    throw new Error("<Routes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
var Index = Routes;

/* src/routes/compounds/time_region_value/index.svelte generated by Svelte v3.59.2 */
function create_fragment(ctx) {
  let index;
  let current;
  index = new Index({
    props: {
      _groups,
      _yearRange,
      hrefBase
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(index.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(index.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(index, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current) return;
      transition_in(index.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(index.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(index, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Time_region_value', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Time_region_value> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$capture_state = () => ({
    Index,
    hrefBase,
    _groups,
    _yearRange
  });
  return [];
}
class Time_region_value extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Time_region_value",
      options,
      id: create_fragment.name
    });
  }
}

export { Time_region_value as default };
