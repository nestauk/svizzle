import { a6 as generic, a7 as curry, a8 as curryRight, Z as pipe, a9 as splitBy, U as mapWith, aa as debounce, ab as filterWith, ac as isIterableNotEmpty, ad as find, ae as hasKeyValue, af as some, ag as collect, ah as getPath, ai as fromPairs, aj as reduceWith, ak as hasPathValue, a0 as getKey, R as keys, S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, al as isClientSide, p as noop, I as svg_element, J as claim_svg_element, g as children, b as detach_dev, k as attr_dev, m as add_location, n as insert_hydration_dev, r as create_slot, am as validate_store, N as createEventDispatcher, K as makeStyleVars, e as element, f as claim_element, H as toggle_class, o as append_hydration_dev, M as listen_dev, an as stop_propagation, y as update_slot_base, z as get_all_dirty_from_scope, A as get_slot_changes, u as transition_in, B as transition_out, ao as run_all, ap as subscribe, aq as bubble, q as validate_each_argument, ar as _, as as tick, at as empty, C as destroy_each, a4 as zip, t as text, j as claim_text, a5 as set_data_dev, a as space, c as claim_space, au as compute_slots, w as group_outros, x as check_outros, D as create_component, E as claim_component, F as mount_component, G as destroy_component, av as construct_svelte_component_dev, aw as component_subscribe, ax as setupResizeObserver, ay as action_destroyer, az as _screen, aA as onDestroy, aB as StorageIO, aC as NoScript, aD as Switch, aE as A11yMenu, aF as A11yMenuDriver, aG as ColorCorrection, aH as _a11ySettings, aI as _currentId, aJ as _currentSetting, aK as _formatValue, aL as setNextId, aM as setPrevId, aN as _hasPrev, aO as _hasNext, aP as updateCurrentValue, aQ as mergeDefaultSettings, aR as _groupsResetStatus, aS as _isA11yDirty, aT as resetGroup, aU as _a11yColorStyles, aV as _a11yTextStyles, aW as applyStyles, aX as FontsLoader, aY as getFamily, aZ as getFamilies, a_ as isFamilyEqualTo, a$ as createFontFaces, b0 as loadFontFaces, L as Icon, b1 as ArrowLeftCircle, X as ArrowRightCircle, b2 as ChevronLeft, b3 as ChevronRight, b4 as MinusCircle, b5 as PlusCircle, b6 as A11yPerson, b7 as ScreenSensor, b8 as isServerSide, b9 as PLATFORM, ba as isPlatformIn, bb as getContext, bc as setContext, bd as set_store_value, be as writable, bf as onMount, O as globals, bg as null_to_empty, bh as assign, bi as get_spread_update, bj as get_spread_object, bk as readable, bl as add_render_callback, bm as add_iframe_resize_listener, bn as concat, bo as mergeObj, bp as appendTo, bq as has, br as last, bs as pullFrom, bt as sort, bu as uniques, bv as is_function, bw as makeKeyed, bx as pairs, h as head_selector, by as setIn, bz as binding_callbacks, P as prop_dev, bA as validate_dynamic_element, bB as validate_void_dynamic_element, bC as set_dynamic_element_data, bD as set_data_maybe_contenteditable_dev, bE as set_svg_attributes } from './client.9324a931.js';
import { A as AlphabetPicker, C as CopyToClipboard, a as AlertTriangle, b as Clipboard, c as Copy, S as Sun, l as lookup } from './_utils.acb42815.js';
import { S as Scroller, B as BarchartVDiv, C as ChoroplethG, d as defaultGeometry, p as projections } from './ChoroplethG.e40beecf.js';
import { C as CenteredView, L as LinkButton, M as MessageView, X as XorSelector, a as CheckSquare, b as ChevronDown, c as ChevronUp, G as Globe, d as MinusSquare, S as Square, v as vectorLength2D, g as getBinsTicks, e as getValuesLength, f as exactAmountBins, h as areValidBins, i as getBinsItems, j as getBinsMax, k as getBinsMin, l as getBinsExtent, m as isNonEmptyBin, n as findFirstNonEmptyBinIndex, o as findLastNonEmptyBinIndex, p as getTrimmedBinsStats, q as getBinsTicksExtent, r as getNonEmptyBinsTicks, s as ColorBinsG, t as ColorBinsDiv } from './ColorBinsDiv.02b8c741.js';
import { D as Download, t as transformer, c as copy, i as initRange, a as ticks, l as linear } from './quantize.fabb71de.js';
import { f as formatSpecifier, b as format, g as getValue } from './defaultLocale.a39c0f65.js';
import { t as trim, a as arrayMaxWith, i as inclusiveRange } from './linear.f307c541.js';
import { A as Activity, B as BarChart, C as Clock, L as List, M as MapPin, r as rxStreamToSvReadable, a as rxStreamToSvWritable } from './rx.94943ab1.js';
import { L as Link, E as ExternalLink, d as defaultRel } from './Link.bc395b32.js';
import { L as LoadingView, a as Loader } from './topojson.82b98301.js';
import { I as Info } from './Info.5b1c1c96.js';
import { S as Settings } from './Settings.7bbfdce8.js';
import './rgb.1861a087.js';
import './equalEarth.ffb2f4e1.js';
import './index.421d9617.js';

/**
 * Returns true if the provided RegExp is empty
 * @arg {RegExp} regexp
 * @return {boolean} - true if RegExp is empty
 */

/**
 * Returns true if the provided RegExp is not empty
 * @arg {RegExp} regexp
 * @return {boolean} - true if RegExp is not empty
 */
const isRegexpNotEmpty = regexp => regexp.source !== '(?:)';

/**
* @module @svizzle/utils/string_proto-array
*/

/**
 * Return an array splitting the input string with the provided separator or regex
 * @see
 {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split|String.prototype.split},
 {@link module:@svizzle/utils/string-[string-array].makeSplitBy|makeSplitBy},
 {@link module:@svizzle/utils/string-[string-array].makeSplitStringBy|makeSplitStringBy},
 {@link module:@svizzle/utils/string-array.splitByDot|splitByDot},
 {@link module:@svizzle/utils/string-array.splitByEOL|splitByEOL},
 {@link module:@svizzle/utils/string-array.splitBySemiColon|splitBySemiColon}
 *
 * @function
 * @arg {string} string - The input string
 * @arg {stringOrRegex} stringOrRegex - Separator or regex
 * @return {array}
 *
 * @example
> split('a-b-c', '-')
['a', 'b', 'c']
 *
 * @since 0.1.0
 */
const split = generic(String.prototype.split);

/**
* @module @svizzle/utils/string-[string-array]
*/

/**
 * Return a function expecting a separator or regex to split the provided string
 *
 * @function
 * @arg {string} string - String to split
 * @return {function} - String -> Array
 *
 * @example
> splitStringBy = makeSplitStringBy('a.b-c,d:e')
> splitStringBy(':')
['a.b-c,d', 'e']
> splitStringBy('-')
['a.b', 'c,d:e']
 *
 * @since 0.1.0
 */
curry(split, 2);

/**
 * Return a function expecting a string to be split using the provided separator or regex
 * @see
 {@link module:@svizzle/utils/string-array.splitByDot|splitByDot},
 {@link module:@svizzle/utils/string-array.splitByEOL|splitByEOL},
 {@link module:@svizzle/utils/string-array.splitBySemiColon|splitBySemiColon},
 *
 * @function
 * @arg {stringOrRegex} stringOrRegex - Separator or regex
 * @return {function} - String -> Array
 *
 * @example
> splitByDoubleDot = makeSplitBy('..')
> splitByDoubleDot('aa...a..a.a.aa.....aa..')
> ['aa', '.a', 'a.a.aa', '', '.aa', '']
 *
 * @since 0.1.0
 */
curryRight(split, 2);

/**
 * Return a function that splits the expected string and trims all the elements
 * of the returned array
 * @see {@link module:@svizzle/utils/string-[string-array].makeSplitBy|makeSplitBy}
 *
 * @function
 * @arg {string} separator
 * @return {function} - String -> Array
 *
 * @example
> trimSplitByDoubleDot = makeTrimmedSplitBy('..')
>
> trimSplitByDoubleDot('  aa ..\ta\n..a')
['aa', 'a', 'a']
>
> trimSplitByDoubleDot('  aa ...\na..a.a.aa\n.....\taa..\n')
['aa', '.\na', 'a.a.aa', '', '.\taa', '']
 *
 * @since 0.19.0
 */
const makeTrimmedSplitBy = separator => pipe([splitBy(separator), mapWith(trim)]);

const resizeHandler = function (node) {
  let {
    onResize,
    onResizeEnd,
    onResizeStart,
    timeout = 500
  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let resizing = false;
  const started = size => {
    resizing = true;
    onResizeStart === null || onResizeStart === void 0 || onResizeStart(size);
  };
  const scheduleEnded = debounce(size => {
    resizing = false;
    onResizeEnd === null || onResizeEnd === void 0 || onResizeEnd(size);
  }, timeout);
  const observer = new ResizeObserver(entries => {
    const [size] = entries[0].borderBoxSize;
    !resizing && started(size);
    onResize === null || onResize === void 0 || onResize(size);
    scheduleEnded(size);
  });
  observer.observe(node);
  return () => {
    observer.disconnect();
  };
};

const parseCssText = pipe([splitBy(';'), filterWith(isIterableNotEmpty), mapWith(makeTrimmedSplitBy(':'))]);
const getStylesheet = href => find([...document.styleSheets],
// convert collection to array
hasKeyValue('href', href));
const getSelectorText = getKey('selectorText');
const makeGetStyleRulesObj = selectorRegex => pipe([filterWith(pipe([getSelectorText, makeTrimmedSplitBy(','), some(selectorRegex.test.bind(selectorRegex))])), mapWith(collect([getSelectorText, pipe([getPath('style.cssText'), parseCssText, fromPairs])])), reduceWith((themes, _ref) => {
  let [selector, rules] = _ref;
  const themeEntry = find(themes, hasPathValue('0', selector));
  if (themeEntry) {
    const [, existingRules] = themeEntry;
    themeEntry[1] = {
      ...existingRules,
      ...rules
    };
  } else {
    themes.push([selector, rules]);
  }
  return themes;
}, []), fromPairs]);
const getAllStylesBySelector = pipe([mapWith(collect([getSelectorText, getKey('style')])), fromPairs]);
const setStyleRules = (targetRules, srcRules) => {
  const selectors = keys(srcRules);
  selectors.forEach(selector => {
    if (selector in targetRules) {
      const style = srcRules[selector];
      const properties = keys(style);
      properties.forEach(prop => {
        targetRules[selector].setProperty(prop, style[prop]);
      });
    }
  });
};

const absoluteURLRegex = /^(?:[a-z+]+:)?\/\//iu;
const getURL = href => new URL(href, absoluteURLRegex.test(href) ? undefined : location.origin);

/* ../../components/ui/src/drivers/style/StyleDriver.svelte generated by Svelte v3.59.2 */
function create_fragment$4A(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4A.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4z($$self, $$props, $$invalidate) {
  let hrefURL;
  let allStyleRules;
  let styleRulesObj;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('StyleDriver', slots, []);
  let {
    href
  } = $$props;
  let {
    styleRules
  } = $$props;
  $$self.$$.on_mount.push(function () {
    if (href === undefined && !('href' in $$props || $$self.$$.bound[$$self.$$.props['href']])) {
      console.warn("<StyleDriver> was created without expected prop 'href'");
    }
    if (styleRules === undefined && !('styleRules' in $$props || $$self.$$.bound[$$self.$$.props['styleRules']])) {
      console.warn("<StyleDriver> was created without expected prop 'styleRules'");
    }
  });
  const writable_props = ['href', 'styleRules'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<StyleDriver> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$$set = $$props => {
    if ('href' in $$props) $$invalidate(0, href = $$props.href);
    if ('styleRules' in $$props) $$invalidate(1, styleRules = $$props.styleRules);
  };
  $$self.$capture_state = () => ({
    isClientSide,
    getAllStylesBySelector,
    getStylesheet,
    setStyleRules,
    getURL,
    href,
    styleRules,
    styleRulesObj,
    allStyleRules,
    hrefURL
  });
  $$self.$inject_state = $$props => {
    if ('href' in $$props) $$invalidate(0, href = $$props.href);
    if ('styleRules' in $$props) $$invalidate(1, styleRules = $$props.styleRules);
    if ('styleRulesObj' in $$props) $$invalidate(2, styleRulesObj = $$props.styleRulesObj);
    if ('allStyleRules' in $$props) $$invalidate(3, allStyleRules = $$props.allStyleRules);
    if ('hrefURL' in $$props) $$invalidate(4, hrefURL = $$props.hrefURL);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*href*/1) {
      $$invalidate(4, hrefURL = isClientSide && href && getURL(href).toString());
    }
    if ($$self.$$.dirty & /*hrefURL*/16) {
      $$invalidate(3, allStyleRules = hrefURL ? [...getStylesheet(hrefURL).cssRules] : []); // convert collection to array
    }

    if ($$self.$$.dirty & /*allStyleRules*/8) {
      $$invalidate(2, styleRulesObj = getAllStylesBySelector(allStyleRules));
    }
    if ($$self.$$.dirty & /*styleRulesObj, styleRules*/6) {
      setStyleRules(styleRulesObj, styleRules);
    }
  };
  return [href, styleRules, styleRulesObj, allStyleRules, hrefURL];
}
class StyleDriver extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4z, create_fragment$4A, safe_not_equal, {
      href: 0,
      styleRules: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StyleDriver",
      options,
      id: create_fragment$4A.name
    });
  }
  get href() {
    throw new Error("<StyleDriver>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<StyleDriver>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get styleRules() {
    throw new Error("<StyleDriver>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set styleRules(value) {
    throw new Error("<StyleDriver>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
var StyleDriver$1 = StyleDriver;

/* ../../components/ui/src/icons/feather/Airplay.svelte generated by Svelte v3.59.2 */
const file$4v = "../../components/ui/src/icons/feather/Airplay.svelte";
function create_fragment$4z(ctx) {
  let path;
  let polygon;
  const block = {
    c: function create() {
      path = svg_element("path");
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1");
      add_location(path, file$4v, 1, 0, 34);
      attr_dev(polygon, "points", "12 15 17 21 7 21 12 15");
      add_location(polygon, file$4v, 1, 92, 126);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, polygon, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(polygon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4z.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4y($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Airplay', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Airplay> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Airplay extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4y, create_fragment$4z, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Airplay",
      options,
      id: create_fragment$4z.name
    });
  }
}
var Airplay$1 = Airplay;

/* ../../components/ui/src/icons/feather/AlertCircle.svelte generated by Svelte v3.59.2 */
const file$4u = "../../components/ui/src/icons/feather/AlertCircle.svelte";
function create_fragment$4y(ctx) {
  let circle;
  let line0;
  let line1;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file$4u, 1, 0, 34);
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "8");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "12");
      add_location(line0, file$4u, 1, 40, 74);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "16");
      attr_dev(line1, "x2", "12.01");
      attr_dev(line1, "y2", "16");
      add_location(line1, file$4u, 1, 84, 118);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4y.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4x($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('AlertCircle', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<AlertCircle> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class AlertCircle extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4x, create_fragment$4y, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AlertCircle",
      options,
      id: create_fragment$4y.name
    });
  }
}
var AlertCircle$1 = AlertCircle;

/* ../../components/ui/src/icons/feather/AlertOctagon.svelte generated by Svelte v3.59.2 */
const file$4t = "../../components/ui/src/icons/feather/AlertOctagon.svelte";
function create_fragment$4x(ctx) {
  let polygon;
  let line0;
  let line1;
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2");
      add_location(polygon, file$4t, 1, 0, 34);
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "8");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "12");
      add_location(line0, file$4t, 1, 99, 133);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "16");
      attr_dev(line1, "x2", "12.01");
      attr_dev(line1, "y2", "16");
      add_location(line1, file$4t, 1, 143, 177);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polygon);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4x.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4w($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('AlertOctagon', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<AlertOctagon> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class AlertOctagon extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4w, create_fragment$4x, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AlertOctagon",
      options,
      id: create_fragment$4x.name
    });
  }
}
var AlertOctagon$1 = AlertOctagon;

/* ../../components/ui/src/icons/feather/AlignCenter.svelte generated by Svelte v3.59.2 */
const file$4s = "../../components/ui/src/icons/feather/AlignCenter.svelte";
function create_fragment$4w(ctx) {
  let line0;
  let line1;
  let line2;
  let line3;
  const block = {
    c: function create() {
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line3).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "18");
      attr_dev(line0, "y1", "10");
      attr_dev(line0, "x2", "6");
      attr_dev(line0, "y2", "10");
      add_location(line0, file$4s, 1, 0, 34);
      attr_dev(line1, "x1", "21");
      attr_dev(line1, "y1", "6");
      attr_dev(line1, "x2", "3");
      attr_dev(line1, "y2", "6");
      add_location(line1, file$4s, 1, 44, 78);
      attr_dev(line2, "x1", "21");
      attr_dev(line2, "y1", "14");
      attr_dev(line2, "x2", "3");
      attr_dev(line2, "y2", "14");
      add_location(line2, file$4s, 1, 86, 120);
      attr_dev(line3, "x1", "18");
      attr_dev(line3, "y1", "18");
      attr_dev(line3, "x2", "6");
      attr_dev(line3, "y2", "18");
      add_location(line3, file$4s, 1, 130, 164);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
      insert_hydration_dev(target, line3, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
      if (detaching) detach_dev(line3);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4w.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4v($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('AlignCenter', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<AlignCenter> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class AlignCenter extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4v, create_fragment$4w, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AlignCenter",
      options,
      id: create_fragment$4w.name
    });
  }
}
var AlignCenter$1 = AlignCenter;

/* ../../components/ui/src/icons/feather/AlignJustify.svelte generated by Svelte v3.59.2 */
const file$4r = "../../components/ui/src/icons/feather/AlignJustify.svelte";
function create_fragment$4v(ctx) {
  let line0;
  let line1;
  let line2;
  let line3;
  const block = {
    c: function create() {
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line3).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "21");
      attr_dev(line0, "y1", "10");
      attr_dev(line0, "x2", "3");
      attr_dev(line0, "y2", "10");
      add_location(line0, file$4r, 1, 0, 34);
      attr_dev(line1, "x1", "21");
      attr_dev(line1, "y1", "6");
      attr_dev(line1, "x2", "3");
      attr_dev(line1, "y2", "6");
      add_location(line1, file$4r, 1, 44, 78);
      attr_dev(line2, "x1", "21");
      attr_dev(line2, "y1", "14");
      attr_dev(line2, "x2", "3");
      attr_dev(line2, "y2", "14");
      add_location(line2, file$4r, 1, 86, 120);
      attr_dev(line3, "x1", "21");
      attr_dev(line3, "y1", "18");
      attr_dev(line3, "x2", "3");
      attr_dev(line3, "y2", "18");
      add_location(line3, file$4r, 1, 130, 164);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
      insert_hydration_dev(target, line3, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
      if (detaching) detach_dev(line3);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4v.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4u($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('AlignJustify', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<AlignJustify> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class AlignJustify extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4u, create_fragment$4v, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AlignJustify",
      options,
      id: create_fragment$4v.name
    });
  }
}
var AlignJustify$1 = AlignJustify;

/* ../../components/ui/src/icons/feather/AlignLeft.svelte generated by Svelte v3.59.2 */
const file$4q = "../../components/ui/src/icons/feather/AlignLeft.svelte";
function create_fragment$4u(ctx) {
  let line0;
  let line1;
  let line2;
  let line3;
  const block = {
    c: function create() {
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line3).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "17");
      attr_dev(line0, "y1", "10");
      attr_dev(line0, "x2", "3");
      attr_dev(line0, "y2", "10");
      add_location(line0, file$4q, 1, 0, 34);
      attr_dev(line1, "x1", "21");
      attr_dev(line1, "y1", "6");
      attr_dev(line1, "x2", "3");
      attr_dev(line1, "y2", "6");
      add_location(line1, file$4q, 1, 44, 78);
      attr_dev(line2, "x1", "21");
      attr_dev(line2, "y1", "14");
      attr_dev(line2, "x2", "3");
      attr_dev(line2, "y2", "14");
      add_location(line2, file$4q, 1, 86, 120);
      attr_dev(line3, "x1", "17");
      attr_dev(line3, "y1", "18");
      attr_dev(line3, "x2", "3");
      attr_dev(line3, "y2", "18");
      add_location(line3, file$4q, 1, 130, 164);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
      insert_hydration_dev(target, line3, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
      if (detaching) detach_dev(line3);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4u.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4t($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('AlignLeft', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<AlignLeft> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class AlignLeft extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4t, create_fragment$4u, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AlignLeft",
      options,
      id: create_fragment$4u.name
    });
  }
}
var AlignLeft$1 = AlignLeft;

/* ../../components/ui/src/icons/feather/AlignRight.svelte generated by Svelte v3.59.2 */
const file$4p = "../../components/ui/src/icons/feather/AlignRight.svelte";
function create_fragment$4t(ctx) {
  let line0;
  let line1;
  let line2;
  let line3;
  const block = {
    c: function create() {
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line3).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "21");
      attr_dev(line0, "y1", "10");
      attr_dev(line0, "x2", "7");
      attr_dev(line0, "y2", "10");
      add_location(line0, file$4p, 1, 0, 34);
      attr_dev(line1, "x1", "21");
      attr_dev(line1, "y1", "6");
      attr_dev(line1, "x2", "3");
      attr_dev(line1, "y2", "6");
      add_location(line1, file$4p, 1, 44, 78);
      attr_dev(line2, "x1", "21");
      attr_dev(line2, "y1", "14");
      attr_dev(line2, "x2", "3");
      attr_dev(line2, "y2", "14");
      add_location(line2, file$4p, 1, 86, 120);
      attr_dev(line3, "x1", "21");
      attr_dev(line3, "y1", "18");
      attr_dev(line3, "x2", "7");
      attr_dev(line3, "y2", "18");
      add_location(line3, file$4p, 1, 130, 164);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
      insert_hydration_dev(target, line3, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
      if (detaching) detach_dev(line3);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4t.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4s($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('AlignRight', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<AlignRight> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class AlignRight extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4s, create_fragment$4t, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AlignRight",
      options,
      id: create_fragment$4t.name
    });
  }
}
var AlignRight$1 = AlignRight;

/* ../../components/ui/src/icons/feather/Anchor.svelte generated by Svelte v3.59.2 */
const file$4o = "../../components/ui/src/icons/feather/Anchor.svelte";
function create_fragment$4s(ctx) {
  let circle;
  let line;
  let path;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      line = svg_element("line");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "5");
      attr_dev(circle, "r", "3");
      add_location(circle, file$4o, 1, 0, 34);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "22");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "8");
      add_location(line, file$4o, 1, 38, 72);
      attr_dev(path, "d", "M5 12H2a10 10 0 0 0 20 0h-3");
      add_location(path, file$4o, 1, 82, 116);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, line, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(line);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4s.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4r($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Anchor', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Anchor> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Anchor extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4r, create_fragment$4s, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Anchor",
      options,
      id: create_fragment$4s.name
    });
  }
}
var Anchor$1 = Anchor;

/* ../../components/ui/src/icons/feather/Aperture.svelte generated by Svelte v3.59.2 */
const file$4n = "../../components/ui/src/icons/feather/Aperture.svelte";
function create_fragment$4r(ctx) {
  let circle;
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let line5;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      line5 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line3).forEach(detach_dev);
      line4 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line4).forEach(detach_dev);
      line5 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line5).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file$4n, 1, 0, 34);
      attr_dev(line0, "x1", "14.31");
      attr_dev(line0, "y1", "8");
      attr_dev(line0, "x2", "20.05");
      attr_dev(line0, "y2", "17.94");
      add_location(line0, file$4n, 1, 40, 74);
      attr_dev(line1, "x1", "9.69");
      attr_dev(line1, "y1", "8");
      attr_dev(line1, "x2", "21.17");
      attr_dev(line1, "y2", "8");
      add_location(line1, file$4n, 1, 93, 127);
      attr_dev(line2, "x1", "7.38");
      attr_dev(line2, "y1", "12");
      attr_dev(line2, "x2", "13.12");
      attr_dev(line2, "y2", "2.06");
      add_location(line2, file$4n, 1, 141, 175);
      attr_dev(line3, "x1", "9.69");
      attr_dev(line3, "y1", "16");
      attr_dev(line3, "x2", "3.95");
      attr_dev(line3, "y2", "6.06");
      add_location(line3, file$4n, 1, 193, 227);
      attr_dev(line4, "x1", "14.31");
      attr_dev(line4, "y1", "16");
      attr_dev(line4, "x2", "2.83");
      attr_dev(line4, "y2", "16");
      add_location(line4, file$4n, 1, 244, 278);
      attr_dev(line5, "x1", "16.62");
      attr_dev(line5, "y1", "12");
      attr_dev(line5, "x2", "10.88");
      attr_dev(line5, "y2", "21.94");
      add_location(line5, file$4n, 1, 294, 328);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
      insert_hydration_dev(target, line3, anchor);
      insert_hydration_dev(target, line4, anchor);
      insert_hydration_dev(target, line5, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
      if (detaching) detach_dev(line3);
      if (detaching) detach_dev(line4);
      if (detaching) detach_dev(line5);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4r.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4q($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Aperture', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Aperture> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Aperture extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4q, create_fragment$4r, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Aperture",
      options,
      id: create_fragment$4r.name
    });
  }
}
var Aperture$1 = Aperture;

/* ../../components/ui/src/icons/feather/Archive.svelte generated by Svelte v3.59.2 */
const file$4m = "../../components/ui/src/icons/feather/Archive.svelte";
function create_fragment$4q(ctx) {
  let polyline;
  let rect;
  let line;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      rect = svg_element("rect");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "21 8 21 21 3 21 3 8");
      add_location(polyline, file$4m, 1, 0, 34);
      attr_dev(rect, "x", "1");
      attr_dev(rect, "y", "3");
      attr_dev(rect, "width", "22");
      attr_dev(rect, "height", "5");
      add_location(rect, file$4m, 1, 50, 84);
      attr_dev(line, "x1", "10");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "14");
      attr_dev(line, "y2", "12");
      add_location(line, file$4m, 1, 97, 131);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4q.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4p($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Archive', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Archive> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Archive extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4p, create_fragment$4q, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Archive",
      options,
      id: create_fragment$4q.name
    });
  }
}
var Archive$1 = Archive;

/* ../../components/ui/src/icons/feather/ArrowDownCircle.svelte generated by Svelte v3.59.2 */
const file$4l = "../../components/ui/src/icons/feather/ArrowDownCircle.svelte";
function create_fragment$4p(ctx) {
  let circle;
  let polyline;
  let line;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      polyline = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file$4l, 1, 0, 34);
      attr_dev(polyline, "points", "8 12 12 16 16 12");
      add_location(polyline, file$4l, 1, 40, 74);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "8");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "16");
      add_location(line, file$4l, 1, 87, 121);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4p.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4o($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ArrowDownCircle', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ArrowDownCircle> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ArrowDownCircle extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4o, create_fragment$4p, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowDownCircle",
      options,
      id: create_fragment$4p.name
    });
  }
}
var ArrowDownCircle$1 = ArrowDownCircle;

/* ../../components/ui/src/icons/feather/ArrowDownLeft.svelte generated by Svelte v3.59.2 */
const file$4k = "../../components/ui/src/icons/feather/ArrowDownLeft.svelte";
function create_fragment$4o(ctx) {
  let line;
  let polyline;
  const block = {
    c: function create() {
      line = svg_element("line");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "17");
      attr_dev(line, "y1", "7");
      attr_dev(line, "x2", "7");
      attr_dev(line, "y2", "17");
      add_location(line, file$4k, 1, 0, 34);
      attr_dev(polyline, "points", "17 17 7 17 7 7");
      add_location(polyline, file$4k, 1, 43, 77);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line, anchor);
      insert_hydration_dev(target, polyline, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line);
      if (detaching) detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4o.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4n($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ArrowDownLeft', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ArrowDownLeft> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ArrowDownLeft extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4n, create_fragment$4o, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowDownLeft",
      options,
      id: create_fragment$4o.name
    });
  }
}
var ArrowDownLeft$1 = ArrowDownLeft;

/* ../../components/ui/src/icons/feather/ArrowDownRight.svelte generated by Svelte v3.59.2 */
const file$4j = "../../components/ui/src/icons/feather/ArrowDownRight.svelte";
function create_fragment$4n(ctx) {
  let line;
  let polyline;
  const block = {
    c: function create() {
      line = svg_element("line");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "7");
      attr_dev(line, "y1", "7");
      attr_dev(line, "x2", "17");
      attr_dev(line, "y2", "17");
      add_location(line, file$4j, 1, 0, 34);
      attr_dev(polyline, "points", "17 7 17 17 7 17");
      add_location(polyline, file$4j, 1, 43, 77);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line, anchor);
      insert_hydration_dev(target, polyline, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line);
      if (detaching) detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4n.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4m($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ArrowDownRight', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ArrowDownRight> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ArrowDownRight extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4m, create_fragment$4n, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowDownRight",
      options,
      id: create_fragment$4n.name
    });
  }
}
var ArrowDownRight$1 = ArrowDownRight;

/* ../../components/ui/src/icons/feather/ArrowDown.svelte generated by Svelte v3.59.2 */
const file$4i = "../../components/ui/src/icons/feather/ArrowDown.svelte";
function create_fragment$4m(ctx) {
  let line;
  let polyline;
  const block = {
    c: function create() {
      line = svg_element("line");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "5");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "19");
      add_location(line, file$4i, 1, 0, 34);
      attr_dev(polyline, "points", "19 12 12 19 5 12");
      add_location(polyline, file$4i, 1, 44, 78);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line, anchor);
      insert_hydration_dev(target, polyline, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line);
      if (detaching) detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4m.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4l($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ArrowDown', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ArrowDown> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ArrowDown extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4l, create_fragment$4m, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowDown",
      options,
      id: create_fragment$4m.name
    });
  }
}
var ArrowDown$1 = ArrowDown;

/* ../../components/ui/src/icons/feather/ArrowLeft.svelte generated by Svelte v3.59.2 */
const file$4h = "../../components/ui/src/icons/feather/ArrowLeft.svelte";
function create_fragment$4l(ctx) {
  let line;
  let polyline;
  const block = {
    c: function create() {
      line = svg_element("line");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "19");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "5");
      attr_dev(line, "y2", "12");
      add_location(line, file$4h, 1, 0, 34);
      attr_dev(polyline, "points", "12 19 5 12 12 5");
      add_location(polyline, file$4h, 1, 44, 78);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line, anchor);
      insert_hydration_dev(target, polyline, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line);
      if (detaching) detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4l.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4k($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ArrowLeft', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ArrowLeft> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ArrowLeft extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4k, create_fragment$4l, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowLeft",
      options,
      id: create_fragment$4l.name
    });
  }
}
var ArrowLeft$1 = ArrowLeft;

/* ../../components/ui/src/icons/feather/ArrowRight.svelte generated by Svelte v3.59.2 */
const file$4g = "../../components/ui/src/icons/feather/ArrowRight.svelte";
function create_fragment$4k(ctx) {
  let line;
  let polyline;
  const block = {
    c: function create() {
      line = svg_element("line");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "5");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "19");
      attr_dev(line, "y2", "12");
      add_location(line, file$4g, 1, 0, 34);
      attr_dev(polyline, "points", "12 5 19 12 12 19");
      add_location(polyline, file$4g, 1, 44, 78);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line, anchor);
      insert_hydration_dev(target, polyline, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line);
      if (detaching) detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4k.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4j($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ArrowRight', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ArrowRight> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ArrowRight extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4j, create_fragment$4k, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowRight",
      options,
      id: create_fragment$4k.name
    });
  }
}
var ArrowRight$1 = ArrowRight;

/* ../../components/ui/src/icons/feather/ArrowUpCircle.svelte generated by Svelte v3.59.2 */
const file$4f = "../../components/ui/src/icons/feather/ArrowUpCircle.svelte";
function create_fragment$4j(ctx) {
  let circle;
  let polyline;
  let line;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      polyline = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file$4f, 1, 0, 34);
      attr_dev(polyline, "points", "16 12 12 8 8 12");
      add_location(polyline, file$4f, 1, 40, 74);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "16");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "8");
      add_location(line, file$4f, 1, 86, 120);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4j.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4i($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ArrowUpCircle', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ArrowUpCircle> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ArrowUpCircle extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4i, create_fragment$4j, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowUpCircle",
      options,
      id: create_fragment$4j.name
    });
  }
}
var ArrowUpCircle$1 = ArrowUpCircle;

/* ../../components/ui/src/icons/feather/ArrowUpLeft.svelte generated by Svelte v3.59.2 */
const file$4e = "../../components/ui/src/icons/feather/ArrowUpLeft.svelte";
function create_fragment$4i(ctx) {
  let line;
  let polyline;
  const block = {
    c: function create() {
      line = svg_element("line");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "17");
      attr_dev(line, "y1", "17");
      attr_dev(line, "x2", "7");
      attr_dev(line, "y2", "7");
      add_location(line, file$4e, 1, 0, 34);
      attr_dev(polyline, "points", "7 17 7 7 17 7");
      add_location(polyline, file$4e, 1, 43, 77);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line, anchor);
      insert_hydration_dev(target, polyline, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line);
      if (detaching) detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4i.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4h($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ArrowUpLeft', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ArrowUpLeft> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ArrowUpLeft extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4h, create_fragment$4i, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowUpLeft",
      options,
      id: create_fragment$4i.name
    });
  }
}
var ArrowUpLeft$1 = ArrowUpLeft;

/* ../../components/ui/src/icons/feather/ArrowUpRight.svelte generated by Svelte v3.59.2 */
const file$4d = "../../components/ui/src/icons/feather/ArrowUpRight.svelte";
function create_fragment$4h(ctx) {
  let line;
  let polyline;
  const block = {
    c: function create() {
      line = svg_element("line");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "7");
      attr_dev(line, "y1", "17");
      attr_dev(line, "x2", "17");
      attr_dev(line, "y2", "7");
      add_location(line, file$4d, 1, 0, 34);
      attr_dev(polyline, "points", "7 7 17 7 17 17");
      add_location(polyline, file$4d, 1, 43, 77);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line, anchor);
      insert_hydration_dev(target, polyline, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line);
      if (detaching) detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4h.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4g($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ArrowUpRight', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ArrowUpRight> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ArrowUpRight extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4g, create_fragment$4h, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowUpRight",
      options,
      id: create_fragment$4h.name
    });
  }
}
var ArrowUpRight$1 = ArrowUpRight;

/* ../../components/ui/src/icons/feather/ArrowUp.svelte generated by Svelte v3.59.2 */
const file$4c = "../../components/ui/src/icons/feather/ArrowUp.svelte";
function create_fragment$4g(ctx) {
  let line;
  let polyline;
  const block = {
    c: function create() {
      line = svg_element("line");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "19");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "5");
      add_location(line, file$4c, 1, 0, 34);
      attr_dev(polyline, "points", "5 12 12 5 19 12");
      add_location(polyline, file$4c, 1, 44, 78);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line, anchor);
      insert_hydration_dev(target, polyline, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line);
      if (detaching) detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4g.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4f($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ArrowUp', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ArrowUp> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ArrowUp extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4f, create_fragment$4g, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ArrowUp",
      options,
      id: create_fragment$4g.name
    });
  }
}
var ArrowUp$1 = ArrowUp;

/* ../../components/ui/src/icons/feather/AtSign.svelte generated by Svelte v3.59.2 */
const file$4b = "../../components/ui/src/icons/feather/AtSign.svelte";
function create_fragment$4f(ctx) {
  let circle;
  let path;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "4");
      add_location(circle, file$4b, 1, 0, 34);
      attr_dev(path, "d", "M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94");
      add_location(path, file$4b, 1, 39, 73);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4f.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4e($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('AtSign', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<AtSign> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class AtSign extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4e, create_fragment$4f, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "AtSign",
      options,
      id: create_fragment$4f.name
    });
  }
}
var AtSign$1 = AtSign;

/* ../../components/ui/src/icons/feather/Award.svelte generated by Svelte v3.59.2 */
const file$4a = "../../components/ui/src/icons/feather/Award.svelte";
function create_fragment$4e(ctx) {
  let circle;
  let polyline;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "8");
      attr_dev(circle, "r", "7");
      add_location(circle, file$4a, 1, 0, 34);
      attr_dev(polyline, "points", "8.21 13.89 7 23 12 20 17 23 15.79 13.88");
      add_location(polyline, file$4a, 1, 38, 72);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, polyline, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4e.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4d($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Award', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Award> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Award extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4d, create_fragment$4e, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Award",
      options,
      id: create_fragment$4e.name
    });
  }
}
var Award$1 = Award;

/* ../../components/ui/src/icons/feather/BarChart2.svelte generated by Svelte v3.59.2 */
const file$49 = "../../components/ui/src/icons/feather/BarChart2.svelte";
function create_fragment$4d(ctx) {
  let line0;
  let line1;
  let line2;
  const block = {
    c: function create() {
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "18");
      attr_dev(line0, "y1", "20");
      attr_dev(line0, "x2", "18");
      attr_dev(line0, "y2", "10");
      add_location(line0, file$49, 1, 0, 34);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "20");
      attr_dev(line1, "x2", "12");
      attr_dev(line1, "y2", "4");
      add_location(line1, file$49, 1, 45, 79);
      attr_dev(line2, "x1", "6");
      attr_dev(line2, "y1", "20");
      attr_dev(line2, "x2", "6");
      attr_dev(line2, "y2", "14");
      add_location(line2, file$49, 1, 89, 123);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4d.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4c($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('BarChart2', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<BarChart2> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class BarChart2 extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4c, create_fragment$4d, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BarChart2",
      options,
      id: create_fragment$4d.name
    });
  }
}
var BarChart2$1 = BarChart2;

/* ../../components/ui/src/icons/feather/BatteryCharging.svelte generated by Svelte v3.59.2 */
const file$48 = "../../components/ui/src/icons/feather/BatteryCharging.svelte";
function create_fragment$4c(ctx) {
  let path;
  let line;
  let polyline;
  const block = {
    c: function create() {
      path = svg_element("path");
      line = svg_element("line");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5 18H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3.19M15 6h2a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-3.19");
      add_location(path, file$48, 1, 0, 34);
      attr_dev(line, "x1", "23");
      attr_dev(line, "y1", "13");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "11");
      add_location(line, file$48, 1, 103, 137);
      attr_dev(polyline, "points", "11 6 7 12 13 12 9 18");
      add_location(polyline, file$48, 1, 148, 182);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line, anchor);
      insert_hydration_dev(target, polyline, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line);
      if (detaching) detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4c.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4b($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('BatteryCharging', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<BatteryCharging> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class BatteryCharging extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4b, create_fragment$4c, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BatteryCharging",
      options,
      id: create_fragment$4c.name
    });
  }
}
var BatteryCharging$1 = BatteryCharging;

/* ../../components/ui/src/icons/feather/Battery.svelte generated by Svelte v3.59.2 */
const file$47 = "../../components/ui/src/icons/feather/Battery.svelte";
function create_fragment$4b(ctx) {
  let rect;
  let line;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "1");
      attr_dev(rect, "y", "6");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "12");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file$47, 1, 0, 34);
      attr_dev(line, "x1", "23");
      attr_dev(line, "y1", "13");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "11");
      add_location(line, file$47, 1, 62, 96);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4b.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4a($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Battery', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Battery> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Battery extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4a, create_fragment$4b, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Battery",
      options,
      id: create_fragment$4b.name
    });
  }
}
var Battery$1 = Battery;

/* ../../components/ui/src/icons/feather/BellOff.svelte generated by Svelte v3.59.2 */
const file$46 = "../../components/ui/src/icons/feather/BellOff.svelte";
function create_fragment$4a(ctx) {
  let path0;
  let path1;
  let path2;
  let path3;
  let line;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      path3 = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      path2 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path2).forEach(detach_dev);
      path3 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path3).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M13.73 21a2 2 0 0 1-3.46 0");
      add_location(path0, file$46, 1, 0, 34);
      attr_dev(path1, "d", "M18.63 13A17.89 17.89 0 0 1 18 8");
      add_location(path1, file$46, 1, 44, 78);
      attr_dev(path2, "d", "M6.26 6.26A5.86 5.86 0 0 0 6 8c0 7-3 9-3 9h14");
      add_location(path2, file$46, 1, 94, 128);
      attr_dev(path3, "d", "M18 8a6 6 0 0 0-9.33-5");
      add_location(path3, file$46, 1, 157, 191);
      attr_dev(line, "x1", "1");
      attr_dev(line, "y1", "1");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "23");
      add_location(line, file$46, 1, 197, 231);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, path2, anchor);
      insert_hydration_dev(target, path3, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(path1);
      if (detaching) detach_dev(path2);
      if (detaching) detach_dev(path3);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4a.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$49($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('BellOff', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<BellOff> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class BellOff extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$49, create_fragment$4a, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BellOff",
      options,
      id: create_fragment$4a.name
    });
  }
}
var BellOff$1 = BellOff;

/* ../../components/ui/src/icons/feather/Bell.svelte generated by Svelte v3.59.2 */
const file$45 = "../../components/ui/src/icons/feather/Bell.svelte";
function create_fragment$49(ctx) {
  let path0;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9");
      add_location(path0, file$45, 1, 0, 34);
      attr_dev(path1, "d", "M13.73 21a2 2 0 0 1-3.46 0");
      add_location(path1, file$45, 1, 61, 95);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(path1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$49.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$48($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Bell', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Bell> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Bell extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$48, create_fragment$49, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Bell",
      options,
      id: create_fragment$49.name
    });
  }
}
var Bell$1 = Bell;

/* ../../components/ui/src/icons/feather/Bluetooth.svelte generated by Svelte v3.59.2 */
const file$44 = "../../components/ui/src/icons/feather/Bluetooth.svelte";
function create_fragment$48(ctx) {
  let polyline;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "6.5 6.5 17.5 17.5 12 23 12 1 17.5 6.5 6.5 17.5");
      add_location(polyline, file$44, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$48.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$47($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Bluetooth', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Bluetooth> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Bluetooth extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$47, create_fragment$48, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Bluetooth",
      options,
      id: create_fragment$48.name
    });
  }
}
var Bluetooth$1 = Bluetooth;

/* ../../components/ui/src/icons/feather/Bold.svelte generated by Svelte v3.59.2 */
const file$43 = "../../components/ui/src/icons/feather/Bold.svelte";
function create_fragment$47(ctx) {
  let path0;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z");
      add_location(path0, file$43, 1, 0, 34);
      attr_dev(path1, "d", "M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z");
      add_location(path1, file$43, 1, 55, 89);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(path1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$47.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$46($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Bold', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Bold> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Bold extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$46, create_fragment$47, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Bold",
      options,
      id: create_fragment$47.name
    });
  }
}
var Bold$1 = Bold;

/* ../../components/ui/src/icons/feather/BookOpen.svelte generated by Svelte v3.59.2 */
const file$42 = "../../components/ui/src/icons/feather/BookOpen.svelte";
function create_fragment$46(ctx) {
  let path0;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z");
      add_location(path0, file$42, 1, 0, 34);
      attr_dev(path1, "d", "M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z");
      add_location(path1, file$42, 1, 58, 92);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(path1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$46.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$45($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('BookOpen', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<BookOpen> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class BookOpen extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$45, create_fragment$46, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "BookOpen",
      options,
      id: create_fragment$46.name
    });
  }
}
var BookOpen$1 = BookOpen;

/* ../../components/ui/src/icons/feather/Book.svelte generated by Svelte v3.59.2 */
const file$41 = "../../components/ui/src/icons/feather/Book.svelte";
function create_fragment$45(ctx) {
  let path0;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M4 19.5A2.5 2.5 0 0 1 6.5 17H20");
      add_location(path0, file$41, 1, 0, 34);
      attr_dev(path1, "d", "M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z");
      add_location(path1, file$41, 1, 49, 83);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(path1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$45.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$44($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Book', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Book> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Book extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$44, create_fragment$45, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Book",
      options,
      id: create_fragment$45.name
    });
  }
}
var Book$1 = Book;

/* ../../components/ui/src/icons/feather/Bookmark.svelte generated by Svelte v3.59.2 */
const file$40 = "../../components/ui/src/icons/feather/Bookmark.svelte";
function create_fragment$44(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z");
      add_location(path, file$40, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$44.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$43($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Bookmark', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Bookmark> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Bookmark extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$43, create_fragment$44, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Bookmark",
      options,
      id: create_fragment$44.name
    });
  }
}
var Bookmark$1 = Bookmark;

/* ../../components/ui/src/icons/feather/Box.svelte generated by Svelte v3.59.2 */
const file$3$ = "../../components/ui/src/icons/feather/Box.svelte";
function create_fragment$43(ctx) {
  let path;
  let polyline;
  let line;
  const block = {
    c: function create() {
      path = svg_element("path");
      polyline = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z");
      add_location(path, file$3$, 1, 0, 34);
      attr_dev(polyline, "points", "3.27 6.96 12 12.01 20.73 6.96");
      add_location(polyline, file$3$, 1, 139, 173);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "22.08");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "12");
      add_location(line, file$3$, 1, 199, 233);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$43.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$42($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Box', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Box> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Box extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$42, create_fragment$43, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Box",
      options,
      id: create_fragment$43.name
    });
  }
}
var Box$1 = Box;

/* ../../components/ui/src/icons/feather/Briefcase.svelte generated by Svelte v3.59.2 */
const file$3_ = "../../components/ui/src/icons/feather/Briefcase.svelte";
function create_fragment$42(ctx) {
  let rect;
  let path;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "2");
      attr_dev(rect, "y", "7");
      attr_dev(rect, "width", "20");
      attr_dev(rect, "height", "14");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file$3_, 1, 0, 34);
      attr_dev(path, "d", "M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16");
      add_location(path, file$3_, 1, 62, 96);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$42.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$41($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Briefcase', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Briefcase> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Briefcase extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$41, create_fragment$42, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Briefcase",
      options,
      id: create_fragment$42.name
    });
  }
}
var Briefcase$1 = Briefcase;

/* ../../components/ui/src/icons/feather/Calendar.svelte generated by Svelte v3.59.2 */
const file$3Z = "../../components/ui/src/icons/feather/Calendar.svelte";
function create_fragment$41(ctx) {
  let rect;
  let line0;
  let line1;
  let line2;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "3");
      attr_dev(rect, "y", "4");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "18");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file$3Z, 1, 0, 34);
      attr_dev(line0, "x1", "16");
      attr_dev(line0, "y1", "2");
      attr_dev(line0, "x2", "16");
      attr_dev(line0, "y2", "6");
      add_location(line0, file$3Z, 1, 62, 96);
      attr_dev(line1, "x1", "8");
      attr_dev(line1, "y1", "2");
      attr_dev(line1, "x2", "8");
      attr_dev(line1, "y2", "6");
      add_location(line1, file$3Z, 1, 105, 139);
      attr_dev(line2, "x1", "3");
      attr_dev(line2, "y1", "10");
      attr_dev(line2, "x2", "21");
      attr_dev(line2, "y2", "10");
      add_location(line2, file$3Z, 1, 146, 180);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$41.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$40($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Calendar', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Calendar> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Calendar extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$40, create_fragment$41, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Calendar",
      options,
      id: create_fragment$41.name
    });
  }
}
var Calendar$1 = Calendar;

/* ../../components/ui/src/icons/feather/CameraOff.svelte generated by Svelte v3.59.2 */
const file$3Y = "../../components/ui/src/icons/feather/CameraOff.svelte";
function create_fragment$40(ctx) {
  let line;
  let path;
  const block = {
    c: function create() {
      line = svg_element("line");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "1");
      attr_dev(line, "y1", "1");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "23");
      add_location(line, file$3Y, 1, 0, 34);
      attr_dev(path, "d", "M21 21H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3m3-3h6l2 3h4a2 2 0 0 1 2 2v9.34m-7.72-2.06a4 4 0 1 1-5.56-5.56");
      add_location(path, file$3Y, 1, 43, 77);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$40.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3$($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('CameraOff', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<CameraOff> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class CameraOff extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3$, create_fragment$40, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CameraOff",
      options,
      id: create_fragment$40.name
    });
  }
}
var CameraOff$1 = CameraOff;

/* ../../components/ui/src/icons/feather/Camera.svelte generated by Svelte v3.59.2 */
const file$3X = "../../components/ui/src/icons/feather/Camera.svelte";
function create_fragment$3$(ctx) {
  let path;
  let circle;
  const block = {
    c: function create() {
      path = svg_element("path");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z");
      add_location(path, file$3X, 1, 0, 34);
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "13");
      attr_dev(circle, "r", "4");
      add_location(circle, file$3X, 1, 99, 133);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, circle, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(circle);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3$.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3_($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Camera', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Camera> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Camera extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3_, create_fragment$3$, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Camera",
      options,
      id: create_fragment$3$.name
    });
  }
}
var Camera$1 = Camera;

/* ../../components/ui/src/icons/feather/Cast.svelte generated by Svelte v3.59.2 */
const file$3W = "../../components/ui/src/icons/feather/Cast.svelte";
function create_fragment$3_(ctx) {
  let path;
  let line;
  const block = {
    c: function create() {
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6");
      add_location(path, file$3W, 1, 0, 34);
      attr_dev(line, "x1", "2");
      attr_dev(line, "y1", "20");
      attr_dev(line, "x2", "2.01");
      attr_dev(line, "y2", "20");
      add_location(line, file$3W, 1, 125, 159);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3_.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3Z($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Cast', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Cast> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Cast extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3Z, create_fragment$3_, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Cast",
      options,
      id: create_fragment$3_.name
    });
  }
}
var Cast$1 = Cast;

/* ../../components/ui/src/icons/feather/CheckCircle.svelte generated by Svelte v3.59.2 */
const file$3V = "../../components/ui/src/icons/feather/CheckCircle.svelte";
function create_fragment$3Z(ctx) {
  let path;
  let polyline;
  const block = {
    c: function create() {
      path = svg_element("path");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 11.08V12a10 10 0 1 1-5.93-9.14");
      add_location(path, file$3V, 1, 0, 34);
      attr_dev(polyline, "points", "22 4 12 14.01 9 11.01");
      add_location(polyline, file$3V, 1, 52, 86);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, polyline, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3Z.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3Y($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('CheckCircle', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<CheckCircle> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class CheckCircle extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3Y, create_fragment$3Z, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CheckCircle",
      options,
      id: create_fragment$3Z.name
    });
  }
}
var CheckCircle$1 = CheckCircle;

/* ../../components/ui/src/icons/feather/Check.svelte generated by Svelte v3.59.2 */
const file$3U = "../../components/ui/src/icons/feather/Check.svelte";
function create_fragment$3Y(ctx) {
  let polyline;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "20 6 9 17 4 12");
      add_location(polyline, file$3U, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3Y.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3X($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Check', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Check> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Check extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3X, create_fragment$3Y, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Check",
      options,
      id: create_fragment$3Y.name
    });
  }
}
var Check$1 = Check;

/* ../../components/ui/src/icons/feather/ChevronsDown.svelte generated by Svelte v3.59.2 */
const file$3T = "../../components/ui/src/icons/feather/ChevronsDown.svelte";
function create_fragment$3X(ctx) {
  let polyline0;
  let polyline1;
  const block = {
    c: function create() {
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      polyline0 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "7 13 12 18 17 13");
      add_location(polyline0, file$3T, 1, 0, 34);
      attr_dev(polyline1, "points", "7 6 12 11 17 6");
      add_location(polyline1, file$3T, 1, 47, 81);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline0, anchor);
      insert_hydration_dev(target, polyline1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline0);
      if (detaching) detach_dev(polyline1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3X.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3W($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ChevronsDown', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ChevronsDown> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ChevronsDown extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3W, create_fragment$3X, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChevronsDown",
      options,
      id: create_fragment$3X.name
    });
  }
}
var ChevronsDown$1 = ChevronsDown;

/* ../../components/ui/src/icons/feather/ChevronsLeft.svelte generated by Svelte v3.59.2 */
const file$3S = "../../components/ui/src/icons/feather/ChevronsLeft.svelte";
function create_fragment$3W(ctx) {
  let polyline0;
  let polyline1;
  const block = {
    c: function create() {
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      polyline0 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "11 17 6 12 11 7");
      add_location(polyline0, file$3S, 1, 0, 34);
      attr_dev(polyline1, "points", "18 17 13 12 18 7");
      add_location(polyline1, file$3S, 1, 46, 80);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline0, anchor);
      insert_hydration_dev(target, polyline1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline0);
      if (detaching) detach_dev(polyline1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3W.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3V($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ChevronsLeft', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ChevronsLeft> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ChevronsLeft extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3V, create_fragment$3W, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChevronsLeft",
      options,
      id: create_fragment$3W.name
    });
  }
}
var ChevronsLeft$1 = ChevronsLeft;

/* ../../components/ui/src/icons/feather/ChevronsRight.svelte generated by Svelte v3.59.2 */
const file$3R = "../../components/ui/src/icons/feather/ChevronsRight.svelte";
function create_fragment$3V(ctx) {
  let polyline0;
  let polyline1;
  const block = {
    c: function create() {
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      polyline0 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "13 17 18 12 13 7");
      add_location(polyline0, file$3R, 1, 0, 34);
      attr_dev(polyline1, "points", "6 17 11 12 6 7");
      add_location(polyline1, file$3R, 1, 47, 81);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline0, anchor);
      insert_hydration_dev(target, polyline1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline0);
      if (detaching) detach_dev(polyline1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3V.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3U($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ChevronsRight', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ChevronsRight> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ChevronsRight extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3U, create_fragment$3V, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChevronsRight",
      options,
      id: create_fragment$3V.name
    });
  }
}
var ChevronsRight$1 = ChevronsRight;

/* ../../components/ui/src/icons/feather/ChevronsUp.svelte generated by Svelte v3.59.2 */
const file$3Q = "../../components/ui/src/icons/feather/ChevronsUp.svelte";
function create_fragment$3U(ctx) {
  let polyline0;
  let polyline1;
  const block = {
    c: function create() {
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      polyline0 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "17 11 12 6 7 11");
      add_location(polyline0, file$3Q, 1, 0, 34);
      attr_dev(polyline1, "points", "17 18 12 13 7 18");
      add_location(polyline1, file$3Q, 1, 46, 80);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline0, anchor);
      insert_hydration_dev(target, polyline1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline0);
      if (detaching) detach_dev(polyline1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3U.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3T($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ChevronsUp', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ChevronsUp> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ChevronsUp extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3T, create_fragment$3U, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChevronsUp",
      options,
      id: create_fragment$3U.name
    });
  }
}
var ChevronsUp$1 = ChevronsUp;

/* ../../components/ui/src/icons/feather/Chrome.svelte generated by Svelte v3.59.2 */
const file$3P = "../../components/ui/src/icons/feather/Chrome.svelte";
function create_fragment$3T(ctx) {
  let circle0;
  let circle1;
  let line0;
  let line1;
  let line2;
  const block = {
    c: function create() {
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      circle0 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle1).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "12");
      attr_dev(circle0, "cy", "12");
      attr_dev(circle0, "r", "10");
      add_location(circle0, file$3P, 1, 0, 34);
      attr_dev(circle1, "cx", "12");
      attr_dev(circle1, "cy", "12");
      attr_dev(circle1, "r", "4");
      add_location(circle1, file$3P, 1, 40, 74);
      attr_dev(line0, "x1", "21.17");
      attr_dev(line0, "y1", "8");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "8");
      add_location(line0, file$3P, 1, 79, 113);
      attr_dev(line1, "x1", "3.95");
      attr_dev(line1, "y1", "6.06");
      attr_dev(line1, "x2", "8.54");
      attr_dev(line1, "y2", "14");
      add_location(line1, file$3P, 1, 125, 159);
      attr_dev(line2, "x1", "10.88");
      attr_dev(line2, "y1", "21.94");
      attr_dev(line2, "x2", "15.46");
      attr_dev(line2, "y2", "14");
      add_location(line2, file$3P, 1, 176, 210);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle0, anchor);
      insert_hydration_dev(target, circle1, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle0);
      if (detaching) detach_dev(circle1);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3T.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3S($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Chrome', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Chrome> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Chrome extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3S, create_fragment$3T, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Chrome",
      options,
      id: create_fragment$3T.name
    });
  }
}
var Chrome$1 = Chrome;

/* ../../components/ui/src/icons/feather/Circle.svelte generated by Svelte v3.59.2 */
const file$3O = "../../components/ui/src/icons/feather/Circle.svelte";
function create_fragment$3S(ctx) {
  let circle;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file$3O, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3S.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3R($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Circle', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Circle> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Circle extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3R, create_fragment$3S, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Circle",
      options,
      id: create_fragment$3S.name
    });
  }
}
var Circle$1 = Circle;

/* ../../components/ui/src/icons/feather/CloudDrizzle.svelte generated by Svelte v3.59.2 */
const file$3N = "../../components/ui/src/icons/feather/CloudDrizzle.svelte";
function create_fragment$3R(ctx) {
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let line5;
  let path;
  const block = {
    c: function create() {
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      line5 = svg_element("line");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line3).forEach(detach_dev);
      line4 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line4).forEach(detach_dev);
      line5 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line5).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "8");
      attr_dev(line0, "y1", "19");
      attr_dev(line0, "x2", "8");
      attr_dev(line0, "y2", "21");
      add_location(line0, file$3N, 1, 0, 34);
      attr_dev(line1, "x1", "8");
      attr_dev(line1, "y1", "13");
      attr_dev(line1, "x2", "8");
      attr_dev(line1, "y2", "15");
      add_location(line1, file$3N, 1, 43, 77);
      attr_dev(line2, "x1", "16");
      attr_dev(line2, "y1", "19");
      attr_dev(line2, "x2", "16");
      attr_dev(line2, "y2", "21");
      add_location(line2, file$3N, 1, 86, 120);
      attr_dev(line3, "x1", "16");
      attr_dev(line3, "y1", "13");
      attr_dev(line3, "x2", "16");
      attr_dev(line3, "y2", "15");
      add_location(line3, file$3N, 1, 131, 165);
      attr_dev(line4, "x1", "12");
      attr_dev(line4, "y1", "21");
      attr_dev(line4, "x2", "12");
      attr_dev(line4, "y2", "23");
      add_location(line4, file$3N, 1, 176, 210);
      attr_dev(line5, "x1", "12");
      attr_dev(line5, "y1", "15");
      attr_dev(line5, "x2", "12");
      attr_dev(line5, "y2", "17");
      add_location(line5, file$3N, 1, 221, 255);
      attr_dev(path, "d", "M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25");
      add_location(path, file$3N, 1, 266, 300);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
      insert_hydration_dev(target, line3, anchor);
      insert_hydration_dev(target, line4, anchor);
      insert_hydration_dev(target, line5, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
      if (detaching) detach_dev(line3);
      if (detaching) detach_dev(line4);
      if (detaching) detach_dev(line5);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3R.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3Q($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('CloudDrizzle', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<CloudDrizzle> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class CloudDrizzle extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3Q, create_fragment$3R, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CloudDrizzle",
      options,
      id: create_fragment$3R.name
    });
  }
}
var CloudDrizzle$1 = CloudDrizzle;

/* ../../components/ui/src/icons/feather/CloudLightning.svelte generated by Svelte v3.59.2 */
const file$3M = "../../components/ui/src/icons/feather/CloudLightning.svelte";
function create_fragment$3Q(ctx) {
  let path;
  let polyline;
  const block = {
    c: function create() {
      path = svg_element("path");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 16.9A5 5 0 0 0 18 7h-1.26a8 8 0 1 0-11.62 9");
      add_location(path, file$3M, 1, 0, 34);
      attr_dev(polyline, "points", "13 11 9 17 15 17 11 23");
      add_location(polyline, file$3M, 1, 65, 99);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, polyline, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3Q.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3P($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('CloudLightning', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<CloudLightning> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class CloudLightning extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3P, create_fragment$3Q, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CloudLightning",
      options,
      id: create_fragment$3Q.name
    });
  }
}
var CloudLightning$1 = CloudLightning;

/* ../../components/ui/src/icons/feather/CloudOff.svelte generated by Svelte v3.59.2 */
const file$3L = "../../components/ui/src/icons/feather/CloudOff.svelte";
function create_fragment$3P(ctx) {
  let path;
  let line;
  const block = {
    c: function create() {
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3");
      add_location(path, file$3L, 1, 0, 34);
      attr_dev(line, "x1", "1");
      attr_dev(line, "y1", "1");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "23");
      add_location(line, file$3L, 1, 107, 141);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3P.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3O($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('CloudOff', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<CloudOff> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class CloudOff extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3O, create_fragment$3P, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CloudOff",
      options,
      id: create_fragment$3P.name
    });
  }
}
var CloudOff$1 = CloudOff;

/* ../../components/ui/src/icons/feather/CloudRain.svelte generated by Svelte v3.59.2 */
const file$3K = "../../components/ui/src/icons/feather/CloudRain.svelte";
function create_fragment$3O(ctx) {
  let line0;
  let line1;
  let line2;
  let path;
  const block = {
    c: function create() {
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "16");
      attr_dev(line0, "y1", "13");
      attr_dev(line0, "x2", "16");
      attr_dev(line0, "y2", "21");
      add_location(line0, file$3K, 1, 0, 34);
      attr_dev(line1, "x1", "8");
      attr_dev(line1, "y1", "13");
      attr_dev(line1, "x2", "8");
      attr_dev(line1, "y2", "21");
      add_location(line1, file$3K, 1, 45, 79);
      attr_dev(line2, "x1", "12");
      attr_dev(line2, "y1", "15");
      attr_dev(line2, "x2", "12");
      attr_dev(line2, "y2", "23");
      add_location(line2, file$3K, 1, 88, 122);
      attr_dev(path, "d", "M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25");
      add_location(path, file$3K, 1, 133, 167);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3O.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3N($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('CloudRain', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<CloudRain> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class CloudRain extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3N, create_fragment$3O, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CloudRain",
      options,
      id: create_fragment$3O.name
    });
  }
}
var CloudRain$1 = CloudRain;

/* ../../components/ui/src/icons/feather/CloudSnow.svelte generated by Svelte v3.59.2 */
const file$3J = "../../components/ui/src/icons/feather/CloudSnow.svelte";
function create_fragment$3N(ctx) {
  let path;
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let line5;
  const block = {
    c: function create() {
      path = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      line5 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line3).forEach(detach_dev);
      line4 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line4).forEach(detach_dev);
      line5 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line5).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 17.58A5 5 0 0 0 18 8h-1.26A8 8 0 1 0 4 16.25");
      add_location(path, file$3J, 1, 0, 34);
      attr_dev(line0, "x1", "8");
      attr_dev(line0, "y1", "16");
      attr_dev(line0, "x2", "8.01");
      attr_dev(line0, "y2", "16");
      add_location(line0, file$3J, 1, 66, 100);
      attr_dev(line1, "x1", "8");
      attr_dev(line1, "y1", "20");
      attr_dev(line1, "x2", "8.01");
      attr_dev(line1, "y2", "20");
      add_location(line1, file$3J, 1, 112, 146);
      attr_dev(line2, "x1", "12");
      attr_dev(line2, "y1", "18");
      attr_dev(line2, "x2", "12.01");
      attr_dev(line2, "y2", "18");
      add_location(line2, file$3J, 1, 158, 192);
      attr_dev(line3, "x1", "12");
      attr_dev(line3, "y1", "22");
      attr_dev(line3, "x2", "12.01");
      attr_dev(line3, "y2", "22");
      add_location(line3, file$3J, 1, 206, 240);
      attr_dev(line4, "x1", "16");
      attr_dev(line4, "y1", "16");
      attr_dev(line4, "x2", "16.01");
      attr_dev(line4, "y2", "16");
      add_location(line4, file$3J, 1, 254, 288);
      attr_dev(line5, "x1", "16");
      attr_dev(line5, "y1", "20");
      attr_dev(line5, "x2", "16.01");
      attr_dev(line5, "y2", "20");
      add_location(line5, file$3J, 1, 302, 336);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
      insert_hydration_dev(target, line3, anchor);
      insert_hydration_dev(target, line4, anchor);
      insert_hydration_dev(target, line5, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
      if (detaching) detach_dev(line3);
      if (detaching) detach_dev(line4);
      if (detaching) detach_dev(line5);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3N.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3M($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('CloudSnow', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<CloudSnow> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class CloudSnow extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3M, create_fragment$3N, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CloudSnow",
      options,
      id: create_fragment$3N.name
    });
  }
}
var CloudSnow$1 = CloudSnow;

/* ../../components/ui/src/icons/feather/Cloud.svelte generated by Svelte v3.59.2 */
const file$3I = "../../components/ui/src/icons/feather/Cloud.svelte";
function create_fragment$3M(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z");
      add_location(path, file$3I, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3M.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3L($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Cloud', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Cloud> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Cloud extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3L, create_fragment$3M, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Cloud",
      options,
      id: create_fragment$3M.name
    });
  }
}
var Cloud$1 = Cloud;

/* ../../components/ui/src/icons/feather/Code.svelte generated by Svelte v3.59.2 */
const file$3H = "../../components/ui/src/icons/feather/Code.svelte";
function create_fragment$3L(ctx) {
  let polyline0;
  let polyline1;
  const block = {
    c: function create() {
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      polyline0 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "16 18 22 12 16 6");
      add_location(polyline0, file$3H, 1, 0, 34);
      attr_dev(polyline1, "points", "8 6 2 12 8 18");
      add_location(polyline1, file$3H, 1, 47, 81);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline0, anchor);
      insert_hydration_dev(target, polyline1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline0);
      if (detaching) detach_dev(polyline1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3L.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3K($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Code', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Code> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Code extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3K, create_fragment$3L, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Code",
      options,
      id: create_fragment$3L.name
    });
  }
}
var Code$1 = Code;

/* ../../components/ui/src/icons/feather/Codepen.svelte generated by Svelte v3.59.2 */
const file$3G = "../../components/ui/src/icons/feather/Codepen.svelte";
function create_fragment$3K(ctx) {
  let polygon;
  let line0;
  let polyline0;
  let polyline1;
  let line1;
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      line0 = svg_element("line");
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      polyline0 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline1).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2");
      add_location(polygon, file$3G, 1, 0, 34);
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "22");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "15.5");
      add_location(line0, file$3G, 1, 72, 106);
      attr_dev(polyline0, "points", "22 8.5 12 15.5 2 8.5");
      add_location(polyline0, file$3G, 1, 119, 153);
      attr_dev(polyline1, "points", "2 15.5 12 8.5 22 15.5");
      add_location(polyline1, file$3G, 1, 170, 204);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "2");
      attr_dev(line1, "x2", "12");
      attr_dev(line1, "y2", "8.5");
      add_location(line1, file$3G, 1, 222, 256);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, polyline0, anchor);
      insert_hydration_dev(target, polyline1, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polygon);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(polyline0);
      if (detaching) detach_dev(polyline1);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3K.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3J($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Codepen', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Codepen> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Codepen extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3J, create_fragment$3K, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Codepen",
      options,
      id: create_fragment$3K.name
    });
  }
}
var Codepen$1 = Codepen;

/* ../../components/ui/src/icons/feather/Codesandbox.svelte generated by Svelte v3.59.2 */
const file$3F = "../../components/ui/src/icons/feather/Codesandbox.svelte";
function create_fragment$3J(ctx) {
  let path;
  let polyline0;
  let polyline1;
  let polyline2;
  let polyline3;
  let line;
  const block = {
    c: function create() {
      path = svg_element("path");
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      polyline2 = svg_element("polyline");
      polyline3 = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      polyline0 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline1).forEach(detach_dev);
      polyline2 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline2).forEach(detach_dev);
      polyline3 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline3).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z");
      add_location(path, file$3F, 1, 0, 34);
      attr_dev(polyline0, "points", "7.5 4.21 12 6.81 16.5 4.21");
      add_location(polyline0, file$3F, 1, 139, 173);
      attr_dev(polyline1, "points", "7.5 19.79 7.5 14.6 3 12");
      add_location(polyline1, file$3F, 1, 196, 230);
      attr_dev(polyline2, "points", "21 12 16.5 14.6 16.5 19.79");
      add_location(polyline2, file$3F, 1, 250, 284);
      attr_dev(polyline3, "points", "3.27 6.96 12 12.01 20.73 6.96");
      add_location(polyline3, file$3F, 1, 307, 341);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "22.08");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "12");
      add_location(line, file$3F, 1, 367, 401);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, polyline0, anchor);
      insert_hydration_dev(target, polyline1, anchor);
      insert_hydration_dev(target, polyline2, anchor);
      insert_hydration_dev(target, polyline3, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(polyline0);
      if (detaching) detach_dev(polyline1);
      if (detaching) detach_dev(polyline2);
      if (detaching) detach_dev(polyline3);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3J.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3I($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Codesandbox', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Codesandbox> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Codesandbox extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3I, create_fragment$3J, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Codesandbox",
      options,
      id: create_fragment$3J.name
    });
  }
}
var Codesandbox$1 = Codesandbox;

/* ../../components/ui/src/icons/feather/Coffee.svelte generated by Svelte v3.59.2 */
const file$3E = "../../components/ui/src/icons/feather/Coffee.svelte";
function create_fragment$3I(ctx) {
  let path0;
  let path1;
  let line0;
  let line1;
  let line2;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M18 8h1a4 4 0 0 1 0 8h-1");
      add_location(path0, file$3E, 1, 0, 34);
      attr_dev(path1, "d", "M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z");
      add_location(path1, file$3E, 1, 42, 76);
      attr_dev(line0, "x1", "6");
      attr_dev(line0, "y1", "1");
      attr_dev(line0, "x2", "6");
      attr_dev(line0, "y2", "4");
      add_location(line0, file$3E, 1, 102, 136);
      attr_dev(line1, "x1", "10");
      attr_dev(line1, "y1", "1");
      attr_dev(line1, "x2", "10");
      attr_dev(line1, "y2", "4");
      add_location(line1, file$3E, 1, 143, 177);
      attr_dev(line2, "x1", "14");
      attr_dev(line2, "y1", "1");
      attr_dev(line2, "x2", "14");
      attr_dev(line2, "y2", "4");
      add_location(line2, file$3E, 1, 186, 220);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(path1);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3I.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3H($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Coffee', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Coffee> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Coffee extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3H, create_fragment$3I, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Coffee",
      options,
      id: create_fragment$3I.name
    });
  }
}
var Coffee$1 = Coffee;

/* ../../components/ui/src/icons/feather/Columns.svelte generated by Svelte v3.59.2 */
const file$3D = "../../components/ui/src/icons/feather/Columns.svelte";
function create_fragment$3H(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18");
      add_location(path, file$3D, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3H.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3G($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Columns', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Columns> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Columns extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3G, create_fragment$3H, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Columns",
      options,
      id: create_fragment$3H.name
    });
  }
}
var Columns$1 = Columns;

/* ../../components/ui/src/icons/feather/Command.svelte generated by Svelte v3.59.2 */
const file$3C = "../../components/ui/src/icons/feather/Command.svelte";
function create_fragment$3G(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z");
      add_location(path, file$3C, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3G.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3F($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Command', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Command> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Command extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3F, create_fragment$3G, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Command",
      options,
      id: create_fragment$3G.name
    });
  }
}
var Command$1 = Command;

/* ../../components/ui/src/icons/feather/Compass.svelte generated by Svelte v3.59.2 */
const file$3B = "../../components/ui/src/icons/feather/Compass.svelte";
function create_fragment$3F(ctx) {
  let circle;
  let polygon;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file$3B, 1, 0, 34);
      attr_dev(polygon, "points", "16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76");
      add_location(polygon, file$3B, 1, 40, 74);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, polygon, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(polygon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3F.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3E($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Compass', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Compass> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Compass extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3E, create_fragment$3F, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Compass",
      options,
      id: create_fragment$3F.name
    });
  }
}
var Compass$1 = Compass;

/* ../../components/ui/src/icons/feather/CornerDownLeft.svelte generated by Svelte v3.59.2 */
const file$3A = "../../components/ui/src/icons/feather/CornerDownLeft.svelte";
function create_fragment$3E(ctx) {
  let polyline;
  let path;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "9 10 4 15 9 20");
      add_location(polyline, file$3A, 1, 0, 34);
      attr_dev(path, "d", "M20 4v7a4 4 0 0 1-4 4H4");
      add_location(path, file$3A, 1, 45, 79);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3E.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3D($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('CornerDownLeft', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<CornerDownLeft> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class CornerDownLeft extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3D, create_fragment$3E, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CornerDownLeft",
      options,
      id: create_fragment$3E.name
    });
  }
}
var CornerDownLeft$1 = CornerDownLeft;

/* ../../components/ui/src/icons/feather/CornerDownRight.svelte generated by Svelte v3.59.2 */
const file$3z = "../../components/ui/src/icons/feather/CornerDownRight.svelte";
function create_fragment$3D(ctx) {
  let polyline;
  let path;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "15 10 20 15 15 20");
      add_location(polyline, file$3z, 1, 0, 34);
      attr_dev(path, "d", "M4 4v7a4 4 0 0 0 4 4h12");
      add_location(path, file$3z, 1, 48, 82);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3D.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3C($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('CornerDownRight', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<CornerDownRight> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class CornerDownRight extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3C, create_fragment$3D, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CornerDownRight",
      options,
      id: create_fragment$3D.name
    });
  }
}
var CornerDownRight$1 = CornerDownRight;

/* ../../components/ui/src/icons/feather/CornerLeftDown.svelte generated by Svelte v3.59.2 */
const file$3y = "../../components/ui/src/icons/feather/CornerLeftDown.svelte";
function create_fragment$3C(ctx) {
  let polyline;
  let path;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "14 15 9 20 4 15");
      add_location(polyline, file$3y, 1, 0, 34);
      attr_dev(path, "d", "M20 4h-7a4 4 0 0 0-4 4v12");
      add_location(path, file$3y, 1, 46, 80);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3C.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3B($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('CornerLeftDown', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<CornerLeftDown> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class CornerLeftDown extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3B, create_fragment$3C, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CornerLeftDown",
      options,
      id: create_fragment$3C.name
    });
  }
}
var CornerLeftDown$1 = CornerLeftDown;

/* ../../components/ui/src/icons/feather/CornerLeftUp.svelte generated by Svelte v3.59.2 */
const file$3x = "../../components/ui/src/icons/feather/CornerLeftUp.svelte";
function create_fragment$3B(ctx) {
  let polyline;
  let path;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "14 9 9 4 4 9");
      add_location(polyline, file$3x, 1, 0, 34);
      attr_dev(path, "d", "M20 20h-7a4 4 0 0 1-4-4V4");
      add_location(path, file$3x, 1, 43, 77);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3B.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3A($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('CornerLeftUp', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<CornerLeftUp> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class CornerLeftUp extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3A, create_fragment$3B, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CornerLeftUp",
      options,
      id: create_fragment$3B.name
    });
  }
}
var CornerLeftUp$1 = CornerLeftUp;

/* ../../components/ui/src/icons/feather/CornerRightDown.svelte generated by Svelte v3.59.2 */
const file$3w = "../../components/ui/src/icons/feather/CornerRightDown.svelte";
function create_fragment$3A(ctx) {
  let polyline;
  let path;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "10 15 15 20 20 15");
      add_location(polyline, file$3w, 1, 0, 34);
      attr_dev(path, "d", "M4 4h7a4 4 0 0 1 4 4v12");
      add_location(path, file$3w, 1, 48, 82);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3A.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3z($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('CornerRightDown', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<CornerRightDown> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class CornerRightDown extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3z, create_fragment$3A, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CornerRightDown",
      options,
      id: create_fragment$3A.name
    });
  }
}
var CornerRightDown$1 = CornerRightDown;

/* ../../components/ui/src/icons/feather/CornerRightUp.svelte generated by Svelte v3.59.2 */
const file$3v = "../../components/ui/src/icons/feather/CornerRightUp.svelte";
function create_fragment$3z(ctx) {
  let polyline;
  let path;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "10 9 15 4 20 9");
      add_location(polyline, file$3v, 1, 0, 34);
      attr_dev(path, "d", "M4 20h7a4 4 0 0 0 4-4V4");
      add_location(path, file$3v, 1, 45, 79);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3z.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3y($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('CornerRightUp', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<CornerRightUp> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class CornerRightUp extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3y, create_fragment$3z, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CornerRightUp",
      options,
      id: create_fragment$3z.name
    });
  }
}
var CornerRightUp$1 = CornerRightUp;

/* ../../components/ui/src/icons/feather/CornerUpLeft.svelte generated by Svelte v3.59.2 */
const file$3u = "../../components/ui/src/icons/feather/CornerUpLeft.svelte";
function create_fragment$3y(ctx) {
  let polyline;
  let path;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "9 14 4 9 9 4");
      add_location(polyline, file$3u, 1, 0, 34);
      attr_dev(path, "d", "M20 20v-7a4 4 0 0 0-4-4H4");
      add_location(path, file$3u, 1, 43, 77);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3y.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3x($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('CornerUpLeft', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<CornerUpLeft> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class CornerUpLeft extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3x, create_fragment$3y, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CornerUpLeft",
      options,
      id: create_fragment$3y.name
    });
  }
}
var CornerUpLeft$1 = CornerUpLeft;

/* ../../components/ui/src/icons/feather/CornerUpRight.svelte generated by Svelte v3.59.2 */
const file$3t = "../../components/ui/src/icons/feather/CornerUpRight.svelte";
function create_fragment$3x(ctx) {
  let polyline;
  let path;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "15 14 20 9 15 4");
      add_location(polyline, file$3t, 1, 0, 34);
      attr_dev(path, "d", "M4 20v-7a4 4 0 0 1 4-4h12");
      add_location(path, file$3t, 1, 46, 80);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3x.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3w($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('CornerUpRight', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<CornerUpRight> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class CornerUpRight extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3w, create_fragment$3x, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CornerUpRight",
      options,
      id: create_fragment$3x.name
    });
  }
}
var CornerUpRight$1 = CornerUpRight;

/* ../../components/ui/src/icons/feather/Cpu.svelte generated by Svelte v3.59.2 */
const file$3s = "../../components/ui/src/icons/feather/Cpu.svelte";
function create_fragment$3w(ctx) {
  let rect0;
  let rect1;
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let line5;
  let line6;
  let line7;
  const block = {
    c: function create() {
      rect0 = svg_element("rect");
      rect1 = svg_element("rect");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      line5 = svg_element("line");
      line6 = svg_element("line");
      line7 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      rect0 = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect0).forEach(detach_dev);
      rect1 = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect1).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line3).forEach(detach_dev);
      line4 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line4).forEach(detach_dev);
      line5 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line5).forEach(detach_dev);
      line6 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line6).forEach(detach_dev);
      line7 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line7).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect0, "x", "4");
      attr_dev(rect0, "y", "4");
      attr_dev(rect0, "width", "16");
      attr_dev(rect0, "height", "16");
      attr_dev(rect0, "rx", "2");
      attr_dev(rect0, "ry", "2");
      add_location(rect0, file$3s, 1, 0, 34);
      attr_dev(rect1, "x", "9");
      attr_dev(rect1, "y", "9");
      attr_dev(rect1, "width", "6");
      attr_dev(rect1, "height", "6");
      add_location(rect1, file$3s, 1, 62, 96);
      attr_dev(line0, "x1", "9");
      attr_dev(line0, "y1", "1");
      attr_dev(line0, "x2", "9");
      attr_dev(line0, "y2", "4");
      add_location(line0, file$3s, 1, 108, 142);
      attr_dev(line1, "x1", "15");
      attr_dev(line1, "y1", "1");
      attr_dev(line1, "x2", "15");
      attr_dev(line1, "y2", "4");
      add_location(line1, file$3s, 1, 149, 183);
      attr_dev(line2, "x1", "9");
      attr_dev(line2, "y1", "20");
      attr_dev(line2, "x2", "9");
      attr_dev(line2, "y2", "23");
      add_location(line2, file$3s, 1, 192, 226);
      attr_dev(line3, "x1", "15");
      attr_dev(line3, "y1", "20");
      attr_dev(line3, "x2", "15");
      attr_dev(line3, "y2", "23");
      add_location(line3, file$3s, 1, 235, 269);
      attr_dev(line4, "x1", "20");
      attr_dev(line4, "y1", "9");
      attr_dev(line4, "x2", "23");
      attr_dev(line4, "y2", "9");
      add_location(line4, file$3s, 1, 280, 314);
      attr_dev(line5, "x1", "20");
      attr_dev(line5, "y1", "14");
      attr_dev(line5, "x2", "23");
      attr_dev(line5, "y2", "14");
      add_location(line5, file$3s, 1, 323, 357);
      attr_dev(line6, "x1", "1");
      attr_dev(line6, "y1", "9");
      attr_dev(line6, "x2", "4");
      attr_dev(line6, "y2", "9");
      add_location(line6, file$3s, 1, 368, 402);
      attr_dev(line7, "x1", "1");
      attr_dev(line7, "y1", "14");
      attr_dev(line7, "x2", "4");
      attr_dev(line7, "y2", "14");
      add_location(line7, file$3s, 1, 409, 443);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect0, anchor);
      insert_hydration_dev(target, rect1, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
      insert_hydration_dev(target, line3, anchor);
      insert_hydration_dev(target, line4, anchor);
      insert_hydration_dev(target, line5, anchor);
      insert_hydration_dev(target, line6, anchor);
      insert_hydration_dev(target, line7, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect0);
      if (detaching) detach_dev(rect1);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
      if (detaching) detach_dev(line3);
      if (detaching) detach_dev(line4);
      if (detaching) detach_dev(line5);
      if (detaching) detach_dev(line6);
      if (detaching) detach_dev(line7);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3w.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3v($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Cpu', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Cpu> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Cpu extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3v, create_fragment$3w, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Cpu",
      options,
      id: create_fragment$3w.name
    });
  }
}
var Cpu$1 = Cpu;

/* ../../components/ui/src/icons/feather/CreditCard.svelte generated by Svelte v3.59.2 */
const file$3r = "../../components/ui/src/icons/feather/CreditCard.svelte";
function create_fragment$3v(ctx) {
  let rect;
  let line;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "1");
      attr_dev(rect, "y", "4");
      attr_dev(rect, "width", "22");
      attr_dev(rect, "height", "16");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file$3r, 1, 0, 34);
      attr_dev(line, "x1", "1");
      attr_dev(line, "y1", "10");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "10");
      add_location(line, file$3r, 1, 62, 96);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3v.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3u($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('CreditCard', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<CreditCard> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class CreditCard extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3u, create_fragment$3v, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CreditCard",
      options,
      id: create_fragment$3v.name
    });
  }
}
var CreditCard$1 = CreditCard;

/* ../../components/ui/src/icons/feather/Crop.svelte generated by Svelte v3.59.2 */
const file$3q = "../../components/ui/src/icons/feather/Crop.svelte";
function create_fragment$3u(ctx) {
  let path0;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M6.13 1L6 16a2 2 0 0 0 2 2h15");
      add_location(path0, file$3q, 1, 0, 34);
      attr_dev(path1, "d", "M1 6.13L16 6a2 2 0 0 1 2 2v15");
      add_location(path1, file$3q, 1, 47, 81);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(path1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3u.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3t($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Crop', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Crop> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Crop extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3t, create_fragment$3u, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Crop",
      options,
      id: create_fragment$3u.name
    });
  }
}
var Crop$1 = Crop;

/* ../../components/ui/src/icons/feather/Crosshair.svelte generated by Svelte v3.59.2 */
const file$3p = "../../components/ui/src/icons/feather/Crosshair.svelte";
function create_fragment$3t(ctx) {
  let circle;
  let line0;
  let line1;
  let line2;
  let line3;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line3).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file$3p, 1, 0, 34);
      attr_dev(line0, "x1", "22");
      attr_dev(line0, "y1", "12");
      attr_dev(line0, "x2", "18");
      attr_dev(line0, "y2", "12");
      add_location(line0, file$3p, 1, 40, 74);
      attr_dev(line1, "x1", "6");
      attr_dev(line1, "y1", "12");
      attr_dev(line1, "x2", "2");
      attr_dev(line1, "y2", "12");
      add_location(line1, file$3p, 1, 85, 119);
      attr_dev(line2, "x1", "12");
      attr_dev(line2, "y1", "6");
      attr_dev(line2, "x2", "12");
      attr_dev(line2, "y2", "2");
      add_location(line2, file$3p, 1, 128, 162);
      attr_dev(line3, "x1", "12");
      attr_dev(line3, "y1", "22");
      attr_dev(line3, "x2", "12");
      attr_dev(line3, "y2", "18");
      add_location(line3, file$3p, 1, 171, 205);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
      insert_hydration_dev(target, line3, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
      if (detaching) detach_dev(line3);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3t.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3s($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Crosshair', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Crosshair> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Crosshair extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3s, create_fragment$3t, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Crosshair",
      options,
      id: create_fragment$3t.name
    });
  }
}
var Crosshair$1 = Crosshair;

/* ../../components/ui/src/icons/feather/Database.svelte generated by Svelte v3.59.2 */
const file$3o = "../../components/ui/src/icons/feather/Database.svelte";
function create_fragment$3s(ctx) {
  let ellipse;
  let path0;
  let path1;
  const block = {
    c: function create() {
      ellipse = svg_element("ellipse");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      ellipse = claim_svg_element(nodes, "ellipse", {
        cx: true,
        cy: true,
        rx: true,
        ry: true
      });
      children(ellipse).forEach(detach_dev);
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ellipse, "cx", "12");
      attr_dev(ellipse, "cy", "5");
      attr_dev(ellipse, "rx", "9");
      attr_dev(ellipse, "ry", "3");
      add_location(ellipse, file$3o, 1, 0, 34);
      attr_dev(path0, "d", "M21 12c0 1.66-4 3-9 3s-9-1.34-9-3");
      add_location(path0, file$3o, 1, 48, 82);
      attr_dev(path1, "d", "M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5");
      add_location(path1, file$3o, 1, 99, 133);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ellipse, anchor);
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(ellipse);
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(path1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3s.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3r($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Database', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Database> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Database extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3r, create_fragment$3s, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Database",
      options,
      id: create_fragment$3s.name
    });
  }
}
var Database$1 = Database;

/* ../../components/ui/src/icons/feather/Delete.svelte generated by Svelte v3.59.2 */
const file$3n = "../../components/ui/src/icons/feather/Delete.svelte";
function create_fragment$3r(ctx) {
  let path;
  let line0;
  let line1;
  const block = {
    c: function create() {
      path = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z");
      add_location(path, file$3n, 1, 0, 34);
      attr_dev(line0, "x1", "18");
      attr_dev(line0, "y1", "9");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "15");
      add_location(line0, file$3n, 1, 68, 102);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "9");
      attr_dev(line1, "x2", "18");
      attr_dev(line1, "y2", "15");
      add_location(line1, file$3n, 1, 112, 146);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3r.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3q($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Delete', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Delete> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Delete extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3q, create_fragment$3r, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Delete",
      options,
      id: create_fragment$3r.name
    });
  }
}
var Delete$1 = Delete;

/* ../../components/ui/src/icons/feather/Disc.svelte generated by Svelte v3.59.2 */
const file$3m = "../../components/ui/src/icons/feather/Disc.svelte";
function create_fragment$3q(ctx) {
  let circle0;
  let circle1;
  const block = {
    c: function create() {
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      circle0 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "12");
      attr_dev(circle0, "cy", "12");
      attr_dev(circle0, "r", "10");
      add_location(circle0, file$3m, 1, 0, 34);
      attr_dev(circle1, "cx", "12");
      attr_dev(circle1, "cy", "12");
      attr_dev(circle1, "r", "3");
      add_location(circle1, file$3m, 1, 40, 74);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle0, anchor);
      insert_hydration_dev(target, circle1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle0);
      if (detaching) detach_dev(circle1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3q.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3p($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Disc', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Disc> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Disc extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3p, create_fragment$3q, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Disc",
      options,
      id: create_fragment$3q.name
    });
  }
}
var Disc$1 = Disc;

/* ../../components/ui/src/icons/feather/DivideCircle.svelte generated by Svelte v3.59.2 */
const file$3l = "../../components/ui/src/icons/feather/DivideCircle.svelte";
function create_fragment$3p(ctx) {
  let line0;
  let line1;
  let line2;
  let circle;
  const block = {
    c: function create() {
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "8");
      attr_dev(line0, "y1", "12");
      attr_dev(line0, "x2", "16");
      attr_dev(line0, "y2", "12");
      add_location(line0, file$3l, 1, 0, 34);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "16");
      attr_dev(line1, "x2", "12");
      attr_dev(line1, "y2", "16");
      add_location(line1, file$3l, 1, 44, 78);
      attr_dev(line2, "x1", "12");
      attr_dev(line2, "y1", "8");
      attr_dev(line2, "x2", "12");
      attr_dev(line2, "y2", "8");
      add_location(line2, file$3l, 1, 89, 123);
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file$3l, 1, 132, 166);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
      insert_hydration_dev(target, circle, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
      if (detaching) detach_dev(circle);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3p.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3o($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('DivideCircle', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<DivideCircle> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class DivideCircle extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3o, create_fragment$3p, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DivideCircle",
      options,
      id: create_fragment$3p.name
    });
  }
}
var DivideCircle$1 = DivideCircle;

/* ../../components/ui/src/icons/feather/DivideSquare.svelte generated by Svelte v3.59.2 */
const file$3k = "../../components/ui/src/icons/feather/DivideSquare.svelte";
function create_fragment$3o(ctx) {
  let rect;
  let line0;
  let line1;
  let line2;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "3");
      attr_dev(rect, "y", "3");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "18");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file$3k, 1, 0, 34);
      attr_dev(line0, "x1", "8");
      attr_dev(line0, "y1", "12");
      attr_dev(line0, "x2", "16");
      attr_dev(line0, "y2", "12");
      add_location(line0, file$3k, 1, 62, 96);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "16");
      attr_dev(line1, "x2", "12");
      attr_dev(line1, "y2", "16");
      add_location(line1, file$3k, 1, 106, 140);
      attr_dev(line2, "x1", "12");
      attr_dev(line2, "y1", "8");
      attr_dev(line2, "x2", "12");
      attr_dev(line2, "y2", "8");
      add_location(line2, file$3k, 1, 151, 185);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3o.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3n($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('DivideSquare', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<DivideSquare> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class DivideSquare extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3n, create_fragment$3o, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DivideSquare",
      options,
      id: create_fragment$3o.name
    });
  }
}
var DivideSquare$1 = DivideSquare;

/* ../../components/ui/src/icons/feather/Divide.svelte generated by Svelte v3.59.2 */
const file$3j = "../../components/ui/src/icons/feather/Divide.svelte";
function create_fragment$3n(ctx) {
  let circle0;
  let line;
  let circle1;
  const block = {
    c: function create() {
      circle0 = svg_element("circle");
      line = svg_element("line");
      circle1 = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      circle0 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle0).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      circle1 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "12");
      attr_dev(circle0, "cy", "6");
      attr_dev(circle0, "r", "2");
      add_location(circle0, file$3j, 1, 0, 34);
      attr_dev(line, "x1", "5");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "19");
      attr_dev(line, "y2", "12");
      add_location(line, file$3j, 1, 38, 72);
      attr_dev(circle1, "cx", "12");
      attr_dev(circle1, "cy", "18");
      attr_dev(circle1, "r", "2");
      add_location(circle1, file$3j, 1, 82, 116);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle0, anchor);
      insert_hydration_dev(target, line, anchor);
      insert_hydration_dev(target, circle1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle0);
      if (detaching) detach_dev(line);
      if (detaching) detach_dev(circle1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3n.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3m($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Divide', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Divide> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Divide extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3m, create_fragment$3n, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Divide",
      options,
      id: create_fragment$3n.name
    });
  }
}
var Divide$1 = Divide;

/* ../../components/ui/src/icons/feather/DollarSign.svelte generated by Svelte v3.59.2 */
const file$3i = "../../components/ui/src/icons/feather/DollarSign.svelte";
function create_fragment$3m(ctx) {
  let line;
  let path;
  const block = {
    c: function create() {
      line = svg_element("line");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "1");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "23");
      add_location(line, file$3i, 1, 0, 34);
      attr_dev(path, "d", "M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6");
      add_location(path, file$3i, 1, 44, 78);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3m.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3l($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('DollarSign', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<DollarSign> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class DollarSign extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3l, create_fragment$3m, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DollarSign",
      options,
      id: create_fragment$3m.name
    });
  }
}
var DollarSign$1 = DollarSign;

/* ../../components/ui/src/icons/feather/DownloadCloud.svelte generated by Svelte v3.59.2 */
const file$3h = "../../components/ui/src/icons/feather/DownloadCloud.svelte";
function create_fragment$3l(ctx) {
  let polyline;
  let line;
  let path;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      line = svg_element("line");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "8 17 12 21 16 17");
      add_location(polyline, file$3h, 1, 0, 34);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "21");
      add_location(line, file$3h, 1, 47, 81);
      attr_dev(path, "d", "M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29");
      add_location(path, file$3h, 1, 92, 126);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, line, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(line);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3l.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3k($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('DownloadCloud', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<DownloadCloud> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class DownloadCloud extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3k, create_fragment$3l, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DownloadCloud",
      options,
      id: create_fragment$3l.name
    });
  }
}
var DownloadCloud$1 = DownloadCloud;

/* ../../components/ui/src/icons/feather/Dribbble.svelte generated by Svelte v3.59.2 */
const file$3g = "../../components/ui/src/icons/feather/Dribbble.svelte";
function create_fragment$3k(ctx) {
  let circle;
  let path;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file$3g, 1, 0, 34);
      attr_dev(path, "d", "M8.56 2.75c4.37 6.03 6.02 9.42 8.03 17.72m2.54-15.38c-3.72 4.35-8.94 5.66-16.88 5.85m19.5 1.9c-3.5-.93-6.63-.82-8.94 0-2.58.92-5.01 2.86-7.44 6.32");
      add_location(path, file$3g, 1, 40, 74);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3k.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3j($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Dribbble', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Dribbble> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Dribbble extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3j, create_fragment$3k, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Dribbble",
      options,
      id: create_fragment$3k.name
    });
  }
}
var Dribbble$1 = Dribbble;

/* ../../components/ui/src/icons/feather/Droplet.svelte generated by Svelte v3.59.2 */
const file$3f = "../../components/ui/src/icons/feather/Droplet.svelte";
function create_fragment$3j(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z");
      add_location(path, file$3f, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3j.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3i($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Droplet', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Droplet> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Droplet extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3i, create_fragment$3j, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Droplet",
      options,
      id: create_fragment$3j.name
    });
  }
}
var Droplet$1 = Droplet;

/* ../../components/ui/src/icons/feather/Edit2.svelte generated by Svelte v3.59.2 */
const file$3e = "../../components/ui/src/icons/feather/Edit2.svelte";
function create_fragment$3i(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z");
      add_location(path, file$3e, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3i.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3h($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Edit2', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Edit2> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Edit2 extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3h, create_fragment$3i, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Edit2",
      options,
      id: create_fragment$3i.name
    });
  }
}
var Edit2$1 = Edit2;

/* ../../components/ui/src/icons/feather/Edit3.svelte generated by Svelte v3.59.2 */
const file$3d = "../../components/ui/src/icons/feather/Edit3.svelte";
function create_fragment$3h(ctx) {
  let path0;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M12 20h9");
      add_location(path0, file$3d, 1, 0, 34);
      attr_dev(path1, "d", "M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z");
      add_location(path1, file$3d, 1, 26, 60);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(path1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3h.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3g($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Edit3', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Edit3> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Edit3 extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3g, create_fragment$3h, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Edit3",
      options,
      id: create_fragment$3h.name
    });
  }
}
var Edit3$1 = Edit3;

/* ../../components/ui/src/icons/feather/Edit.svelte generated by Svelte v3.59.2 */
const file$3c = "../../components/ui/src/icons/feather/Edit.svelte";
function create_fragment$3g(ctx) {
  let path0;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7");
      add_location(path0, file$3c, 1, 0, 34);
      attr_dev(path1, "d", "M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z");
      add_location(path1, file$3c, 1, 76, 110);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(path1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3g.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3f($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Edit', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Edit> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Edit extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3f, create_fragment$3g, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Edit",
      options,
      id: create_fragment$3g.name
    });
  }
}
var Edit$1 = Edit;

/* ../../components/ui/src/icons/feather/EyeOff.svelte generated by Svelte v3.59.2 */
const file$3b = "../../components/ui/src/icons/feather/EyeOff.svelte";
function create_fragment$3f(ctx) {
  let path;
  let line;
  const block = {
    c: function create() {
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24");
      add_location(path, file$3b, 1, 0, 34);
      attr_dev(line, "x1", "1");
      attr_dev(line, "y1", "1");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "23");
      add_location(line, file$3b, 1, 198, 232);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3f.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3e($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('EyeOff', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<EyeOff> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class EyeOff extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3e, create_fragment$3f, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "EyeOff",
      options,
      id: create_fragment$3f.name
    });
  }
}
var EyeOff$1 = EyeOff;

/* ../../components/ui/src/icons/feather/Eye.svelte generated by Svelte v3.59.2 */
const file$3a = "../../components/ui/src/icons/feather/Eye.svelte";
function create_fragment$3e(ctx) {
  let path;
  let circle;
  const block = {
    c: function create() {
      path = svg_element("path");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z");
      add_location(path, file$3a, 1, 0, 34);
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "3");
      add_location(circle, file$3a, 1, 62, 96);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, circle, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(circle);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3e.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3d($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Eye', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Eye> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Eye extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3d, create_fragment$3e, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Eye",
      options,
      id: create_fragment$3e.name
    });
  }
}
var Eye$1 = Eye;

/* ../../components/ui/src/icons/feather/Facebook.svelte generated by Svelte v3.59.2 */
const file$39 = "../../components/ui/src/icons/feather/Facebook.svelte";
function create_fragment$3d(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z");
      add_location(path, file$39, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3d.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3c($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Facebook', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Facebook> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Facebook extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3c, create_fragment$3d, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Facebook",
      options,
      id: create_fragment$3d.name
    });
  }
}
var Facebook$1 = Facebook;

/* ../../components/ui/src/icons/feather/FastForward.svelte generated by Svelte v3.59.2 */
const file$38 = "../../components/ui/src/icons/feather/FastForward.svelte";
function create_fragment$3c(ctx) {
  let polygon0;
  let polygon1;
  const block = {
    c: function create() {
      polygon0 = svg_element("polygon");
      polygon1 = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      polygon0 = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon0).forEach(detach_dev);
      polygon1 = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon0, "points", "13 19 22 12 13 5 13 19");
      add_location(polygon0, file$38, 1, 0, 34);
      attr_dev(polygon1, "points", "2 19 11 12 2 5 2 19");
      add_location(polygon1, file$38, 1, 51, 85);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon0, anchor);
      insert_hydration_dev(target, polygon1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polygon0);
      if (detaching) detach_dev(polygon1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3c.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3b($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('FastForward', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<FastForward> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class FastForward extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3b, create_fragment$3c, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FastForward",
      options,
      id: create_fragment$3c.name
    });
  }
}
var FastForward$1 = FastForward;

/* ../../components/ui/src/icons/feather/Feather.svelte generated by Svelte v3.59.2 */
const file$37 = "../../components/ui/src/icons/feather/Feather.svelte";
function create_fragment$3b(ctx) {
  let path;
  let line0;
  let line1;
  const block = {
    c: function create() {
      path = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z");
      add_location(path, file$37, 1, 0, 34);
      attr_dev(line0, "x1", "16");
      attr_dev(line0, "y1", "8");
      attr_dev(line0, "x2", "2");
      attr_dev(line0, "y2", "22");
      add_location(line0, file$37, 1, 65, 99);
      attr_dev(line1, "x1", "17.5");
      attr_dev(line1, "y1", "15");
      attr_dev(line1, "x2", "9");
      attr_dev(line1, "y2", "15");
      add_location(line1, file$37, 1, 108, 142);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3b.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3a($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Feather', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Feather> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Feather extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3a, create_fragment$3b, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Feather",
      options,
      id: create_fragment$3b.name
    });
  }
}
var Feather$1 = Feather;

/* ../../components/ui/src/icons/feather/Figma.svelte generated by Svelte v3.59.2 */
const file$36 = "../../components/ui/src/icons/feather/Figma.svelte";
function create_fragment$3a(ctx) {
  let path0;
  let path1;
  let path2;
  let path3;
  let path4;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      path3 = svg_element("path");
      path4 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      path2 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path2).forEach(detach_dev);
      path3 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path3).forEach(detach_dev);
      path4 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path4).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M5 5.5A3.5 3.5 0 0 1 8.5 2H12v7H8.5A3.5 3.5 0 0 1 5 5.5z");
      add_location(path0, file$36, 1, 0, 34);
      attr_dev(path1, "d", "M12 2h3.5a3.5 3.5 0 1 1 0 7H12V2z");
      add_location(path1, file$36, 1, 74, 108);
      attr_dev(path2, "d", "M12 12.5a3.5 3.5 0 1 1 7 0 3.5 3.5 0 1 1-7 0z");
      add_location(path2, file$36, 1, 125, 159);
      attr_dev(path3, "d", "M5 19.5A3.5 3.5 0 0 1 8.5 16H12v3.5a3.5 3.5 0 1 1-7 0z");
      add_location(path3, file$36, 1, 188, 222);
      attr_dev(path4, "d", "M5 12.5A3.5 3.5 0 0 1 8.5 9H12v7H8.5A3.5 3.5 0 0 1 5 12.5z");
      add_location(path4, file$36, 1, 260, 294);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, path2, anchor);
      insert_hydration_dev(target, path3, anchor);
      insert_hydration_dev(target, path4, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(path1);
      if (detaching) detach_dev(path2);
      if (detaching) detach_dev(path3);
      if (detaching) detach_dev(path4);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3a.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$39($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Figma', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Figma> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Figma extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$39, create_fragment$3a, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Figma",
      options,
      id: create_fragment$3a.name
    });
  }
}
var Figma$1 = Figma;

/* ../../components/ui/src/icons/feather/FileMinus.svelte generated by Svelte v3.59.2 */
const file$35 = "../../components/ui/src/icons/feather/FileMinus.svelte";
function create_fragment$39(ctx) {
  let path;
  let polyline;
  let line;
  const block = {
    c: function create() {
      path = svg_element("path");
      polyline = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z");
      add_location(path, file$35, 1, 0, 34);
      attr_dev(polyline, "points", "14 2 14 8 20 8");
      add_location(polyline, file$35, 1, 76, 110);
      attr_dev(line, "x1", "9");
      attr_dev(line, "y1", "15");
      attr_dev(line, "x2", "15");
      attr_dev(line, "y2", "15");
      add_location(line, file$35, 1, 121, 155);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$39.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$38($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('FileMinus', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<FileMinus> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class FileMinus extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$38, create_fragment$39, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileMinus",
      options,
      id: create_fragment$39.name
    });
  }
}
var FileMinus$1 = FileMinus;

/* ../../components/ui/src/icons/feather/FilePlus.svelte generated by Svelte v3.59.2 */
const file$34 = "../../components/ui/src/icons/feather/FilePlus.svelte";
function create_fragment$38(ctx) {
  let path;
  let polyline;
  let line0;
  let line1;
  const block = {
    c: function create() {
      path = svg_element("path");
      polyline = svg_element("polyline");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z");
      add_location(path, file$34, 1, 0, 34);
      attr_dev(polyline, "points", "14 2 14 8 20 8");
      add_location(polyline, file$34, 1, 76, 110);
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "18");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "12");
      add_location(line0, file$34, 1, 121, 155);
      attr_dev(line1, "x1", "9");
      attr_dev(line1, "y1", "15");
      attr_dev(line1, "x2", "15");
      attr_dev(line1, "y2", "15");
      add_location(line1, file$34, 1, 166, 200);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$38.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$37($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('FilePlus', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<FilePlus> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class FilePlus extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$37, create_fragment$38, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FilePlus",
      options,
      id: create_fragment$38.name
    });
  }
}
var FilePlus$1 = FilePlus;

/* ../../components/ui/src/icons/feather/FileText.svelte generated by Svelte v3.59.2 */
const file$33 = "../../components/ui/src/icons/feather/FileText.svelte";
function create_fragment$37(ctx) {
  let path;
  let polyline0;
  let line0;
  let line1;
  let polyline1;
  const block = {
    c: function create() {
      path = svg_element("path");
      polyline0 = svg_element("polyline");
      line0 = svg_element("line");
      line1 = svg_element("line");
      polyline1 = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      polyline0 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline0).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      polyline1 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z");
      add_location(path, file$33, 1, 0, 34);
      attr_dev(polyline0, "points", "14 2 14 8 20 8");
      add_location(polyline0, file$33, 1, 76, 110);
      attr_dev(line0, "x1", "16");
      attr_dev(line0, "y1", "13");
      attr_dev(line0, "x2", "8");
      attr_dev(line0, "y2", "13");
      add_location(line0, file$33, 1, 121, 155);
      attr_dev(line1, "x1", "16");
      attr_dev(line1, "y1", "17");
      attr_dev(line1, "x2", "8");
      attr_dev(line1, "y2", "17");
      add_location(line1, file$33, 1, 165, 199);
      attr_dev(polyline1, "points", "10 9 9 9 8 9");
      add_location(polyline1, file$33, 1, 209, 243);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, polyline0, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, polyline1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(polyline0);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(polyline1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$37.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$36($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('FileText', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<FileText> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class FileText extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$36, create_fragment$37, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FileText",
      options,
      id: create_fragment$37.name
    });
  }
}
var FileText$1 = FileText;

/* ../../components/ui/src/icons/feather/File.svelte generated by Svelte v3.59.2 */
const file$32 = "../../components/ui/src/icons/feather/File.svelte";
function create_fragment$36(ctx) {
  let path;
  let polyline;
  const block = {
    c: function create() {
      path = svg_element("path");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z");
      add_location(path, file$32, 1, 0, 34);
      attr_dev(polyline, "points", "13 2 13 9 20 9");
      add_location(polyline, file$32, 1, 76, 110);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, polyline, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$36.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$35($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('File', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<File> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class File extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$35, create_fragment$36, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "File",
      options,
      id: create_fragment$36.name
    });
  }
}
var File$1 = File;

/* ../../components/ui/src/icons/feather/Film.svelte generated by Svelte v3.59.2 */
const file$31 = "../../components/ui/src/icons/feather/Film.svelte";
function create_fragment$35(ctx) {
  let rect;
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let line5;
  let line6;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      line5 = svg_element("line");
      line6 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line3).forEach(detach_dev);
      line4 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line4).forEach(detach_dev);
      line5 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line5).forEach(detach_dev);
      line6 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line6).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "2");
      attr_dev(rect, "y", "2");
      attr_dev(rect, "width", "20");
      attr_dev(rect, "height", "20");
      attr_dev(rect, "rx", "2.18");
      attr_dev(rect, "ry", "2.18");
      add_location(rect, file$31, 1, 0, 34);
      attr_dev(line0, "x1", "7");
      attr_dev(line0, "y1", "2");
      attr_dev(line0, "x2", "7");
      attr_dev(line0, "y2", "22");
      add_location(line0, file$31, 1, 68, 102);
      attr_dev(line1, "x1", "17");
      attr_dev(line1, "y1", "2");
      attr_dev(line1, "x2", "17");
      attr_dev(line1, "y2", "22");
      add_location(line1, file$31, 1, 110, 144);
      attr_dev(line2, "x1", "2");
      attr_dev(line2, "y1", "12");
      attr_dev(line2, "x2", "22");
      attr_dev(line2, "y2", "12");
      add_location(line2, file$31, 1, 154, 188);
      attr_dev(line3, "x1", "2");
      attr_dev(line3, "y1", "7");
      attr_dev(line3, "x2", "7");
      attr_dev(line3, "y2", "7");
      add_location(line3, file$31, 1, 198, 232);
      attr_dev(line4, "x1", "2");
      attr_dev(line4, "y1", "17");
      attr_dev(line4, "x2", "7");
      attr_dev(line4, "y2", "17");
      add_location(line4, file$31, 1, 239, 273);
      attr_dev(line5, "x1", "17");
      attr_dev(line5, "y1", "17");
      attr_dev(line5, "x2", "22");
      attr_dev(line5, "y2", "17");
      add_location(line5, file$31, 1, 282, 316);
      attr_dev(line6, "x1", "17");
      attr_dev(line6, "y1", "7");
      attr_dev(line6, "x2", "22");
      attr_dev(line6, "y2", "7");
      add_location(line6, file$31, 1, 327, 361);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
      insert_hydration_dev(target, line3, anchor);
      insert_hydration_dev(target, line4, anchor);
      insert_hydration_dev(target, line5, anchor);
      insert_hydration_dev(target, line6, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
      if (detaching) detach_dev(line3);
      if (detaching) detach_dev(line4);
      if (detaching) detach_dev(line5);
      if (detaching) detach_dev(line6);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$35.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$34($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Film', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Film> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Film extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$34, create_fragment$35, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Film",
      options,
      id: create_fragment$35.name
    });
  }
}
var Film$1 = Film;

/* ../../components/ui/src/icons/feather/Filter.svelte generated by Svelte v3.59.2 */
const file$30 = "../../components/ui/src/icons/feather/Filter.svelte";
function create_fragment$34(ctx) {
  let polygon;
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3");
      add_location(polygon, file$30, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polygon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$34.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$33($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Filter', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Filter> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Filter extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$33, create_fragment$34, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Filter",
      options,
      id: create_fragment$34.name
    });
  }
}
var Filter$1 = Filter;

/* ../../components/ui/src/icons/feather/Flag.svelte generated by Svelte v3.59.2 */
const file$2$ = "../../components/ui/src/icons/feather/Flag.svelte";
function create_fragment$33(ctx) {
  let path;
  let line;
  const block = {
    c: function create() {
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z");
      add_location(path, file$2$, 1, 0, 34);
      attr_dev(line, "x1", "4");
      attr_dev(line, "y1", "22");
      attr_dev(line, "x2", "4");
      attr_dev(line, "y2", "15");
      add_location(line, file$2$, 1, 75, 109);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$33.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$32($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Flag', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Flag> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Flag extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$32, create_fragment$33, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Flag",
      options,
      id: create_fragment$33.name
    });
  }
}
var Flag$1 = Flag;

/* ../../components/ui/src/icons/feather/FolderMinus.svelte generated by Svelte v3.59.2 */
const file$2_ = "../../components/ui/src/icons/feather/FolderMinus.svelte";
function create_fragment$32(ctx) {
  let path;
  let line;
  const block = {
    c: function create() {
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z");
      add_location(path, file$2_, 1, 0, 34);
      attr_dev(line, "x1", "9");
      attr_dev(line, "y1", "14");
      attr_dev(line, "x2", "15");
      attr_dev(line, "y2", "14");
      add_location(line, file$2_, 1, 93, 127);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$32.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$31($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('FolderMinus', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<FolderMinus> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class FolderMinus extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$31, create_fragment$32, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FolderMinus",
      options,
      id: create_fragment$32.name
    });
  }
}
var FolderMinus$1 = FolderMinus;

/* ../../components/ui/src/icons/feather/FolderPlus.svelte generated by Svelte v3.59.2 */
const file$2Z = "../../components/ui/src/icons/feather/FolderPlus.svelte";
function create_fragment$31(ctx) {
  let path;
  let line0;
  let line1;
  const block = {
    c: function create() {
      path = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z");
      add_location(path, file$2Z, 1, 0, 34);
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "11");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "17");
      add_location(line0, file$2Z, 1, 93, 127);
      attr_dev(line1, "x1", "9");
      attr_dev(line1, "y1", "14");
      attr_dev(line1, "x2", "15");
      attr_dev(line1, "y2", "14");
      add_location(line1, file$2Z, 1, 138, 172);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$31.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$30($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('FolderPlus', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<FolderPlus> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class FolderPlus extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$30, create_fragment$31, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FolderPlus",
      options,
      id: create_fragment$31.name
    });
  }
}
var FolderPlus$1 = FolderPlus;

/* ../../components/ui/src/icons/feather/Folder.svelte generated by Svelte v3.59.2 */
const file$2Y = "../../components/ui/src/icons/feather/Folder.svelte";
function create_fragment$30(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z");
      add_location(path, file$2Y, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$30.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2$($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Folder', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Folder> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Folder extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2$, create_fragment$30, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Folder",
      options,
      id: create_fragment$30.name
    });
  }
}
var Folder$1 = Folder;

/* ../../components/ui/src/icons/feather/Framer.svelte generated by Svelte v3.59.2 */
const file$2X = "../../components/ui/src/icons/feather/Framer.svelte";
function create_fragment$2$(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M5 16V9h14V2H5l14 14h-7m-7 0l7 7v-7m-7 0h7");
      add_location(path, file$2X, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2$.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2_($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Framer', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Framer> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Framer extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2_, create_fragment$2$, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Framer",
      options,
      id: create_fragment$2$.name
    });
  }
}
var Framer$1 = Framer;

/* ../../components/ui/src/icons/feather/Frown.svelte generated by Svelte v3.59.2 */
const file$2W = "../../components/ui/src/icons/feather/Frown.svelte";
function create_fragment$2_(ctx) {
  let circle;
  let path;
  let line0;
  let line1;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      path = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file$2W, 1, 0, 34);
      attr_dev(path, "d", "M16 16s-1.5-2-4-2-4 2-4 2");
      add_location(path, file$2W, 1, 40, 74);
      attr_dev(line0, "x1", "9");
      attr_dev(line0, "y1", "9");
      attr_dev(line0, "x2", "9.01");
      attr_dev(line0, "y2", "9");
      add_location(line0, file$2W, 1, 83, 117);
      attr_dev(line1, "x1", "15");
      attr_dev(line1, "y1", "9");
      attr_dev(line1, "x2", "15.01");
      attr_dev(line1, "y2", "9");
      add_location(line1, file$2W, 1, 127, 161);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2_.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2Z($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Frown', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Frown> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Frown extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2Z, create_fragment$2_, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Frown",
      options,
      id: create_fragment$2_.name
    });
  }
}
var Frown$1 = Frown;

/* ../../components/ui/src/icons/feather/Gift.svelte generated by Svelte v3.59.2 */
const file$2V = "../../components/ui/src/icons/feather/Gift.svelte";
function create_fragment$2Z(ctx) {
  let polyline;
  let rect;
  let line;
  let path0;
  let path1;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      rect = svg_element("rect");
      line = svg_element("line");
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "20 12 20 22 4 22 4 12");
      add_location(polyline, file$2V, 1, 0, 34);
      attr_dev(rect, "x", "2");
      attr_dev(rect, "y", "7");
      attr_dev(rect, "width", "20");
      attr_dev(rect, "height", "5");
      add_location(rect, file$2V, 1, 52, 86);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "22");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "7");
      add_location(line, file$2V, 1, 99, 133);
      attr_dev(path0, "d", "M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z");
      add_location(path0, file$2V, 1, 143, 177);
      attr_dev(path1, "d", "M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z");
      add_location(path1, file$2V, 1, 204, 238);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, line, anchor);
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(line);
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(path1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2Z.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2Y($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Gift', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Gift> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Gift extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2Y, create_fragment$2Z, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Gift",
      options,
      id: create_fragment$2Z.name
    });
  }
}
var Gift$1 = Gift;

/* ../../components/ui/src/icons/feather/GitBranch.svelte generated by Svelte v3.59.2 */
const file$2U = "../../components/ui/src/icons/feather/GitBranch.svelte";
function create_fragment$2Y(ctx) {
  let line;
  let circle0;
  let circle1;
  let path;
  const block = {
    c: function create() {
      line = svg_element("line");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      circle0 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle1).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "6");
      attr_dev(line, "y1", "3");
      attr_dev(line, "x2", "6");
      attr_dev(line, "y2", "15");
      add_location(line, file$2U, 1, 0, 34);
      attr_dev(circle0, "cx", "18");
      attr_dev(circle0, "cy", "6");
      attr_dev(circle0, "r", "3");
      add_location(circle0, file$2U, 1, 42, 76);
      attr_dev(circle1, "cx", "6");
      attr_dev(circle1, "cy", "18");
      attr_dev(circle1, "r", "3");
      add_location(circle1, file$2U, 1, 80, 114);
      attr_dev(path, "d", "M18 9a9 9 0 0 1-9 9");
      add_location(path, file$2U, 1, 118, 152);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line, anchor);
      insert_hydration_dev(target, circle0, anchor);
      insert_hydration_dev(target, circle1, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line);
      if (detaching) detach_dev(circle0);
      if (detaching) detach_dev(circle1);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2Y.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2X($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('GitBranch', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<GitBranch> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class GitBranch extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2X, create_fragment$2Y, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GitBranch",
      options,
      id: create_fragment$2Y.name
    });
  }
}
var GitBranch$1 = GitBranch;

/* ../../components/ui/src/icons/feather/GitCommit.svelte generated by Svelte v3.59.2 */
const file$2T = "../../components/ui/src/icons/feather/GitCommit.svelte";
function create_fragment$2X(ctx) {
  let circle;
  let line0;
  let line1;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "4");
      add_location(circle, file$2T, 1, 0, 34);
      attr_dev(line0, "x1", "1.05");
      attr_dev(line0, "y1", "12");
      attr_dev(line0, "x2", "7");
      attr_dev(line0, "y2", "12");
      add_location(line0, file$2T, 1, 39, 73);
      attr_dev(line1, "x1", "17.01");
      attr_dev(line1, "y1", "12");
      attr_dev(line1, "x2", "22.96");
      attr_dev(line1, "y2", "12");
      add_location(line1, file$2T, 1, 85, 119);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2X.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2W($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('GitCommit', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<GitCommit> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class GitCommit extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2W, create_fragment$2X, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GitCommit",
      options,
      id: create_fragment$2X.name
    });
  }
}
var GitCommit$1 = GitCommit;

/* ../../components/ui/src/icons/feather/GitMerge.svelte generated by Svelte v3.59.2 */
const file$2S = "../../components/ui/src/icons/feather/GitMerge.svelte";
function create_fragment$2W(ctx) {
  let circle0;
  let circle1;
  let path;
  const block = {
    c: function create() {
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      circle0 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle1).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "18");
      attr_dev(circle0, "cy", "18");
      attr_dev(circle0, "r", "3");
      add_location(circle0, file$2S, 1, 0, 34);
      attr_dev(circle1, "cx", "6");
      attr_dev(circle1, "cy", "6");
      attr_dev(circle1, "r", "3");
      add_location(circle1, file$2S, 1, 39, 73);
      attr_dev(path, "d", "M6 21V9a9 9 0 0 0 9 9");
      add_location(path, file$2S, 1, 76, 110);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle0, anchor);
      insert_hydration_dev(target, circle1, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle0);
      if (detaching) detach_dev(circle1);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2W.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2V($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('GitMerge', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<GitMerge> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class GitMerge extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2V, create_fragment$2W, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GitMerge",
      options,
      id: create_fragment$2W.name
    });
  }
}
var GitMerge$1 = GitMerge;

/* ../../components/ui/src/icons/feather/GitPullRequest.svelte generated by Svelte v3.59.2 */
const file$2R = "../../components/ui/src/icons/feather/GitPullRequest.svelte";
function create_fragment$2V(ctx) {
  let circle0;
  let circle1;
  let path;
  let line;
  const block = {
    c: function create() {
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      circle0 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle1).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "18");
      attr_dev(circle0, "cy", "18");
      attr_dev(circle0, "r", "3");
      add_location(circle0, file$2R, 1, 0, 34);
      attr_dev(circle1, "cx", "6");
      attr_dev(circle1, "cy", "6");
      attr_dev(circle1, "r", "3");
      add_location(circle1, file$2R, 1, 39, 73);
      attr_dev(path, "d", "M13 6h3a2 2 0 0 1 2 2v7");
      add_location(path, file$2R, 1, 76, 110);
      attr_dev(line, "x1", "6");
      attr_dev(line, "y1", "9");
      attr_dev(line, "x2", "6");
      attr_dev(line, "y2", "21");
      add_location(line, file$2R, 1, 117, 151);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle0, anchor);
      insert_hydration_dev(target, circle1, anchor);
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle0);
      if (detaching) detach_dev(circle1);
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2V.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2U($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('GitPullRequest', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<GitPullRequest> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class GitPullRequest extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2U, create_fragment$2V, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "GitPullRequest",
      options,
      id: create_fragment$2V.name
    });
  }
}
var GitPullRequest$1 = GitPullRequest;

/* ../../components/ui/src/icons/feather/Github.svelte generated by Svelte v3.59.2 */
const file$2Q = "../../components/ui/src/icons/feather/Github.svelte";
function create_fragment$2U(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22");
      add_location(path, file$2Q, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2U.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2T($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Github', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Github> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Github extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2T, create_fragment$2U, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Github",
      options,
      id: create_fragment$2U.name
    });
  }
}
var Github$1 = Github;

/* ../../components/ui/src/icons/feather/Gitlab.svelte generated by Svelte v3.59.2 */
const file$2P = "../../components/ui/src/icons/feather/Gitlab.svelte";
function create_fragment$2T(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22.65 14.39L12 22.13 1.35 14.39a.84.84 0 0 1-.3-.94l1.22-3.78 2.44-7.51A.42.42 0 0 1 4.82 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.49h8.1l2.44-7.51A.42.42 0 0 1 18.6 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.51L23 13.45a.84.84 0 0 1-.35.94z");
      add_location(path, file$2P, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2T.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2S($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Gitlab', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Gitlab> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Gitlab extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2S, create_fragment$2T, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Gitlab",
      options,
      id: create_fragment$2T.name
    });
  }
}
var Gitlab$1 = Gitlab;

/* ../../components/ui/src/icons/feather/Grid.svelte generated by Svelte v3.59.2 */
const file$2O = "../../components/ui/src/icons/feather/Grid.svelte";
function create_fragment$2S(ctx) {
  let rect0;
  let rect1;
  let rect2;
  let rect3;
  const block = {
    c: function create() {
      rect0 = svg_element("rect");
      rect1 = svg_element("rect");
      rect2 = svg_element("rect");
      rect3 = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      rect0 = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect0).forEach(detach_dev);
      rect1 = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect1).forEach(detach_dev);
      rect2 = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect2).forEach(detach_dev);
      rect3 = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect3).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect0, "x", "3");
      attr_dev(rect0, "y", "3");
      attr_dev(rect0, "width", "7");
      attr_dev(rect0, "height", "7");
      add_location(rect0, file$2O, 1, 0, 34);
      attr_dev(rect1, "x", "14");
      attr_dev(rect1, "y", "3");
      attr_dev(rect1, "width", "7");
      attr_dev(rect1, "height", "7");
      add_location(rect1, file$2O, 1, 46, 80);
      attr_dev(rect2, "x", "14");
      attr_dev(rect2, "y", "14");
      attr_dev(rect2, "width", "7");
      attr_dev(rect2, "height", "7");
      add_location(rect2, file$2O, 1, 93, 127);
      attr_dev(rect3, "x", "3");
      attr_dev(rect3, "y", "14");
      attr_dev(rect3, "width", "7");
      attr_dev(rect3, "height", "7");
      add_location(rect3, file$2O, 1, 141, 175);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect0, anchor);
      insert_hydration_dev(target, rect1, anchor);
      insert_hydration_dev(target, rect2, anchor);
      insert_hydration_dev(target, rect3, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect0);
      if (detaching) detach_dev(rect1);
      if (detaching) detach_dev(rect2);
      if (detaching) detach_dev(rect3);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2S.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2R($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Grid', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Grid> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Grid extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2R, create_fragment$2S, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Grid",
      options,
      id: create_fragment$2S.name
    });
  }
}
var Grid$1 = Grid;

/* ../../components/ui/src/icons/feather/HardDrive.svelte generated by Svelte v3.59.2 */
const file$2N = "../../components/ui/src/icons/feather/HardDrive.svelte";
function create_fragment$2R(ctx) {
  let line0;
  let path;
  let line1;
  let line2;
  const block = {
    c: function create() {
      line0 = svg_element("line");
      path = svg_element("path");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "22");
      attr_dev(line0, "y1", "12");
      attr_dev(line0, "x2", "2");
      attr_dev(line0, "y2", "12");
      add_location(line0, file$2N, 1, 0, 34);
      attr_dev(path, "d", "M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z");
      add_location(path, file$2N, 1, 44, 78);
      attr_dev(line1, "x1", "6");
      attr_dev(line1, "y1", "16");
      attr_dev(line1, "x2", "6.01");
      attr_dev(line1, "y2", "16");
      add_location(line1, file$2N, 1, 168, 202);
      attr_dev(line2, "x1", "10");
      attr_dev(line2, "y1", "16");
      attr_dev(line2, "x2", "10.01");
      attr_dev(line2, "y2", "16");
      add_location(line2, file$2N, 1, 214, 248);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2R.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2Q($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('HardDrive', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<HardDrive> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class HardDrive extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2Q, create_fragment$2R, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HardDrive",
      options,
      id: create_fragment$2R.name
    });
  }
}
var HardDrive$1 = HardDrive;

/* ../../components/ui/src/icons/feather/Hash.svelte generated by Svelte v3.59.2 */
const file$2M = "../../components/ui/src/icons/feather/Hash.svelte";
function create_fragment$2Q(ctx) {
  let line0;
  let line1;
  let line2;
  let line3;
  const block = {
    c: function create() {
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line3).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "4");
      attr_dev(line0, "y1", "9");
      attr_dev(line0, "x2", "20");
      attr_dev(line0, "y2", "9");
      add_location(line0, file$2M, 1, 0, 34);
      attr_dev(line1, "x1", "4");
      attr_dev(line1, "y1", "15");
      attr_dev(line1, "x2", "20");
      attr_dev(line1, "y2", "15");
      add_location(line1, file$2M, 1, 42, 76);
      attr_dev(line2, "x1", "10");
      attr_dev(line2, "y1", "3");
      attr_dev(line2, "x2", "8");
      attr_dev(line2, "y2", "21");
      add_location(line2, file$2M, 1, 86, 120);
      attr_dev(line3, "x1", "16");
      attr_dev(line3, "y1", "3");
      attr_dev(line3, "x2", "14");
      attr_dev(line3, "y2", "21");
      add_location(line3, file$2M, 1, 129, 163);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
      insert_hydration_dev(target, line3, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
      if (detaching) detach_dev(line3);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2Q.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2P($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Hash', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Hash> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Hash extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2P, create_fragment$2Q, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Hash",
      options,
      id: create_fragment$2Q.name
    });
  }
}
var Hash$1 = Hash;

/* ../../components/ui/src/icons/feather/Headphones.svelte generated by Svelte v3.59.2 */
const file$2L = "../../components/ui/src/icons/feather/Headphones.svelte";
function create_fragment$2P(ctx) {
  let path0;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M3 18v-6a9 9 0 0 1 18 0v6");
      add_location(path0, file$2L, 1, 0, 34);
      attr_dev(path1, "d", "M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z");
      add_location(path1, file$2L, 1, 43, 77);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(path1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2P.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2O($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Headphones', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Headphones> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Headphones extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2O, create_fragment$2P, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Headphones",
      options,
      id: create_fragment$2P.name
    });
  }
}
var Headphones$1 = Headphones;

/* ../../components/ui/src/icons/feather/Heart.svelte generated by Svelte v3.59.2 */
const file$2K = "../../components/ui/src/icons/feather/Heart.svelte";
function create_fragment$2O(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z");
      add_location(path, file$2K, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2O.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2N($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Heart', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Heart> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Heart extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2N, create_fragment$2O, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Heart",
      options,
      id: create_fragment$2O.name
    });
  }
}
var Heart$1 = Heart;

/* ../../components/ui/src/icons/feather/HelpCircle.svelte generated by Svelte v3.59.2 */
const file$2J = "../../components/ui/src/icons/feather/HelpCircle.svelte";
function create_fragment$2N(ctx) {
  let circle;
  let path;
  let line;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file$2J, 1, 0, 34);
      attr_dev(path, "d", "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3");
      add_location(path, file$2J, 1, 40, 74);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "17");
      attr_dev(line, "x2", "12.01");
      attr_dev(line, "y2", "17");
      add_location(line, file$2J, 1, 94, 128);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2N.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2M($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('HelpCircle', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<HelpCircle> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class HelpCircle extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2M, create_fragment$2N, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HelpCircle",
      options,
      id: create_fragment$2N.name
    });
  }
}
var HelpCircle$1 = HelpCircle;

/* ../../components/ui/src/icons/feather/Hexagon.svelte generated by Svelte v3.59.2 */
const file$2I = "../../components/ui/src/icons/feather/Hexagon.svelte";
function create_fragment$2M(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z");
      add_location(path, file$2I, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2M.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2L($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Hexagon', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Hexagon> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Hexagon extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2L, create_fragment$2M, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Hexagon",
      options,
      id: create_fragment$2M.name
    });
  }
}
var Hexagon$1 = Hexagon;

/* ../../components/ui/src/icons/feather/Home.svelte generated by Svelte v3.59.2 */
const file$2H = "../../components/ui/src/icons/feather/Home.svelte";
function create_fragment$2L(ctx) {
  let path;
  let polyline;
  const block = {
    c: function create() {
      path = svg_element("path");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z");
      add_location(path, file$2H, 1, 0, 34);
      attr_dev(polyline, "points", "9 22 9 12 15 12 15 22");
      add_location(polyline, file$2H, 1, 64, 98);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, polyline, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2L.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2K($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Home', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Home> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Home extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2K, create_fragment$2L, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Home",
      options,
      id: create_fragment$2L.name
    });
  }
}
var Home$1 = Home;

/* ../../components/ui/src/icons/feather/Image.svelte generated by Svelte v3.59.2 */
const file$2G = "../../components/ui/src/icons/feather/Image.svelte";
function create_fragment$2K(ctx) {
  let rect;
  let circle;
  let polyline;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      circle = svg_element("circle");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "3");
      attr_dev(rect, "y", "3");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "18");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file$2G, 1, 0, 34);
      attr_dev(circle, "cx", "8.5");
      attr_dev(circle, "cy", "8.5");
      attr_dev(circle, "r", "1.5");
      add_location(circle, file$2G, 1, 62, 96);
      attr_dev(polyline, "points", "21 15 16 10 5 21");
      add_location(polyline, file$2G, 1, 105, 139);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, polyline, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2K.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2J($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Image', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Image> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Image extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2J, create_fragment$2K, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Image",
      options,
      id: create_fragment$2K.name
    });
  }
}
var Image$1 = Image;

/* ../../components/ui/src/icons/feather/Inbox.svelte generated by Svelte v3.59.2 */
const file$2F = "../../components/ui/src/icons/feather/Inbox.svelte";
function create_fragment$2J(ctx) {
  let polyline;
  let path;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "22 12 16 12 14 15 10 15 8 12 2 12");
      add_location(polyline, file$2F, 1, 0, 34);
      attr_dev(path, "d", "M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z");
      add_location(path, file$2F, 1, 64, 98);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2J.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2I($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Inbox', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Inbox> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Inbox extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2I, create_fragment$2J, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Inbox",
      options,
      id: create_fragment$2J.name
    });
  }
}
var Inbox$1 = Inbox;

/* ../../components/ui/src/icons/feather/Instagram.svelte generated by Svelte v3.59.2 */
const file$2E = "../../components/ui/src/icons/feather/Instagram.svelte";
function create_fragment$2I(ctx) {
  let rect;
  let path;
  let line;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "2");
      attr_dev(rect, "y", "2");
      attr_dev(rect, "width", "20");
      attr_dev(rect, "height", "20");
      attr_dev(rect, "rx", "5");
      attr_dev(rect, "ry", "5");
      add_location(rect, file$2E, 1, 0, 34);
      attr_dev(path, "d", "M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z");
      add_location(path, file$2E, 1, 62, 96);
      attr_dev(line, "x1", "17.5");
      attr_dev(line, "y1", "6.5");
      attr_dev(line, "x2", "17.51");
      attr_dev(line, "y2", "6.5");
      add_location(line, file$2E, 1, 127, 161);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2I.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2H($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Instagram', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Instagram> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Instagram extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2H, create_fragment$2I, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Instagram",
      options,
      id: create_fragment$2I.name
    });
  }
}
var Instagram$1 = Instagram;

/* ../../components/ui/src/icons/feather/Italic.svelte generated by Svelte v3.59.2 */
const file$2D = "../../components/ui/src/icons/feather/Italic.svelte";
function create_fragment$2H(ctx) {
  let line0;
  let line1;
  let line2;
  const block = {
    c: function create() {
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "19");
      attr_dev(line0, "y1", "4");
      attr_dev(line0, "x2", "10");
      attr_dev(line0, "y2", "4");
      add_location(line0, file$2D, 1, 0, 34);
      attr_dev(line1, "x1", "14");
      attr_dev(line1, "y1", "20");
      attr_dev(line1, "x2", "5");
      attr_dev(line1, "y2", "20");
      add_location(line1, file$2D, 1, 43, 77);
      attr_dev(line2, "x1", "15");
      attr_dev(line2, "y1", "4");
      attr_dev(line2, "x2", "9");
      attr_dev(line2, "y2", "20");
      add_location(line2, file$2D, 1, 87, 121);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2H.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2G($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Italic', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Italic> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Italic extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2G, create_fragment$2H, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Italic",
      options,
      id: create_fragment$2H.name
    });
  }
}
var Italic$1 = Italic;

/* ../../components/ui/src/icons/feather/Key.svelte generated by Svelte v3.59.2 */
const file$2C = "../../components/ui/src/icons/feather/Key.svelte";
function create_fragment$2G(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4");
      add_location(path, file$2C, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2G.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2F($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Key', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Key> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Key extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2F, create_fragment$2G, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Key",
      options,
      id: create_fragment$2G.name
    });
  }
}
var Key$1 = Key;

/* ../../components/ui/src/icons/feather/Layers.svelte generated by Svelte v3.59.2 */
const file$2B = "../../components/ui/src/icons/feather/Layers.svelte";
function create_fragment$2F(ctx) {
  let polygon;
  let polyline0;
  let polyline1;
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      polyline0 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "12 2 2 7 12 12 22 7 12 2");
      add_location(polygon, file$2B, 1, 0, 34);
      attr_dev(polyline0, "points", "2 17 12 22 22 17");
      add_location(polyline0, file$2B, 1, 53, 87);
      attr_dev(polyline1, "points", "2 12 12 17 22 12");
      add_location(polyline1, file$2B, 1, 100, 134);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon, anchor);
      insert_hydration_dev(target, polyline0, anchor);
      insert_hydration_dev(target, polyline1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polygon);
      if (detaching) detach_dev(polyline0);
      if (detaching) detach_dev(polyline1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2F.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2E($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Layers', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Layers> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Layers extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2E, create_fragment$2F, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Layers",
      options,
      id: create_fragment$2F.name
    });
  }
}
var Layers$1 = Layers;

/* ../../components/ui/src/icons/feather/Layout.svelte generated by Svelte v3.59.2 */
const file$2A = "../../components/ui/src/icons/feather/Layout.svelte";
function create_fragment$2E(ctx) {
  let rect;
  let line0;
  let line1;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "3");
      attr_dev(rect, "y", "3");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "18");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file$2A, 1, 0, 34);
      attr_dev(line0, "x1", "3");
      attr_dev(line0, "y1", "9");
      attr_dev(line0, "x2", "21");
      attr_dev(line0, "y2", "9");
      add_location(line0, file$2A, 1, 62, 96);
      attr_dev(line1, "x1", "9");
      attr_dev(line1, "y1", "21");
      attr_dev(line1, "x2", "9");
      attr_dev(line1, "y2", "9");
      add_location(line1, file$2A, 1, 104, 138);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2E.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2D($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Layout', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Layout> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Layout extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2D, create_fragment$2E, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Layout",
      options,
      id: create_fragment$2E.name
    });
  }
}
var Layout$1 = Layout;

/* ../../components/ui/src/icons/feather/LifeBuoy.svelte generated by Svelte v3.59.2 */
const file$2z = "../../components/ui/src/icons/feather/LifeBuoy.svelte";
function create_fragment$2D(ctx) {
  let circle0;
  let circle1;
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  const block = {
    c: function create() {
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      circle0 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle1).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line3).forEach(detach_dev);
      line4 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line4).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "12");
      attr_dev(circle0, "cy", "12");
      attr_dev(circle0, "r", "10");
      add_location(circle0, file$2z, 1, 0, 34);
      attr_dev(circle1, "cx", "12");
      attr_dev(circle1, "cy", "12");
      attr_dev(circle1, "r", "4");
      add_location(circle1, file$2z, 1, 40, 74);
      attr_dev(line0, "x1", "4.93");
      attr_dev(line0, "y1", "4.93");
      attr_dev(line0, "x2", "9.17");
      attr_dev(line0, "y2", "9.17");
      add_location(line0, file$2z, 1, 79, 113);
      attr_dev(line1, "x1", "14.83");
      attr_dev(line1, "y1", "14.83");
      attr_dev(line1, "x2", "19.07");
      attr_dev(line1, "y2", "19.07");
      add_location(line1, file$2z, 1, 132, 166);
      attr_dev(line2, "x1", "14.83");
      attr_dev(line2, "y1", "9.17");
      attr_dev(line2, "x2", "19.07");
      attr_dev(line2, "y2", "4.93");
      add_location(line2, file$2z, 1, 189, 223);
      attr_dev(line3, "x1", "14.83");
      attr_dev(line3, "y1", "9.17");
      attr_dev(line3, "x2", "18.36");
      attr_dev(line3, "y2", "5.64");
      add_location(line3, file$2z, 1, 244, 278);
      attr_dev(line4, "x1", "4.93");
      attr_dev(line4, "y1", "19.07");
      attr_dev(line4, "x2", "9.17");
      attr_dev(line4, "y2", "14.83");
      add_location(line4, file$2z, 1, 299, 333);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle0, anchor);
      insert_hydration_dev(target, circle1, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
      insert_hydration_dev(target, line3, anchor);
      insert_hydration_dev(target, line4, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle0);
      if (detaching) detach_dev(circle1);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
      if (detaching) detach_dev(line3);
      if (detaching) detach_dev(line4);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2D.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2C($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('LifeBuoy', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<LifeBuoy> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class LifeBuoy extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2C, create_fragment$2D, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LifeBuoy",
      options,
      id: create_fragment$2D.name
    });
  }
}
var LifeBuoy$1 = LifeBuoy;

/* ../../components/ui/src/icons/feather/Link2.svelte generated by Svelte v3.59.2 */
const file$2y = "../../components/ui/src/icons/feather/Link2.svelte";
function create_fragment$2C(ctx) {
  let path;
  let line;
  const block = {
    c: function create() {
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3");
      add_location(path, file$2y, 1, 0, 34);
      attr_dev(line, "x1", "8");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "16");
      attr_dev(line, "y2", "12");
      add_location(line, file$2y, 1, 93, 127);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2C.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2B($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Link2', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Link2> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Link2 extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2B, create_fragment$2C, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Link2",
      options,
      id: create_fragment$2C.name
    });
  }
}
var Link2$1 = Link2;

/* ../../components/ui/src/icons/feather/Linkedin.svelte generated by Svelte v3.59.2 */
const file$2x = "../../components/ui/src/icons/feather/Linkedin.svelte";
function create_fragment$2B(ctx) {
  let path;
  let rect;
  let circle;
  const block = {
    c: function create() {
      path = svg_element("path");
      rect = svg_element("rect");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect).forEach(detach_dev);
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z");
      add_location(path, file$2x, 1, 0, 34);
      attr_dev(rect, "x", "2");
      attr_dev(rect, "y", "9");
      attr_dev(rect, "width", "4");
      attr_dev(rect, "height", "12");
      add_location(rect, file$2x, 1, 96, 130);
      attr_dev(circle, "cx", "4");
      attr_dev(circle, "cy", "4");
      attr_dev(circle, "r", "2");
      add_location(circle, file$2x, 1, 143, 177);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, circle, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(circle);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2B.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2A($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Linkedin', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Linkedin> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Linkedin extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2A, create_fragment$2B, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Linkedin",
      options,
      id: create_fragment$2B.name
    });
  }
}
var Linkedin$1 = Linkedin;

/* ../../components/ui/src/icons/feather/Lock.svelte generated by Svelte v3.59.2 */
const file$2w = "../../components/ui/src/icons/feather/Lock.svelte";
function create_fragment$2A(ctx) {
  let rect;
  let path;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "3");
      attr_dev(rect, "y", "11");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "11");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file$2w, 1, 0, 34);
      attr_dev(path, "d", "M7 11V7a5 5 0 0 1 10 0v4");
      add_location(path, file$2w, 1, 63, 97);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2A.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2z($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Lock', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Lock> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Lock extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2z, create_fragment$2A, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Lock",
      options,
      id: create_fragment$2A.name
    });
  }
}
var Lock$1 = Lock;

/* ../../components/ui/src/icons/feather/LogIn.svelte generated by Svelte v3.59.2 */
const file$2v = "../../components/ui/src/icons/feather/LogIn.svelte";
function create_fragment$2z(ctx) {
  let path;
  let polyline;
  let line;
  const block = {
    c: function create() {
      path = svg_element("path");
      polyline = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4");
      add_location(path, file$2v, 1, 0, 34);
      attr_dev(polyline, "points", "10 17 15 12 10 7");
      add_location(polyline, file$2v, 1, 59, 93);
      attr_dev(line, "x1", "15");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "3");
      attr_dev(line, "y2", "12");
      add_location(line, file$2v, 1, 106, 140);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2z.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2y($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('LogIn', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<LogIn> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class LogIn extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2y, create_fragment$2z, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LogIn",
      options,
      id: create_fragment$2z.name
    });
  }
}
var LogIn$1 = LogIn;

/* ../../components/ui/src/icons/feather/LogOut.svelte generated by Svelte v3.59.2 */
const file$2u = "../../components/ui/src/icons/feather/LogOut.svelte";
function create_fragment$2y(ctx) {
  let path;
  let polyline;
  let line;
  const block = {
    c: function create() {
      path = svg_element("path");
      polyline = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4");
      add_location(path, file$2u, 1, 0, 34);
      attr_dev(polyline, "points", "16 17 21 12 16 7");
      add_location(polyline, file$2u, 1, 57, 91);
      attr_dev(line, "x1", "21");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "9");
      attr_dev(line, "y2", "12");
      add_location(line, file$2u, 1, 104, 138);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2y.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2x($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('LogOut', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<LogOut> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class LogOut extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2x, create_fragment$2y, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LogOut",
      options,
      id: create_fragment$2y.name
    });
  }
}
var LogOut$1 = LogOut;

/* ../../components/ui/src/icons/feather/Mail.svelte generated by Svelte v3.59.2 */
const file$2t = "../../components/ui/src/icons/feather/Mail.svelte";
function create_fragment$2x(ctx) {
  let path;
  let polyline;
  const block = {
    c: function create() {
      path = svg_element("path");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z");
      add_location(path, file$2t, 1, 0, 34);
      attr_dev(polyline, "points", "22,6 12,13 2,6");
      add_location(polyline, file$2t, 1, 93, 127);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, polyline, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2x.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2w($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Mail', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Mail> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Mail extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2w, create_fragment$2x, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Mail",
      options,
      id: create_fragment$2x.name
    });
  }
}
var Mail$1 = Mail;

/* ../../components/ui/src/icons/feather/Map.svelte generated by Svelte v3.59.2 */
const file$2s = "../../components/ui/src/icons/feather/Map.svelte";
function create_fragment$2w(ctx) {
  let polygon;
  let line0;
  let line1;
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6");
      add_location(polygon, file$2s, 1, 0, 34);
      attr_dev(line0, "x1", "8");
      attr_dev(line0, "y1", "2");
      attr_dev(line0, "x2", "8");
      attr_dev(line0, "y2", "18");
      add_location(line0, file$2s, 1, 72, 106);
      attr_dev(line1, "x1", "16");
      attr_dev(line1, "y1", "6");
      attr_dev(line1, "x2", "16");
      attr_dev(line1, "y2", "22");
      add_location(line1, file$2s, 1, 114, 148);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polygon);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2w.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2v($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Map', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Map> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Map extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2v, create_fragment$2w, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Map",
      options,
      id: create_fragment$2w.name
    });
  }
}
var Map$1 = Map;

/* ../../components/ui/src/icons/feather/Maximize2.svelte generated by Svelte v3.59.2 */
const file$2r = "../../components/ui/src/icons/feather/Maximize2.svelte";
function create_fragment$2v(ctx) {
  let polyline0;
  let polyline1;
  let line0;
  let line1;
  const block = {
    c: function create() {
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      polyline0 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline1).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "15 3 21 3 21 9");
      add_location(polyline0, file$2r, 1, 0, 34);
      attr_dev(polyline1, "points", "9 21 3 21 3 15");
      add_location(polyline1, file$2r, 1, 45, 79);
      attr_dev(line0, "x1", "21");
      attr_dev(line0, "y1", "3");
      attr_dev(line0, "x2", "14");
      attr_dev(line0, "y2", "10");
      add_location(line0, file$2r, 1, 90, 124);
      attr_dev(line1, "x1", "3");
      attr_dev(line1, "y1", "21");
      attr_dev(line1, "x2", "10");
      attr_dev(line1, "y2", "14");
      add_location(line1, file$2r, 1, 134, 168);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline0, anchor);
      insert_hydration_dev(target, polyline1, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline0);
      if (detaching) detach_dev(polyline1);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2v.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2u($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Maximize2', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Maximize2> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Maximize2 extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2u, create_fragment$2v, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Maximize2",
      options,
      id: create_fragment$2v.name
    });
  }
}
var Maximize2$1 = Maximize2;

/* ../../components/ui/src/icons/feather/Maximize.svelte generated by Svelte v3.59.2 */
const file$2q = "../../components/ui/src/icons/feather/Maximize.svelte";
function create_fragment$2u(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3");
      add_location(path, file$2q, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2u.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2t($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Maximize', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Maximize> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Maximize extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2t, create_fragment$2u, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Maximize",
      options,
      id: create_fragment$2u.name
    });
  }
}
var Maximize$1 = Maximize;

/* ../../components/ui/src/icons/feather/Meh.svelte generated by Svelte v3.59.2 */
const file$2p = "../../components/ui/src/icons/feather/Meh.svelte";
function create_fragment$2t(ctx) {
  let circle;
  let line0;
  let line1;
  let line2;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file$2p, 1, 0, 34);
      attr_dev(line0, "x1", "8");
      attr_dev(line0, "y1", "15");
      attr_dev(line0, "x2", "16");
      attr_dev(line0, "y2", "15");
      add_location(line0, file$2p, 1, 40, 74);
      attr_dev(line1, "x1", "9");
      attr_dev(line1, "y1", "9");
      attr_dev(line1, "x2", "9.01");
      attr_dev(line1, "y2", "9");
      add_location(line1, file$2p, 1, 84, 118);
      attr_dev(line2, "x1", "15");
      attr_dev(line2, "y1", "9");
      attr_dev(line2, "x2", "15.01");
      attr_dev(line2, "y2", "9");
      add_location(line2, file$2p, 1, 128, 162);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2t.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2s($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Meh', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Meh> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Meh extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2s, create_fragment$2t, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Meh",
      options,
      id: create_fragment$2t.name
    });
  }
}
var Meh$1 = Meh;

/* ../../components/ui/src/icons/feather/Menu.svelte generated by Svelte v3.59.2 */
const file$2o = "../../components/ui/src/icons/feather/Menu.svelte";
function create_fragment$2s(ctx) {
  let line0;
  let line1;
  let line2;
  const block = {
    c: function create() {
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "3");
      attr_dev(line0, "y1", "12");
      attr_dev(line0, "x2", "21");
      attr_dev(line0, "y2", "12");
      add_location(line0, file$2o, 1, 0, 34);
      attr_dev(line1, "x1", "3");
      attr_dev(line1, "y1", "6");
      attr_dev(line1, "x2", "21");
      attr_dev(line1, "y2", "6");
      add_location(line1, file$2o, 1, 44, 78);
      attr_dev(line2, "x1", "3");
      attr_dev(line2, "y1", "18");
      attr_dev(line2, "x2", "21");
      attr_dev(line2, "y2", "18");
      add_location(line2, file$2o, 1, 86, 120);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2s.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2r($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Menu', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Menu> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Menu extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2r, create_fragment$2s, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Menu",
      options,
      id: create_fragment$2s.name
    });
  }
}
var Menu$1 = Menu;

/* ../../components/ui/src/icons/feather/MessageCircle.svelte generated by Svelte v3.59.2 */
const file$2n = "../../components/ui/src/icons/feather/MessageCircle.svelte";
function create_fragment$2r(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z");
      add_location(path, file$2n, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2r.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2q($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('MessageCircle', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<MessageCircle> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class MessageCircle extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2q, create_fragment$2r, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MessageCircle",
      options,
      id: create_fragment$2r.name
    });
  }
}
var MessageCircle$1 = MessageCircle;

/* ../../components/ui/src/icons/feather/MessageSquare.svelte generated by Svelte v3.59.2 */
const file$2m = "../../components/ui/src/icons/feather/MessageSquare.svelte";
function create_fragment$2q(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z");
      add_location(path, file$2m, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2q.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2p($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('MessageSquare', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<MessageSquare> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class MessageSquare extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2p, create_fragment$2q, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MessageSquare",
      options,
      id: create_fragment$2q.name
    });
  }
}
var MessageSquare$1 = MessageSquare;

/* ../../components/ui/src/icons/feather/MicOff.svelte generated by Svelte v3.59.2 */
const file$2l = "../../components/ui/src/icons/feather/MicOff.svelte";
function create_fragment$2p(ctx) {
  let line0;
  let path0;
  let path1;
  let line1;
  let line2;
  const block = {
    c: function create() {
      line0 = svg_element("line");
      path0 = svg_element("path");
      path1 = svg_element("path");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "1");
      attr_dev(line0, "y1", "1");
      attr_dev(line0, "x2", "23");
      attr_dev(line0, "y2", "23");
      add_location(line0, file$2l, 1, 0, 34);
      attr_dev(path0, "d", "M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6");
      add_location(path0, file$2l, 1, 43, 77);
      attr_dev(path1, "d", "M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23");
      add_location(path1, file$2l, 1, 115, 149);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "19");
      attr_dev(line1, "x2", "12");
      attr_dev(line1, "y2", "23");
      add_location(line1, file$2l, 1, 186, 220);
      attr_dev(line2, "x1", "8");
      attr_dev(line2, "y1", "23");
      attr_dev(line2, "x2", "16");
      attr_dev(line2, "y2", "23");
      add_location(line2, file$2l, 1, 231, 265);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(path1);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2p.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2o($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('MicOff', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<MicOff> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class MicOff extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2o, create_fragment$2p, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MicOff",
      options,
      id: create_fragment$2p.name
    });
  }
}
var MicOff$1 = MicOff;

/* ../../components/ui/src/icons/feather/Mic.svelte generated by Svelte v3.59.2 */
const file$2k = "../../components/ui/src/icons/feather/Mic.svelte";
function create_fragment$2o(ctx) {
  let path0;
  let path1;
  let line0;
  let line1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z");
      add_location(path0, file$2k, 1, 0, 34);
      attr_dev(path1, "d", "M19 10v2a7 7 0 0 1-14 0v-2");
      add_location(path1, file$2k, 1, 70, 104);
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "19");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "23");
      add_location(line0, file$2k, 1, 114, 148);
      attr_dev(line1, "x1", "8");
      attr_dev(line1, "y1", "23");
      attr_dev(line1, "x2", "16");
      attr_dev(line1, "y2", "23");
      add_location(line1, file$2k, 1, 159, 193);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(path1);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2o.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2n($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Mic', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Mic> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Mic extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2n, create_fragment$2o, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Mic",
      options,
      id: create_fragment$2o.name
    });
  }
}
var Mic$1 = Mic;

/* ../../components/ui/src/icons/feather/Minimize2.svelte generated by Svelte v3.59.2 */
const file$2j = "../../components/ui/src/icons/feather/Minimize2.svelte";
function create_fragment$2n(ctx) {
  let polyline0;
  let polyline1;
  let line0;
  let line1;
  const block = {
    c: function create() {
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      polyline0 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline1).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "4 14 10 14 10 20");
      add_location(polyline0, file$2j, 1, 0, 34);
      attr_dev(polyline1, "points", "20 10 14 10 14 4");
      add_location(polyline1, file$2j, 1, 47, 81);
      attr_dev(line0, "x1", "14");
      attr_dev(line0, "y1", "10");
      attr_dev(line0, "x2", "21");
      attr_dev(line0, "y2", "3");
      add_location(line0, file$2j, 1, 94, 128);
      attr_dev(line1, "x1", "3");
      attr_dev(line1, "y1", "21");
      attr_dev(line1, "x2", "10");
      attr_dev(line1, "y2", "14");
      add_location(line1, file$2j, 1, 138, 172);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline0, anchor);
      insert_hydration_dev(target, polyline1, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline0);
      if (detaching) detach_dev(polyline1);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2n.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2m($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Minimize2', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Minimize2> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Minimize2 extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2m, create_fragment$2n, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Minimize2",
      options,
      id: create_fragment$2n.name
    });
  }
}
var Minimize2$1 = Minimize2;

/* ../../components/ui/src/icons/feather/Minimize.svelte generated by Svelte v3.59.2 */
const file$2i = "../../components/ui/src/icons/feather/Minimize.svelte";
function create_fragment$2m(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3");
      add_location(path, file$2i, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2m.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2l($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Minimize', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Minimize> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Minimize extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2l, create_fragment$2m, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Minimize",
      options,
      id: create_fragment$2m.name
    });
  }
}
var Minimize$1 = Minimize;

/* ../../components/ui/src/icons/feather/Minus.svelte generated by Svelte v3.59.2 */
const file$2h = "../../components/ui/src/icons/feather/Minus.svelte";
function create_fragment$2l(ctx) {
  let line;
  const block = {
    c: function create() {
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "5");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "19");
      attr_dev(line, "y2", "12");
      add_location(line, file$2h, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2l.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2k($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Minus', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Minus> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Minus extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2k, create_fragment$2l, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Minus",
      options,
      id: create_fragment$2l.name
    });
  }
}
var Minus$1 = Minus;

/* ../../components/ui/src/icons/feather/Monitor.svelte generated by Svelte v3.59.2 */
const file$2g = "../../components/ui/src/icons/feather/Monitor.svelte";
function create_fragment$2k(ctx) {
  let rect;
  let line0;
  let line1;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "2");
      attr_dev(rect, "y", "3");
      attr_dev(rect, "width", "20");
      attr_dev(rect, "height", "14");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file$2g, 1, 0, 34);
      attr_dev(line0, "x1", "8");
      attr_dev(line0, "y1", "21");
      attr_dev(line0, "x2", "16");
      attr_dev(line0, "y2", "21");
      add_location(line0, file$2g, 1, 62, 96);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "17");
      attr_dev(line1, "x2", "12");
      attr_dev(line1, "y2", "21");
      add_location(line1, file$2g, 1, 106, 140);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2k.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2j($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Monitor', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Monitor> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Monitor extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2j, create_fragment$2k, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Monitor",
      options,
      id: create_fragment$2k.name
    });
  }
}
var Monitor$1 = Monitor;

/* ../../components/ui/src/icons/feather/Moon.svelte generated by Svelte v3.59.2 */
const file$2f = "../../components/ui/src/icons/feather/Moon.svelte";
function create_fragment$2j(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z");
      add_location(path, file$2f, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2j.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2i($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Moon', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Moon> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Moon extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2i, create_fragment$2j, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Moon",
      options,
      id: create_fragment$2j.name
    });
  }
}
var Moon$1 = Moon;

/* ../../components/ui/src/icons/feather/MoreHorizontal.svelte generated by Svelte v3.59.2 */
const file$2e = "../../components/ui/src/icons/feather/MoreHorizontal.svelte";
function create_fragment$2i(ctx) {
  let circle0;
  let circle1;
  let circle2;
  const block = {
    c: function create() {
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      circle2 = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      circle0 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle1).forEach(detach_dev);
      circle2 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "12");
      attr_dev(circle0, "cy", "12");
      attr_dev(circle0, "r", "1");
      add_location(circle0, file$2e, 1, 0, 34);
      attr_dev(circle1, "cx", "19");
      attr_dev(circle1, "cy", "12");
      attr_dev(circle1, "r", "1");
      add_location(circle1, file$2e, 1, 39, 73);
      attr_dev(circle2, "cx", "5");
      attr_dev(circle2, "cy", "12");
      attr_dev(circle2, "r", "1");
      add_location(circle2, file$2e, 1, 78, 112);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle0, anchor);
      insert_hydration_dev(target, circle1, anchor);
      insert_hydration_dev(target, circle2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle0);
      if (detaching) detach_dev(circle1);
      if (detaching) detach_dev(circle2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2i.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2h($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('MoreHorizontal', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<MoreHorizontal> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class MoreHorizontal extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2h, create_fragment$2i, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MoreHorizontal",
      options,
      id: create_fragment$2i.name
    });
  }
}
var MoreHorizontal$1 = MoreHorizontal;

/* ../../components/ui/src/icons/feather/MoreVertical.svelte generated by Svelte v3.59.2 */
const file$2d = "../../components/ui/src/icons/feather/MoreVertical.svelte";
function create_fragment$2h(ctx) {
  let circle0;
  let circle1;
  let circle2;
  const block = {
    c: function create() {
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      circle2 = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      circle0 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle1).forEach(detach_dev);
      circle2 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "12");
      attr_dev(circle0, "cy", "12");
      attr_dev(circle0, "r", "1");
      add_location(circle0, file$2d, 1, 0, 34);
      attr_dev(circle1, "cx", "12");
      attr_dev(circle1, "cy", "5");
      attr_dev(circle1, "r", "1");
      add_location(circle1, file$2d, 1, 39, 73);
      attr_dev(circle2, "cx", "12");
      attr_dev(circle2, "cy", "19");
      attr_dev(circle2, "r", "1");
      add_location(circle2, file$2d, 1, 77, 111);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle0, anchor);
      insert_hydration_dev(target, circle1, anchor);
      insert_hydration_dev(target, circle2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle0);
      if (detaching) detach_dev(circle1);
      if (detaching) detach_dev(circle2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2h.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2g($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('MoreVertical', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<MoreVertical> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class MoreVertical extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2g, create_fragment$2h, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MoreVertical",
      options,
      id: create_fragment$2h.name
    });
  }
}
var MoreVertical$1 = MoreVertical;

/* ../../components/ui/src/icons/feather/MousePointer.svelte generated by Svelte v3.59.2 */
const file$2c = "../../components/ui/src/icons/feather/MousePointer.svelte";
function create_fragment$2g(ctx) {
  let path0;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z");
      add_location(path0, file$2c, 1, 0, 34);
      attr_dev(path1, "d", "M13 13l6 6");
      add_location(path1, file$2c, 1, 58, 92);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(path1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2g.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2f($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('MousePointer', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<MousePointer> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class MousePointer extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2f, create_fragment$2g, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MousePointer",
      options,
      id: create_fragment$2g.name
    });
  }
}
var MousePointer$1 = MousePointer;

/* ../../components/ui/src/icons/feather/Move.svelte generated by Svelte v3.59.2 */
const file$2b = "../../components/ui/src/icons/feather/Move.svelte";
function create_fragment$2f(ctx) {
  let polyline0;
  let polyline1;
  let polyline2;
  let polyline3;
  let line0;
  let line1;
  const block = {
    c: function create() {
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      polyline2 = svg_element("polyline");
      polyline3 = svg_element("polyline");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      polyline0 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline1).forEach(detach_dev);
      polyline2 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline2).forEach(detach_dev);
      polyline3 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline3).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "5 9 2 12 5 15");
      add_location(polyline0, file$2b, 1, 0, 34);
      attr_dev(polyline1, "points", "9 5 12 2 15 5");
      add_location(polyline1, file$2b, 1, 44, 78);
      attr_dev(polyline2, "points", "15 19 12 22 9 19");
      add_location(polyline2, file$2b, 1, 88, 122);
      attr_dev(polyline3, "points", "19 9 22 12 19 15");
      add_location(polyline3, file$2b, 1, 135, 169);
      attr_dev(line0, "x1", "2");
      attr_dev(line0, "y1", "12");
      attr_dev(line0, "x2", "22");
      attr_dev(line0, "y2", "12");
      add_location(line0, file$2b, 1, 182, 216);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "2");
      attr_dev(line1, "x2", "12");
      attr_dev(line1, "y2", "22");
      add_location(line1, file$2b, 1, 226, 260);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline0, anchor);
      insert_hydration_dev(target, polyline1, anchor);
      insert_hydration_dev(target, polyline2, anchor);
      insert_hydration_dev(target, polyline3, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline0);
      if (detaching) detach_dev(polyline1);
      if (detaching) detach_dev(polyline2);
      if (detaching) detach_dev(polyline3);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2f.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2e($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Move', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Move> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Move extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2e, create_fragment$2f, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Move",
      options,
      id: create_fragment$2f.name
    });
  }
}
var Move$1 = Move;

/* ../../components/ui/src/icons/feather/Music.svelte generated by Svelte v3.59.2 */
const file$2a = "../../components/ui/src/icons/feather/Music.svelte";
function create_fragment$2e(ctx) {
  let path;
  let circle0;
  let circle1;
  const block = {
    c: function create() {
      path = svg_element("path");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      circle0 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 18V5l12-2v13");
      add_location(path, file$2a, 1, 0, 34);
      attr_dev(circle0, "cx", "6");
      attr_dev(circle0, "cy", "18");
      attr_dev(circle0, "r", "3");
      add_location(circle0, file$2a, 1, 33, 67);
      attr_dev(circle1, "cx", "18");
      attr_dev(circle1, "cy", "16");
      attr_dev(circle1, "r", "3");
      add_location(circle1, file$2a, 1, 71, 105);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, circle0, anchor);
      insert_hydration_dev(target, circle1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(circle0);
      if (detaching) detach_dev(circle1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2e.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2d($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Music', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Music> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Music extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2d, create_fragment$2e, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Music",
      options,
      id: create_fragment$2e.name
    });
  }
}
var Music$1 = Music;

/* ../../components/ui/src/icons/feather/Navigation2.svelte generated by Svelte v3.59.2 */
const file$29 = "../../components/ui/src/icons/feather/Navigation2.svelte";
function create_fragment$2d(ctx) {
  let polygon;
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "12 2 19 21 12 17 5 21 12 2");
      add_location(polygon, file$29, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polygon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2d.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2c($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Navigation2', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Navigation2> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Navigation2 extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2c, create_fragment$2d, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Navigation2",
      options,
      id: create_fragment$2d.name
    });
  }
}
var Navigation2$1 = Navigation2;

/* ../../components/ui/src/icons/feather/Navigation.svelte generated by Svelte v3.59.2 */
const file$28 = "../../components/ui/src/icons/feather/Navigation.svelte";
function create_fragment$2c(ctx) {
  let polygon;
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "3 11 22 2 13 21 11 13 3 11");
      add_location(polygon, file$28, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polygon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2c.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2b($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Navigation', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Navigation> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Navigation extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2b, create_fragment$2c, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Navigation",
      options,
      id: create_fragment$2c.name
    });
  }
}
var Navigation$1 = Navigation;

/* ../../components/ui/src/icons/feather/Octagon.svelte generated by Svelte v3.59.2 */
const file$27 = "../../components/ui/src/icons/feather/Octagon.svelte";
function create_fragment$2b(ctx) {
  let polygon;
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2");
      add_location(polygon, file$27, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polygon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2b.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2a($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Octagon', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Octagon> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Octagon extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2a, create_fragment$2b, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Octagon",
      options,
      id: create_fragment$2b.name
    });
  }
}
var Octagon$1 = Octagon;

/* ../../components/ui/src/icons/feather/Package.svelte generated by Svelte v3.59.2 */
const file$26 = "../../components/ui/src/icons/feather/Package.svelte";
function create_fragment$2a(ctx) {
  let line0;
  let path;
  let polyline;
  let line1;
  const block = {
    c: function create() {
      line0 = svg_element("line");
      path = svg_element("path");
      polyline = svg_element("polyline");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "16.5");
      attr_dev(line0, "y1", "9.4");
      attr_dev(line0, "x2", "7.5");
      attr_dev(line0, "y2", "4.21");
      add_location(line0, file$26, 1, 0, 34);
      attr_dev(path, "d", "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z");
      add_location(path, file$26, 1, 51, 85);
      attr_dev(polyline, "points", "3.27 6.96 12 12.01 20.73 6.96");
      add_location(polyline, file$26, 1, 190, 224);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "22.08");
      attr_dev(line1, "x2", "12");
      attr_dev(line1, "y2", "12");
      add_location(line1, file$26, 1, 250, 284);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2a.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$29($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Package', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Package> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Package extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$29, create_fragment$2a, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Package",
      options,
      id: create_fragment$2a.name
    });
  }
}
var Package$1 = Package;

/* ../../components/ui/src/icons/feather/Paperclip.svelte generated by Svelte v3.59.2 */
const file$25 = "../../components/ui/src/icons/feather/Paperclip.svelte";
function create_fragment$29(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48");
      add_location(path, file$25, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$29.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$28($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Paperclip', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Paperclip> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Paperclip extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$28, create_fragment$29, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Paperclip",
      options,
      id: create_fragment$29.name
    });
  }
}
var Paperclip$1 = Paperclip;

/* ../../components/ui/src/icons/feather/PauseCircle.svelte generated by Svelte v3.59.2 */
const file$24 = "../../components/ui/src/icons/feather/PauseCircle.svelte";
function create_fragment$28(ctx) {
  let circle;
  let line0;
  let line1;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file$24, 1, 0, 34);
      attr_dev(line0, "x1", "10");
      attr_dev(line0, "y1", "15");
      attr_dev(line0, "x2", "10");
      attr_dev(line0, "y2", "9");
      add_location(line0, file$24, 1, 40, 74);
      attr_dev(line1, "x1", "14");
      attr_dev(line1, "y1", "15");
      attr_dev(line1, "x2", "14");
      attr_dev(line1, "y2", "9");
      add_location(line1, file$24, 1, 84, 118);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$28.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$27($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('PauseCircle', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<PauseCircle> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class PauseCircle extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$27, create_fragment$28, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PauseCircle",
      options,
      id: create_fragment$28.name
    });
  }
}
var PauseCircle$1 = PauseCircle;

/* ../../components/ui/src/icons/feather/Pause.svelte generated by Svelte v3.59.2 */
const file$23 = "../../components/ui/src/icons/feather/Pause.svelte";
function create_fragment$27(ctx) {
  let rect0;
  let rect1;
  const block = {
    c: function create() {
      rect0 = svg_element("rect");
      rect1 = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      rect0 = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect0).forEach(detach_dev);
      rect1 = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect0, "x", "6");
      attr_dev(rect0, "y", "4");
      attr_dev(rect0, "width", "4");
      attr_dev(rect0, "height", "16");
      add_location(rect0, file$23, 1, 0, 34);
      attr_dev(rect1, "x", "14");
      attr_dev(rect1, "y", "4");
      attr_dev(rect1, "width", "4");
      attr_dev(rect1, "height", "16");
      add_location(rect1, file$23, 1, 47, 81);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect0, anchor);
      insert_hydration_dev(target, rect1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect0);
      if (detaching) detach_dev(rect1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$27.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$26($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Pause', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Pause> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Pause extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$26, create_fragment$27, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pause",
      options,
      id: create_fragment$27.name
    });
  }
}
var Pause$1 = Pause;

/* ../../components/ui/src/icons/feather/PenTool.svelte generated by Svelte v3.59.2 */
const file$22 = "../../components/ui/src/icons/feather/PenTool.svelte";
function create_fragment$26(ctx) {
  let path0;
  let path1;
  let path2;
  let circle;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      path2 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path2).forEach(detach_dev);
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M12 19l7-7 3 3-7 7-3-3z");
      add_location(path0, file$22, 1, 0, 34);
      attr_dev(path1, "d", "M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z");
      add_location(path1, file$22, 1, 41, 75);
      attr_dev(path2, "d", "M2 2l7.586 7.586");
      add_location(path2, file$22, 1, 98, 132);
      attr_dev(circle, "cx", "11");
      attr_dev(circle, "cy", "11");
      attr_dev(circle, "r", "2");
      add_location(circle, file$22, 1, 132, 166);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, path2, anchor);
      insert_hydration_dev(target, circle, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(path1);
      if (detaching) detach_dev(path2);
      if (detaching) detach_dev(circle);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$26.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$25($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('PenTool', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<PenTool> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class PenTool extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$25, create_fragment$26, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PenTool",
      options,
      id: create_fragment$26.name
    });
  }
}
var PenTool$1 = PenTool;

/* ../../components/ui/src/icons/feather/Percent.svelte generated by Svelte v3.59.2 */
const file$21 = "../../components/ui/src/icons/feather/Percent.svelte";
function create_fragment$25(ctx) {
  let line;
  let circle0;
  let circle1;
  const block = {
    c: function create() {
      line = svg_element("line");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      circle0 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "19");
      attr_dev(line, "y1", "5");
      attr_dev(line, "x2", "5");
      attr_dev(line, "y2", "19");
      add_location(line, file$21, 1, 0, 34);
      attr_dev(circle0, "cx", "6.5");
      attr_dev(circle0, "cy", "6.5");
      attr_dev(circle0, "r", "2.5");
      add_location(circle0, file$21, 1, 43, 77);
      attr_dev(circle1, "cx", "17.5");
      attr_dev(circle1, "cy", "17.5");
      attr_dev(circle1, "r", "2.5");
      add_location(circle1, file$21, 1, 86, 120);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line, anchor);
      insert_hydration_dev(target, circle0, anchor);
      insert_hydration_dev(target, circle1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line);
      if (detaching) detach_dev(circle0);
      if (detaching) detach_dev(circle1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$25.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$24($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Percent', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Percent> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Percent extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$24, create_fragment$25, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Percent",
      options,
      id: create_fragment$25.name
    });
  }
}
var Percent$1 = Percent;

/* ../../components/ui/src/icons/feather/PhoneCall.svelte generated by Svelte v3.59.2 */
const file$20 = "../../components/ui/src/icons/feather/PhoneCall.svelte";
function create_fragment$24(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.98v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
      add_location(path, file$20, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$24.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$23($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('PhoneCall', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<PhoneCall> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class PhoneCall extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$23, create_fragment$24, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PhoneCall",
      options,
      id: create_fragment$24.name
    });
  }
}
var PhoneCall$1 = PhoneCall;

/* ../../components/ui/src/icons/feather/PhoneForwarded.svelte generated by Svelte v3.59.2 */
const file$1$ = "../../components/ui/src/icons/feather/PhoneForwarded.svelte";
function create_fragment$23(ctx) {
  let polyline;
  let line;
  let path;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      line = svg_element("line");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "19 1 23 5 19 9");
      add_location(polyline, file$1$, 1, 0, 34);
      attr_dev(line, "x1", "15");
      attr_dev(line, "y1", "5");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "5");
      add_location(line, file$1$, 1, 45, 79);
      attr_dev(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
      add_location(path, file$1$, 1, 88, 122);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, line, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(line);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$23.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$22($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('PhoneForwarded', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<PhoneForwarded> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class PhoneForwarded extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$22, create_fragment$23, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PhoneForwarded",
      options,
      id: create_fragment$23.name
    });
  }
}
var PhoneForwarded$1 = PhoneForwarded;

/* ../../components/ui/src/icons/feather/PhoneIncoming.svelte generated by Svelte v3.59.2 */
const file$1_ = "../../components/ui/src/icons/feather/PhoneIncoming.svelte";
function create_fragment$22(ctx) {
  let polyline;
  let line;
  let path;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      line = svg_element("line");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "16 2 16 8 22 8");
      add_location(polyline, file$1_, 1, 0, 34);
      attr_dev(line, "x1", "23");
      attr_dev(line, "y1", "1");
      attr_dev(line, "x2", "16");
      attr_dev(line, "y2", "8");
      add_location(line, file$1_, 1, 45, 79);
      attr_dev(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
      add_location(path, file$1_, 1, 88, 122);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, line, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(line);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$22.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$21($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('PhoneIncoming', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<PhoneIncoming> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class PhoneIncoming extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$21, create_fragment$22, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PhoneIncoming",
      options,
      id: create_fragment$22.name
    });
  }
}
var PhoneIncoming$1 = PhoneIncoming;

/* ../../components/ui/src/icons/feather/PhoneMissed.svelte generated by Svelte v3.59.2 */
const file$1Z = "../../components/ui/src/icons/feather/PhoneMissed.svelte";
function create_fragment$21(ctx) {
  let line0;
  let line1;
  let path;
  const block = {
    c: function create() {
      line0 = svg_element("line");
      line1 = svg_element("line");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "23");
      attr_dev(line0, "y1", "1");
      attr_dev(line0, "x2", "17");
      attr_dev(line0, "y2", "7");
      add_location(line0, file$1Z, 1, 0, 34);
      attr_dev(line1, "x1", "17");
      attr_dev(line1, "y1", "1");
      attr_dev(line1, "x2", "23");
      attr_dev(line1, "y2", "7");
      add_location(line1, file$1Z, 1, 43, 77);
      attr_dev(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
      add_location(path, file$1Z, 1, 86, 120);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$21.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$20($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('PhoneMissed', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<PhoneMissed> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class PhoneMissed extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$20, create_fragment$21, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PhoneMissed",
      options,
      id: create_fragment$21.name
    });
  }
}
var PhoneMissed$1 = PhoneMissed;

/* ../../components/ui/src/icons/feather/PhoneOff.svelte generated by Svelte v3.59.2 */
const file$1Y = "../../components/ui/src/icons/feather/PhoneOff.svelte";
function create_fragment$20(ctx) {
  let path;
  let line;
  const block = {
    c: function create() {
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91");
      add_location(path, file$1Y, 1, 0, 34);
      attr_dev(line, "x1", "23");
      attr_dev(line, "y1", "1");
      attr_dev(line, "x2", "1");
      attr_dev(line, "y2", "23");
      add_location(line, file$1Y, 1, 327, 361);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$20.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1$($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('PhoneOff', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<PhoneOff> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class PhoneOff extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1$, create_fragment$20, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PhoneOff",
      options,
      id: create_fragment$20.name
    });
  }
}
var PhoneOff$1 = PhoneOff;

/* ../../components/ui/src/icons/feather/PhoneOutgoing.svelte generated by Svelte v3.59.2 */
const file$1X = "../../components/ui/src/icons/feather/PhoneOutgoing.svelte";
function create_fragment$1$(ctx) {
  let polyline;
  let line;
  let path;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      line = svg_element("line");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "23 7 23 1 17 1");
      add_location(polyline, file$1X, 1, 0, 34);
      attr_dev(line, "x1", "16");
      attr_dev(line, "y1", "8");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "1");
      add_location(line, file$1X, 1, 45, 79);
      attr_dev(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
      add_location(path, file$1X, 1, 88, 122);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, line, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(line);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1$.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1_($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('PhoneOutgoing', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<PhoneOutgoing> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class PhoneOutgoing extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1_, create_fragment$1$, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PhoneOutgoing",
      options,
      id: create_fragment$1$.name
    });
  }
}
var PhoneOutgoing$1 = PhoneOutgoing;

/* ../../components/ui/src/icons/feather/Phone.svelte generated by Svelte v3.59.2 */
const file$1W = "../../components/ui/src/icons/feather/Phone.svelte";
function create_fragment$1_(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
      add_location(path, file$1W, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1_.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1Z($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Phone', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Phone> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Phone extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1Z, create_fragment$1_, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Phone",
      options,
      id: create_fragment$1_.name
    });
  }
}
var Phone$1 = Phone;

/* ../../components/ui/src/icons/feather/PieChart.svelte generated by Svelte v3.59.2 */
const file$1V = "../../components/ui/src/icons/feather/PieChart.svelte";
function create_fragment$1Z(ctx) {
  let path0;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M21.21 15.89A10 10 0 1 1 8 2.83");
      add_location(path0, file$1V, 1, 0, 34);
      attr_dev(path1, "d", "M22 12A10 10 0 0 0 12 2v10z");
      add_location(path1, file$1V, 1, 49, 83);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(path1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1Z.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1Y($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('PieChart', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<PieChart> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class PieChart extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1Y, create_fragment$1Z, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PieChart",
      options,
      id: create_fragment$1Z.name
    });
  }
}
var PieChart$1 = PieChart;

/* ../../components/ui/src/icons/feather/PlayCircle.svelte generated by Svelte v3.59.2 */
const file$1U = "../../components/ui/src/icons/feather/PlayCircle.svelte";
function create_fragment$1Y(ctx) {
  let circle;
  let polygon;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file$1U, 1, 0, 34);
      attr_dev(polygon, "points", "10 8 16 12 10 16 10 8");
      add_location(polygon, file$1U, 1, 40, 74);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, polygon, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(polygon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1Y.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1X($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('PlayCircle', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<PlayCircle> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class PlayCircle extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1X, create_fragment$1Y, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PlayCircle",
      options,
      id: create_fragment$1Y.name
    });
  }
}
var PlayCircle$1 = PlayCircle;

/* ../../components/ui/src/icons/feather/Play.svelte generated by Svelte v3.59.2 */
const file$1T = "../../components/ui/src/icons/feather/Play.svelte";
function create_fragment$1X(ctx) {
  let polygon;
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "5 3 19 12 5 21 5 3");
      add_location(polygon, file$1T, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polygon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1X.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1W($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Play', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Play> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Play extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1W, create_fragment$1X, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Play",
      options,
      id: create_fragment$1X.name
    });
  }
}
var Play$1 = Play;

/* ../../components/ui/src/icons/feather/PlusSquare.svelte generated by Svelte v3.59.2 */
const file$1S = "../../components/ui/src/icons/feather/PlusSquare.svelte";
function create_fragment$1W(ctx) {
  let rect;
  let line0;
  let line1;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "3");
      attr_dev(rect, "y", "3");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "18");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file$1S, 1, 0, 34);
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "8");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "16");
      add_location(line0, file$1S, 1, 62, 96);
      attr_dev(line1, "x1", "8");
      attr_dev(line1, "y1", "12");
      attr_dev(line1, "x2", "16");
      attr_dev(line1, "y2", "12");
      add_location(line1, file$1S, 1, 106, 140);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1W.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1V($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('PlusSquare', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<PlusSquare> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class PlusSquare extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1V, create_fragment$1W, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PlusSquare",
      options,
      id: create_fragment$1W.name
    });
  }
}
var PlusSquare$1 = PlusSquare;

/* ../../components/ui/src/icons/feather/Plus.svelte generated by Svelte v3.59.2 */
const file$1R = "../../components/ui/src/icons/feather/Plus.svelte";
function create_fragment$1V(ctx) {
  let line0;
  let line1;
  const block = {
    c: function create() {
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "5");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "19");
      add_location(line0, file$1R, 1, 0, 34);
      attr_dev(line1, "x1", "5");
      attr_dev(line1, "y1", "12");
      attr_dev(line1, "x2", "19");
      attr_dev(line1, "y2", "12");
      add_location(line1, file$1R, 1, 44, 78);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1V.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1U($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Plus', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Plus> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Plus extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1U, create_fragment$1V, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Plus",
      options,
      id: create_fragment$1V.name
    });
  }
}
var Plus$1 = Plus;

/* ../../components/ui/src/icons/feather/Pocket.svelte generated by Svelte v3.59.2 */
const file$1Q = "../../components/ui/src/icons/feather/Pocket.svelte";
function create_fragment$1U(ctx) {
  let path;
  let polyline;
  const block = {
    c: function create() {
      path = svg_element("path");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 3h16a2 2 0 0 1 2 2v6a10 10 0 0 1-10 10A10 10 0 0 1 2 11V5a2 2 0 0 1 2-2z");
      add_location(path, file$1Q, 1, 0, 34);
      attr_dev(polyline, "points", "8 10 12 14 16 10");
      add_location(polyline, file$1Q, 1, 93, 127);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, polyline, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1U.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1T($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Pocket', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Pocket> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Pocket extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1T, create_fragment$1U, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pocket",
      options,
      id: create_fragment$1U.name
    });
  }
}
var Pocket$1 = Pocket;

/* ../../components/ui/src/icons/feather/Power.svelte generated by Svelte v3.59.2 */
const file$1P = "../../components/ui/src/icons/feather/Power.svelte";
function create_fragment$1T(ctx) {
  let path;
  let line;
  const block = {
    c: function create() {
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M18.36 6.64a9 9 0 1 1-12.73 0");
      add_location(path, file$1P, 1, 0, 34);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "2");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "12");
      add_location(line, file$1P, 1, 47, 81);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1T.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1S($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Power', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Power> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Power extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1S, create_fragment$1T, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Power",
      options,
      id: create_fragment$1T.name
    });
  }
}
var Power$1 = Power;

/* ../../components/ui/src/icons/feather/Printer.svelte generated by Svelte v3.59.2 */
const file$1O = "../../components/ui/src/icons/feather/Printer.svelte";
function create_fragment$1S(ctx) {
  let polyline;
  let path;
  let rect;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      path = svg_element("path");
      rect = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "6 9 6 2 18 2 18 9");
      add_location(polyline, file$1O, 1, 0, 34);
      attr_dev(path, "d", "M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2");
      add_location(path, file$1O, 1, 48, 82);
      attr_dev(rect, "x", "6");
      attr_dev(rect, "y", "14");
      attr_dev(rect, "width", "12");
      attr_dev(rect, "height", "8");
      add_location(rect, file$1O, 1, 140, 174);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, rect, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(rect);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1S.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1R($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Printer', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Printer> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Printer extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1R, create_fragment$1S, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Printer",
      options,
      id: create_fragment$1S.name
    });
  }
}
var Printer$1 = Printer;

/* ../../components/ui/src/icons/feather/Radio.svelte generated by Svelte v3.59.2 */
const file$1N = "../../components/ui/src/icons/feather/Radio.svelte";
function create_fragment$1R(ctx) {
  let circle;
  let path;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "2");
      add_location(circle, file$1N, 1, 0, 34);
      attr_dev(path, "d", "M16.24 7.76a6 6 0 0 1 0 8.49m-8.48-.01a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0 14.14m-14.14 0a10 10 0 0 1 0-14.14");
      add_location(path, file$1N, 1, 39, 73);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1R.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1Q($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Radio', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Radio> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Radio extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1Q, create_fragment$1R, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Radio",
      options,
      id: create_fragment$1R.name
    });
  }
}
var Radio$1 = Radio;

/* ../../components/ui/src/icons/feather/RefreshCcw.svelte generated by Svelte v3.59.2 */
const file$1M = "../../components/ui/src/icons/feather/RefreshCcw.svelte";
function create_fragment$1Q(ctx) {
  let polyline0;
  let polyline1;
  let path;
  const block = {
    c: function create() {
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      polyline0 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline1).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "1 4 1 10 7 10");
      add_location(polyline0, file$1M, 1, 0, 34);
      attr_dev(polyline1, "points", "23 20 23 14 17 14");
      add_location(polyline1, file$1M, 1, 44, 78);
      attr_dev(path, "d", "M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15");
      add_location(path, file$1M, 1, 92, 126);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline0, anchor);
      insert_hydration_dev(target, polyline1, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline0);
      if (detaching) detach_dev(polyline1);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1Q.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1P($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('RefreshCcw', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<RefreshCcw> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class RefreshCcw extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1P, create_fragment$1Q, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RefreshCcw",
      options,
      id: create_fragment$1Q.name
    });
  }
}
var RefreshCcw$1 = RefreshCcw;

/* ../../components/ui/src/icons/feather/RefreshCw.svelte generated by Svelte v3.59.2 */
const file$1L = "../../components/ui/src/icons/feather/RefreshCw.svelte";
function create_fragment$1P(ctx) {
  let polyline0;
  let polyline1;
  let path;
  const block = {
    c: function create() {
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      polyline0 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline1).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "23 4 23 10 17 10");
      add_location(polyline0, file$1L, 1, 0, 34);
      attr_dev(polyline1, "points", "1 20 1 14 7 14");
      add_location(polyline1, file$1L, 1, 47, 81);
      attr_dev(path, "d", "M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15");
      add_location(path, file$1L, 1, 92, 126);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline0, anchor);
      insert_hydration_dev(target, polyline1, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline0);
      if (detaching) detach_dev(polyline1);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1P.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1O($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('RefreshCw', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<RefreshCw> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class RefreshCw extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1O, create_fragment$1P, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RefreshCw",
      options,
      id: create_fragment$1P.name
    });
  }
}
var RefreshCw$1 = RefreshCw;

/* ../../components/ui/src/icons/feather/Repeat.svelte generated by Svelte v3.59.2 */
const file$1K = "../../components/ui/src/icons/feather/Repeat.svelte";
function create_fragment$1O(ctx) {
  let polyline0;
  let path0;
  let polyline1;
  let path1;
  const block = {
    c: function create() {
      polyline0 = svg_element("polyline");
      path0 = svg_element("path");
      polyline1 = svg_element("polyline");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      polyline0 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline0).forEach(detach_dev);
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      polyline1 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline1).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "17 1 21 5 17 9");
      add_location(polyline0, file$1K, 1, 0, 34);
      attr_dev(path0, "d", "M3 11V9a4 4 0 0 1 4-4h14");
      add_location(path0, file$1K, 1, 45, 79);
      attr_dev(polyline1, "points", "7 23 3 19 7 15");
      add_location(polyline1, file$1K, 1, 87, 121);
      attr_dev(path1, "d", "M21 13v2a4 4 0 0 1-4 4H3");
      add_location(path1, file$1K, 1, 132, 166);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline0, anchor);
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, polyline1, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline0);
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(polyline1);
      if (detaching) detach_dev(path1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1O.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1N($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Repeat', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Repeat> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Repeat extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1N, create_fragment$1O, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Repeat",
      options,
      id: create_fragment$1O.name
    });
  }
}
var Repeat$1 = Repeat;

/* ../../components/ui/src/icons/feather/Rewind.svelte generated by Svelte v3.59.2 */
const file$1J = "../../components/ui/src/icons/feather/Rewind.svelte";
function create_fragment$1N(ctx) {
  let polygon0;
  let polygon1;
  const block = {
    c: function create() {
      polygon0 = svg_element("polygon");
      polygon1 = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      polygon0 = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon0).forEach(detach_dev);
      polygon1 = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon0, "points", "11 19 2 12 11 5 11 19");
      add_location(polygon0, file$1J, 1, 0, 34);
      attr_dev(polygon1, "points", "22 19 13 12 22 5 22 19");
      add_location(polygon1, file$1J, 1, 50, 84);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon0, anchor);
      insert_hydration_dev(target, polygon1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polygon0);
      if (detaching) detach_dev(polygon1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1N.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1M($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Rewind', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Rewind> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Rewind extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1M, create_fragment$1N, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Rewind",
      options,
      id: create_fragment$1N.name
    });
  }
}
var Rewind$1 = Rewind;

/* ../../components/ui/src/icons/feather/RotateCcw.svelte generated by Svelte v3.59.2 */
const file$1I = "../../components/ui/src/icons/feather/RotateCcw.svelte";
function create_fragment$1M(ctx) {
  let polyline;
  let path;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "1 4 1 10 7 10");
      add_location(polyline, file$1I, 1, 0, 34);
      attr_dev(path, "d", "M3.51 15a9 9 0 1 0 2.13-9.36L1 10");
      add_location(path, file$1I, 1, 44, 78);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1M.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1L($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('RotateCcw', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<RotateCcw> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class RotateCcw extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1L, create_fragment$1M, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RotateCcw",
      options,
      id: create_fragment$1M.name
    });
  }
}
var RotateCcw$1 = RotateCcw;

/* ../../components/ui/src/icons/feather/RotateCw.svelte generated by Svelte v3.59.2 */
const file$1H = "../../components/ui/src/icons/feather/RotateCw.svelte";
function create_fragment$1L(ctx) {
  let polyline;
  let path;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "23 4 23 10 17 10");
      add_location(polyline, file$1H, 1, 0, 34);
      attr_dev(path, "d", "M20.49 15a9 9 0 1 1-2.12-9.36L23 10");
      add_location(path, file$1H, 1, 47, 81);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1L.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1K($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('RotateCw', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<RotateCw> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class RotateCw extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1K, create_fragment$1L, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RotateCw",
      options,
      id: create_fragment$1L.name
    });
  }
}
var RotateCw$1 = RotateCw;

/* ../../components/ui/src/icons/feather/Rss.svelte generated by Svelte v3.59.2 */
const file$1G = "../../components/ui/src/icons/feather/Rss.svelte";
function create_fragment$1K(ctx) {
  let path0;
  let path1;
  let circle;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M4 11a9 9 0 0 1 9 9");
      add_location(path0, file$1G, 1, 0, 34);
      attr_dev(path1, "d", "M4 4a16 16 0 0 1 16 16");
      add_location(path1, file$1G, 1, 37, 71);
      attr_dev(circle, "cx", "5");
      attr_dev(circle, "cy", "19");
      attr_dev(circle, "r", "1");
      add_location(circle, file$1G, 1, 77, 111);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, circle, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(path1);
      if (detaching) detach_dev(circle);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1K.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1J($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Rss', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Rss> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Rss extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1J, create_fragment$1K, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Rss",
      options,
      id: create_fragment$1K.name
    });
  }
}
var Rss$1 = Rss;

/* ../../components/ui/src/icons/feather/Save.svelte generated by Svelte v3.59.2 */
const file$1F = "../../components/ui/src/icons/feather/Save.svelte";
function create_fragment$1J(ctx) {
  let path;
  let polyline0;
  let polyline1;
  const block = {
    c: function create() {
      path = svg_element("path");
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      polyline0 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z");
      add_location(path, file$1F, 1, 0, 34);
      attr_dev(polyline0, "points", "17 21 17 13 7 13 7 21");
      add_location(polyline0, file$1F, 1, 81, 115);
      attr_dev(polyline1, "points", "7 3 7 8 15 8");
      add_location(polyline1, file$1F, 1, 133, 167);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, polyline0, anchor);
      insert_hydration_dev(target, polyline1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(polyline0);
      if (detaching) detach_dev(polyline1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1J.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1I($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Save', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Save> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Save extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1I, create_fragment$1J, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Save",
      options,
      id: create_fragment$1J.name
    });
  }
}
var Save$1 = Save;

/* ../../components/ui/src/icons/feather/Scissors.svelte generated by Svelte v3.59.2 */
const file$1E = "../../components/ui/src/icons/feather/Scissors.svelte";
function create_fragment$1I(ctx) {
  let circle0;
  let circle1;
  let line0;
  let line1;
  let line2;
  const block = {
    c: function create() {
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      circle0 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle1).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "6");
      attr_dev(circle0, "cy", "6");
      attr_dev(circle0, "r", "3");
      add_location(circle0, file$1E, 1, 0, 34);
      attr_dev(circle1, "cx", "6");
      attr_dev(circle1, "cy", "18");
      attr_dev(circle1, "r", "3");
      add_location(circle1, file$1E, 1, 37, 71);
      attr_dev(line0, "x1", "20");
      attr_dev(line0, "y1", "4");
      attr_dev(line0, "x2", "8.12");
      attr_dev(line0, "y2", "15.88");
      add_location(line0, file$1E, 1, 75, 109);
      attr_dev(line1, "x1", "14.47");
      attr_dev(line1, "y1", "14.48");
      attr_dev(line1, "x2", "20");
      attr_dev(line1, "y2", "20");
      add_location(line1, file$1E, 1, 124, 158);
      attr_dev(line2, "x1", "8.12");
      attr_dev(line2, "y1", "8.12");
      attr_dev(line2, "x2", "12");
      attr_dev(line2, "y2", "12");
      add_location(line2, file$1E, 1, 175, 209);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle0, anchor);
      insert_hydration_dev(target, circle1, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle0);
      if (detaching) detach_dev(circle1);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1I.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1H($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Scissors', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Scissors> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Scissors extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1H, create_fragment$1I, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Scissors",
      options,
      id: create_fragment$1I.name
    });
  }
}
var Scissors$1 = Scissors;

/* ../../components/ui/src/icons/feather/Search.svelte generated by Svelte v3.59.2 */
const file$1D = "../../components/ui/src/icons/feather/Search.svelte";
function create_fragment$1H(ctx) {
  let circle;
  let line;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "11");
      attr_dev(circle, "cy", "11");
      attr_dev(circle, "r", "8");
      add_location(circle, file$1D, 1, 0, 34);
      attr_dev(line, "x1", "21");
      attr_dev(line, "y1", "21");
      attr_dev(line, "x2", "16.65");
      attr_dev(line, "y2", "16.65");
      add_location(line, file$1D, 1, 39, 73);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1H.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1G($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Search', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Search> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Search extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1G, create_fragment$1H, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Search",
      options,
      id: create_fragment$1H.name
    });
  }
}
var Search$1 = Search;

/* ../../components/ui/src/icons/feather/Send.svelte generated by Svelte v3.59.2 */
const file$1C = "../../components/ui/src/icons/feather/Send.svelte";
function create_fragment$1G(ctx) {
  let line;
  let polygon;
  const block = {
    c: function create() {
      line = svg_element("line");
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "x1", "22");
      attr_dev(line, "y1", "2");
      attr_dev(line, "x2", "11");
      attr_dev(line, "y2", "13");
      add_location(line, file$1C, 1, 0, 34);
      attr_dev(polygon, "points", "22 2 15 22 11 13 2 9 22 2");
      add_location(polygon, file$1C, 1, 44, 78);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line, anchor);
      insert_hydration_dev(target, polygon, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line);
      if (detaching) detach_dev(polygon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1G.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1F($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Send', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Send> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Send extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1F, create_fragment$1G, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Send",
      options,
      id: create_fragment$1G.name
    });
  }
}
var Send$1 = Send;

/* ../../components/ui/src/icons/feather/Server.svelte generated by Svelte v3.59.2 */
const file$1B = "../../components/ui/src/icons/feather/Server.svelte";
function create_fragment$1F(ctx) {
  let rect0;
  let rect1;
  let line0;
  let line1;
  const block = {
    c: function create() {
      rect0 = svg_element("rect");
      rect1 = svg_element("rect");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      rect0 = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect0).forEach(detach_dev);
      rect1 = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect1).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect0, "x", "2");
      attr_dev(rect0, "y", "2");
      attr_dev(rect0, "width", "20");
      attr_dev(rect0, "height", "8");
      attr_dev(rect0, "rx", "2");
      attr_dev(rect0, "ry", "2");
      add_location(rect0, file$1B, 1, 0, 34);
      attr_dev(rect1, "x", "2");
      attr_dev(rect1, "y", "14");
      attr_dev(rect1, "width", "20");
      attr_dev(rect1, "height", "8");
      attr_dev(rect1, "rx", "2");
      attr_dev(rect1, "ry", "2");
      add_location(rect1, file$1B, 1, 61, 95);
      attr_dev(line0, "x1", "6");
      attr_dev(line0, "y1", "6");
      attr_dev(line0, "x2", "6.01");
      attr_dev(line0, "y2", "6");
      add_location(line0, file$1B, 1, 123, 157);
      attr_dev(line1, "x1", "6");
      attr_dev(line1, "y1", "18");
      attr_dev(line1, "x2", "6.01");
      attr_dev(line1, "y2", "18");
      add_location(line1, file$1B, 1, 167, 201);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect0, anchor);
      insert_hydration_dev(target, rect1, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect0);
      if (detaching) detach_dev(rect1);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1F.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1E($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Server', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Server> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Server extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1E, create_fragment$1F, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Server",
      options,
      id: create_fragment$1F.name
    });
  }
}
var Server$1 = Server;

/* ../../components/ui/src/icons/feather/Share2.svelte generated by Svelte v3.59.2 */
const file$1A = "../../components/ui/src/icons/feather/Share2.svelte";
function create_fragment$1E(ctx) {
  let circle0;
  let circle1;
  let circle2;
  let line0;
  let line1;
  const block = {
    c: function create() {
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      circle2 = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      circle0 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle1).forEach(detach_dev);
      circle2 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle2).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "18");
      attr_dev(circle0, "cy", "5");
      attr_dev(circle0, "r", "3");
      add_location(circle0, file$1A, 1, 0, 34);
      attr_dev(circle1, "cx", "6");
      attr_dev(circle1, "cy", "12");
      attr_dev(circle1, "r", "3");
      add_location(circle1, file$1A, 1, 38, 72);
      attr_dev(circle2, "cx", "18");
      attr_dev(circle2, "cy", "19");
      attr_dev(circle2, "r", "3");
      add_location(circle2, file$1A, 1, 76, 110);
      attr_dev(line0, "x1", "8.59");
      attr_dev(line0, "y1", "13.51");
      attr_dev(line0, "x2", "15.42");
      attr_dev(line0, "y2", "17.49");
      add_location(line0, file$1A, 1, 115, 149);
      attr_dev(line1, "x1", "15.41");
      attr_dev(line1, "y1", "6.51");
      attr_dev(line1, "x2", "8.59");
      attr_dev(line1, "y2", "10.49");
      add_location(line1, file$1A, 1, 171, 205);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle0, anchor);
      insert_hydration_dev(target, circle1, anchor);
      insert_hydration_dev(target, circle2, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle0);
      if (detaching) detach_dev(circle1);
      if (detaching) detach_dev(circle2);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1E.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1D($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Share2', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Share2> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Share2 extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1D, create_fragment$1E, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Share2",
      options,
      id: create_fragment$1E.name
    });
  }
}
var Share2$1 = Share2;

/* ../../components/ui/src/icons/feather/Share.svelte generated by Svelte v3.59.2 */
const file$1z = "../../components/ui/src/icons/feather/Share.svelte";
function create_fragment$1D(ctx) {
  let path;
  let polyline;
  let line;
  const block = {
    c: function create() {
      path = svg_element("path");
      polyline = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8");
      add_location(path, file$1z, 1, 0, 34);
      attr_dev(polyline, "points", "16 6 12 2 8 6");
      add_location(polyline, file$1z, 1, 59, 93);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "2");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "15");
      add_location(line, file$1z, 1, 103, 137);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1D.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1C($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Share', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Share> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Share extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1C, create_fragment$1D, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Share",
      options,
      id: create_fragment$1D.name
    });
  }
}
var Share$1 = Share;

/* ../../components/ui/src/icons/feather/ShieldOff.svelte generated by Svelte v3.59.2 */
const file$1y = "../../components/ui/src/icons/feather/ShieldOff.svelte";
function create_fragment$1C(ctx) {
  let path0;
  let path1;
  let line;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M19.69 14a6.9 6.9 0 0 0 .31-2V5l-8-3-3.16 1.18");
      add_location(path0, file$1y, 1, 0, 34);
      attr_dev(path1, "d", "M4.73 4.73L4 5v7c0 6 8 10 8 10a20.29 20.29 0 0 0 5.62-4.38");
      add_location(path1, file$1y, 1, 64, 98);
      attr_dev(line, "x1", "1");
      attr_dev(line, "y1", "1");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "23");
      add_location(line, file$1y, 1, 140, 174);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(path1);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1C.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1B($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ShieldOff', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ShieldOff> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ShieldOff extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1B, create_fragment$1C, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ShieldOff",
      options,
      id: create_fragment$1C.name
    });
  }
}
var ShieldOff$1 = ShieldOff;

/* ../../components/ui/src/icons/feather/Shield.svelte generated by Svelte v3.59.2 */
const file$1x = "../../components/ui/src/icons/feather/Shield.svelte";
function create_fragment$1B(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z");
      add_location(path, file$1x, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1B.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1A($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Shield', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Shield> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Shield extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1A, create_fragment$1B, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Shield",
      options,
      id: create_fragment$1B.name
    });
  }
}
var Shield$1 = Shield;

/* ../../components/ui/src/icons/feather/ShoppingBag.svelte generated by Svelte v3.59.2 */
const file$1w = "../../components/ui/src/icons/feather/ShoppingBag.svelte";
function create_fragment$1A(ctx) {
  let path0;
  let line;
  let path1;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      line = svg_element("line");
      path1 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z");
      add_location(path0, file$1w, 1, 0, 34);
      attr_dev(line, "x1", "3");
      attr_dev(line, "y1", "6");
      attr_dev(line, "x2", "21");
      attr_dev(line, "y2", "6");
      add_location(line, file$1w, 1, 68, 102);
      attr_dev(path1, "d", "M16 10a4 4 0 0 1-8 0");
      add_location(path1, file$1w, 1, 110, 144);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, line, anchor);
      insert_hydration_dev(target, path1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(line);
      if (detaching) detach_dev(path1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1A.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1z($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ShoppingBag', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ShoppingBag> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ShoppingBag extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1z, create_fragment$1A, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ShoppingBag",
      options,
      id: create_fragment$1A.name
    });
  }
}
var ShoppingBag$1 = ShoppingBag;

/* ../../components/ui/src/icons/feather/ShoppingCart.svelte generated by Svelte v3.59.2 */
const file$1v = "../../components/ui/src/icons/feather/ShoppingCart.svelte";
function create_fragment$1z(ctx) {
  let circle0;
  let circle1;
  let path;
  const block = {
    c: function create() {
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      circle0 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle1).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "9");
      attr_dev(circle0, "cy", "21");
      attr_dev(circle0, "r", "1");
      add_location(circle0, file$1v, 1, 0, 34);
      attr_dev(circle1, "cx", "20");
      attr_dev(circle1, "cy", "21");
      attr_dev(circle1, "r", "1");
      add_location(circle1, file$1v, 1, 38, 72);
      attr_dev(path, "d", "M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6");
      add_location(path, file$1v, 1, 77, 111);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle0, anchor);
      insert_hydration_dev(target, circle1, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle0);
      if (detaching) detach_dev(circle1);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1z.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1y($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ShoppingCart', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ShoppingCart> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ShoppingCart extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1y, create_fragment$1z, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ShoppingCart",
      options,
      id: create_fragment$1z.name
    });
  }
}
var ShoppingCart$1 = ShoppingCart;

/* ../../components/ui/src/icons/feather/Shuffle.svelte generated by Svelte v3.59.2 */
const file$1u = "../../components/ui/src/icons/feather/Shuffle.svelte";
function create_fragment$1y(ctx) {
  let polyline0;
  let line0;
  let polyline1;
  let line1;
  let line2;
  const block = {
    c: function create() {
      polyline0 = svg_element("polyline");
      line0 = svg_element("line");
      polyline1 = svg_element("polyline");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      polyline0 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline0).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      polyline1 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline1).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "16 3 21 3 21 8");
      add_location(polyline0, file$1u, 1, 0, 34);
      attr_dev(line0, "x1", "4");
      attr_dev(line0, "y1", "20");
      attr_dev(line0, "x2", "21");
      attr_dev(line0, "y2", "3");
      add_location(line0, file$1u, 1, 45, 79);
      attr_dev(polyline1, "points", "21 16 21 21 16 21");
      add_location(polyline1, file$1u, 1, 88, 122);
      attr_dev(line1, "x1", "15");
      attr_dev(line1, "y1", "15");
      attr_dev(line1, "x2", "21");
      attr_dev(line1, "y2", "21");
      add_location(line1, file$1u, 1, 136, 170);
      attr_dev(line2, "x1", "4");
      attr_dev(line2, "y1", "4");
      attr_dev(line2, "x2", "9");
      attr_dev(line2, "y2", "9");
      add_location(line2, file$1u, 1, 181, 215);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline0, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, polyline1, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline0);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(polyline1);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1y.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1x($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Shuffle', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Shuffle> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Shuffle extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1x, create_fragment$1y, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Shuffle",
      options,
      id: create_fragment$1y.name
    });
  }
}
var Shuffle$1 = Shuffle;

/* ../../components/ui/src/icons/feather/Sidebar.svelte generated by Svelte v3.59.2 */
const file$1t = "../../components/ui/src/icons/feather/Sidebar.svelte";
function create_fragment$1x(ctx) {
  let rect;
  let line;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "3");
      attr_dev(rect, "y", "3");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "18");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file$1t, 1, 0, 34);
      attr_dev(line, "x1", "9");
      attr_dev(line, "y1", "3");
      attr_dev(line, "x2", "9");
      attr_dev(line, "y2", "21");
      add_location(line, file$1t, 1, 62, 96);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1x.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1w($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Sidebar', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Sidebar> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Sidebar extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1w, create_fragment$1x, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Sidebar",
      options,
      id: create_fragment$1x.name
    });
  }
}
var Sidebar$1 = Sidebar;

/* ../../components/ui/src/icons/feather/SkipBack.svelte generated by Svelte v3.59.2 */
const file$1s = "../../components/ui/src/icons/feather/SkipBack.svelte";
function create_fragment$1w(ctx) {
  let polygon;
  let line;
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "19 20 9 12 19 4 19 20");
      add_location(polygon, file$1s, 1, 0, 34);
      attr_dev(line, "x1", "5");
      attr_dev(line, "y1", "19");
      attr_dev(line, "x2", "5");
      attr_dev(line, "y2", "5");
      add_location(line, file$1s, 1, 50, 84);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polygon);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1w.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1v($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('SkipBack', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<SkipBack> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class SkipBack extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1v, create_fragment$1w, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SkipBack",
      options,
      id: create_fragment$1w.name
    });
  }
}
var SkipBack$1 = SkipBack;

/* ../../components/ui/src/icons/feather/SkipForward.svelte generated by Svelte v3.59.2 */
const file$1r = "../../components/ui/src/icons/feather/SkipForward.svelte";
function create_fragment$1v(ctx) {
  let polygon;
  let line;
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "5 4 15 12 5 20 5 4");
      add_location(polygon, file$1r, 1, 0, 34);
      attr_dev(line, "x1", "19");
      attr_dev(line, "y1", "5");
      attr_dev(line, "x2", "19");
      attr_dev(line, "y2", "19");
      add_location(line, file$1r, 1, 47, 81);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polygon);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1v.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1u($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('SkipForward', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<SkipForward> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class SkipForward extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1u, create_fragment$1v, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SkipForward",
      options,
      id: create_fragment$1v.name
    });
  }
}
var SkipForward$1 = SkipForward;

/* ../../components/ui/src/icons/feather/Slack.svelte generated by Svelte v3.59.2 */
const file$1q = "../../components/ui/src/icons/feather/Slack.svelte";
function create_fragment$1u(ctx) {
  let path0;
  let path1;
  let path2;
  let path3;
  let path4;
  let path5;
  let path6;
  let path7;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      path3 = svg_element("path");
      path4 = svg_element("path");
      path5 = svg_element("path");
      path6 = svg_element("path");
      path7 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      path2 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path2).forEach(detach_dev);
      path3 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path3).forEach(detach_dev);
      path4 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path4).forEach(detach_dev);
      path5 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path5).forEach(detach_dev);
      path6 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path6).forEach(detach_dev);
      path7 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path7).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M14.5 10c-.83 0-1.5-.67-1.5-1.5v-5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5z");
      add_location(path0, file$1q, 1, 0, 34);
      attr_dev(path1, "d", "M20.5 10H19V8.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z");
      add_location(path1, file$1q, 1, 113, 147);
      attr_dev(path2, "d", "M9.5 14c.83 0 1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5S8 21.33 8 20.5v-5c0-.83.67-1.5 1.5-1.5z");
      add_location(path2, file$1q, 1, 199, 233);
      attr_dev(path3, "d", "M3.5 14H5v1.5c0 .83-.67 1.5-1.5 1.5S2 16.33 2 15.5 2.67 14 3.5 14z");
      add_location(path3, file$1q, 1, 309, 343);
      attr_dev(path4, "d", "M14 14.5c0-.83.67-1.5 1.5-1.5h5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z");
      add_location(path4, file$1q, 1, 393, 427);
      attr_dev(path5, "d", "M15.5 19H14v1.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z");
      add_location(path5, file$1q, 1, 507, 541);
      attr_dev(path6, "d", "M10 9.5C10 8.67 9.33 8 8.5 8h-5C2.67 8 2 8.67 2 9.5S2.67 11 3.5 11h5c.83 0 1.5-.67 1.5-1.5z");
      add_location(path6, file$1q, 1, 594, 628);
      attr_dev(path7, "d", "M8.5 5H10V3.5C10 2.67 9.33 2 8.5 2S7 2.67 7 3.5 7.67 5 8.5 5z");
      add_location(path7, file$1q, 1, 703, 737);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, path2, anchor);
      insert_hydration_dev(target, path3, anchor);
      insert_hydration_dev(target, path4, anchor);
      insert_hydration_dev(target, path5, anchor);
      insert_hydration_dev(target, path6, anchor);
      insert_hydration_dev(target, path7, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(path1);
      if (detaching) detach_dev(path2);
      if (detaching) detach_dev(path3);
      if (detaching) detach_dev(path4);
      if (detaching) detach_dev(path5);
      if (detaching) detach_dev(path6);
      if (detaching) detach_dev(path7);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1u.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1t($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Slack', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Slack> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Slack extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1t, create_fragment$1u, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Slack",
      options,
      id: create_fragment$1u.name
    });
  }
}
var Slack$1 = Slack;

/* ../../components/ui/src/icons/feather/Slash.svelte generated by Svelte v3.59.2 */
const file$1p = "../../components/ui/src/icons/feather/Slash.svelte";
function create_fragment$1t(ctx) {
  let circle;
  let line;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file$1p, 1, 0, 34);
      attr_dev(line, "x1", "4.93");
      attr_dev(line, "y1", "4.93");
      attr_dev(line, "x2", "19.07");
      attr_dev(line, "y2", "19.07");
      add_location(line, file$1p, 1, 40, 74);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1t.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1s($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Slash', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Slash> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Slash extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1s, create_fragment$1t, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Slash",
      options,
      id: create_fragment$1t.name
    });
  }
}
var Slash$1 = Slash;

/* ../../components/ui/src/icons/feather/Sliders.svelte generated by Svelte v3.59.2 */
const file$1o = "../../components/ui/src/icons/feather/Sliders.svelte";
function create_fragment$1s(ctx) {
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let line5;
  let line6;
  let line7;
  let line8;
  const block = {
    c: function create() {
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      line5 = svg_element("line");
      line6 = svg_element("line");
      line7 = svg_element("line");
      line8 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line3).forEach(detach_dev);
      line4 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line4).forEach(detach_dev);
      line5 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line5).forEach(detach_dev);
      line6 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line6).forEach(detach_dev);
      line7 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line7).forEach(detach_dev);
      line8 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line8).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "4");
      attr_dev(line0, "y1", "21");
      attr_dev(line0, "x2", "4");
      attr_dev(line0, "y2", "14");
      add_location(line0, file$1o, 1, 0, 34);
      attr_dev(line1, "x1", "4");
      attr_dev(line1, "y1", "10");
      attr_dev(line1, "x2", "4");
      attr_dev(line1, "y2", "3");
      add_location(line1, file$1o, 1, 43, 77);
      attr_dev(line2, "x1", "12");
      attr_dev(line2, "y1", "21");
      attr_dev(line2, "x2", "12");
      attr_dev(line2, "y2", "12");
      add_location(line2, file$1o, 1, 85, 119);
      attr_dev(line3, "x1", "12");
      attr_dev(line3, "y1", "8");
      attr_dev(line3, "x2", "12");
      attr_dev(line3, "y2", "3");
      add_location(line3, file$1o, 1, 130, 164);
      attr_dev(line4, "x1", "20");
      attr_dev(line4, "y1", "21");
      attr_dev(line4, "x2", "20");
      attr_dev(line4, "y2", "16");
      add_location(line4, file$1o, 1, 173, 207);
      attr_dev(line5, "x1", "20");
      attr_dev(line5, "y1", "12");
      attr_dev(line5, "x2", "20");
      attr_dev(line5, "y2", "3");
      add_location(line5, file$1o, 1, 218, 252);
      attr_dev(line6, "x1", "1");
      attr_dev(line6, "y1", "14");
      attr_dev(line6, "x2", "7");
      attr_dev(line6, "y2", "14");
      add_location(line6, file$1o, 1, 262, 296);
      attr_dev(line7, "x1", "9");
      attr_dev(line7, "y1", "8");
      attr_dev(line7, "x2", "15");
      attr_dev(line7, "y2", "8");
      add_location(line7, file$1o, 1, 305, 339);
      attr_dev(line8, "x1", "17");
      attr_dev(line8, "y1", "16");
      attr_dev(line8, "x2", "23");
      attr_dev(line8, "y2", "16");
      add_location(line8, file$1o, 1, 347, 381);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
      insert_hydration_dev(target, line3, anchor);
      insert_hydration_dev(target, line4, anchor);
      insert_hydration_dev(target, line5, anchor);
      insert_hydration_dev(target, line6, anchor);
      insert_hydration_dev(target, line7, anchor);
      insert_hydration_dev(target, line8, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
      if (detaching) detach_dev(line3);
      if (detaching) detach_dev(line4);
      if (detaching) detach_dev(line5);
      if (detaching) detach_dev(line6);
      if (detaching) detach_dev(line7);
      if (detaching) detach_dev(line8);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1s.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1r($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Sliders', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Sliders> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Sliders extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1r, create_fragment$1s, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Sliders",
      options,
      id: create_fragment$1s.name
    });
  }
}
var Sliders$1 = Sliders;

/* ../../components/ui/src/icons/feather/Smartphone.svelte generated by Svelte v3.59.2 */
const file$1n = "../../components/ui/src/icons/feather/Smartphone.svelte";
function create_fragment$1r(ctx) {
  let rect;
  let line;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "5");
      attr_dev(rect, "y", "2");
      attr_dev(rect, "width", "14");
      attr_dev(rect, "height", "20");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file$1n, 1, 0, 34);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "18");
      attr_dev(line, "x2", "12.01");
      attr_dev(line, "y2", "18");
      add_location(line, file$1n, 1, 62, 96);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1r.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1q($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Smartphone', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Smartphone> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Smartphone extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1q, create_fragment$1r, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Smartphone",
      options,
      id: create_fragment$1r.name
    });
  }
}
var Smartphone$1 = Smartphone;

/* ../../components/ui/src/icons/feather/Smile.svelte generated by Svelte v3.59.2 */
const file$1m = "../../components/ui/src/icons/feather/Smile.svelte";
function create_fragment$1q(ctx) {
  let circle;
  let path;
  let line0;
  let line1;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      path = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file$1m, 1, 0, 34);
      attr_dev(path, "d", "M8 14s1.5 2 4 2 4-2 4-2");
      add_location(path, file$1m, 1, 40, 74);
      attr_dev(line0, "x1", "9");
      attr_dev(line0, "y1", "9");
      attr_dev(line0, "x2", "9.01");
      attr_dev(line0, "y2", "9");
      add_location(line0, file$1m, 1, 81, 115);
      attr_dev(line1, "x1", "15");
      attr_dev(line1, "y1", "9");
      attr_dev(line1, "x2", "15.01");
      attr_dev(line1, "y2", "9");
      add_location(line1, file$1m, 1, 125, 159);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1q.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1p($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Smile', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Smile> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Smile extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1p, create_fragment$1q, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Smile",
      options,
      id: create_fragment$1q.name
    });
  }
}
var Smile$1 = Smile;

/* ../../components/ui/src/icons/feather/Speaker.svelte generated by Svelte v3.59.2 */
const file$1l = "../../components/ui/src/icons/feather/Speaker.svelte";
function create_fragment$1p(ctx) {
  let rect;
  let circle;
  let line;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      circle = svg_element("circle");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "4");
      attr_dev(rect, "y", "2");
      attr_dev(rect, "width", "16");
      attr_dev(rect, "height", "20");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file$1l, 1, 0, 34);
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "14");
      attr_dev(circle, "r", "4");
      add_location(circle, file$1l, 1, 62, 96);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "6");
      attr_dev(line, "x2", "12.01");
      attr_dev(line, "y2", "6");
      add_location(line, file$1l, 1, 101, 135);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1p.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1o($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Speaker', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Speaker> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Speaker extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1o, create_fragment$1p, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Speaker",
      options,
      id: create_fragment$1p.name
    });
  }
}
var Speaker$1 = Speaker;

/* ../../components/ui/src/icons/feather/Star.svelte generated by Svelte v3.59.2 */
const file$1k = "../../components/ui/src/icons/feather/Star.svelte";
function create_fragment$1o(ctx) {
  let polygon;
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2");
      add_location(polygon, file$1k, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polygon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1o.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1n($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Star', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Star> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Star extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1n, create_fragment$1o, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Star",
      options,
      id: create_fragment$1o.name
    });
  }
}
var Star$1 = Star;

/* ../../components/ui/src/icons/feather/StopCircle.svelte generated by Svelte v3.59.2 */
const file$1j = "../../components/ui/src/icons/feather/StopCircle.svelte";
function create_fragment$1n(ctx) {
  let circle;
  let rect;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      rect = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file$1j, 1, 0, 34);
      attr_dev(rect, "x", "9");
      attr_dev(rect, "y", "9");
      attr_dev(rect, "width", "6");
      attr_dev(rect, "height", "6");
      add_location(rect, file$1j, 1, 40, 74);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, rect, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(rect);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1n.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1m($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('StopCircle', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<StopCircle> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class StopCircle extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1m, create_fragment$1n, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StopCircle",
      options,
      id: create_fragment$1n.name
    });
  }
}
var StopCircle$1 = StopCircle;

/* ../../components/ui/src/icons/feather/Sunrise.svelte generated by Svelte v3.59.2 */
const file$1i = "../../components/ui/src/icons/feather/Sunrise.svelte";
function create_fragment$1m(ctx) {
  let path;
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let line5;
  let polyline;
  const block = {
    c: function create() {
      path = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      line5 = svg_element("line");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line3).forEach(detach_dev);
      line4 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line4).forEach(detach_dev);
      line5 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line5).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 18a5 5 0 0 0-10 0");
      add_location(path, file$1i, 1, 0, 34);
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "2");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "9");
      add_location(line0, file$1i, 1, 39, 73);
      attr_dev(line1, "x1", "4.22");
      attr_dev(line1, "y1", "10.22");
      attr_dev(line1, "x2", "5.64");
      attr_dev(line1, "y2", "11.64");
      add_location(line1, file$1i, 1, 82, 116);
      attr_dev(line2, "x1", "1");
      attr_dev(line2, "y1", "18");
      attr_dev(line2, "x2", "3");
      attr_dev(line2, "y2", "18");
      add_location(line2, file$1i, 1, 137, 171);
      attr_dev(line3, "x1", "21");
      attr_dev(line3, "y1", "18");
      attr_dev(line3, "x2", "23");
      attr_dev(line3, "y2", "18");
      add_location(line3, file$1i, 1, 180, 214);
      attr_dev(line4, "x1", "18.36");
      attr_dev(line4, "y1", "11.64");
      attr_dev(line4, "x2", "19.78");
      attr_dev(line4, "y2", "10.22");
      add_location(line4, file$1i, 1, 225, 259);
      attr_dev(line5, "x1", "23");
      attr_dev(line5, "y1", "22");
      attr_dev(line5, "x2", "1");
      attr_dev(line5, "y2", "22");
      add_location(line5, file$1i, 1, 282, 316);
      attr_dev(polyline, "points", "8 6 12 2 16 6");
      add_location(polyline, file$1i, 1, 326, 360);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
      insert_hydration_dev(target, line3, anchor);
      insert_hydration_dev(target, line4, anchor);
      insert_hydration_dev(target, line5, anchor);
      insert_hydration_dev(target, polyline, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
      if (detaching) detach_dev(line3);
      if (detaching) detach_dev(line4);
      if (detaching) detach_dev(line5);
      if (detaching) detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1m.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1l($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Sunrise', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Sunrise> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Sunrise extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1l, create_fragment$1m, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Sunrise",
      options,
      id: create_fragment$1m.name
    });
  }
}
var Sunrise$1 = Sunrise;

/* ../../components/ui/src/icons/feather/Sunset.svelte generated by Svelte v3.59.2 */
const file$1h = "../../components/ui/src/icons/feather/Sunset.svelte";
function create_fragment$1l(ctx) {
  let path;
  let line0;
  let line1;
  let line2;
  let line3;
  let line4;
  let line5;
  let polyline;
  const block = {
    c: function create() {
      path = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      line3 = svg_element("line");
      line4 = svg_element("line");
      line5 = svg_element("line");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      line3 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line3).forEach(detach_dev);
      line4 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line4).forEach(detach_dev);
      line5 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line5).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M17 18a5 5 0 0 0-10 0");
      add_location(path, file$1h, 1, 0, 34);
      attr_dev(line0, "x1", "12");
      attr_dev(line0, "y1", "9");
      attr_dev(line0, "x2", "12");
      attr_dev(line0, "y2", "2");
      add_location(line0, file$1h, 1, 39, 73);
      attr_dev(line1, "x1", "4.22");
      attr_dev(line1, "y1", "10.22");
      attr_dev(line1, "x2", "5.64");
      attr_dev(line1, "y2", "11.64");
      add_location(line1, file$1h, 1, 82, 116);
      attr_dev(line2, "x1", "1");
      attr_dev(line2, "y1", "18");
      attr_dev(line2, "x2", "3");
      attr_dev(line2, "y2", "18");
      add_location(line2, file$1h, 1, 137, 171);
      attr_dev(line3, "x1", "21");
      attr_dev(line3, "y1", "18");
      attr_dev(line3, "x2", "23");
      attr_dev(line3, "y2", "18");
      add_location(line3, file$1h, 1, 180, 214);
      attr_dev(line4, "x1", "18.36");
      attr_dev(line4, "y1", "11.64");
      attr_dev(line4, "x2", "19.78");
      attr_dev(line4, "y2", "10.22");
      add_location(line4, file$1h, 1, 225, 259);
      attr_dev(line5, "x1", "23");
      attr_dev(line5, "y1", "22");
      attr_dev(line5, "x2", "1");
      attr_dev(line5, "y2", "22");
      add_location(line5, file$1h, 1, 282, 316);
      attr_dev(polyline, "points", "16 5 12 9 8 5");
      add_location(polyline, file$1h, 1, 326, 360);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
      insert_hydration_dev(target, line3, anchor);
      insert_hydration_dev(target, line4, anchor);
      insert_hydration_dev(target, line5, anchor);
      insert_hydration_dev(target, polyline, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
      if (detaching) detach_dev(line3);
      if (detaching) detach_dev(line4);
      if (detaching) detach_dev(line5);
      if (detaching) detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1l.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1k($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Sunset', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Sunset> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Sunset extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1k, create_fragment$1l, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Sunset",
      options,
      id: create_fragment$1l.name
    });
  }
}
var Sunset$1 = Sunset;

/* ../../components/ui/src/icons/feather/Table.svelte generated by Svelte v3.59.2 */
const file$1g = "../../components/ui/src/icons/feather/Table.svelte";
function create_fragment$1k(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18");
      add_location(path, file$1g, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1k.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1j($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Table', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Table> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Table extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1j, create_fragment$1k, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Table",
      options,
      id: create_fragment$1k.name
    });
  }
}
var Table$1 = Table;

/* ../../components/ui/src/icons/feather/Tablet.svelte generated by Svelte v3.59.2 */
const file$1f = "../../components/ui/src/icons/feather/Tablet.svelte";
function create_fragment$1j(ctx) {
  let rect;
  let line;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "4");
      attr_dev(rect, "y", "2");
      attr_dev(rect, "width", "16");
      attr_dev(rect, "height", "20");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file$1f, 1, 0, 34);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "18");
      attr_dev(line, "x2", "12.01");
      attr_dev(line, "y2", "18");
      add_location(line, file$1f, 1, 62, 96);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1j.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1i($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Tablet', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Tablet> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Tablet extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1i, create_fragment$1j, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tablet",
      options,
      id: create_fragment$1j.name
    });
  }
}
var Tablet$1 = Tablet;

/* ../../components/ui/src/icons/feather/Tag.svelte generated by Svelte v3.59.2 */
const file$1e = "../../components/ui/src/icons/feather/Tag.svelte";
function create_fragment$1i(ctx) {
  let path;
  let line;
  const block = {
    c: function create() {
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z");
      add_location(path, file$1e, 1, 0, 34);
      attr_dev(line, "x1", "7");
      attr_dev(line, "y1", "7");
      attr_dev(line, "x2", "7.01");
      attr_dev(line, "y2", "7");
      add_location(line, file$1e, 1, 96, 130);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1i.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1h($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Tag', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Tag> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Tag extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1h, create_fragment$1i, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tag",
      options,
      id: create_fragment$1i.name
    });
  }
}
var Tag$1 = Tag;

/* ../../components/ui/src/icons/feather/Target.svelte generated by Svelte v3.59.2 */
const file$1d = "../../components/ui/src/icons/feather/Target.svelte";
function create_fragment$1h(ctx) {
  let circle0;
  let circle1;
  let circle2;
  const block = {
    c: function create() {
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      circle2 = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      circle0 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle1).forEach(detach_dev);
      circle2 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "12");
      attr_dev(circle0, "cy", "12");
      attr_dev(circle0, "r", "10");
      add_location(circle0, file$1d, 1, 0, 34);
      attr_dev(circle1, "cx", "12");
      attr_dev(circle1, "cy", "12");
      attr_dev(circle1, "r", "6");
      add_location(circle1, file$1d, 1, 40, 74);
      attr_dev(circle2, "cx", "12");
      attr_dev(circle2, "cy", "12");
      attr_dev(circle2, "r", "2");
      add_location(circle2, file$1d, 1, 79, 113);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle0, anchor);
      insert_hydration_dev(target, circle1, anchor);
      insert_hydration_dev(target, circle2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle0);
      if (detaching) detach_dev(circle1);
      if (detaching) detach_dev(circle2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1h.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1g($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Target', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Target> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Target extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1g, create_fragment$1h, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Target",
      options,
      id: create_fragment$1h.name
    });
  }
}
var Target$1 = Target;

/* ../../components/ui/src/icons/feather/Terminal.svelte generated by Svelte v3.59.2 */
const file$1c = "../../components/ui/src/icons/feather/Terminal.svelte";
function create_fragment$1g(ctx) {
  let polyline;
  let line;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "4 17 10 11 4 5");
      add_location(polyline, file$1c, 1, 0, 34);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "19");
      attr_dev(line, "x2", "20");
      attr_dev(line, "y2", "19");
      add_location(line, file$1c, 1, 45, 79);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1g.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1f($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Terminal', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Terminal> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Terminal extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1f, create_fragment$1g, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Terminal",
      options,
      id: create_fragment$1g.name
    });
  }
}
var Terminal$1 = Terminal;

/* ../../components/ui/src/icons/feather/Thermometer.svelte generated by Svelte v3.59.2 */
const file$1b = "../../components/ui/src/icons/feather/Thermometer.svelte";
function create_fragment$1f(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z");
      add_location(path, file$1b, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1f.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1e($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Thermometer', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Thermometer> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Thermometer extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1e, create_fragment$1f, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Thermometer",
      options,
      id: create_fragment$1f.name
    });
  }
}
var Thermometer$1 = Thermometer;

/* ../../components/ui/src/icons/feather/ThumbsDown.svelte generated by Svelte v3.59.2 */
const file$1a = "../../components/ui/src/icons/feather/ThumbsDown.svelte";
function create_fragment$1e(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17");
      add_location(path, file$1a, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1e.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1d($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ThumbsDown', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ThumbsDown> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ThumbsDown extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1d, create_fragment$1e, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ThumbsDown",
      options,
      id: create_fragment$1e.name
    });
  }
}
var ThumbsDown$1 = ThumbsDown;

/* ../../components/ui/src/icons/feather/ThumbsUp.svelte generated by Svelte v3.59.2 */
const file$19 = "../../components/ui/src/icons/feather/ThumbsUp.svelte";
function create_fragment$1d(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3");
      add_location(path, file$19, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1d.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1c($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ThumbsUp', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ThumbsUp> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ThumbsUp extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1c, create_fragment$1d, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ThumbsUp",
      options,
      id: create_fragment$1d.name
    });
  }
}
var ThumbsUp$1 = ThumbsUp;

/* ../../components/ui/src/icons/feather/ToggleLeft.svelte generated by Svelte v3.59.2 */
const file$18 = "../../components/ui/src/icons/feather/ToggleLeft.svelte";
function create_fragment$1c(ctx) {
  let rect;
  let circle;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "1");
      attr_dev(rect, "y", "5");
      attr_dev(rect, "width", "22");
      attr_dev(rect, "height", "14");
      attr_dev(rect, "rx", "7");
      attr_dev(rect, "ry", "7");
      add_location(rect, file$18, 1, 0, 34);
      attr_dev(circle, "cx", "8");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "3");
      add_location(circle, file$18, 1, 62, 96);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, circle, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(circle);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1c.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1b($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ToggleLeft', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ToggleLeft> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ToggleLeft extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1b, create_fragment$1c, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToggleLeft",
      options,
      id: create_fragment$1c.name
    });
  }
}
var ToggleLeft$1 = ToggleLeft;

/* ../../components/ui/src/icons/feather/ToggleRight.svelte generated by Svelte v3.59.2 */
const file$17 = "../../components/ui/src/icons/feather/ToggleRight.svelte";
function create_fragment$1b(ctx) {
  let rect;
  let circle;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "1");
      attr_dev(rect, "y", "5");
      attr_dev(rect, "width", "22");
      attr_dev(rect, "height", "14");
      attr_dev(rect, "rx", "7");
      attr_dev(rect, "ry", "7");
      add_location(rect, file$17, 1, 0, 34);
      attr_dev(circle, "cx", "16");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "3");
      add_location(circle, file$17, 1, 62, 96);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, circle, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(circle);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1b.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1a($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ToggleRight', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ToggleRight> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ToggleRight extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1a, create_fragment$1b, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ToggleRight",
      options,
      id: create_fragment$1b.name
    });
  }
}
var ToggleRight$1 = ToggleRight;

/* ../../components/ui/src/icons/feather/Tool.svelte generated by Svelte v3.59.2 */
const file$16 = "../../components/ui/src/icons/feather/Tool.svelte";
function create_fragment$1a(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z");
      add_location(path, file$16, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1a.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$19($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Tool', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Tool> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Tool extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$19, create_fragment$1a, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tool",
      options,
      id: create_fragment$1a.name
    });
  }
}
var Tool$1 = Tool;

/* ../../components/ui/src/icons/feather/Trash2.svelte generated by Svelte v3.59.2 */
const file$15 = "../../components/ui/src/icons/feather/Trash2.svelte";
function create_fragment$19(ctx) {
  let polyline;
  let path;
  let line0;
  let line1;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      path = svg_element("path");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "3 6 5 6 21 6");
      add_location(polyline, file$15, 1, 0, 34);
      attr_dev(path, "d", "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2");
      add_location(path, file$15, 1, 43, 77);
      attr_dev(line0, "x1", "10");
      attr_dev(line0, "y1", "11");
      attr_dev(line0, "x2", "10");
      attr_dev(line0, "y2", "17");
      add_location(line0, file$15, 1, 139, 173);
      attr_dev(line1, "x1", "14");
      attr_dev(line1, "y1", "11");
      attr_dev(line1, "x2", "14");
      attr_dev(line1, "y2", "17");
      add_location(line1, file$15, 1, 184, 218);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$19.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$18($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Trash2', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Trash2> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Trash2 extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$18, create_fragment$19, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Trash2",
      options,
      id: create_fragment$19.name
    });
  }
}
var Trash2$1 = Trash2;

/* ../../components/ui/src/icons/feather/Trash.svelte generated by Svelte v3.59.2 */
const file$14 = "../../components/ui/src/icons/feather/Trash.svelte";
function create_fragment$18(ctx) {
  let polyline;
  let path;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "3 6 5 6 21 6");
      add_location(polyline, file$14, 1, 0, 34);
      attr_dev(path, "d", "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2");
      add_location(path, file$14, 1, 43, 77);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$18.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$17($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Trash', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Trash> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Trash extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$17, create_fragment$18, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Trash",
      options,
      id: create_fragment$18.name
    });
  }
}
var Trash$1 = Trash;

/* ../../components/ui/src/icons/feather/Trello.svelte generated by Svelte v3.59.2 */
const file$13 = "../../components/ui/src/icons/feather/Trello.svelte";
function create_fragment$17(ctx) {
  let rect0;
  let rect1;
  let rect2;
  const block = {
    c: function create() {
      rect0 = svg_element("rect");
      rect1 = svg_element("rect");
      rect2 = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      rect0 = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect0).forEach(detach_dev);
      rect1 = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect1).forEach(detach_dev);
      rect2 = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect0, "x", "3");
      attr_dev(rect0, "y", "3");
      attr_dev(rect0, "width", "18");
      attr_dev(rect0, "height", "18");
      attr_dev(rect0, "rx", "2");
      attr_dev(rect0, "ry", "2");
      add_location(rect0, file$13, 1, 0, 34);
      attr_dev(rect1, "x", "7");
      attr_dev(rect1, "y", "7");
      attr_dev(rect1, "width", "3");
      attr_dev(rect1, "height", "9");
      add_location(rect1, file$13, 1, 62, 96);
      attr_dev(rect2, "x", "14");
      attr_dev(rect2, "y", "7");
      attr_dev(rect2, "width", "3");
      attr_dev(rect2, "height", "5");
      add_location(rect2, file$13, 1, 108, 142);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect0, anchor);
      insert_hydration_dev(target, rect1, anchor);
      insert_hydration_dev(target, rect2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect0);
      if (detaching) detach_dev(rect1);
      if (detaching) detach_dev(rect2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$17.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$16($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Trello', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Trello> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Trello extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$16, create_fragment$17, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Trello",
      options,
      id: create_fragment$17.name
    });
  }
}
var Trello$1 = Trello;

/* ../../components/ui/src/icons/feather/TrendingDown.svelte generated by Svelte v3.59.2 */
const file$12 = "../../components/ui/src/icons/feather/TrendingDown.svelte";
function create_fragment$16(ctx) {
  let polyline0;
  let polyline1;
  const block = {
    c: function create() {
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      polyline0 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "23 18 13.5 8.5 8.5 13.5 1 6");
      add_location(polyline0, file$12, 1, 0, 34);
      attr_dev(polyline1, "points", "17 18 23 18 23 12");
      add_location(polyline1, file$12, 1, 58, 92);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline0, anchor);
      insert_hydration_dev(target, polyline1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline0);
      if (detaching) detach_dev(polyline1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$16.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$15($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('TrendingDown', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<TrendingDown> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class TrendingDown extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$15, create_fragment$16, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TrendingDown",
      options,
      id: create_fragment$16.name
    });
  }
}
var TrendingDown$1 = TrendingDown;

/* ../../components/ui/src/icons/feather/TrendingUp.svelte generated by Svelte v3.59.2 */
const file$11 = "../../components/ui/src/icons/feather/TrendingUp.svelte";
function create_fragment$15(ctx) {
  let polyline0;
  let polyline1;
  const block = {
    c: function create() {
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      polyline0 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "23 6 13.5 15.5 8.5 10.5 1 18");
      add_location(polyline0, file$11, 1, 0, 34);
      attr_dev(polyline1, "points", "17 6 23 6 23 12");
      add_location(polyline1, file$11, 1, 59, 93);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline0, anchor);
      insert_hydration_dev(target, polyline1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline0);
      if (detaching) detach_dev(polyline1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$15.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$14($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('TrendingUp', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<TrendingUp> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class TrendingUp extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$14, create_fragment$15, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TrendingUp",
      options,
      id: create_fragment$15.name
    });
  }
}
var TrendingUp$1 = TrendingUp;

/* ../../components/ui/src/icons/feather/Triangle.svelte generated by Svelte v3.59.2 */
const file$10 = "../../components/ui/src/icons/feather/Triangle.svelte";
function create_fragment$14(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z");
      add_location(path, file$10, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$14.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$13($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Triangle', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Triangle> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Triangle extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$13, create_fragment$14, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Triangle",
      options,
      id: create_fragment$14.name
    });
  }
}
var Triangle$1 = Triangle;

/* ../../components/ui/src/icons/feather/Truck.svelte generated by Svelte v3.59.2 */
const file$$ = "../../components/ui/src/icons/feather/Truck.svelte";
function create_fragment$13(ctx) {
  let rect;
  let polygon;
  let circle0;
  let circle1;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      polygon = svg_element("polygon");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true
      });
      children(rect).forEach(detach_dev);
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      circle0 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "1");
      attr_dev(rect, "y", "3");
      attr_dev(rect, "width", "15");
      attr_dev(rect, "height", "13");
      add_location(rect, file$$, 1, 0, 34);
      attr_dev(polygon, "points", "16 8 20 8 23 11 23 16 16 16 16 8");
      add_location(polygon, file$$, 1, 48, 82);
      attr_dev(circle0, "cx", "5.5");
      attr_dev(circle0, "cy", "18.5");
      attr_dev(circle0, "r", "2.5");
      add_location(circle0, file$$, 1, 109, 143);
      attr_dev(circle1, "cx", "18.5");
      attr_dev(circle1, "cy", "18.5");
      attr_dev(circle1, "r", "2.5");
      add_location(circle1, file$$, 1, 153, 187);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, polygon, anchor);
      insert_hydration_dev(target, circle0, anchor);
      insert_hydration_dev(target, circle1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(polygon);
      if (detaching) detach_dev(circle0);
      if (detaching) detach_dev(circle1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$13.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$12($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Truck', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Truck> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Truck extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$12, create_fragment$13, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Truck",
      options,
      id: create_fragment$13.name
    });
  }
}
var Truck$1 = Truck;

/* ../../components/ui/src/icons/feather/Tv.svelte generated by Svelte v3.59.2 */
const file$_ = "../../components/ui/src/icons/feather/Tv.svelte";
function create_fragment$12(ctx) {
  let rect;
  let polyline;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "2");
      attr_dev(rect, "y", "7");
      attr_dev(rect, "width", "20");
      attr_dev(rect, "height", "15");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file$_, 1, 0, 34);
      attr_dev(polyline, "points", "17 2 12 7 7 2");
      add_location(polyline, file$_, 1, 62, 96);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, polyline, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$12.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$11($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Tv', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Tv> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Tv extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$11, create_fragment$12, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tv",
      options,
      id: create_fragment$12.name
    });
  }
}
var Tv$1 = Tv;

/* ../../components/ui/src/icons/feather/Twitch.svelte generated by Svelte v3.59.2 */
const file$Z = "../../components/ui/src/icons/feather/Twitch.svelte";
function create_fragment$11(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 2H3v16h5v4l4-4h5l4-4V2zm-10 9V7m5 4V7");
      add_location(path, file$Z, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$11.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$10($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Twitch', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Twitch> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Twitch extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$10, create_fragment$11, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Twitch",
      options,
      id: create_fragment$11.name
    });
  }
}
var Twitch$1 = Twitch;

/* ../../components/ui/src/icons/feather/Twitter.svelte generated by Svelte v3.59.2 */
const file$Y = "../../components/ui/src/icons/feather/Twitter.svelte";
function create_fragment$10(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z");
      add_location(path, file$Y, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$10.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$$($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Twitter', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Twitter> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Twitter extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$$, create_fragment$10, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Twitter",
      options,
      id: create_fragment$10.name
    });
  }
}
var Twitter$1 = Twitter;

/* ../../components/ui/src/icons/feather/Type.svelte generated by Svelte v3.59.2 */
const file$X = "../../components/ui/src/icons/feather/Type.svelte";
function create_fragment$$(ctx) {
  let polyline;
  let line0;
  let line1;
  const block = {
    c: function create() {
      polyline = svg_element("polyline");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline, "points", "4 7 4 4 20 4 20 7");
      add_location(polyline, file$X, 1, 0, 34);
      attr_dev(line0, "x1", "9");
      attr_dev(line0, "y1", "20");
      attr_dev(line0, "x2", "15");
      attr_dev(line0, "y2", "20");
      add_location(line0, file$X, 1, 48, 82);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "4");
      attr_dev(line1, "x2", "12");
      attr_dev(line1, "y2", "20");
      add_location(line1, file$X, 1, 92, 126);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$$.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$_($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Type', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Type> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Type extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$_, create_fragment$$, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Type",
      options,
      id: create_fragment$$.name
    });
  }
}
var Type$1 = Type;

/* ../../components/ui/src/icons/feather/Umbrella.svelte generated by Svelte v3.59.2 */
const file$W = "../../components/ui/src/icons/feather/Umbrella.svelte";
function create_fragment$_(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M23 12a11.05 11.05 0 0 0-22 0zm-5 7a3 3 0 0 1-6 0v-7");
      add_location(path, file$W, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$_.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$Z($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Umbrella', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Umbrella> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Umbrella extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$Z, create_fragment$_, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Umbrella",
      options,
      id: create_fragment$_.name
    });
  }
}
var Umbrella$1 = Umbrella;

/* ../../components/ui/src/icons/feather/Underline.svelte generated by Svelte v3.59.2 */
const file$V = "../../components/ui/src/icons/feather/Underline.svelte";
function create_fragment$Z(ctx) {
  let path;
  let line;
  const block = {
    c: function create() {
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3");
      add_location(path, file$V, 1, 0, 34);
      attr_dev(line, "x1", "4");
      attr_dev(line, "y1", "21");
      attr_dev(line, "x2", "20");
      attr_dev(line, "y2", "21");
      add_location(line, file$V, 1, 54, 88);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$Z.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$Y($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Underline', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Underline> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Underline extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$Y, create_fragment$Z, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Underline",
      options,
      id: create_fragment$Z.name
    });
  }
}
var Underline$1 = Underline;

/* ../../components/ui/src/icons/feather/Unlock.svelte generated by Svelte v3.59.2 */
const file$U = "../../components/ui/src/icons/feather/Unlock.svelte";
function create_fragment$Y(ctx) {
  let rect;
  let path;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "3");
      attr_dev(rect, "y", "11");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "11");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file$U, 1, 0, 34);
      attr_dev(path, "d", "M7 11V7a5 5 0 0 1 9.9-1");
      add_location(path, file$U, 1, 63, 97);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$Y.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$X($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Unlock', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Unlock> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Unlock extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$X, create_fragment$Y, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Unlock",
      options,
      id: create_fragment$Y.name
    });
  }
}
var Unlock$1 = Unlock;

/* ../../components/ui/src/icons/feather/UploadCloud.svelte generated by Svelte v3.59.2 */
const file$T = "../../components/ui/src/icons/feather/UploadCloud.svelte";
function create_fragment$X(ctx) {
  let polyline0;
  let line;
  let path;
  let polyline1;
  const block = {
    c: function create() {
      polyline0 = svg_element("polyline");
      line = svg_element("line");
      path = svg_element("path");
      polyline1 = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      polyline0 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline0).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      polyline1 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "16 16 12 12 8 16");
      add_location(polyline0, file$T, 1, 0, 34);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "12");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "21");
      add_location(line, file$T, 1, 47, 81);
      attr_dev(path, "d", "M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3");
      add_location(path, file$T, 1, 92, 126);
      attr_dev(polyline1, "points", "16 16 12 12 8 16");
      add_location(polyline1, file$T, 1, 160, 194);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline0, anchor);
      insert_hydration_dev(target, line, anchor);
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, polyline1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline0);
      if (detaching) detach_dev(line);
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(polyline1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$X.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$W($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('UploadCloud', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<UploadCloud> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class UploadCloud extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$W, create_fragment$X, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UploadCloud",
      options,
      id: create_fragment$X.name
    });
  }
}
var UploadCloud$1 = UploadCloud;

/* ../../components/ui/src/icons/feather/Upload.svelte generated by Svelte v3.59.2 */
const file$S = "../../components/ui/src/icons/feather/Upload.svelte";
function create_fragment$W(ctx) {
  let path;
  let polyline;
  let line;
  const block = {
    c: function create() {
      path = svg_element("path");
      polyline = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4");
      add_location(path, file$S, 1, 0, 34);
      attr_dev(polyline, "points", "17 8 12 3 7 8");
      add_location(polyline, file$S, 1, 59, 93);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "3");
      attr_dev(line, "x2", "12");
      attr_dev(line, "y2", "15");
      add_location(line, file$S, 1, 103, 137);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$W.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$V($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Upload', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Upload> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Upload extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$V, create_fragment$W, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Upload",
      options,
      id: create_fragment$W.name
    });
  }
}
var Upload$1 = Upload;

/* ../../components/ui/src/icons/feather/UserCheck.svelte generated by Svelte v3.59.2 */
const file$R = "../../components/ui/src/icons/feather/UserCheck.svelte";
function create_fragment$V(ctx) {
  let path;
  let circle;
  let polyline;
  const block = {
    c: function create() {
      path = svg_element("path");
      circle = svg_element("circle");
      polyline = svg_element("polyline");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
      add_location(path, file$R, 1, 0, 34);
      attr_dev(circle, "cx", "8.5");
      attr_dev(circle, "cy", "7");
      attr_dev(circle, "r", "4");
      add_location(circle, file$R, 1, 59, 93);
      attr_dev(polyline, "points", "17 11 19 13 23 9");
      add_location(polyline, file$R, 1, 98, 132);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, polyline, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(polyline);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$V.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$U($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('UserCheck', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<UserCheck> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class UserCheck extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$U, create_fragment$V, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UserCheck",
      options,
      id: create_fragment$V.name
    });
  }
}
var UserCheck$1 = UserCheck;

/* ../../components/ui/src/icons/feather/UserMinus.svelte generated by Svelte v3.59.2 */
const file$Q = "../../components/ui/src/icons/feather/UserMinus.svelte";
function create_fragment$U(ctx) {
  let path;
  let circle;
  let line;
  const block = {
    c: function create() {
      path = svg_element("path");
      circle = svg_element("circle");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
      add_location(path, file$Q, 1, 0, 34);
      attr_dev(circle, "cx", "8.5");
      attr_dev(circle, "cy", "7");
      attr_dev(circle, "r", "4");
      add_location(circle, file$Q, 1, 59, 93);
      attr_dev(line, "x1", "23");
      attr_dev(line, "y1", "11");
      attr_dev(line, "x2", "17");
      attr_dev(line, "y2", "11");
      add_location(line, file$Q, 1, 98, 132);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$U.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$T($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('UserMinus', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<UserMinus> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class UserMinus extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$T, create_fragment$U, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UserMinus",
      options,
      id: create_fragment$U.name
    });
  }
}
var UserMinus$1 = UserMinus;

/* ../../components/ui/src/icons/feather/UserPlus.svelte generated by Svelte v3.59.2 */
const file$P = "../../components/ui/src/icons/feather/UserPlus.svelte";
function create_fragment$T(ctx) {
  let path;
  let circle;
  let line0;
  let line1;
  const block = {
    c: function create() {
      path = svg_element("path");
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
      add_location(path, file$P, 1, 0, 34);
      attr_dev(circle, "cx", "8.5");
      attr_dev(circle, "cy", "7");
      attr_dev(circle, "r", "4");
      add_location(circle, file$P, 1, 59, 93);
      attr_dev(line0, "x1", "20");
      attr_dev(line0, "y1", "8");
      attr_dev(line0, "x2", "20");
      attr_dev(line0, "y2", "14");
      add_location(line0, file$P, 1, 98, 132);
      attr_dev(line1, "x1", "23");
      attr_dev(line1, "y1", "11");
      attr_dev(line1, "x2", "17");
      attr_dev(line1, "y2", "11");
      add_location(line1, file$P, 1, 142, 176);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$T.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$S($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('UserPlus', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<UserPlus> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class UserPlus extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$S, create_fragment$T, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UserPlus",
      options,
      id: create_fragment$T.name
    });
  }
}
var UserPlus$1 = UserPlus;

/* ../../components/ui/src/icons/feather/UserX.svelte generated by Svelte v3.59.2 */
const file$O = "../../components/ui/src/icons/feather/UserX.svelte";
function create_fragment$S(ctx) {
  let path;
  let circle;
  let line0;
  let line1;
  const block = {
    c: function create() {
      path = svg_element("path");
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
      add_location(path, file$O, 1, 0, 34);
      attr_dev(circle, "cx", "8.5");
      attr_dev(circle, "cy", "7");
      attr_dev(circle, "r", "4");
      add_location(circle, file$O, 1, 59, 93);
      attr_dev(line0, "x1", "18");
      attr_dev(line0, "y1", "8");
      attr_dev(line0, "x2", "23");
      attr_dev(line0, "y2", "13");
      add_location(line0, file$O, 1, 98, 132);
      attr_dev(line1, "x1", "23");
      attr_dev(line1, "y1", "8");
      attr_dev(line1, "x2", "18");
      attr_dev(line1, "y2", "13");
      add_location(line1, file$O, 1, 142, 176);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$S.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$R($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('UserX', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<UserX> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class UserX extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$R, create_fragment$S, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "UserX",
      options,
      id: create_fragment$S.name
    });
  }
}
var UserX$1 = UserX;

/* ../../components/ui/src/icons/feather/User.svelte generated by Svelte v3.59.2 */
const file$N = "../../components/ui/src/icons/feather/User.svelte";
function create_fragment$R(ctx) {
  let path;
  let circle;
  const block = {
    c: function create() {
      path = svg_element("path");
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2");
      add_location(path, file$N, 1, 0, 34);
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "7");
      attr_dev(circle, "r", "4");
      add_location(circle, file$N, 1, 59, 93);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, circle, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(circle);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$R.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$Q($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('User', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<User> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class User extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$Q, create_fragment$R, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "User",
      options,
      id: create_fragment$R.name
    });
  }
}
var User$1 = User;

/* ../../components/ui/src/icons/feather/Users.svelte generated by Svelte v3.59.2 */
const file$M = "../../components/ui/src/icons/feather/Users.svelte";
function create_fragment$Q(ctx) {
  let path0;
  let circle;
  let path1;
  let path2;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      circle = svg_element("circle");
      path1 = svg_element("path");
      path2 = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      path2 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
      add_location(path0, file$M, 1, 0, 34);
      attr_dev(circle, "cx", "9");
      attr_dev(circle, "cy", "7");
      attr_dev(circle, "r", "4");
      add_location(circle, file$M, 1, 59, 93);
      attr_dev(path1, "d", "M23 21v-2a4 4 0 0 0-3-3.87");
      add_location(path1, file$M, 1, 96, 130);
      attr_dev(path2, "d", "M16 3.13a4 4 0 0 1 0 7.75");
      add_location(path2, file$M, 1, 140, 174);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, path2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(path1);
      if (detaching) detach_dev(path2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$Q.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$P($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Users', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Users> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Users extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$P, create_fragment$Q, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Users",
      options,
      id: create_fragment$Q.name
    });
  }
}
var Users$1 = Users;

/* ../../components/ui/src/icons/feather/VideoOff.svelte generated by Svelte v3.59.2 */
const file$L = "../../components/ui/src/icons/feather/VideoOff.svelte";
function create_fragment$P(ctx) {
  let path;
  let line;
  const block = {
    c: function create() {
      path = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10");
      add_location(path, file$L, 1, 0, 34);
      attr_dev(line, "x1", "1");
      attr_dev(line, "y1", "1");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "23");
      add_location(line, file$L, 1, 115, 149);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$P.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$O($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('VideoOff', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<VideoOff> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class VideoOff extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$O, create_fragment$P, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VideoOff",
      options,
      id: create_fragment$P.name
    });
  }
}
var VideoOff$1 = VideoOff;

/* ../../components/ui/src/icons/feather/Video.svelte generated by Svelte v3.59.2 */
const file$K = "../../components/ui/src/icons/feather/Video.svelte";
function create_fragment$O(ctx) {
  let polygon;
  let rect;
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      rect = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "23 7 16 12 23 17 23 7");
      add_location(polygon, file$K, 1, 0, 34);
      attr_dev(rect, "x", "1");
      attr_dev(rect, "y", "5");
      attr_dev(rect, "width", "15");
      attr_dev(rect, "height", "14");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file$K, 1, 50, 84);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon, anchor);
      insert_hydration_dev(target, rect, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polygon);
      if (detaching) detach_dev(rect);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$O.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$N($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Video', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Video> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Video extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$N, create_fragment$O, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Video",
      options,
      id: create_fragment$O.name
    });
  }
}
var Video$1 = Video;

/* ../../components/ui/src/icons/feather/Voicemail.svelte generated by Svelte v3.59.2 */
const file$J = "../../components/ui/src/icons/feather/Voicemail.svelte";
function create_fragment$N(ctx) {
  let circle0;
  let circle1;
  let line;
  const block = {
    c: function create() {
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      circle0 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle1).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "5.5");
      attr_dev(circle0, "cy", "11.5");
      attr_dev(circle0, "r", "4.5");
      add_location(circle0, file$J, 1, 0, 34);
      attr_dev(circle1, "cx", "18.5");
      attr_dev(circle1, "cy", "11.5");
      attr_dev(circle1, "r", "4.5");
      add_location(circle1, file$J, 1, 44, 78);
      attr_dev(line, "x1", "5.5");
      attr_dev(line, "y1", "16");
      attr_dev(line, "x2", "18.5");
      attr_dev(line, "y2", "16");
      add_location(line, file$J, 1, 89, 123);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle0, anchor);
      insert_hydration_dev(target, circle1, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle0);
      if (detaching) detach_dev(circle1);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$N.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$M($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Voicemail', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Voicemail> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Voicemail extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$M, create_fragment$N, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Voicemail",
      options,
      id: create_fragment$N.name
    });
  }
}
var Voicemail$1 = Voicemail;

/* ../../components/ui/src/icons/feather/Volume1.svelte generated by Svelte v3.59.2 */
const file$I = "../../components/ui/src/icons/feather/Volume1.svelte";
function create_fragment$M(ctx) {
  let polygon;
  let path;
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "11 5 6 9 2 9 2 15 6 15 11 19 11 5");
      add_location(polygon, file$I, 1, 0, 34);
      attr_dev(path, "d", "M15.54 8.46a5 5 0 0 1 0 7.07");
      add_location(path, file$I, 1, 62, 96);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polygon);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$M.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$L($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Volume1', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Volume1> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Volume1 extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$L, create_fragment$M, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Volume1",
      options,
      id: create_fragment$M.name
    });
  }
}
var Volume1$1 = Volume1;

/* ../../components/ui/src/icons/feather/Volume2.svelte generated by Svelte v3.59.2 */
const file$H = "../../components/ui/src/icons/feather/Volume2.svelte";
function create_fragment$L(ctx) {
  let polygon;
  let path;
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "11 5 6 9 2 9 2 15 6 15 11 19 11 5");
      add_location(polygon, file$H, 1, 0, 34);
      attr_dev(path, "d", "M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07");
      add_location(path, file$H, 1, 62, 96);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polygon);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$L.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$K($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Volume2', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Volume2> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Volume2 extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$K, create_fragment$L, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Volume2",
      options,
      id: create_fragment$L.name
    });
  }
}
var Volume2$1 = Volume2;

/* ../../components/ui/src/icons/feather/VolumeX.svelte generated by Svelte v3.59.2 */
const file$G = "../../components/ui/src/icons/feather/VolumeX.svelte";
function create_fragment$K(ctx) {
  let polygon;
  let line0;
  let line1;
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "11 5 6 9 2 9 2 15 6 15 11 19 11 5");
      add_location(polygon, file$G, 1, 0, 34);
      attr_dev(line0, "x1", "23");
      attr_dev(line0, "y1", "9");
      attr_dev(line0, "x2", "17");
      attr_dev(line0, "y2", "15");
      add_location(line0, file$G, 1, 62, 96);
      attr_dev(line1, "x1", "17");
      attr_dev(line1, "y1", "9");
      attr_dev(line1, "x2", "23");
      attr_dev(line1, "y2", "15");
      add_location(line1, file$G, 1, 106, 140);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polygon);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$K.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$J($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('VolumeX', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<VolumeX> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class VolumeX extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$J, create_fragment$K, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VolumeX",
      options,
      id: create_fragment$K.name
    });
  }
}
var VolumeX$1 = VolumeX;

/* ../../components/ui/src/icons/feather/Volume.svelte generated by Svelte v3.59.2 */
const file$F = "../../components/ui/src/icons/feather/Volume.svelte";
function create_fragment$J(ctx) {
  let polygon;
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "11 5 6 9 2 9 2 15 6 15 11 19 11 5");
      add_location(polygon, file$F, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polygon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$J.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$I($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Volume', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Volume> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Volume extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$I, create_fragment$J, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Volume",
      options,
      id: create_fragment$J.name
    });
  }
}
var Volume$1 = Volume;

/* ../../components/ui/src/icons/feather/Watch.svelte generated by Svelte v3.59.2 */
const file$E = "../../components/ui/src/icons/feather/Watch.svelte";
function create_fragment$I(ctx) {
  let circle;
  let polyline;
  let path;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      polyline = svg_element("polyline");
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      polyline = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline).forEach(detach_dev);
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "7");
      add_location(circle, file$E, 1, 0, 34);
      attr_dev(polyline, "points", "12 9 12 12 13.5 13.5");
      add_location(polyline, file$E, 1, 39, 73);
      attr_dev(path, "d", "M16.51 17.35l-.35 3.83a2 2 0 0 1-2 1.82H9.83a2 2 0 0 1-2-1.82l-.35-3.83m.01-10.7l.35-3.83A2 2 0 0 1 9.83 1h4.35a2 2 0 0 1 2 1.82l.35 3.83");
      add_location(path, file$E, 1, 90, 124);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, polyline, anchor);
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(polyline);
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$I.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$H($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Watch', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Watch> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Watch extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$H, create_fragment$I, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Watch",
      options,
      id: create_fragment$I.name
    });
  }
}
var Watch$1 = Watch;

/* ../../components/ui/src/icons/feather/WifiOff.svelte generated by Svelte v3.59.2 */
const file$D = "../../components/ui/src/icons/feather/WifiOff.svelte";
function create_fragment$H(ctx) {
  let line0;
  let path0;
  let path1;
  let path2;
  let path3;
  let path4;
  let line1;
  const block = {
    c: function create() {
      line0 = svg_element("line");
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      path3 = svg_element("path");
      path4 = svg_element("path");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      path2 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path2).forEach(detach_dev);
      path3 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path3).forEach(detach_dev);
      path4 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path4).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "1");
      attr_dev(line0, "y1", "1");
      attr_dev(line0, "x2", "23");
      attr_dev(line0, "y2", "23");
      add_location(line0, file$D, 1, 0, 34);
      attr_dev(path0, "d", "M16.72 11.06A10.94 10.94 0 0 1 19 12.55");
      add_location(path0, file$D, 1, 43, 77);
      attr_dev(path1, "d", "M5 12.55a10.94 10.94 0 0 1 5.17-2.39");
      add_location(path1, file$D, 1, 100, 134);
      attr_dev(path2, "d", "M10.71 5.05A16 16 0 0 1 22.58 9");
      add_location(path2, file$D, 1, 154, 188);
      attr_dev(path3, "d", "M1.42 9a15.91 15.91 0 0 1 4.7-2.88");
      add_location(path3, file$D, 1, 203, 237);
      attr_dev(path4, "d", "M8.53 16.11a6 6 0 0 1 6.95 0");
      add_location(path4, file$D, 1, 255, 289);
      attr_dev(line1, "x1", "12");
      attr_dev(line1, "y1", "20");
      attr_dev(line1, "x2", "12.01");
      attr_dev(line1, "y2", "20");
      add_location(line1, file$D, 1, 301, 335);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, path2, anchor);
      insert_hydration_dev(target, path3, anchor);
      insert_hydration_dev(target, path4, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(path1);
      if (detaching) detach_dev(path2);
      if (detaching) detach_dev(path3);
      if (detaching) detach_dev(path4);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$H.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$G($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('WifiOff', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<WifiOff> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class WifiOff extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$G, create_fragment$H, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "WifiOff",
      options,
      id: create_fragment$H.name
    });
  }
}
var WifiOff$1 = WifiOff;

/* ../../components/ui/src/icons/feather/Wifi.svelte generated by Svelte v3.59.2 */
const file$C = "../../components/ui/src/icons/feather/Wifi.svelte";
function create_fragment$G(ctx) {
  let path0;
  let path1;
  let path2;
  let line;
  const block = {
    c: function create() {
      path0 = svg_element("path");
      path1 = svg_element("path");
      path2 = svg_element("path");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      path0 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path0).forEach(detach_dev);
      path1 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path1).forEach(detach_dev);
      path2 = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path2).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path0, "d", "M5 12.55a11 11 0 0 1 14.08 0");
      add_location(path0, file$C, 1, 0, 34);
      attr_dev(path1, "d", "M1.42 9a16 16 0 0 1 21.16 0");
      add_location(path1, file$C, 1, 46, 80);
      attr_dev(path2, "d", "M8.53 16.11a6 6 0 0 1 6.95 0");
      add_location(path2, file$C, 1, 91, 125);
      attr_dev(line, "x1", "12");
      attr_dev(line, "y1", "20");
      attr_dev(line, "x2", "12.01");
      attr_dev(line, "y2", "20");
      add_location(line, file$C, 1, 137, 171);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path0, anchor);
      insert_hydration_dev(target, path1, anchor);
      insert_hydration_dev(target, path2, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path0);
      if (detaching) detach_dev(path1);
      if (detaching) detach_dev(path2);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$G.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$F($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Wifi', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Wifi> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Wifi extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$F, create_fragment$G, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Wifi",
      options,
      id: create_fragment$G.name
    });
  }
}
var Wifi$1 = Wifi;

/* ../../components/ui/src/icons/feather/Wind.svelte generated by Svelte v3.59.2 */
const file$B = "../../components/ui/src/icons/feather/Wind.svelte";
function create_fragment$F(ctx) {
  let path;
  const block = {
    c: function create() {
      path = svg_element("path");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2");
      add_location(path, file$B, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$F.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$E($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Wind', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Wind> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Wind extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$E, create_fragment$F, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Wind",
      options,
      id: create_fragment$F.name
    });
  }
}
var Wind$1 = Wind;

/* ../../components/ui/src/icons/feather/XCircle.svelte generated by Svelte v3.59.2 */
const file$A = "../../components/ui/src/icons/feather/XCircle.svelte";
function create_fragment$E(ctx) {
  let circle;
  let line0;
  let line1;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "12");
      attr_dev(circle, "cy", "12");
      attr_dev(circle, "r", "10");
      add_location(circle, file$A, 1, 0, 34);
      attr_dev(line0, "x1", "15");
      attr_dev(line0, "y1", "9");
      attr_dev(line0, "x2", "9");
      attr_dev(line0, "y2", "15");
      add_location(line0, file$A, 1, 40, 74);
      attr_dev(line1, "x1", "9");
      attr_dev(line1, "y1", "9");
      attr_dev(line1, "x2", "15");
      attr_dev(line1, "y2", "15");
      add_location(line1, file$A, 1, 83, 117);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$E.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$D($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('XCircle', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<XCircle> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class XCircle extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$D, create_fragment$E, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "XCircle",
      options,
      id: create_fragment$E.name
    });
  }
}
var XCircle$1 = XCircle;

/* ../../components/ui/src/icons/feather/XOctagon.svelte generated by Svelte v3.59.2 */
const file$z = "../../components/ui/src/icons/feather/XOctagon.svelte";
function create_fragment$D(ctx) {
  let polygon;
  let line0;
  let line1;
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2");
      add_location(polygon, file$z, 1, 0, 34);
      attr_dev(line0, "x1", "15");
      attr_dev(line0, "y1", "9");
      attr_dev(line0, "x2", "9");
      attr_dev(line0, "y2", "15");
      add_location(line0, file$z, 1, 99, 133);
      attr_dev(line1, "x1", "9");
      attr_dev(line1, "y1", "9");
      attr_dev(line1, "x2", "15");
      attr_dev(line1, "y2", "15");
      add_location(line1, file$z, 1, 142, 176);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polygon);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$D.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$C($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('XOctagon', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<XOctagon> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class XOctagon extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$C, create_fragment$D, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "XOctagon",
      options,
      id: create_fragment$D.name
    });
  }
}
var XOctagon$1 = XOctagon;

/* ../../components/ui/src/icons/feather/XSquare.svelte generated by Svelte v3.59.2 */
const file$y = "../../components/ui/src/icons/feather/XSquare.svelte";
function create_fragment$C(ctx) {
  let rect;
  let line0;
  let line1;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        x: true,
        y: true,
        width: true,
        height: true,
        rx: true,
        ry: true
      });
      children(rect).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "x", "3");
      attr_dev(rect, "y", "3");
      attr_dev(rect, "width", "18");
      attr_dev(rect, "height", "18");
      attr_dev(rect, "rx", "2");
      attr_dev(rect, "ry", "2");
      add_location(rect, file$y, 1, 0, 34);
      attr_dev(line0, "x1", "9");
      attr_dev(line0, "y1", "9");
      attr_dev(line0, "x2", "15");
      attr_dev(line0, "y2", "15");
      add_location(line0, file$y, 1, 62, 96);
      attr_dev(line1, "x1", "15");
      attr_dev(line1, "y1", "9");
      attr_dev(line1, "x2", "9");
      attr_dev(line1, "y2", "15");
      add_location(line1, file$y, 1, 105, 139);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$C.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$B($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('XSquare', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<XSquare> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class XSquare extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$B, create_fragment$C, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "XSquare",
      options,
      id: create_fragment$C.name
    });
  }
}
var XSquare$1 = XSquare;

/* ../../components/ui/src/icons/feather/X.svelte generated by Svelte v3.59.2 */
const file$x = "../../components/ui/src/icons/feather/X.svelte";
function create_fragment$B(ctx) {
  let line0;
  let line1;
  const block = {
    c: function create() {
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line0, "x1", "18");
      attr_dev(line0, "y1", "6");
      attr_dev(line0, "x2", "6");
      attr_dev(line0, "y2", "18");
      add_location(line0, file$x, 1, 0, 34);
      attr_dev(line1, "x1", "6");
      attr_dev(line1, "y1", "6");
      attr_dev(line1, "x2", "18");
      attr_dev(line1, "y2", "18");
      add_location(line1, file$x, 1, 43, 77);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$B.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$A($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('X', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<X> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class X extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$A, create_fragment$B, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "X",
      options,
      id: create_fragment$B.name
    });
  }
}
var X$1 = X;

/* ../../components/ui/src/icons/feather/Youtube.svelte generated by Svelte v3.59.2 */
const file$w = "../../components/ui/src/icons/feather/Youtube.svelte";
function create_fragment$A(ctx) {
  let path;
  let polygon;
  const block = {
    c: function create() {
      path = svg_element("path");
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      path = claim_svg_element(nodes, "path", {
        d: true
      });
      children(path).forEach(detach_dev);
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(path, "d", "M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z");
      add_location(path, file$w, 1, 0, 34);
      attr_dev(polygon, "points", "9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02");
      add_location(polygon, file$w, 1, 275, 309);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, path, anchor);
      insert_hydration_dev(target, polygon, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(path);
      if (detaching) detach_dev(polygon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$A.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$z($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Youtube', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Youtube> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Youtube extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$z, create_fragment$A, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Youtube",
      options,
      id: create_fragment$A.name
    });
  }
}
var Youtube$1 = Youtube;

/* ../../components/ui/src/icons/feather/ZapOff.svelte generated by Svelte v3.59.2 */
const file$v = "../../components/ui/src/icons/feather/ZapOff.svelte";
function create_fragment$z(ctx) {
  let polyline0;
  let polyline1;
  let polyline2;
  let line;
  const block = {
    c: function create() {
      polyline0 = svg_element("polyline");
      polyline1 = svg_element("polyline");
      polyline2 = svg_element("polyline");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      polyline0 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline0).forEach(detach_dev);
      polyline1 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline1).forEach(detach_dev);
      polyline2 = claim_svg_element(nodes, "polyline", {
        points: true
      });
      children(polyline2).forEach(detach_dev);
      line = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polyline0, "points", "12.41 6.75 13 2 10.57 4.92");
      add_location(polyline0, file$v, 1, 0, 34);
      attr_dev(polyline1, "points", "18.57 12.91 21 10 15.66 10");
      add_location(polyline1, file$v, 1, 57, 91);
      attr_dev(polyline2, "points", "8 8 3 14 12 14 11 22 16 16");
      add_location(polyline2, file$v, 1, 114, 148);
      attr_dev(line, "x1", "1");
      attr_dev(line, "y1", "1");
      attr_dev(line, "x2", "23");
      attr_dev(line, "y2", "23");
      add_location(line, file$v, 1, 171, 205);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polyline0, anchor);
      insert_hydration_dev(target, polyline1, anchor);
      insert_hydration_dev(target, polyline2, anchor);
      insert_hydration_dev(target, line, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polyline0);
      if (detaching) detach_dev(polyline1);
      if (detaching) detach_dev(polyline2);
      if (detaching) detach_dev(line);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$z.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$y($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ZapOff', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ZapOff> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ZapOff extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$y, create_fragment$z, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ZapOff",
      options,
      id: create_fragment$z.name
    });
  }
}
var ZapOff$1 = ZapOff;

/* ../../components/ui/src/icons/feather/Zap.svelte generated by Svelte v3.59.2 */
const file$u = "../../components/ui/src/icons/feather/Zap.svelte";
function create_fragment$y(ctx) {
  let polygon;
  const block = {
    c: function create() {
      polygon = svg_element("polygon");
      this.h();
    },
    l: function claim(nodes) {
      polygon = claim_svg_element(nodes, "polygon", {
        points: true
      });
      children(polygon).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(polygon, "points", "13 2 3 14 12 14 11 22 21 10 12 10 13 2");
      add_location(polygon, file$u, 1, 0, 34);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, polygon, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(polygon);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$y.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$x($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Zap', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Zap> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class Zap extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$x, create_fragment$y, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Zap",
      options,
      id: create_fragment$y.name
    });
  }
}
var Zap$1 = Zap;

/* ../../components/ui/src/icons/feather/ZoomIn.svelte generated by Svelte v3.59.2 */
const file$t = "../../components/ui/src/icons/feather/ZoomIn.svelte";
function create_fragment$x(ctx) {
  let circle;
  let line0;
  let line1;
  let line2;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      line2 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      line2 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line2).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "11");
      attr_dev(circle, "cy", "11");
      attr_dev(circle, "r", "8");
      add_location(circle, file$t, 1, 0, 34);
      attr_dev(line0, "x1", "21");
      attr_dev(line0, "y1", "21");
      attr_dev(line0, "x2", "16.65");
      attr_dev(line0, "y2", "16.65");
      add_location(line0, file$t, 1, 39, 73);
      attr_dev(line1, "x1", "11");
      attr_dev(line1, "y1", "8");
      attr_dev(line1, "x2", "11");
      attr_dev(line1, "y2", "14");
      add_location(line1, file$t, 1, 90, 124);
      attr_dev(line2, "x1", "8");
      attr_dev(line2, "y1", "11");
      attr_dev(line2, "x2", "14");
      attr_dev(line2, "y2", "11");
      add_location(line2, file$t, 1, 134, 168);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
      insert_hydration_dev(target, line2, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
      if (detaching) detach_dev(line2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$x.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$w($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ZoomIn', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ZoomIn> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ZoomIn extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$w, create_fragment$x, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ZoomIn",
      options,
      id: create_fragment$x.name
    });
  }
}
var ZoomIn$1 = ZoomIn;

/* ../../components/ui/src/icons/feather/ZoomOut.svelte generated by Svelte v3.59.2 */
const file$s = "../../components/ui/src/icons/feather/ZoomOut.svelte";
function create_fragment$w(ctx) {
  let circle;
  let line0;
  let line1;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      line0 = svg_element("line");
      line1 = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        cx: true,
        cy: true,
        r: true
      });
      children(circle).forEach(detach_dev);
      line0 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line0).forEach(detach_dev);
      line1 = claim_svg_element(nodes, "line", {
        x1: true,
        y1: true,
        x2: true,
        y2: true
      });
      children(line1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "cx", "11");
      attr_dev(circle, "cy", "11");
      attr_dev(circle, "r", "8");
      add_location(circle, file$s, 1, 0, 34);
      attr_dev(line0, "x1", "21");
      attr_dev(line0, "y1", "21");
      attr_dev(line0, "x2", "16.65");
      attr_dev(line0, "y2", "16.65");
      add_location(line0, file$s, 1, 39, 73);
      attr_dev(line1, "x1", "8");
      attr_dev(line1, "y1", "11");
      attr_dev(line1, "x2", "14");
      attr_dev(line1, "y2", "11");
      add_location(line1, file$s, 1, 90, 124);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
      insert_hydration_dev(target, line0, anchor);
      insert_hydration_dev(target, line1, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
      if (detaching) detach_dev(line0);
      if (detaching) detach_dev(line1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$w.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$v($$self, $$props) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ZoomOut', slots, []);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ZoomOut> was created with unknown prop '".concat(key, "'"));
  });
  return [];
}
class ZoomOut extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$v, create_fragment$w, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ZoomOut",
      options,
      id: create_fragment$w.name
    });
  }
}
var ZoomOut$1 = ZoomOut;

/* ../../components/ui/src/sensors/style/StyleSensor.svelte generated by Svelte v3.59.2 */
function create_fragment$v(ctx) {
  const block = {
    c: noop,
    l: noop,
    m: noop,
    p: noop,
    i: noop,
    o: noop,
    d: noop
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$v.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$u($$self, $$props, $$invalidate) {
  let hrefURL;
  let allStyleRules;
  let getStyleRulesObj;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('StyleSensor', slots, []);
  let {
    href
  } = $$props;
  let {
    selectorRegex
  } = $$props;
  let {
    styleRules
  } = $$props;
  $$self.$$.on_mount.push(function () {
    if (href === undefined && !('href' in $$props || $$self.$$.bound[$$self.$$.props['href']])) {
      console.warn("<StyleSensor> was created without expected prop 'href'");
    }
    if (selectorRegex === undefined && !('selectorRegex' in $$props || $$self.$$.bound[$$self.$$.props['selectorRegex']])) {
      console.warn("<StyleSensor> was created without expected prop 'selectorRegex'");
    }
    if (styleRules === undefined && !('styleRules' in $$props || $$self.$$.bound[$$self.$$.props['styleRules']])) {
      console.warn("<StyleSensor> was created without expected prop 'styleRules'");
    }
  });
  const writable_props = ['href', 'selectorRegex', 'styleRules'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<StyleSensor> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$$set = $$props => {
    if ('href' in $$props) $$invalidate(1, href = $$props.href);
    if ('selectorRegex' in $$props) $$invalidate(2, selectorRegex = $$props.selectorRegex);
    if ('styleRules' in $$props) $$invalidate(0, styleRules = $$props.styleRules);
  };
  $$self.$capture_state = () => ({
    isClientSide,
    getStylesheet,
    makeGetStyleRulesObj,
    getURL,
    href,
    selectorRegex,
    styleRules,
    allStyleRules,
    getStyleRulesObj,
    hrefURL
  });
  $$self.$inject_state = $$props => {
    if ('href' in $$props) $$invalidate(1, href = $$props.href);
    if ('selectorRegex' in $$props) $$invalidate(2, selectorRegex = $$props.selectorRegex);
    if ('styleRules' in $$props) $$invalidate(0, styleRules = $$props.styleRules);
    if ('allStyleRules' in $$props) $$invalidate(3, allStyleRules = $$props.allStyleRules);
    if ('getStyleRulesObj' in $$props) $$invalidate(4, getStyleRulesObj = $$props.getStyleRulesObj);
    if ('hrefURL' in $$props) $$invalidate(5, hrefURL = $$props.hrefURL);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*href*/2) {
      $$invalidate(5, hrefURL = isClientSide && href && getURL(href).toString());
    }
    if ($$self.$$.dirty & /*hrefURL*/32) {
      $$invalidate(3, allStyleRules = hrefURL ? [...getStylesheet(hrefURL).cssRules] : []); // convert collection to array
    }

    if ($$self.$$.dirty & /*selectorRegex*/4) {
      $$invalidate(4, getStyleRulesObj = makeGetStyleRulesObj(selectorRegex));
    }
    if ($$self.$$.dirty & /*getStyleRulesObj, allStyleRules*/24) {
      $$invalidate(0, styleRules = getStyleRulesObj(allStyleRules));
    }
  };
  return [styleRules, href, selectorRegex, allStyleRules, getStyleRulesObj, hrefURL];
}
class StyleSensor extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$u, create_fragment$v, safe_not_equal, {
      href: 1,
      selectorRegex: 2,
      styleRules: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "StyleSensor",
      options,
      id: create_fragment$v.name
    });
  }
  get href() {
    throw new Error("<StyleSensor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<StyleSensor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectorRegex() {
    throw new Error("<StyleSensor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectorRegex(value) {
    throw new Error("<StyleSensor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get styleRules() {
    throw new Error("<StyleSensor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set styleRules(value) {
    throw new Error("<StyleSensor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
var StyleSensor$1 = StyleSensor;

/* ../../components/ui/src/Banner.svelte generated by Svelte v3.59.2 */
const file$r = "../../components/ui/src/Banner.svelte";
function create_fragment$u(ctx) {
  let div1;
  let div0;
  let div1_class_value;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = /*#slots*/ctx[9].default;
  const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ctx[8], null);
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {
        style: true,
        "aria-label": true,
        class: true,
        role: true
      });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", {
        class: true,
        role: true
      });
      var div0_nodes = children(div0);
      if (default_slot) default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _ctx$;
      attr_dev(div0, "class", "inner svelte-9xlv57");
      attr_dev(div0, "role", "button");
      toggle_class(div0, "narrow", /*isNarrow*/ctx[2]);
      add_location(div0, file$r, 47, 1, 1159);
      attr_dev(div1, "style", /*style*/ctx[3]);
      attr_dev(div1, "aria-label", "Banner");
      attr_dev(div1, "class", div1_class_value = "Banner " + ( /*$_screen*/(_ctx$ = ctx[4]) === null || _ctx$ === void 0 ? void 0 : _ctx$.classes) + " svelte-9xlv57");
      attr_dev(div1, "role", "alert");
      toggle_class(div1, "backdrop", /*hasBackdrop*/ctx[1]);
      add_location(div1, file$r, 37, 0, 909);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      current = true;
      if (!mounted) {
        dispose = [listen_dev(window, "keydown", /*onKeyDown*/ctx[6], false, false, false, false), listen_dev(div0, "click", stop_propagation( /*click_handler*/ctx[10]), false, false, true, false), listen_dev(div0, "keydown", stop_propagation( /*keydown_handler*/ctx[11]), false, false, true, false), listen_dev(div1, "click", /*close*/ctx[5], false, false, false, false), listen_dev(div1, "keydown", /*onKeyDown*/ctx[6], false, false, false, false)];
        mounted = true;
      }
    },
    p: function update(ctx, _ref) {
      var _ctx$2;
      let [dirty] = _ref;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/256)) {
          update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ctx[8], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[8]) : get_slot_changes(default_slot_template, /*$$scope*/ctx[8], dirty, null), null);
        }
      }
      if (!current || dirty & /*isNarrow*/4) {
        toggle_class(div0, "narrow", /*isNarrow*/ctx[2]);
      }
      if (!current || dirty & /*style*/8) {
        attr_dev(div1, "style", /*style*/ctx[3]);
      }
      if (!current || dirty & /*$_screen*/16 && div1_class_value !== (div1_class_value = "Banner " + ( /*$_screen*/(_ctx$2 = ctx[4]) === null || _ctx$2 === void 0 ? void 0 : _ctx$2.classes) + " svelte-9xlv57")) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (!current || dirty & /*$_screen, hasBackdrop*/18) {
        toggle_class(div1, "backdrop", /*hasBackdrop*/ctx[1]);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(div1);
      if (default_slot) default_slot.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$u.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$t($$self, $$props, $$invalidate) {
  let style;
  let $_screen,
    $$unsubscribe__screen = noop,
    $$subscribe__screen = () => ($$unsubscribe__screen(), $$unsubscribe__screen = subscribe(_screen, $$value => $$invalidate(4, $_screen = $$value)), _screen);
  $$self.$$.on_destroy.push(() => $$unsubscribe__screen());
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Banner', slots, ['default']);
  const defaultTheme = {
    border: 'thin solid rgb(70, 70, 70)',
    borderRadius: '1rem',
    colorBackdropSensor: 'rgba(0, 0, 0, 0.25)',
    colorBackground: 'white',
    colorBoxShadow: 'lightgrey',
    colorText: 'black',
    padding: '0.5rem',
    shadowGeometry: '2px 8px 9px -4px',
    zIndex: 2000
  };
  let {
    _screen
  } = $$props;
  validate_store(_screen, '_screen');
  $$subscribe__screen();
  let {
    hasBackdrop = true
  } = $$props;
  let {
    isNarrow = true
  } = $$props;
  let {
    theme
  } = $$props;
  const dispatch = createEventDispatcher();
  const close = () => dispatch('close');
  const onKeyDown = event => {
    if (event.key === 'Escape') {
      event.preventDefault();
      close();
    }
  };
  $$self.$$.on_mount.push(function () {
    if (_screen === undefined && !('_screen' in $$props || $$self.$$.bound[$$self.$$.props['_screen']])) {
      console.warn("<Banner> was created without expected prop '_screen'");
    }
    if (theme === undefined && !('theme' in $$props || $$self.$$.bound[$$self.$$.props['theme']])) {
      console.warn("<Banner> was created without expected prop 'theme'");
    }
  });
  const writable_props = ['_screen', 'hasBackdrop', 'isNarrow', 'theme'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Banner> was created with unknown prop '".concat(key, "'"));
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = $$props => {
    if ('_screen' in $$props) $$subscribe__screen($$invalidate(0, _screen = $$props._screen));
    if ('hasBackdrop' in $$props) $$invalidate(1, hasBackdrop = $$props.hasBackdrop);
    if ('isNarrow' in $$props) $$invalidate(2, isNarrow = $$props.isNarrow);
    if ('theme' in $$props) $$invalidate(7, theme = $$props.theme);
    if ('$$scope' in $$props) $$invalidate(8, $$scope = $$props.$$scope);
  };
  $$self.$capture_state = () => ({
    makeStyleVars,
    createEventDispatcher,
    defaultTheme,
    _screen,
    hasBackdrop,
    isNarrow,
    theme,
    dispatch,
    close,
    onKeyDown,
    style,
    $_screen
  });
  $$self.$inject_state = $$props => {
    if ('_screen' in $$props) $$subscribe__screen($$invalidate(0, _screen = $$props._screen));
    if ('hasBackdrop' in $$props) $$invalidate(1, hasBackdrop = $$props.hasBackdrop);
    if ('isNarrow' in $$props) $$invalidate(2, isNarrow = $$props.isNarrow);
    if ('theme' in $$props) $$invalidate(7, theme = $$props.theme);
    if ('style' in $$props) $$invalidate(3, style = $$props.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*theme*/128) {
      $$invalidate(7, theme = theme ? {
        ...defaultTheme,
        ...theme
      } : defaultTheme);
    }
    if ($$self.$$.dirty & /*theme*/128) {
      $$invalidate(3, style = makeStyleVars(theme));
    }
  };
  return [_screen, hasBackdrop, isNarrow, style, $_screen, close, onKeyDown, theme, $$scope, slots, click_handler, keydown_handler];
}
class Banner extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$t, create_fragment$u, safe_not_equal, {
      _screen: 0,
      hasBackdrop: 1,
      isNarrow: 2,
      theme: 7
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Banner",
      options,
      id: create_fragment$u.name
    });
  }
  get _screen() {
    throw new Error("<Banner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set _screen(value) {
    throw new Error("<Banner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hasBackdrop() {
    throw new Error("<Banner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hasBackdrop(value) {
    throw new Error("<Banner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isNarrow() {
    throw new Error("<Banner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isNarrow(value) {
    throw new Error("<Banner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<Banner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<Banner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
var Banner$1 = Banner;

/* ../../components/ui/src/HighlightedText.svelte generated by Svelte v3.59.2 */
const file$q = "../../components/ui/src/HighlightedText.svelte";
function get_each_context$6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i][0];
  child_ctx[10] = list[i][1];
  child_ctx[12] = i;
  return child_ctx;
}

// (53:44) {#if styled}
function create_if_block$g(ctx) {
  let span;
  let t_value = /*styled*/ctx[10] + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        style: true,
        id: true,
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "style", /*style*/ctx[0]);
      attr_dev(span, "id", "highlighted-" + /*i*/ctx[12]);
      attr_dev(span, "class", "highlighted svelte-9csl53");
      add_location(span, file$q, 52, 56, 1301);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*parts*/2 && t_value !== (t_value = /*styled*/ctx[10] + "")) set_data_dev(t, t_value);
      if (dirty & /*style*/1) {
        attr_dev(span, "style", /*style*/ctx[0]);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$g.name,
    type: "if",
    source: "(53:44) {#if styled}",
    ctx
  });
  return block;
}

// (53:0) {#each parts as [normal, styled], i}
function create_each_block$6(ctx) {
  let t_value = /*normal*/ctx[9] + "";
  let t;
  let if_block_anchor;
  let if_block = /*styled*/ctx[10] && create_if_block$g(ctx);
  const block = {
    c: function create() {
      t = text(t_value);
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*parts*/2 && t_value !== (t_value = /*normal*/ctx[9] + "")) set_data_dev(t, t_value);
      if ( /*styled*/ctx[10]) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block$g(ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(t);
      if (if_block) if_block.d(detaching);
      if (detaching) detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block$6.name,
    type: "each",
    source: "(53:0) {#each parts as [normal, styled], i}",
    ctx
  });
  return block;
}
function create_fragment$t(ctx) {
  let each_1_anchor;
  let each_value = /*parts*/ctx[1];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx, _ref) {
      let [dirty] = _ref;
      if (dirty & /*style, parts*/3) {
        each_value = /*parts*/ctx[1];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$6(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$6(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching) detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$t.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
const defaultString = '';
function instance$s($$self, $$props, $$invalidate) {
  let parts;
  let style;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('HighlightedText', slots, []);
  const defaultTheme = {
    colorHighlightedBackground: 'yellow',
    colorHighlightedText: 'black'
  };
  let {
    regex
  } = $$props;
  let {
    shouldScroll = false
  } = $$props;
  let {
    string = defaultString
  } = $$props;
  let {
    theme
  } = $$props;
  const splitText = (text, regExp) => {
    let pairs = [[text, '']];
    if (regExp && isRegexpNotEmpty(regExp)) {
      const remains = text.split(regExp);
      if (remains.length > 1) {
        var _text$match;
        const matches = (_text$match = text.match(regExp)) === null || _text$match === void 0 ? void 0 : _text$match.concat('');
        pairs = zip(remains, matches);
      }
    }
    return pairs;
  };
  const scrollIntoView = async () => {
    await tick();
    const targetElement = document.getElementById('highlighted-0');
    if (targetElement) {
      if (targetElement.scrollIntoViewIfNeeded) {
        targetElement.scrollIntoViewIfNeeded(); // Chrome/Safari/Edge
      } else {
        targetElement.scrollIntoView(); // FF
      }
    }
  };

  $$self.$$.on_mount.push(function () {
    if (regex === undefined && !('regex' in $$props || $$self.$$.bound[$$self.$$.props['regex']])) {
      console.warn("<HighlightedText> was created without expected prop 'regex'");
    }
    if (theme === undefined && !('theme' in $$props || $$self.$$.bound[$$self.$$.props['theme']])) {
      console.warn("<HighlightedText> was created without expected prop 'theme'");
    }
  });
  const writable_props = ['regex', 'shouldScroll', 'string', 'theme'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<HighlightedText> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$$set = $$props => {
    if ('regex' in $$props) $$invalidate(4, regex = $$props.regex);
    if ('shouldScroll' in $$props) $$invalidate(5, shouldScroll = $$props.shouldScroll);
    if ('string' in $$props) $$invalidate(2, string = $$props.string);
    if ('theme' in $$props) $$invalidate(3, theme = $$props.theme);
  };
  $$self.$capture_state = () => ({
    makeStyleVars,
    isRegexpNotEmpty,
    _,
    tick,
    defaultString,
    defaultTheme,
    regex,
    shouldScroll,
    string,
    theme,
    splitText,
    scrollIntoView,
    style,
    parts
  });
  $$self.$inject_state = $$props => {
    if ('regex' in $$props) $$invalidate(4, regex = $$props.regex);
    if ('shouldScroll' in $$props) $$invalidate(5, shouldScroll = $$props.shouldScroll);
    if ('string' in $$props) $$invalidate(2, string = $$props.string);
    if ('theme' in $$props) $$invalidate(3, theme = $$props.theme);
    if ('style' in $$props) $$invalidate(0, style = $$props.style);
    if ('parts' in $$props) $$invalidate(1, parts = $$props.parts);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*string*/4) {
      $$invalidate(2, string = string || defaultString);
    }
    if ($$self.$$.dirty & /*string, regex*/20) {
      $$invalidate(1, parts = splitText(string, regex));
    }
    if ($$self.$$.dirty & /*theme*/8) {
      $$invalidate(3, theme = {
        ...defaultTheme,
        ...theme
      });
    }
    if ($$self.$$.dirty & /*theme*/8) {
      $$invalidate(0, style = makeStyleVars(theme));
    }
    if ($$self.$$.dirty & /*string, regex, shouldScroll*/52) {
      string && regex && shouldScroll && scrollIntoView();
    }
  };
  return [style, parts, string, theme, regex, shouldScroll];
}
class HighlightedText extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$s, create_fragment$t, safe_not_equal, {
      regex: 4,
      shouldScroll: 5,
      string: 2,
      theme: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HighlightedText",
      options,
      id: create_fragment$t.name
    });
  }
  get regex() {
    throw new Error("<HighlightedText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set regex(value) {
    throw new Error("<HighlightedText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shouldScroll() {
    throw new Error("<HighlightedText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shouldScroll(value) {
    throw new Error("<HighlightedText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get string() {
    throw new Error("<HighlightedText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set string(value) {
    throw new Error("<HighlightedText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<HighlightedText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<HighlightedText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
var HighlightedText$1 = HighlightedText;

/* ../../components/ui/src/LayoutHMF.svelte generated by Svelte v3.59.2 */
const file$p = "../../components/ui/src/LayoutHMF.svelte";
const get_footer_slot_changes = dirty => ({});
const get_footer_slot_context = ctx => ({});
const get_main_slot_changes = dirty => ({});
const get_main_slot_context = ctx => ({});
const get_header_slot_changes = dirty => ({});
const get_header_slot_context = ctx => ({});
function create_fragment$s(ctx) {
  let div;
  let header;
  let t0;
  let main;
  let t1;
  let footer;
  let current;
  const header_slot_template = /*#slots*/ctx[3].header;
  const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ctx[2], get_header_slot_context);
  const main_slot_template = /*#slots*/ctx[3].main;
  const main_slot = create_slot(main_slot_template, ctx, /*$$scope*/ctx[2], get_main_slot_context);
  const footer_slot_template = /*#slots*/ctx[3].footer;
  const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ctx[2], get_footer_slot_context);
  const block = {
    c: function create() {
      div = element("div");
      header = element("header");
      if (header_slot) header_slot.c();
      t0 = space();
      main = element("main");
      if (main_slot) main_slot.c();
      t1 = space();
      footer = element("footer");
      if (footer_slot) footer_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        style: true
      });
      var div_nodes = children(div);
      header = claim_element(div_nodes, "HEADER", {
        class: true
      });
      var header_nodes = children(header);
      if (header_slot) header_slot.l(header_nodes);
      header_nodes.forEach(detach_dev);
      t0 = claim_space(div_nodes);
      main = claim_element(div_nodes, "MAIN", {
        class: true
      });
      var main_nodes = children(main);
      if (main_slot) main_slot.l(main_nodes);
      main_nodes.forEach(detach_dev);
      t1 = claim_space(div_nodes);
      footer = claim_element(div_nodes, "FOOTER", {
        class: true
      });
      var footer_nodes = children(footer);
      if (footer_slot) footer_slot.l(footer_nodes);
      footer_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(header, "class", "svelte-1al1j4k");
      add_location(header, file$p, 6, 1, 160);
      attr_dev(main, "class", "svelte-1al1j4k");
      add_location(main, file$p, 9, 1, 206);
      attr_dev(footer, "class", "svelte-1al1j4k");
      add_location(footer, file$p, 12, 1, 246);
      attr_dev(div, "class", "LayoutHMF svelte-1al1j4k");
      attr_dev(div, "style", /*style*/ctx[0]);
      add_location(div, file$p, 5, 0, 127);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, header);
      if (header_slot) {
        header_slot.m(header, null);
      }
      append_hydration_dev(div, t0);
      append_hydration_dev(div, main);
      if (main_slot) {
        main_slot.m(main, null);
      }
      append_hydration_dev(div, t1);
      append_hydration_dev(div, footer);
      if (footer_slot) {
        footer_slot.m(footer, null);
      }
      current = true;
    },
    p: function update(ctx, _ref) {
      let [dirty] = _ref;
      if (header_slot) {
        if (header_slot.p && (!current || dirty & /*$$scope*/4)) {
          update_slot_base(header_slot, header_slot_template, ctx, /*$$scope*/ctx[2], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[2]) : get_slot_changes(header_slot_template, /*$$scope*/ctx[2], dirty, get_header_slot_changes), get_header_slot_context);
        }
      }
      if (main_slot) {
        if (main_slot.p && (!current || dirty & /*$$scope*/4)) {
          update_slot_base(main_slot, main_slot_template, ctx, /*$$scope*/ctx[2], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[2]) : get_slot_changes(main_slot_template, /*$$scope*/ctx[2], dirty, get_main_slot_changes), get_main_slot_context);
        }
      }
      if (footer_slot) {
        if (footer_slot.p && (!current || dirty & /*$$scope*/4)) {
          update_slot_base(footer_slot, footer_slot_template, ctx, /*$$scope*/ctx[2], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[2]) : get_slot_changes(footer_slot_template, /*$$scope*/ctx[2], dirty, get_footer_slot_changes), get_footer_slot_context);
        }
      }
      if (!current || dirty & /*style*/1) {
        attr_dev(div, "style", /*style*/ctx[0]);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(header_slot, local);
      transition_in(main_slot, local);
      transition_in(footer_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(header_slot, local);
      transition_out(main_slot, local);
      transition_out(footer_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(div);
      if (header_slot) header_slot.d(detaching);
      if (main_slot) main_slot.d(detaching);
      if (footer_slot) footer_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$s.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$r($$self, $$props, $$invalidate) {
  let headerPaddingTop;
  let style;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('LayoutHMF', slots, ['header', 'main', 'footer']);
  const $$slots = compute_slots(slots);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<LayoutHMF> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$$set = $$props => {
    if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
  };
  $$self.$capture_state = () => ({
    headerPaddingTop,
    style
  });
  $$self.$inject_state = $$props => {
    if ('headerPaddingTop' in $$props) $$invalidate(1, headerPaddingTop = $$props.headerPaddingTop);
    if ('style' in $$props) $$invalidate(0, style = $$props.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*headerPaddingTop*/2) {
      $$invalidate(0, style = "--headerPaddingTop: ".concat(headerPaddingTop, ";"));
    }
  };
  $$invalidate(1, headerPaddingTop = $$slots.header ? '1em' : 0);
  return [style, headerPaddingTop, $$scope, slots];
}
class LayoutHMF extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$r, create_fragment$s, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LayoutHMF",
      options,
      id: create_fragment$s.name
    });
  }
}
var LayoutHMF$1 = LayoutHMF;

/* ../../components/ui/src/MultiBanner.svelte generated by Svelte v3.59.2 */
const file$o = "../../components/ui/src/MultiBanner.svelte";

// (35:0) {#if isActive}
function create_if_block$f(ctx) {
  let banner;
  let current;
  banner = new Banner$1({
    props: {
      _screen: /*_screen*/ctx[1],
      theme: /*theme*/ctx[3],
      $$slots: {
        default: [create_default_slot$3]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  banner.$on("close", /*next*/ctx[6]);
  const block = {
    c: function create() {
      create_component(banner.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(banner.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(banner, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const banner_changes = {};
      if (dirty & /*_screen*/2) banner_changes._screen = /*_screen*/ctx[1];
      if (dirty & /*theme*/8) banner_changes.theme = /*theme*/ctx[3];
      if (dirty & /*$$scope, footerText, components, currentIndex*/277) {
        banner_changes.$$scope = {
          dirty,
          ctx
        };
      }
      banner.$set(banner_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(banner.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(banner.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(banner, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$f.name,
    type: "if",
    source: "(35:0) {#if isActive}",
    ctx
  });
  return block;
}

// (43:4) <Scroller>
function create_default_slot_1$2(ctx) {
  var _ctx$;
  let switch_instance;
  let switch_instance_anchor;
  let current;
  var switch_value = /*components*/(_ctx$ = ctx[2]) === null || _ctx$ === void 0 ? void 0 : _ctx$[/*currentIndex*/ctx[4]];
  function switch_props(ctx) {
    return {
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props());
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      var _ctx$2;
      if (dirty & /*components, currentIndex*/20 && switch_value !== (switch_value = /*components*/(_ctx$2 = ctx[2]) === null || _ctx$2 === void 0 ? void 0 : _ctx$2[/*currentIndex*/ctx[4]])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(switch_instance_anchor);
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$2.name,
    type: "slot",
    source: "(43:4) <Scroller>",
    ctx
  });
  return block;
}

// (42:3) 
function create_main_slot(ctx) {
  let div;
  let scroller;
  let current;
  scroller = new Scroller({
    props: {
      $$slots: {
        default: [create_default_slot_1$2]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      create_component(scroller.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        slot: true,
        class: true
      });
      var div_nodes = children(div);
      claim_component(scroller.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "slot", "main");
      attr_dev(div, "class", "svelte-16lglc9");
      add_location(div, file$o, 41, 3, 808);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(scroller, div, null);
      current = true;
    },
    p: function update(ctx, dirty) {
      const scroller_changes = {};
      if (dirty & /*$$scope, components, currentIndex*/276) {
        scroller_changes.$$scope = {
          dirty,
          ctx
        };
      }
      scroller.$set(scroller_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(scroller.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(scroller.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(div);
      destroy_component(scroller);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_main_slot.name,
    type: "slot",
    source: "(42:3) ",
    ctx
  });
  return block;
}

// (47:3) 
function create_footer_slot(ctx) {
  let p;
  let t;
  const block = {
    c: function create() {
      p = element("p");
      t = text( /*footerText*/ctx[0]);
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {
        slot: true
      });
      var p_nodes = children(p);
      t = claim_text(p_nodes, /*footerText*/ctx[0]);
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(p, "slot", "footer");
      add_location(p, file$o, 46, 3, 930);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*footerText*/1) set_data_dev(t, /*footerText*/ctx[0]);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(p);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_footer_slot.name,
    type: "slot",
    source: "(47:3) ",
    ctx
  });
  return block;
}

// (36:1) <Banner   {_screen}   {theme}   on:close={next}  >
function create_default_slot$3(ctx) {
  let layouthmf;
  let current;
  layouthmf = new LayoutHMF$1({
    props: {
      $$slots: {
        footer: [create_footer_slot],
        main: [create_main_slot]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(layouthmf.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(layouthmf.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(layouthmf, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const layouthmf_changes = {};
      if (dirty & /*$$scope, footerText, components, currentIndex*/277) {
        layouthmf_changes.$$scope = {
          dirty,
          ctx
        };
      }
      layouthmf.$set(layouthmf_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(layouthmf.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(layouthmf.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(layouthmf, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$3.name,
    type: "slot",
    source: "(36:1) <Banner   {_screen}   {theme}   on:close={next}  >",
    ctx
  });
  return block;
}
function create_fragment$r(ctx) {
  let if_block_anchor;
  let current;
  let if_block = /*isActive*/ctx[5] && create_if_block$f(ctx);
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx, _ref) {
      let [dirty] = _ref;
      if ( /*isActive*/ctx[5]) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*isActive*/32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$f(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block) if_block.d(detaching);
      if (detaching) detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$r.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
const defaultFooterText = 'Click on background to dismiss';
function instance$q($$self, $$props, $$invalidate) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('MultiBanner', slots, []);
  let {
    _screen
  } = $$props;
  let {
    components
  } = $$props;
  let {
    footerText = defaultFooterText
  } = $$props;
  let {
    theme
  } = $$props;
  let currentIndex = 0;
  let isActive = false;
  function init() {
    $$invalidate(4, currentIndex = 0);
    $$invalidate(5, isActive = true);
  }
  function next() {
    $$invalidate(4, currentIndex++, currentIndex);
    if (currentIndex >= components.length) {
      $$invalidate(5, isActive = false);
    }
  }
  $$self.$$.on_mount.push(function () {
    if (_screen === undefined && !('_screen' in $$props || $$self.$$.bound[$$self.$$.props['_screen']])) {
      console.warn("<MultiBanner> was created without expected prop '_screen'");
    }
    if (components === undefined && !('components' in $$props || $$self.$$.bound[$$self.$$.props['components']])) {
      console.warn("<MultiBanner> was created without expected prop 'components'");
    }
    if (theme === undefined && !('theme' in $$props || $$self.$$.bound[$$self.$$.props['theme']])) {
      console.warn("<MultiBanner> was created without expected prop 'theme'");
    }
  });
  const writable_props = ['_screen', 'components', 'footerText', 'theme'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<MultiBanner> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$$set = $$props => {
    if ('_screen' in $$props) $$invalidate(1, _screen = $$props._screen);
    if ('components' in $$props) $$invalidate(2, components = $$props.components);
    if ('footerText' in $$props) $$invalidate(0, footerText = $$props.footerText);
    if ('theme' in $$props) $$invalidate(3, theme = $$props.theme);
  };
  $$self.$capture_state = () => ({
    Banner: Banner$1,
    LayoutHMF: LayoutHMF$1,
    Scroller,
    defaultFooterText,
    _screen,
    components,
    footerText,
    theme,
    currentIndex,
    isActive,
    init,
    next
  });
  $$self.$inject_state = $$props => {
    if ('_screen' in $$props) $$invalidate(1, _screen = $$props._screen);
    if ('components' in $$props) $$invalidate(2, components = $$props.components);
    if ('footerText' in $$props) $$invalidate(0, footerText = $$props.footerText);
    if ('theme' in $$props) $$invalidate(3, theme = $$props.theme);
    if ('currentIndex' in $$props) $$invalidate(4, currentIndex = $$props.currentIndex);
    if ('isActive' in $$props) $$invalidate(5, isActive = $$props.isActive);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*footerText*/1) {
      $$invalidate(0, footerText = footerText || defaultFooterText);
    }
    if ($$self.$$.dirty & /*components*/4) {
      var _components;
      ((_components = components) === null || _components === void 0 ? void 0 : _components.length) > 0 && init();
    }
    if ($$self.$$.dirty & /*components*/4) {
      var _components2;
      if (!components || ((_components2 = components) === null || _components2 === void 0 ? void 0 : _components2.length) === 0) {
        $$invalidate(5, isActive = false);
      }
    }
  };
  return [footerText, _screen, components, theme, currentIndex, isActive, next];
}
class MultiBanner extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$q, create_fragment$r, safe_not_equal, {
      _screen: 1,
      components: 2,
      footerText: 0,
      theme: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MultiBanner",
      options,
      id: create_fragment$r.name
    });
  }
  get _screen() {
    throw new Error("<MultiBanner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set _screen(value) {
    throw new Error("<MultiBanner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get components() {
    throw new Error("<MultiBanner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set components(value) {
    throw new Error("<MultiBanner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get footerText() {
    throw new Error("<MultiBanner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set footerText(value) {
    throw new Error("<MultiBanner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<MultiBanner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<MultiBanner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
var MultiBanner$1 = MultiBanner;

/* ../../components/ui/src/ResponsiveButton.svelte generated by Svelte v3.59.2 */
const file$n = "../../components/ui/src/ResponsiveButton.svelte";
const get_always_slot_changes_1 = dirty => ({});
const get_always_slot_context_1 = ctx => ({});
const get_optional_slot_changes_1 = dirty => ({});
const get_optional_slot_context_1 = ctx => ({});
const get_always_slot_changes = dirty => ({});
const get_always_slot_context = ctx => ({});
const get_optional_slot_changes = dirty => ({});
const get_optional_slot_context = ctx => ({});

// (52:2) {#if !doesOverflow && !isOptionalHidden}
function create_if_block$e(ctx) {
  let current;
  const optional_slot_template = /*#slots*/ctx[13].optional;
  const optional_slot = create_slot(optional_slot_template, ctx, /*$$scope*/ctx[12], get_optional_slot_context);
  const block = {
    c: function create() {
      if (optional_slot) optional_slot.c();
    },
    l: function claim(nodes) {
      if (optional_slot) optional_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (optional_slot) {
        optional_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx, dirty) {
      if (optional_slot) {
        if (optional_slot.p && (!current || dirty & /*$$scope*/4096)) {
          update_slot_base(optional_slot, optional_slot_template, ctx, /*$$scope*/ctx[12], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[12]) : get_slot_changes(optional_slot_template, /*$$scope*/ctx[12], dirty, get_optional_slot_changes), get_optional_slot_context);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(optional_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(optional_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (optional_slot) optional_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$e.name,
    type: "if",
    source: "(52:2) {#if !doesOverflow && !isOptionalHidden}",
    ctx
  });
  return block;
}
function create_fragment$q(ctx) {
  let button;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  let current;
  let mounted;
  let dispose;
  let if_block = ! /*doesOverflow*/ctx[0] && ! /*isOptionalHidden*/ctx[2] && create_if_block$e(ctx);
  const always_slot_template = /*#slots*/ctx[13].always;
  const always_slot = create_slot(always_slot_template, ctx, /*$$scope*/ctx[12], get_always_slot_context);
  const optional_slot_template = /*#slots*/ctx[13].optional;
  const optional_slot = create_slot(optional_slot_template, ctx, /*$$scope*/ctx[12], get_optional_slot_context_1);
  const always_slot_template_1 = /*#slots*/ctx[13].always;
  const always_slot_1 = create_slot(always_slot_template_1, ctx, /*$$scope*/ctx[12], get_always_slot_context_1);
  const block = {
    c: function create() {
      button = element("button");
      div0 = element("div");
      if (if_block) if_block.c();
      t0 = space();
      if (always_slot) always_slot.c();
      t1 = space();
      div1 = element("div");
      if (optional_slot) optional_slot.c();
      t2 = space();
      if (always_slot_1) always_slot_1.c();
      this.h();
    },
    l: function claim(nodes) {
      button = claim_element(nodes, "BUTTON", {
        style: true,
        title: true,
        class: true
      });
      var button_nodes = children(button);
      div0 = claim_element(button_nodes, "DIV", {
        class: true
      });
      var div0_nodes = children(div0);
      if (if_block) if_block.l(div0_nodes);
      t0 = claim_space(div0_nodes);
      if (always_slot) always_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      button_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      div1 = claim_element(nodes, "DIV", {
        class: true,
        role: true
      });
      var div1_nodes = children(div1);
      if (optional_slot) optional_slot.l(div1_nodes);
      t2 = claim_space(div1_nodes);
      if (always_slot_1) always_slot_1.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "content svelte-sacwwa");
      add_location(div0, file$n, 47, 1, 1006);
      attr_dev(button, "style", /*style*/ctx[4]);
      attr_dev(button, "title", /*title*/ctx[3]);
      attr_dev(button, "class", "ResponsiveButton nowrap svelte-sacwwa");
      toggle_class(button, "active", /*isActive*/ctx[1]);
      add_location(button, file$n, 40, 0, 909);
      attr_dev(div1, "class", "ResponsiveButtonSensor nowrap svelte-sacwwa");
      attr_dev(div1, "role", "none");
      add_location(div1, file$n, 58, 0, 1181);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, button, anchor);
      append_hydration_dev(button, div0);
      if (if_block) if_block.m(div0, null);
      append_hydration_dev(div0, t0);
      if (always_slot) {
        always_slot.m(div0, null);
      }
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, div1, anchor);
      if (optional_slot) {
        optional_slot.m(div1, null);
      }
      append_hydration_dev(div1, t2);
      if (always_slot_1) {
        always_slot_1.m(div1, null);
      }
      current = true;
      if (!mounted) {
        dispose = [action_destroyer(/*contentSizeObserver*/ctx[6].call(null, div0)), listen_dev(button, "click", /*click_handler*/ctx[14], false, false, false, false), action_destroyer(/*sensorSizeObserver*/ctx[8].call(null, div1))];
        mounted = true;
      }
    },
    p: function update(ctx, _ref) {
      let [dirty] = _ref;
      if (! /*doesOverflow*/ctx[0] && ! /*isOptionalHidden*/ctx[2]) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty & /*doesOverflow, isOptionalHidden*/5) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$e(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div0, t0);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (always_slot) {
        if (always_slot.p && (!current || dirty & /*$$scope*/4096)) {
          update_slot_base(always_slot, always_slot_template, ctx, /*$$scope*/ctx[12], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[12]) : get_slot_changes(always_slot_template, /*$$scope*/ctx[12], dirty, get_always_slot_changes), get_always_slot_context);
        }
      }
      if (!current || dirty & /*style*/16) {
        attr_dev(button, "style", /*style*/ctx[4]);
      }
      if (!current || dirty & /*title*/8) {
        attr_dev(button, "title", /*title*/ctx[3]);
      }
      if (!current || dirty & /*isActive*/2) {
        toggle_class(button, "active", /*isActive*/ctx[1]);
      }
      if (optional_slot) {
        if (optional_slot.p && (!current || dirty & /*$$scope*/4096)) {
          update_slot_base(optional_slot, optional_slot_template, ctx, /*$$scope*/ctx[12], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[12]) : get_slot_changes(optional_slot_template, /*$$scope*/ctx[12], dirty, get_optional_slot_changes_1), get_optional_slot_context_1);
        }
      }
      if (always_slot_1) {
        if (always_slot_1.p && (!current || dirty & /*$$scope*/4096)) {
          update_slot_base(always_slot_1, always_slot_template_1, ctx, /*$$scope*/ctx[12], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[12]) : get_slot_changes(always_slot_template_1, /*$$scope*/ctx[12], dirty, get_always_slot_changes_1), get_always_slot_context_1);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      transition_in(always_slot, local);
      transition_in(optional_slot, local);
      transition_in(always_slot_1, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      transition_out(always_slot, local);
      transition_out(optional_slot, local);
      transition_out(always_slot_1, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(button);
      if (if_block) if_block.d();
      if (always_slot) always_slot.d(detaching);
      if (detaching) detach_dev(t1);
      if (detaching) detach_dev(div1);
      if (optional_slot) optional_slot.d(detaching);
      if (always_slot_1) always_slot_1.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$q.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$p($$self, $$props, $$invalidate) {
  let style;
  let $_sensorSize;
  let $_contentSize;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ResponsiveButton', slots, ['optional', 'always']);
  const {
    _writable: _contentSize,
    resizeObserver: contentSizeObserver
  } = setupResizeObserver();
  validate_store(_contentSize, '_contentSize');
  component_subscribe($$self, _contentSize, value => $$invalidate(11, $_contentSize = value));
  const {
    _writable: _sensorSize,
    resizeObserver: sensorSizeObserver
  } = setupResizeObserver();
  validate_store(_sensorSize, '_sensorSize');
  component_subscribe($$self, _sensorSize, value => $$invalidate(10, $_sensorSize = value));
  let {
    doesOverflow
  } = $$props;
  let {
    isActive
  } = $$props;
  let {
    isOptionalHidden
  } = $$props;
  let {
    title = ''
  } = $$props;
  let {
    theme
  } = $$props;
  const defaultTheme = {
    borderBottom: 'none',
    borderLeft: 'none',
    borderRight: 'none',
    borderTop: 'none',
    colorBackground: 'initial',
    colorBackgroundActive: '#333',
    colorText: 'initial',
    colorTextActive: 'white',
    outlineColor: 'black',
    outlineStyle: 'auto',
    outlineWidth: '2px'
  };
  $$self.$$.on_mount.push(function () {
    if (doesOverflow === undefined && !('doesOverflow' in $$props || $$self.$$.bound[$$self.$$.props['doesOverflow']])) {
      console.warn("<ResponsiveButton> was created without expected prop 'doesOverflow'");
    }
    if (isActive === undefined && !('isActive' in $$props || $$self.$$.bound[$$self.$$.props['isActive']])) {
      console.warn("<ResponsiveButton> was created without expected prop 'isActive'");
    }
    if (isOptionalHidden === undefined && !('isOptionalHidden' in $$props || $$self.$$.bound[$$self.$$.props['isOptionalHidden']])) {
      console.warn("<ResponsiveButton> was created without expected prop 'isOptionalHidden'");
    }
    if (theme === undefined && !('theme' in $$props || $$self.$$.bound[$$self.$$.props['theme']])) {
      console.warn("<ResponsiveButton> was created without expected prop 'theme'");
    }
  });
  const writable_props = ['doesOverflow', 'isActive', 'isOptionalHidden', 'title', 'theme'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ResponsiveButton> was created with unknown prop '".concat(key, "'"));
  });
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = $$props => {
    if ('doesOverflow' in $$props) $$invalidate(0, doesOverflow = $$props.doesOverflow);
    if ('isActive' in $$props) $$invalidate(1, isActive = $$props.isActive);
    if ('isOptionalHidden' in $$props) $$invalidate(2, isOptionalHidden = $$props.isOptionalHidden);
    if ('title' in $$props) $$invalidate(3, title = $$props.title);
    if ('theme' in $$props) $$invalidate(9, theme = $$props.theme);
    if ('$$scope' in $$props) $$invalidate(12, $$scope = $$props.$$scope);
  };
  $$self.$capture_state = () => ({
    makeStyleVars,
    setupResizeObserver,
    _contentSize,
    contentSizeObserver,
    _sensorSize,
    sensorSizeObserver,
    doesOverflow,
    isActive,
    isOptionalHidden,
    title,
    theme,
    defaultTheme,
    style,
    $_sensorSize,
    $_contentSize
  });
  $$self.$inject_state = $$props => {
    if ('doesOverflow' in $$props) $$invalidate(0, doesOverflow = $$props.doesOverflow);
    if ('isActive' in $$props) $$invalidate(1, isActive = $$props.isActive);
    if ('isOptionalHidden' in $$props) $$invalidate(2, isOptionalHidden = $$props.isOptionalHidden);
    if ('title' in $$props) $$invalidate(3, title = $$props.title);
    if ('theme' in $$props) $$invalidate(9, theme = $$props.theme);
    if ('style' in $$props) $$invalidate(4, style = $$props.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$_contentSize, $_sensorSize*/3072) {
      $$invalidate(0, doesOverflow = $_contentSize.inlineSize < $_sensorSize.inlineSize);
    }
    if ($$self.$$.dirty & /*theme*/512) {
      $$invalidate(9, theme = {
        ...defaultTheme,
        ...theme
      });
    }
    if ($$self.$$.dirty & /*theme*/512) {
      $$invalidate(4, style = makeStyleVars(theme));
    }
  };
  return [doesOverflow, isActive, isOptionalHidden, title, style, _contentSize, contentSizeObserver, _sensorSize, sensorSizeObserver, theme, $_sensorSize, $_contentSize, $$scope, slots, click_handler];
}
class ResponsiveButton extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$p, create_fragment$q, safe_not_equal, {
      doesOverflow: 0,
      isActive: 1,
      isOptionalHidden: 2,
      title: 3,
      theme: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ResponsiveButton",
      options,
      id: create_fragment$q.name
    });
  }
  get doesOverflow() {
    throw new Error("<ResponsiveButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set doesOverflow(value) {
    throw new Error("<ResponsiveButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isActive() {
    throw new Error("<ResponsiveButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isActive(value) {
    throw new Error("<ResponsiveButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOptionalHidden() {
    throw new Error("<ResponsiveButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isOptionalHidden(value) {
    throw new Error("<ResponsiveButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ResponsiveButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ResponsiveButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<ResponsiveButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<ResponsiveButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
var ResponsiveButton$1 = ResponsiveButton;

/* ../../components/ui/src/ResponsiveFlex.svelte generated by Svelte v3.59.2 */
const file$m = "../../components/ui/src/ResponsiveFlex.svelte";
function create_fragment$p(ctx) {
  let div;
  let div_class_value;
  let current;
  const default_slot_template = /*#slots*/ctx[2].default;
  const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ctx[1], null);
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot) default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true
      });
      var div_nodes = children(div);
      if (default_slot) default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      var _ctx$;
      attr_dev(div, "class", div_class_value = "ResponsiveFlex " + ( /*$_screen*/(_ctx$ = ctx[0]) === null || _ctx$ === void 0 ? void 0 : _ctx$.classes) + " svelte-1tya6p1");
      add_location(div, file$m, 4, 0, 83);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx, _ref) {
      var _ctx$2;
      let [dirty] = _ref;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/2)) {
          update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ctx[1], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[1]) : get_slot_changes(default_slot_template, /*$$scope*/ctx[1], dirty, null), null);
        }
      }
      if (!current || dirty & /*$_screen*/1 && div_class_value !== (div_class_value = "ResponsiveFlex " + ( /*$_screen*/(_ctx$2 = ctx[0]) === null || _ctx$2 === void 0 ? void 0 : _ctx$2.classes) + " svelte-1tya6p1")) {
        attr_dev(div, "class", div_class_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(div);
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$p.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$o($$self, $$props, $$invalidate) {
  let $_screen;
  validate_store(_screen, '_screen');
  component_subscribe($$self, _screen, $$value => $$invalidate(0, $_screen = $$value));
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ResponsiveFlex', slots, ['default']);
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ResponsiveFlex> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$$set = $$props => {
    if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
  };
  $$self.$capture_state = () => ({
    _screen,
    $_screen
  });
  return [$_screen, $$scope, slots];
}
class ResponsiveFlex extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$o, create_fragment$p, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ResponsiveFlex",
      options,
      id: create_fragment$p.name
    });
  }
}
var ResponsiveFlex$1 = ResponsiveFlex;

/* ../../components/ui/src/ScrollbarStyler.svelte generated by Svelte v3.59.2 */
const file$l = "../../components/ui/src/ScrollbarStyler.svelte";
function create_fragment$o(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true
      });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "svelte-t9pxmr");
      add_location(div, file$l, 36, 0, 964);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$o.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$n($$self, $$props, $$invalidate) {
  let rootElement;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ScrollbarStyler', slots, []);
  let {
    isEnabled = true
  } = $$props;
  let {
    theme
  } = $$props;
  let {
    defaultTheme = {
      thumbColor: 'grey',
      thumbRadius: '50px',
      trackBorderColor: 'lightgrey',
      trackColor: 'rgb(250,250,250)',
      trackWidth: '9px'
    }
  } = $$props;

  // eslint-disable-next-line no-undef
  const getRootElement = () => {
    var _globalThis$document;
    return (_globalThis$document = globalThis.document) === null || _globalThis$document === void 0 ? void 0 : _globalThis$document.documentElement;
  };
  const getClassList = () => {
    var _getRootElement;
    return (_getRootElement = getRootElement()) === null || _getRootElement === void 0 ? void 0 : _getRootElement.classList;
  };
  const enableStyle = () => {
    var _getClassList;
    return (_getClassList = getClassList()) === null || _getClassList === void 0 ? void 0 : _getClassList.add('styledScrollbar');
  };
  const disableStyle = () => {
    var _getClassList2;
    return (_getClassList2 = getClassList()) === null || _getClassList2 === void 0 ? void 0 : _getClassList2.remove('styledScrollbar');
  };
  onDestroy(disableStyle);
  $$self.$$.on_mount.push(function () {
    if (theme === undefined && !('theme' in $$props || $$self.$$.bound[$$self.$$.props['theme']])) {
      console.warn("<ScrollbarStyler> was created without expected prop 'theme'");
    }
  });
  const writable_props = ['isEnabled', 'theme', 'defaultTheme'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ScrollbarStyler> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$$set = $$props => {
    if ('isEnabled' in $$props) $$invalidate(0, isEnabled = $$props.isEnabled);
    if ('theme' in $$props) $$invalidate(1, theme = $$props.theme);
    if ('defaultTheme' in $$props) $$invalidate(2, defaultTheme = $$props.defaultTheme);
  };
  $$self.$capture_state = () => ({
    makeStyleVars,
    onDestroy,
    isClientSide,
    isEnabled,
    theme,
    defaultTheme,
    getRootElement,
    getClassList,
    enableStyle,
    disableStyle,
    rootElement
  });
  $$self.$inject_state = $$props => {
    if ('isEnabled' in $$props) $$invalidate(0, isEnabled = $$props.isEnabled);
    if ('theme' in $$props) $$invalidate(1, theme = $$props.theme);
    if ('defaultTheme' in $$props) $$invalidate(2, defaultTheme = $$props.defaultTheme);
    if ('rootElement' in $$props) $$invalidate(3, rootElement = $$props.rootElement);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*isEnabled*/1) {
      var _isEnabled;
      $$invalidate(0, isEnabled = (_isEnabled = isEnabled) !== null && _isEnabled !== void 0 ? _isEnabled : true);
    }
    if ($$self.$$.dirty & /*isEnabled*/1) {
      isClientSide && isEnabled ? enableStyle() : disableStyle();
    }
    if ($$self.$$.dirty & /*theme, defaultTheme*/6) {
      $$invalidate(1, theme = theme ? {
        ...defaultTheme,
        ...theme
      } : defaultTheme);
    }
    if ($$self.$$.dirty & /*rootElement, theme*/10) {
      if (rootElement) {
        $$invalidate(3, rootElement.style = makeStyleVars(theme), rootElement);
      }
    }
  };
  $$invalidate(3, rootElement = getRootElement());
  return [isEnabled, theme, defaultTheme, rootElement];
}
class ScrollbarStyler extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$n, create_fragment$o, safe_not_equal, {
      isEnabled: 0,
      theme: 1,
      defaultTheme: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ScrollbarStyler",
      options,
      id: create_fragment$o.name
    });
  }
  get isEnabled() {
    throw new Error("<ScrollbarStyler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isEnabled(value) {
    throw new Error("<ScrollbarStyler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<ScrollbarStyler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<ScrollbarStyler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultTheme() {
    throw new Error("<ScrollbarStyler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultTheme(value) {
    throw new Error("<ScrollbarStyler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
var ScrollbarStyler$1 = ScrollbarStyler;

var ui = /*#__PURE__*/Object.freeze({
	__proto__: null,
	StyleDriver: StyleDriver$1,
	StorageIO: StorageIO,
	AlphabetPicker: AlphabetPicker,
	Banner: Banner$1,
	CenteredView: CenteredView,
	CopyToClipboard: CopyToClipboard,
	HighlightedText: HighlightedText$1,
	LayoutHMF: LayoutHMF$1,
	Link: Link,
	LinkButton: LinkButton,
	LoadingView: LoadingView,
	MessageView: MessageView,
	MultiBanner: MultiBanner$1,
	NoScript: NoScript,
	ResponsiveButton: ResponsiveButton$1,
	ResponsiveFlex: ResponsiveFlex$1,
	ScrollbarStyler: ScrollbarStyler$1,
	Scroller: Scroller,
	Switch: Switch,
	XorSelector: XorSelector,
	A11yMenu: A11yMenu,
	A11yMenuDriver: A11yMenuDriver,
	ColorCorrection: ColorCorrection,
	_a11ySettings: _a11ySettings,
	_currentId: _currentId,
	_currentSetting: _currentSetting,
	_formatValue: _formatValue,
	setNextId: setNextId,
	setPrevId: setPrevId,
	_hasPrev: _hasPrev,
	_hasNext: _hasNext,
	updateCurrentValue: updateCurrentValue,
	mergeDefaultSettings: mergeDefaultSettings,
	_groupsResetStatus: _groupsResetStatus,
	_isA11yDirty: _isA11yDirty,
	resetGroup: resetGroup,
	_a11yColorStyles: _a11yColorStyles,
	_a11yTextStyles: _a11yTextStyles,
	applyStyles: applyStyles,
	resizeHandler: resizeHandler,
	setupResizeObserver: setupResizeObserver,
	FontsLoader: FontsLoader,
	getFamily: getFamily,
	getFamilies: getFamilies,
	isFamilyEqualTo: isFamilyEqualTo,
	createFontFaces: createFontFaces,
	loadFontFaces: loadFontFaces,
	Icon: Icon,
	Activity: Activity,
	Airplay: Airplay$1,
	AlertCircle: AlertCircle$1,
	AlertOctagon: AlertOctagon$1,
	AlertTriangle: AlertTriangle,
	AlignCenter: AlignCenter$1,
	AlignJustify: AlignJustify$1,
	AlignLeft: AlignLeft$1,
	AlignRight: AlignRight$1,
	Anchor: Anchor$1,
	Aperture: Aperture$1,
	Archive: Archive$1,
	ArrowDownCircle: ArrowDownCircle$1,
	ArrowDownLeft: ArrowDownLeft$1,
	ArrowDownRight: ArrowDownRight$1,
	ArrowDown: ArrowDown$1,
	ArrowLeftCircle: ArrowLeftCircle,
	ArrowLeft: ArrowLeft$1,
	ArrowRightCircle: ArrowRightCircle,
	ArrowRight: ArrowRight$1,
	ArrowUpCircle: ArrowUpCircle$1,
	ArrowUpLeft: ArrowUpLeft$1,
	ArrowUpRight: ArrowUpRight$1,
	ArrowUp: ArrowUp$1,
	AtSign: AtSign$1,
	Award: Award$1,
	BarChart2: BarChart2$1,
	BarChart: BarChart,
	BatteryCharging: BatteryCharging$1,
	Battery: Battery$1,
	BellOff: BellOff$1,
	Bell: Bell$1,
	Bluetooth: Bluetooth$1,
	Bold: Bold$1,
	BookOpen: BookOpen$1,
	Book: Book$1,
	Bookmark: Bookmark$1,
	Box: Box$1,
	Briefcase: Briefcase$1,
	Calendar: Calendar$1,
	CameraOff: CameraOff$1,
	Camera: Camera$1,
	Cast: Cast$1,
	CheckCircle: CheckCircle$1,
	CheckSquare: CheckSquare,
	Check: Check$1,
	ChevronDown: ChevronDown,
	ChevronLeft: ChevronLeft,
	ChevronRight: ChevronRight,
	ChevronUp: ChevronUp,
	ChevronsDown: ChevronsDown$1,
	ChevronsLeft: ChevronsLeft$1,
	ChevronsRight: ChevronsRight$1,
	ChevronsUp: ChevronsUp$1,
	Chrome: Chrome$1,
	Circle: Circle$1,
	Clipboard: Clipboard,
	Clock: Clock,
	CloudDrizzle: CloudDrizzle$1,
	CloudLightning: CloudLightning$1,
	CloudOff: CloudOff$1,
	CloudRain: CloudRain$1,
	CloudSnow: CloudSnow$1,
	Cloud: Cloud$1,
	Code: Code$1,
	Codepen: Codepen$1,
	Codesandbox: Codesandbox$1,
	Coffee: Coffee$1,
	Columns: Columns$1,
	Command: Command$1,
	Compass: Compass$1,
	Copy: Copy,
	CornerDownLeft: CornerDownLeft$1,
	CornerDownRight: CornerDownRight$1,
	CornerLeftDown: CornerLeftDown$1,
	CornerLeftUp: CornerLeftUp$1,
	CornerRightDown: CornerRightDown$1,
	CornerRightUp: CornerRightUp$1,
	CornerUpLeft: CornerUpLeft$1,
	CornerUpRight: CornerUpRight$1,
	Cpu: Cpu$1,
	CreditCard: CreditCard$1,
	Crop: Crop$1,
	Crosshair: Crosshair$1,
	Database: Database$1,
	Delete: Delete$1,
	Disc: Disc$1,
	DivideCircle: DivideCircle$1,
	DivideSquare: DivideSquare$1,
	Divide: Divide$1,
	DollarSign: DollarSign$1,
	DownloadCloud: DownloadCloud$1,
	Download: Download,
	Dribbble: Dribbble$1,
	Droplet: Droplet$1,
	Edit2: Edit2$1,
	Edit3: Edit3$1,
	Edit: Edit$1,
	ExternalLink: ExternalLink,
	EyeOff: EyeOff$1,
	Eye: Eye$1,
	Facebook: Facebook$1,
	FastForward: FastForward$1,
	Feather: Feather$1,
	Figma: Figma$1,
	FileMinus: FileMinus$1,
	FilePlus: FilePlus$1,
	FileText: FileText$1,
	File: File$1,
	Film: Film$1,
	Filter: Filter$1,
	Flag: Flag$1,
	FolderMinus: FolderMinus$1,
	FolderPlus: FolderPlus$1,
	Folder: Folder$1,
	Framer: Framer$1,
	Frown: Frown$1,
	Gift: Gift$1,
	GitBranch: GitBranch$1,
	GitCommit: GitCommit$1,
	GitMerge: GitMerge$1,
	GitPullRequest: GitPullRequest$1,
	Github: Github$1,
	Gitlab: Gitlab$1,
	Globe: Globe,
	Grid: Grid$1,
	HardDrive: HardDrive$1,
	Hash: Hash$1,
	Headphones: Headphones$1,
	Heart: Heart$1,
	HelpCircle: HelpCircle$1,
	Hexagon: Hexagon$1,
	Home: Home$1,
	Image: Image$1,
	Inbox: Inbox$1,
	Info: Info,
	Instagram: Instagram$1,
	Italic: Italic$1,
	Key: Key$1,
	Layers: Layers$1,
	Layout: Layout$1,
	LifeBuoy: LifeBuoy$1,
	Link2: Link2$1,
	Linkedin: Linkedin$1,
	List: List,
	Loader: Loader,
	Lock: Lock$1,
	LogIn: LogIn$1,
	LogOut: LogOut$1,
	Mail: Mail$1,
	MapPin: MapPin,
	Map: Map$1,
	Maximize2: Maximize2$1,
	Maximize: Maximize$1,
	Meh: Meh$1,
	Menu: Menu$1,
	MessageCircle: MessageCircle$1,
	MessageSquare: MessageSquare$1,
	MicOff: MicOff$1,
	Mic: Mic$1,
	Minimize2: Minimize2$1,
	Minimize: Minimize$1,
	MinusCircle: MinusCircle,
	MinusSquare: MinusSquare,
	Minus: Minus$1,
	Monitor: Monitor$1,
	Moon: Moon$1,
	MoreHorizontal: MoreHorizontal$1,
	MoreVertical: MoreVertical$1,
	MousePointer: MousePointer$1,
	Move: Move$1,
	Music: Music$1,
	Navigation2: Navigation2$1,
	Navigation: Navigation$1,
	Octagon: Octagon$1,
	Package: Package$1,
	Paperclip: Paperclip$1,
	PauseCircle: PauseCircle$1,
	Pause: Pause$1,
	PenTool: PenTool$1,
	Percent: Percent$1,
	PhoneCall: PhoneCall$1,
	PhoneForwarded: PhoneForwarded$1,
	PhoneIncoming: PhoneIncoming$1,
	PhoneMissed: PhoneMissed$1,
	PhoneOff: PhoneOff$1,
	PhoneOutgoing: PhoneOutgoing$1,
	Phone: Phone$1,
	PieChart: PieChart$1,
	PlayCircle: PlayCircle$1,
	Play: Play$1,
	PlusCircle: PlusCircle,
	PlusSquare: PlusSquare$1,
	Plus: Plus$1,
	Pocket: Pocket$1,
	Power: Power$1,
	Printer: Printer$1,
	Radio: Radio$1,
	RefreshCcw: RefreshCcw$1,
	RefreshCw: RefreshCw$1,
	Repeat: Repeat$1,
	Rewind: Rewind$1,
	RotateCcw: RotateCcw$1,
	RotateCw: RotateCw$1,
	Rss: Rss$1,
	Save: Save$1,
	Scissors: Scissors$1,
	Search: Search$1,
	Send: Send$1,
	Server: Server$1,
	Settings: Settings,
	Share2: Share2$1,
	Share: Share$1,
	ShieldOff: ShieldOff$1,
	Shield: Shield$1,
	ShoppingBag: ShoppingBag$1,
	ShoppingCart: ShoppingCart$1,
	Shuffle: Shuffle$1,
	Sidebar: Sidebar$1,
	SkipBack: SkipBack$1,
	SkipForward: SkipForward$1,
	Slack: Slack$1,
	Slash: Slash$1,
	Sliders: Sliders$1,
	Smartphone: Smartphone$1,
	Smile: Smile$1,
	Speaker: Speaker$1,
	Square: Square,
	Star: Star$1,
	StopCircle: StopCircle$1,
	Sun: Sun,
	Sunrise: Sunrise$1,
	Sunset: Sunset$1,
	Table: Table$1,
	Tablet: Tablet$1,
	Tag: Tag$1,
	Target: Target$1,
	Terminal: Terminal$1,
	Thermometer: Thermometer$1,
	ThumbsDown: ThumbsDown$1,
	ThumbsUp: ThumbsUp$1,
	ToggleLeft: ToggleLeft$1,
	ToggleRight: ToggleRight$1,
	Tool: Tool$1,
	Trash2: Trash2$1,
	Trash: Trash$1,
	Trello: Trello$1,
	TrendingDown: TrendingDown$1,
	TrendingUp: TrendingUp$1,
	Triangle: Triangle$1,
	Truck: Truck$1,
	Tv: Tv$1,
	Twitch: Twitch$1,
	Twitter: Twitter$1,
	Type: Type$1,
	Umbrella: Umbrella$1,
	Underline: Underline$1,
	Unlock: Unlock$1,
	UploadCloud: UploadCloud$1,
	Upload: Upload$1,
	UserCheck: UserCheck$1,
	UserMinus: UserMinus$1,
	UserPlus: UserPlus$1,
	UserX: UserX$1,
	User: User$1,
	Users: Users$1,
	VideoOff: VideoOff$1,
	Video: Video$1,
	Voicemail: Voicemail$1,
	Volume1: Volume1$1,
	Volume2: Volume2$1,
	VolumeX: VolumeX$1,
	Volume: Volume$1,
	Watch: Watch$1,
	WifiOff: WifiOff$1,
	Wifi: Wifi$1,
	Wind: Wind$1,
	XCircle: XCircle$1,
	XOctagon: XOctagon$1,
	XSquare: XSquare$1,
	X: X$1,
	Youtube: Youtube$1,
	ZapOff: ZapOff$1,
	Zap: Zap$1,
	ZoomIn: ZoomIn$1,
	ZoomOut: ZoomOut$1,
	A11yPerson: A11yPerson,
	_screen: _screen,
	ScreenSensor: ScreenSensor,
	StyleSensor: StyleSensor$1,
	isServerSide: isServerSide,
	isClientSide: isClientSide,
	PLATFORM: PLATFORM,
	isPlatformIn: isPlatformIn,
	rxStreamToSvReadable: rxStreamToSvReadable,
	rxStreamToSvWritable: rxStreamToSvWritable,
	defaultRel: defaultRel
});

function nice(domain, interval) {
  domain = domain.slice();
  var i0 = 0,
    i1 = domain.length - 1,
    x0 = domain[i0],
    x1 = domain[i1],
    t;
  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }
  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}

function transformLog(x) {
  return Math.log(x);
}
function transformExp(x) {
  return Math.exp(x);
}
function transformLogn(x) {
  return -Math.log(-x);
}
function transformExpn(x) {
  return -Math.exp(-x);
}
function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}
function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : x => Math.pow(base, x);
}
function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), x => Math.log(x) / base);
}
function reflect(f) {
  return (x, k) => -f(-x, k);
}
function loggish(transform) {
  const scale = transform(transformLog, transformExp);
  const domain = scale.domain;
  let base = 10;
  let logs;
  let pows;
  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }
  scale.base = function (_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };
  scale.domain = function (_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale.ticks = count => {
    const d = domain();
    let u = d[0];
    let v = d[d.length - 1];
    const r = v < u;
    if (r) [u, v] = [v, u];
    let i = logs(u);
    let j = logs(v);
    let k;
    let t;
    const n = count == null ? 10 : +count;
    let z = [];
    if (!(base % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0) for (; i <= j; ++i) {
        for (k = 1; k < base; ++k) {
          t = i < 0 ? k / pows(-i) : k * pows(i);
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i <= j; ++i) {
        for (k = base - 1; k >= 1; --k) {
          t = i > 0 ? k / pows(-i) : k * pows(i);
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
      if (z.length * 2 < n) z = ticks(u, v, n);
    } else {
      z = ticks(i, j, Math.min(j - i, n)).map(pows);
    }
    return r ? z.reverse() : z;
  };
  scale.tickFormat = (count, specifier) => {
    if (count == null) count = 10;
    if (specifier == null) specifier = base === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
      specifier = format(specifier);
    }
    if (count === Infinity) return specifier;
    const k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return d => {
      let i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };
  scale.nice = () => {
    return domain(nice(domain(), {
      floor: x => pows(Math.floor(logs(x))),
      ceil: x => pows(Math.ceil(logs(x)))
    }));
  };
  return scale;
}
function log() {
  const scale = loggish(transformer()).domain([1, 10]);
  scale.copy = () => copy(scale, log()).base(scale.base());
  initRange.apply(scale, arguments);
  return scale;
}

const STATE = {};
function useState(newState, opts) {
  const currentState = getContext(STATE);
  const _newState = typeof newState === 'function' ? newState(currentState) : newState;
  const nextState = {
    ...currentState,
    ..._newState
  };
  if (opts !== null && opts !== void 0 && opts.expandable) nextState.isParentExpanded = nextState.expanded;
  setContext(STATE, nextState);
  return currentState;
}

/* ../../../node_modules/svelte-json-tree/_/JSONArrow.svelte generated by Svelte v3.59.2 */
const file$k = "../../../node_modules/svelte-json-tree/_/JSONArrow.svelte";

// (6:0) {#if $expandable}
function create_if_block$d(ctx) {
  let span1;
  let span0;
  let t_value = '\u25B6' + "";
  let t;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      span1 = element("span");
      span0 = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span1 = claim_element(nodes, "SPAN", {
        class: true
      });
      var span1_nodes = children(span1);
      span0 = claim_element(span1_nodes, "SPAN", {
        class: true
      });
      var span0_nodes = children(span0);
      t = claim_text(span0_nodes, t_value);
      span0_nodes.forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "arrow svelte-1qd6nto");
      toggle_class(span0, "expanded", /*$expanded*/ctx[2]);
      add_location(span0, file$k, 13, 4, 304);
      attr_dev(span1, "class", "container svelte-1qd6nto");
      add_location(span1, file$k, 6, 2, 173);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, span0);
      append_hydration_dev(span0, t);
      if (!mounted) {
        dispose = listen_dev(span1, "click", /*click_handler*/ctx[4], false, false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx, dirty) {
      if (dirty & /*$expanded*/4) {
        toggle_class(span0, "expanded", /*$expanded*/ctx[2]);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span1);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$d.name,
    type: "if",
    source: "(6:0) {#if $expandable}",
    ctx
  });
  return block;
}
function create_fragment$n(ctx) {
  let if_block_anchor;
  let if_block = /*$expandable*/ctx[1] && create_if_block$d(ctx);
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx, _ref) {
      let [dirty] = _ref;
      if ( /*$expandable*/ctx[1]) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block$d(ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block) if_block.d(detaching);
      if (detaching) detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$n.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$m($$self, $$props, $$invalidate) {
  let $expandable;
  let $expanded,
    $$unsubscribe_expanded = noop,
    $$subscribe_expanded = () => ($$unsubscribe_expanded(), $$unsubscribe_expanded = subscribe(expanded, $$value => $$invalidate(2, $expanded = $$value)), expanded);
  $$self.$$.on_destroy.push(() => $$unsubscribe_expanded());
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('JSONArrow', slots, []);
  const {
    expanded: _expanded,
    expandable
  } = useState();
  validate_store(expandable, 'expandable');
  component_subscribe($$self, expandable, value => $$invalidate(1, $expandable = value));
  let {
    expanded = _expanded
  } = $$props;
  validate_store(expanded, 'expanded');
  $$subscribe_expanded();
  const writable_props = ['expanded'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<JSONArrow> was created with unknown prop '".concat(key, "'"));
  });
  const click_handler = event => {
    event.stopPropagation();
    set_store_value(expanded, $expanded = !$expanded, $expanded);
  };
  $$self.$$set = $$props => {
    if ('expanded' in $$props) $$subscribe_expanded($$invalidate(0, expanded = $$props.expanded));
  };
  $$self.$capture_state = () => ({
    useState,
    _expanded,
    expandable,
    expanded,
    $expandable,
    $expanded
  });
  $$self.$inject_state = $$props => {
    if ('expanded' in $$props) $$subscribe_expanded($$invalidate(0, expanded = $$props.expanded));
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [expanded, $expandable, $expanded, expandable, click_handler];
}
class JSONArrow extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$m, create_fragment$n, safe_not_equal, {
      expanded: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "JSONArrow",
      options,
      id: create_fragment$n.name
    });
  }
  get expanded() {
    throw new Error("<JSONArrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expanded(value) {
    throw new Error("<JSONArrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}

/* ../../../node_modules/svelte-json-tree/_/Summary.svelte generated by Svelte v3.59.2 */
function create_fragment$m(ctx) {
  let current;
  const default_slot_template = /*#slots*/ctx[1].default;
  const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ctx[0], null);
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx, _ref) {
      let [dirty] = _ref;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/1)) {
          update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ctx[0], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[0]) : get_slot_changes(default_slot_template, /*$$scope*/ctx[0], dirty, null), null);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$m.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$l($$self, $$props, $$invalidate) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Summary', slots, ['default']);
  useState({
    displayMode: 'summary'
  });
  const writable_props = [];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Summary> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$$set = $$props => {
    if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
  };
  $$self.$capture_state = () => ({
    useState
  });
  return [$$scope, slots];
}
class Summary extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$l, create_fragment$m, safe_not_equal, {});
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Summary",
      options,
      id: create_fragment$m.name
    });
  }
}

/* ../../../node_modules/svelte-json-tree/_/Expandable.svelte generated by Svelte v3.59.2 */
function create_fragment$l(ctx) {
  let current;
  const default_slot_template = /*#slots*/ctx[3].default;
  const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ctx[2], null);
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot) default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx, _ref) {
      let [dirty] = _ref;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/4)) {
          update_slot_base(default_slot, default_slot_template, ctx, /*$$scope*/ctx[2], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[2]) : get_slot_changes(default_slot_template, /*$$scope*/ctx[2], dirty, null), null);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$l.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$k($$self, $$props, $$invalidate) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Expandable', slots, ['default']);
  let {
    expanded
  } = $$props;
  let {
    key
  } = $$props;
  const expandable = writable(false);
  useState(_ref2 => {
    let {
      keyPath,
      level
    } = _ref2;
    if (key !== '[[Entries]]') {
      keyPath = [...keyPath, key];
      level = level + 1;
    }
    return {
      keyPath,
      level,
      expanded,
      expandable
    };
  });
  $$self.$$.on_mount.push(function () {
    if (expanded === undefined && !('expanded' in $$props || $$self.$$.bound[$$self.$$.props['expanded']])) {
      console.warn("<Expandable> was created without expected prop 'expanded'");
    }
    if (key === undefined && !('key' in $$props || $$self.$$.bound[$$self.$$.props['key']])) {
      console.warn("<Expandable> was created without expected prop 'key'");
    }
  });
  const writable_props = ['expanded', 'key'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Expandable> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$$set = $$props => {
    if ('expanded' in $$props) $$invalidate(0, expanded = $$props.expanded);
    if ('key' in $$props) $$invalidate(1, key = $$props.key);
    if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
  };
  $$self.$capture_state = () => ({
    writable,
    useState,
    expanded,
    key,
    expandable
  });
  $$self.$inject_state = $$props => {
    if ('expanded' in $$props) $$invalidate(0, expanded = $$props.expanded);
    if ('key' in $$props) $$invalidate(1, key = $$props.key);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [expanded, key, $$scope, slots];
}
class Expandable extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$k, create_fragment$l, safe_not_equal, {
      expanded: 0,
      key: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Expandable",
      options,
      id: create_fragment$l.name
    });
  }
  get expanded() {
    throw new Error("<Expandable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expanded(value) {
    throw new Error("<Expandable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get key() {
    throw new Error("<Expandable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value) {
    throw new Error("<Expandable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}

/* ../../../node_modules/svelte-json-tree/_/JSONNested.svelte generated by Svelte v3.59.2 */
const file$j = "../../../node_modules/svelte-json-tree/_/JSONNested.svelte";
function get_each_context$5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  child_ctx[21] = i;
  return child_ctx;
}
const get_item_value_slot_changes = dirty => ({
  key: dirty & /*keys*/1
});
const get_item_value_slot_context = ctx => ({
  key: /*key*/ctx[19],
  index: /*index*/ctx[21]
});
const get_item_key_slot_changes = dirty => ({
  key: dirty & /*keys*/1
});
const get_item_key_slot_context = ctx => ({
  key: /*key*/ctx[19],
  index: /*index*/ctx[21]
});
const get_preview_slot_changes = dirty => ({});
const get_preview_slot_context = ctx => ({});
const get_summary_slot_changes = dirty => ({});
const get_summary_slot_context = ctx => ({});

// (39:0) {:else}
function create_else_block$8(ctx) {
  let span;
  let t0;
  let summary;
  let t1;
  let if_block1_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block0 = /*root*/ctx[6] && create_if_block_3$4(ctx);
  summary = new Summary({
    props: {
      $$slots: {
        default: [create_default_slot_1$1]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  let if_block1 = /*$expanded*/ctx[4] && create_if_block_1$6(ctx);
  const block = {
    c: function create() {
      span = element("span");
      if (if_block0) if_block0.c();
      t0 = space();
      create_component(summary.$$.fragment);
      t1 = space();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      if (if_block0) if_block0.l(span_nodes);
      t0 = claim_space(span_nodes);
      claim_component(summary.$$.fragment, span_nodes);
      span_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      if_block1_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "root svelte-19drypg");
      add_location(span, file$j, 39, 2, 1294);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (if_block0) if_block0.m(span, null);
      append_hydration_dev(span, t0);
      mount_component(summary, span, null);
      insert_hydration_dev(target, t1, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen_dev(span, "click", /*toggleExpand*/ctx[9], false, false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx, dirty) {
      if ( /*root*/ctx[6]) if_block0.p(ctx, dirty);
      const summary_changes = {};
      if (dirty & /*$$scope*/8192) {
        summary_changes.$$scope = {
          dirty,
          ctx
        };
      }
      summary.$set(summary_changes);
      if ( /*$expanded*/ctx[4]) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty & /*$expanded*/16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_1$6(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(summary.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(summary.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
      if (if_block0) if_block0.d();
      destroy_component(summary);
      if (detaching) detach_dev(t1);
      if (if_block1) if_block1.d(detaching);
      if (detaching) detach_dev(if_block1_anchor);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block$8.name,
    type: "else",
    source: "(39:0) {:else}",
    ctx
  });
  return block;
}

// (37:0) {#if displayMode === 'summary'}
function create_if_block$c(ctx) {
  let current;
  const summary_slot_template = /*#slots*/ctx[11].summary;
  const summary_slot = create_slot(summary_slot_template, ctx, /*$$scope*/ctx[13], get_summary_slot_context);
  const block = {
    c: function create() {
      if (summary_slot) summary_slot.c();
    },
    l: function claim(nodes) {
      if (summary_slot) summary_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (summary_slot) {
        summary_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx, dirty) {
      if (summary_slot) {
        if (summary_slot.p && (!current || dirty & /*$$scope*/8192)) {
          update_slot_base(summary_slot, summary_slot_template, ctx, /*$$scope*/ctx[13], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[13]) : get_slot_changes(summary_slot_template, /*$$scope*/ctx[13], dirty, get_summary_slot_changes), get_summary_slot_context);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(summary_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(summary_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (summary_slot) summary_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$c.name,
    type: "if",
    source: "(37:0) {#if displayMode === 'summary'}",
    ctx
  });
  return block;
}

// (41:4) {#if root}
function create_if_block_3$4(ctx) {
  let jsonarrow;
  let current;
  jsonarrow = new JSONArrow({
    props: {
      expanded: /*expanded*/ctx[7]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonarrow.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonarrow.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonarrow, target, anchor);
      current = true;
    },
    p: noop,
    i: function intro(local) {
      if (current) return;
      transition_in(jsonarrow.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonarrow.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonarrow, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3$4.name,
    type: "if",
    source: "(41:4) {#if root}",
    ctx
  });
  return block;
}

// (44:4) <Summary>
function create_default_slot_1$1(ctx) {
  let current;
  const preview_slot_template = /*#slots*/ctx[11].preview;
  const preview_slot = create_slot(preview_slot_template, ctx, /*$$scope*/ctx[13], get_preview_slot_context);
  const block = {
    c: function create() {
      if (preview_slot) preview_slot.c();
    },
    l: function claim(nodes) {
      if (preview_slot) preview_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (preview_slot) {
        preview_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx, dirty) {
      if (preview_slot) {
        if (preview_slot.p && (!current || dirty & /*$$scope*/8192)) {
          update_slot_base(preview_slot, preview_slot_template, ctx, /*$$scope*/ctx[13], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[13]) : get_slot_changes(preview_slot_template, /*$$scope*/ctx[13], dirty, get_preview_slot_changes), get_preview_slot_context);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(preview_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(preview_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (preview_slot) preview_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1$1.name,
    type: "slot",
    source: "(44:4) <Summary>",
    ctx
  });
  return block;
}

// (49:2) {#if $expanded}
function create_if_block_1$6(ctx) {
  let ul;
  let current;
  let mounted;
  let dispose;
  let each_value = /*keys*/ctx[0];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
  }
  const out = i => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", {});
      var ul_nodes = children(ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(ul_nodes);
      }
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(ul, file$j, 49, 4, 1486);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(ul, "click", stop_propagation( /*toggleExpand*/ctx[9]), false, false, true, false);
        mounted = true;
      }
    },
    p: function update(ctx, dirty) {
      if (dirty & /*$expanded, expandKey, keys, child_expanded, $$scope, shouldShowColon*/8223) {
        each_value = /*keys*/ctx[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$5(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(ul, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(ul);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1$6.name,
    type: "if",
    source: "(49:2) {#if $expanded}",
    ctx
  });
  return block;
}

// (55:65) {#if !shouldShowColon || shouldShowColon(key)}
function create_if_block_2$4(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(":");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, ":");
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "operator");
      add_location(span, file$j, 54, 111, 1924);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2$4.name,
    type: "if",
    source: "(55:65) {#if !shouldShowColon || shouldShowColon(key)}",
    ctx
  });
  return block;
}

// (53:10) <Expandable key={expandKey(key)} expanded={child_expanded[index]}>
function create_default_slot$2(ctx) {
  let span;
  let jsonarrow;
  let show_if = ! /*shouldShowColon*/ctx[1] || /*shouldShowColon*/ctx[1]( /*key*/ctx[19]);
  let t;
  let current;
  let mounted;
  let dispose;
  jsonarrow = new JSONArrow({
    $$inline: true
  });
  const item_key_slot_template = /*#slots*/ctx[11].item_key;
  const item_key_slot = create_slot(item_key_slot_template, ctx, /*$$scope*/ctx[13], get_item_key_slot_context);
  let if_block = show_if && create_if_block_2$4(ctx);
  function click_handler() {
    return (/*click_handler*/ctx[12]( /*index*/ctx[21])
    );
  }
  const item_value_slot_template = /*#slots*/ctx[11].item_value;
  const item_value_slot = create_slot(item_value_slot_template, ctx, /*$$scope*/ctx[13], get_item_value_slot_context);
  const block = {
    c: function create() {
      span = element("span");
      create_component(jsonarrow.$$.fragment);
      if (item_key_slot) item_key_slot.c();
      if (if_block) if_block.c();
      t = space();
      if (item_value_slot) item_value_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      claim_component(jsonarrow.$$.fragment, span_nodes);
      if (item_key_slot) item_key_slot.l(span_nodes);
      if (if_block) if_block.l(span_nodes);
      t = claim_space(span_nodes);
      span_nodes.forEach(detach_dev);
      if (item_value_slot) item_value_slot.l(nodes);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "label svelte-19drypg");
      add_location(span, file$j, 53, 12, 1727);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      mount_component(jsonarrow, span, null);
      if (item_key_slot) {
        item_key_slot.m(span, null);
      }
      if (if_block) if_block.m(span, null);
      append_hydration_dev(span, t);
      if (item_value_slot) {
        item_value_slot.m(target, anchor);
      }
      current = true;
      if (!mounted) {
        dispose = listen_dev(span, "click", click_handler, false, false, false, false);
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (item_key_slot) {
        if (item_key_slot.p && (!current || dirty & /*$$scope, keys*/8193)) {
          update_slot_base(item_key_slot, item_key_slot_template, ctx, /*$$scope*/ctx[13], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[13]) : get_slot_changes(item_key_slot_template, /*$$scope*/ctx[13], dirty, get_item_key_slot_changes), get_item_key_slot_context);
        }
      }
      if (dirty & /*shouldShowColon, keys*/3) show_if = ! /*shouldShowColon*/ctx[1] || /*shouldShowColon*/ctx[1]( /*key*/ctx[19]);
      if (show_if) {
        if (if_block) ; else {
          if_block = create_if_block_2$4(ctx);
          if_block.c();
          if_block.m(span, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (item_value_slot) {
        if (item_value_slot.p && (!current || dirty & /*$$scope, keys*/8193)) {
          update_slot_base(item_value_slot, item_value_slot_template, ctx, /*$$scope*/ctx[13], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[13]) : get_slot_changes(item_value_slot_template, /*$$scope*/ctx[13], dirty, get_item_value_slot_changes), get_item_value_slot_context);
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonarrow.$$.fragment, local);
      transition_in(item_key_slot, local);
      transition_in(item_value_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonarrow.$$.fragment, local);
      transition_out(item_key_slot, local);
      transition_out(item_value_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
      destroy_component(jsonarrow);
      if (item_key_slot) item_key_slot.d(detaching);
      if (if_block) if_block.d();
      if (item_value_slot) item_value_slot.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$2.name,
    type: "slot",
    source: "(53:10) <Expandable key={expandKey(key)} expanded={child_expanded[index]}>",
    ctx
  });
  return block;
}

// (51:6) {#each keys as key, index}
function create_each_block$5(ctx) {
  let li;
  let expandable_1;
  let t;
  let current;
  let mounted;
  let dispose;
  expandable_1 = new Expandable({
    props: {
      key: /*expandKey*/ctx[2]( /*key*/ctx[19]),
      expanded: /*child_expanded*/ctx[3][/*index*/ctx[21]],
      $$slots: {
        default: [create_default_slot$2]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      li = element("li");
      create_component(expandable_1.$$.fragment);
      t = space();
      this.h();
    },
    l: function claim(nodes) {
      li = claim_element(nodes, "LI", {
        class: true
      });
      var li_nodes = children(li);
      claim_component(expandable_1.$$.fragment, li_nodes);
      t = claim_space(li_nodes);
      li_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(li, "class", "svelte-19drypg");
      toggle_class(li, "indent", /*$expanded*/ctx[4]);
      add_location(li, file$j, 51, 8, 1572);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, li, anchor);
      mount_component(expandable_1, li, null);
      append_hydration_dev(li, t);
      current = true;
      if (!mounted) {
        dispose = listen_dev(li, "click", stop_propagation(click_handler_1), false, false, true, false);
        mounted = true;
      }
    },
    p: function update(ctx, dirty) {
      const expandable_1_changes = {};
      if (dirty & /*expandKey, keys*/5) expandable_1_changes.key = /*expandKey*/ctx[2]( /*key*/ctx[19]);
      if (dirty & /*child_expanded*/8) expandable_1_changes.expanded = /*child_expanded*/ctx[3][/*index*/ctx[21]];
      if (dirty & /*$$scope, keys, child_expanded, shouldShowColon*/8203) {
        expandable_1_changes.$$scope = {
          dirty,
          ctx
        };
      }
      expandable_1.$set(expandable_1_changes);
      if (!current || dirty & /*$expanded*/16) {
        toggle_class(li, "indent", /*$expanded*/ctx[4]);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(expandable_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(expandable_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(li);
      destroy_component(expandable_1);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block$5.name,
    type: "each",
    source: "(51:6) {#each keys as key, index}",
    ctx
  });
  return block;
}
function create_fragment$k(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$c, create_else_block$8];
  const if_blocks = [];
  function select_block_type(ctx, dirty) {
    if ( /*displayMode*/ctx[5] === 'summary') return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx, _ref) {
      let [dirty] = _ref;
      if_block.p(ctx, dirty);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching) detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$k.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
const click_handler_1 = () => {};
function instance$j($$self, $$props, $$invalidate) {
  let child_expanded;
  let $expanded;
  let $expandable;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('JSONNested', slots, ['summary', 'preview', 'item_key', 'item_value']);
  let {
    keys
  } = $$props;
  let {
    shouldShowColon = undefined
  } = $$props;
  let {
    expandKey = key => key
  } = $$props;
  let {
    defaultExpanded = false
  } = $$props;
  const {
    isParentExpanded,
    displayMode,
    root,
    expanded,
    expandable,
    keyPath,
    level,
    shouldExpandNode
  } = useState({
    root: false
  }, {
    expandable: true
  });
  validate_store(expanded, 'expanded');
  component_subscribe($$self, expanded, value => $$invalidate(4, $expanded = value));
  validate_store(expandable, 'expandable');
  component_subscribe($$self, expandable, value => $$invalidate(14, $expandable = value));
  set_store_value(expandable, $expandable = true, $expandable);
  if (displayMode !== 'summary') {
    // if not internally control to open
    if (!defaultExpanded) {
      const controlled = shouldExpandNode({
        keyPath,
        level
      });
      if (controlled !== undefined) {
        defaultExpanded = controlled;
      }
    }
    onMount(() => {
      return isParentExpanded.subscribe(value => {
        if (!value) expanded.set(false);else expanded.set(defaultExpanded);
      });
    });
  }
  function toggleExpand() {
    set_store_value(expanded, $expanded = !$expanded, $expanded);
  }
  $$self.$$.on_mount.push(function () {
    if (keys === undefined && !('keys' in $$props || $$self.$$.bound[$$self.$$.props['keys']])) {
      console.warn("<JSONNested> was created without expected prop 'keys'");
    }
  });
  const writable_props = ['keys', 'shouldShowColon', 'expandKey', 'defaultExpanded'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<JSONNested> was created with unknown prop '".concat(key, "'"));
  });
  const click_handler = index => child_expanded[index].update(value => !value);
  $$self.$$set = $$props => {
    if ('keys' in $$props) $$invalidate(0, keys = $$props.keys);
    if ('shouldShowColon' in $$props) $$invalidate(1, shouldShowColon = $$props.shouldShowColon);
    if ('expandKey' in $$props) $$invalidate(2, expandKey = $$props.expandKey);
    if ('defaultExpanded' in $$props) $$invalidate(10, defaultExpanded = $$props.defaultExpanded);
    if ('$$scope' in $$props) $$invalidate(13, $$scope = $$props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    JSONArrow,
    useState,
    writable,
    Summary,
    Expandable,
    keys,
    shouldShowColon,
    expandKey,
    defaultExpanded,
    isParentExpanded,
    displayMode,
    root,
    expanded,
    expandable,
    keyPath,
    level,
    shouldExpandNode,
    toggleExpand,
    child_expanded,
    $expanded,
    $expandable
  });
  $$self.$inject_state = $$props => {
    if ('keys' in $$props) $$invalidate(0, keys = $$props.keys);
    if ('shouldShowColon' in $$props) $$invalidate(1, shouldShowColon = $$props.shouldShowColon);
    if ('expandKey' in $$props) $$invalidate(2, expandKey = $$props.expandKey);
    if ('defaultExpanded' in $$props) $$invalidate(10, defaultExpanded = $$props.defaultExpanded);
    if ('child_expanded' in $$props) $$invalidate(3, child_expanded = $$props.child_expanded);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*keys*/1) {
      $$invalidate(3, child_expanded = keys.map(() => writable(false)));
    }
  };
  return [keys, shouldShowColon, expandKey, child_expanded, $expanded, displayMode, root, expanded, expandable, toggleExpand, defaultExpanded, slots, click_handler, $$scope];
}
class JSONNested extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$j, create_fragment$k, safe_not_equal, {
      keys: 0,
      shouldShowColon: 1,
      expandKey: 2,
      defaultExpanded: 10
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "JSONNested",
      options,
      id: create_fragment$k.name
    });
  }
  get keys() {
    throw new Error("<JSONNested>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keys(value) {
    throw new Error("<JSONNested>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shouldShowColon() {
    throw new Error("<JSONNested>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set shouldShowColon(value) {
    throw new Error("<JSONNested>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get expandKey() {
    throw new Error("<JSONNested>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set expandKey(value) {
    throw new Error("<JSONNested>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultExpanded() {
    throw new Error("<JSONNested>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultExpanded(value) {
    throw new Error("<JSONNested>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}

/* ../../../node_modules/svelte-json-tree/_/PreviewList.svelte generated by Svelte v3.59.2 */
const file$i = "../../../node_modules/svelte-json-tree/_/PreviewList.svelte";
function get_each_context$4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  child_ctx[9] = i;
  return child_ctx;
}
const get_item_slot_changes = dirty => ({
  item: dirty & /*list*/1
});
const get_item_slot_context = ctx => ({
  item: /*item*/ctx[7],
  index: /*index*/ctx[9]
});

// (8:0) {#if prefix}
function create_if_block_3$3(ctx) {
  let span;
  let t;
  let if_block = /*label*/ctx[2] && create_if_block_4$2(ctx);
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      span = element("span");
      t = text( /*prefix*/ctx[3]);
      this.h();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, /*prefix*/ctx[3]);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "operator");
      add_location(span, file$i, 7, 62, 212);
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx, dirty) {
      if ( /*label*/ctx[2]) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_4$2(ctx);
          if_block.c();
          if_block.m(span.parentNode, span);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*prefix*/8) set_data_dev(t, /*prefix*/ctx[3]);
    },
    d: function destroy(detaching) {
      if (if_block) if_block.d(detaching);
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3$3.name,
    type: "if",
    source: "(8:0) {#if prefix}",
    ctx
  });
  return block;
}

// (8:12) {#if label}
function create_if_block_4$2(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text( /*label*/ctx[2]);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, /*label*/ctx[2]);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "label");
      add_location(span, file$i, 7, 23, 173);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*label*/4) set_data_dev(t, /*label*/ctx[2]);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4$2.name,
    type: "if",
    source: "(8:12) {#if label}",
    ctx
  });
  return block;
}

// (11:2) {#if index < list.length - 1}
function create_if_block_2$3(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(",");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, ",");
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "comma operator svelte-150ffaa");
      add_location(span, file$i, 11, 4, 358);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2$3.name,
    type: "if",
    source: "(11:2) {#if index < list.length - 1}",
    ctx
  });
  return block;
}

// (9:0) {#each list as item, index}
function create_each_block$4(ctx) {
  let t;
  let if_block_anchor;
  let current;
  const item_slot_template = /*#slots*/ctx[6].item;
  const item_slot = create_slot(item_slot_template, ctx, /*$$scope*/ctx[5], get_item_slot_context);
  let if_block = /*index*/ctx[9] < /*list*/ctx[0].length - 1 && create_if_block_2$3(ctx);
  const block = {
    c: function create() {
      if (item_slot) item_slot.c();
      t = space();
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (item_slot) item_slot.l(nodes);
      t = claim_space(nodes);
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (item_slot) {
        item_slot.m(target, anchor);
      }
      insert_hydration_dev(target, t, anchor);
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      if (item_slot) {
        if (item_slot.p && (!current || dirty & /*$$scope, list*/33)) {
          update_slot_base(item_slot, item_slot_template, ctx, /*$$scope*/ctx[5], !current ? get_all_dirty_from_scope( /*$$scope*/ctx[5]) : get_slot_changes(item_slot_template, /*$$scope*/ctx[5], dirty, get_item_slot_changes), get_item_slot_context);
        }
      }
      if ( /*index*/ctx[9] < /*list*/ctx[0].length - 1) {
        if (if_block) ; else {
          if_block = create_if_block_2$3(ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(item_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(item_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (item_slot) item_slot.d(detaching);
      if (detaching) detach_dev(t);
      if (if_block) if_block.d(detaching);
      if (detaching) detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block$4.name,
    type: "each",
    source: "(9:0) {#each list as item, index}",
    ctx
  });
  return block;
}

// (15:0) {#if hasMore}
function create_if_block_1$5(ctx) {
  let span0;
  let t0;
  let t1;
  let span1;
  let t2;
  const block = {
    c: function create() {
      span0 = element("span");
      t0 = text(",");
      t1 = space();
      span1 = element("span");
      t2 = text("");
      this.h();
    },
    l: function claim(nodes) {
      span0 = claim_element(nodes, "SPAN", {
        class: true
      });
      var span0_nodes = children(span0);
      t0 = claim_text(span0_nodes, ",");
      span0_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      span1 = claim_element(nodes, "SPAN", {
        class: true
      });
      var span1_nodes = children(span1);
      t2 = claim_text(span1_nodes, "");
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "comma operator svelte-150ffaa");
      add_location(span0, file$i, 15, 2, 428);
      attr_dev(span1, "class", "operator");
      add_location(span1, file$i, 16, 2, 468);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span0, anchor);
      append_hydration_dev(span0, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, t2);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span0);
      if (detaching) detach_dev(t1);
      if (detaching) detach_dev(span1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1$5.name,
    type: "if",
    source: "(15:0) {#if hasMore}",
    ctx
  });
  return block;
}

// (19:0) {#if postfix}
function create_if_block$b(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text( /*postfix*/ctx[4]);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, /*postfix*/ctx[4]);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "operator");
      add_location(span, file$i, 18, 13, 519);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*postfix*/16) set_data_dev(t, /*postfix*/ctx[4]);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$b.name,
    type: "if",
    source: "(19:0) {#if postfix}",
    ctx
  });
  return block;
}
function create_fragment$j(ctx) {
  let t0;
  let t1;
  let t2;
  let if_block2_anchor;
  let current;
  let if_block0 = /*prefix*/ctx[3] && create_if_block_3$3(ctx);
  let each_value = /*list*/ctx[0];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
  }
  const out = i => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let if_block1 = /*hasMore*/ctx[1] && create_if_block_1$5(ctx);
  let if_block2 = /*postfix*/ctx[4] && create_if_block$b(ctx);
  const block = {
    c: function create() {
      if (if_block0) if_block0.c();
      t0 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0) if_block0.l(nodes);
      t0 = claim_space(nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      t1 = claim_space(nodes);
      if (if_block1) if_block1.l(nodes);
      t2 = claim_space(nodes);
      if (if_block2) if_block2.l(nodes);
      if_block2_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, t0, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, t1, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      if (if_block2) if_block2.m(target, anchor);
      insert_hydration_dev(target, if_block2_anchor, anchor);
      current = true;
    },
    p: function update(ctx, _ref) {
      let [dirty] = _ref;
      if ( /*prefix*/ctx[3]) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_3$3(ctx);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*list, $$scope*/33) {
        each_value = /*list*/ctx[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$4(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$4(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(t1.parentNode, t1);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if ( /*hasMore*/ctx[1]) {
        if (if_block1) ; else {
          if_block1 = create_if_block_1$5(ctx);
          if_block1.c();
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if ( /*postfix*/ctx[4]) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
        } else {
          if_block2 = create_if_block$b(ctx);
          if_block2.c();
          if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (if_block0) if_block0.d(detaching);
      if (detaching) detach_dev(t0);
      destroy_each(each_blocks, detaching);
      if (detaching) detach_dev(t1);
      if (if_block1) if_block1.d(detaching);
      if (detaching) detach_dev(t2);
      if (if_block2) if_block2.d(detaching);
      if (detaching) detach_dev(if_block2_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$j.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$i($$self, $$props, $$invalidate) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('PreviewList', slots, ['item']);
  let {
    list
  } = $$props;
  let {
    hasMore
  } = $$props;
  let {
    label = undefined
  } = $$props;
  let {
    prefix = undefined
  } = $$props;
  let {
    postfix = undefined
  } = $$props;
  $$self.$$.on_mount.push(function () {
    if (list === undefined && !('list' in $$props || $$self.$$.bound[$$self.$$.props['list']])) {
      console.warn("<PreviewList> was created without expected prop 'list'");
    }
    if (hasMore === undefined && !('hasMore' in $$props || $$self.$$.bound[$$self.$$.props['hasMore']])) {
      console.warn("<PreviewList> was created without expected prop 'hasMore'");
    }
  });
  const writable_props = ['list', 'hasMore', 'label', 'prefix', 'postfix'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<PreviewList> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$$set = $$props => {
    if ('list' in $$props) $$invalidate(0, list = $$props.list);
    if ('hasMore' in $$props) $$invalidate(1, hasMore = $$props.hasMore);
    if ('label' in $$props) $$invalidate(2, label = $$props.label);
    if ('prefix' in $$props) $$invalidate(3, prefix = $$props.prefix);
    if ('postfix' in $$props) $$invalidate(4, postfix = $$props.postfix);
    if ('$$scope' in $$props) $$invalidate(5, $$scope = $$props.$$scope);
  };
  $$self.$capture_state = () => ({
    list,
    hasMore,
    label,
    prefix,
    postfix
  });
  $$self.$inject_state = $$props => {
    if ('list' in $$props) $$invalidate(0, list = $$props.list);
    if ('hasMore' in $$props) $$invalidate(1, hasMore = $$props.hasMore);
    if ('label' in $$props) $$invalidate(2, label = $$props.label);
    if ('prefix' in $$props) $$invalidate(3, prefix = $$props.prefix);
    if ('postfix' in $$props) $$invalidate(4, postfix = $$props.postfix);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [list, hasMore, label, prefix, postfix, $$scope, slots];
}
class PreviewList extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$i, create_fragment$j, safe_not_equal, {
      list: 0,
      hasMore: 1,
      label: 2,
      prefix: 3,
      postfix: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PreviewList",
      options,
      id: create_fragment$j.name
    });
  }
  get list() {
    throw new Error("<PreviewList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set list(value) {
    throw new Error("<PreviewList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hasMore() {
    throw new Error("<PreviewList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hasMore(value) {
    throw new Error("<PreviewList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<PreviewList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<PreviewList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get prefix() {
    throw new Error("<PreviewList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set prefix(value) {
    throw new Error("<PreviewList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get postfix() {
    throw new Error("<PreviewList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set postfix(value) {
    throw new Error("<PreviewList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}

/* ../../../node_modules/svelte-json-tree/_/JSONObjectNode.svelte generated by Svelte v3.59.2 */
const {
  Object: Object_1$3
} = globals;
const file$h = "../../../node_modules/svelte-json-tree/_/JSONObjectNode.svelte";

// (10:2) <svelte:fragment slot="summary">
function create_summary_slot$8(ctx) {
  let span;
  let t_value = '{}' + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "label");
      add_location(span, file$h, 9, 34, 308);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_summary_slot$8.name,
    type: "slot",
    source: "(10:2) <svelte:fragment slot=\\\"summary\\\">",
    ctx
  });
  return block;
}

// (13:6) <svelte:fragment slot="item" let:item         >
function create_item_slot$5(ctx) {
  let span0;
  let t0_value = /*item*/ctx[4] + "";
  let t0;
  let span1;
  let t1_value = ': ' + "";
  let t1;
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: /*value*/ctx[0][/*item*/ctx[4]]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      span0 = element("span");
      t0 = text(t0_value);
      span1 = element("span");
      t1 = text(t1_value);
      create_component(jsonnode.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      span0 = claim_element(nodes, "SPAN", {
        class: true
      });
      var span0_nodes = children(span0);
      t0 = claim_text(span0_nodes, t0_value);
      span0_nodes.forEach(detach_dev);
      span1 = claim_element(nodes, "SPAN", {
        class: true
      });
      var span1_nodes = children(span1);
      t1 = claim_text(span1_nodes, t1_value);
      span1_nodes.forEach(detach_dev);
      claim_component(jsonnode.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "property");
      add_location(span0, file$h, 13, 9, 556);
      attr_dev(span1, "class", "operator");
      add_location(span1, file$h, 13, 45, 592);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span0, anchor);
      append_hydration_dev(span0, t0);
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, t1);
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      if ((!current || dirty & /*item*/16) && t0_value !== (t0_value = /*item*/ctx[4] + "")) set_data_dev(t0, t0_value);
      const jsonnode_changes = {};
      if (dirty & /*value, item*/17) jsonnode_changes.value = /*value*/ctx[0][/*item*/ctx[4]];
      jsonnode.$set(jsonnode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span0);
      if (detaching) detach_dev(span1);
      destroy_component(jsonnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_slot$5.name,
    type: "slot",
    source: "(13:6) <svelte:fragment slot=\\\"item\\\" let:item         >",
    ctx
  });
  return block;
}

// (11:2) <svelte:fragment slot="preview">
function create_preview_slot$8(ctx) {
  let previewlist;
  let current;
  previewlist = new PreviewList({
    props: {
      list: /*previewKeys*/ctx[2],
      hasMore: /*previewKeys*/ctx[2].length < /*keys*/ctx[1].length,
      prefix: '{',
      postfix: '}',
      $$slots: {
        item: [create_item_slot$5, _ref => {
          let {
            item
          } = _ref;
          return {
            4: item
          };
        }, _ref2 => {
          let {
            item
          } = _ref2;
          return item ? 16 : 0;
        }]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(previewlist.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(previewlist.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(previewlist, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const previewlist_changes = {};
      if (dirty & /*previewKeys*/4) previewlist_changes.list = /*previewKeys*/ctx[2];
      if (dirty & /*previewKeys, keys*/6) previewlist_changes.hasMore = /*previewKeys*/ctx[2].length < /*keys*/ctx[1].length;
      if (dirty & /*$$scope, value, item*/49) {
        previewlist_changes.$$scope = {
          dirty,
          ctx
        };
      }
      previewlist.$set(previewlist_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(previewlist.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(previewlist.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(previewlist, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_preview_slot$8.name,
    type: "slot",
    source: "(11:2) <svelte:fragment slot=\\\"preview\\\">",
    ctx
  });
  return block;
}

// (18:2) <svelte:fragment slot="item_key" let:key>
function create_item_key_slot$8(ctx) {
  let span;
  let t_value = /*key*/ctx[3] + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "property");
      add_location(span, file$h, 17, 43, 769);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*key*/8 && t_value !== (t_value = /*key*/ctx[3] + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_key_slot$8.name,
    type: "slot",
    source: "(18:2) <svelte:fragment slot=\\\"item_key\\\" let:key>",
    ctx
  });
  return block;
}

// (19:2) <svelte:fragment slot="item_value" let:key>
function create_item_value_slot$8(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: /*value*/ctx[0][/*key*/ctx[3]]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const jsonnode_changes = {};
      if (dirty & /*value, key*/9) jsonnode_changes.value = /*value*/ctx[0][/*key*/ctx[3]];
      jsonnode.$set(jsonnode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_value_slot$8.name,
    type: "slot",
    source: "(19:2) <svelte:fragment slot=\\\"item_value\\\" let:key>",
    ctx
  });
  return block;
}
function create_fragment$i(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: /*keys*/ctx[1],
      $$slots: {
        item_value: [create_item_value_slot$8, _ref3 => {
          let {
            key
          } = _ref3;
          return {
            3: key
          };
        }, _ref4 => {
          let {
            key
          } = _ref4;
          return key ? 8 : 0;
        }],
        item_key: [create_item_key_slot$8, _ref5 => {
          let {
            key
          } = _ref5;
          return {
            3: key
          };
        }, _ref6 => {
          let {
            key
          } = _ref6;
          return key ? 8 : 0;
        }],
        preview: [create_preview_slot$8],
        summary: [create_summary_slot$8]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnested.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnested.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p: function update(ctx, _ref7) {
      let [dirty] = _ref7;
      const jsonnested_changes = {};
      if (dirty & /*keys*/2) jsonnested_changes.keys = /*keys*/ctx[1];
      if (dirty & /*$$scope, value, key, previewKeys, keys*/47) {
        jsonnested_changes.$$scope = {
          dirty,
          ctx
        };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$i.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$h($$self, $$props, $$invalidate) {
  let keys;
  let previewKeys;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('JSONObjectNode', slots, []);
  let {
    value
  } = $$props;
  $$self.$$.on_mount.push(function () {
    if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
      console.warn("<JSONObjectNode> was created without expected prop 'value'");
    }
  });
  const writable_props = ['value'];
  Object_1$3.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<JSONObjectNode> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$$set = $$props => {
    if ('value' in $$props) $$invalidate(0, value = $$props.value);
  };
  $$self.$capture_state = () => ({
    JSONNested,
    JSONNode,
    PreviewList,
    value,
    keys,
    previewKeys
  });
  $$self.$inject_state = $$props => {
    if ('value' in $$props) $$invalidate(0, value = $$props.value);
    if ('keys' in $$props) $$invalidate(1, keys = $$props.keys);
    if ('previewKeys' in $$props) $$invalidate(2, previewKeys = $$props.previewKeys);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/1) {
      $$invalidate(1, keys = Object.getOwnPropertyNames(value));
    }
    if ($$self.$$.dirty & /*keys*/2) {
      $$invalidate(2, previewKeys = keys.slice(0, 5));
    }
  };
  return [value, keys, previewKeys];
}
class JSONObjectNode extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$h, create_fragment$i, safe_not_equal, {
      value: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "JSONObjectNode",
      options,
      id: create_fragment$i.name
    });
  }
  get value() {
    throw new Error("<JSONObjectNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<JSONObjectNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}

/* ../../../node_modules/svelte-json-tree/_/JSONArrayNode.svelte generated by Svelte v3.59.2 */
const {
  Object: Object_1$2
} = globals;
const file$g = "../../../node_modules/svelte-json-tree/_/JSONArrayNode.svelte";

// (10:2) <svelte:fragment slot="summary">
function create_summary_slot$7(ctx) {
  let span;
  let t0;
  let t1_value = /*value*/ctx[0].length + "";
  let t1;
  let t2;
  const block = {
    c: function create() {
      span = element("span");
      t0 = text("Array(");
      t1 = text(t1_value);
      t2 = text(")");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, "Array(");
      t1 = claim_text(span_nodes, t1_value);
      t2 = claim_text(span_nodes, ")");
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "label");
      add_location(span, file$g, 9, 34, 305);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t0);
      append_hydration_dev(span, t1);
      append_hydration_dev(span, t2);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*value*/1 && t1_value !== (t1_value = /*value*/ctx[0].length + "")) set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_summary_slot$7.name,
    type: "slot",
    source: "(10:2) <svelte:fragment slot=\\\"summary\\\">",
    ctx
  });
  return block;
}

// (13:6) <svelte:fragment slot="item" let:item>
function create_item_slot$4(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: /*item*/ctx[4]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const jsonnode_changes = {};
      if (dirty & /*item*/16) jsonnode_changes.value = /*item*/ctx[4];
      jsonnode.$set(jsonnode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_slot$4.name,
    type: "slot",
    source: "(13:6) <svelte:fragment slot=\\\"item\\\" let:item>",
    ctx
  });
  return block;
}

// (11:2) <svelte:fragment slot="preview">
function create_preview_slot$7(ctx) {
  let previewlist;
  let current;
  previewlist = new PreviewList({
    props: {
      list: /*preview*/ctx[1],
      hasMore: /*preview*/ctx[1].length < /*value*/ctx[0].length,
      label: "(" + /*value*/ctx[0].length + ") ",
      prefix: "[",
      postfix: "]",
      $$slots: {
        item: [create_item_slot$4, _ref => {
          let {
            item
          } = _ref;
          return {
            4: item
          };
        }, _ref2 => {
          let {
            item
          } = _ref2;
          return item ? 16 : 0;
        }]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(previewlist.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(previewlist.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(previewlist, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const previewlist_changes = {};
      if (dirty & /*preview*/2) previewlist_changes.list = /*preview*/ctx[1];
      if (dirty & /*preview, value*/3) previewlist_changes.hasMore = /*preview*/ctx[1].length < /*value*/ctx[0].length;
      if (dirty & /*value*/1) previewlist_changes.label = "(" + /*value*/ctx[0].length + ") ";
      if (dirty & /*$$scope, item*/48) {
        previewlist_changes.$$scope = {
          dirty,
          ctx
        };
      }
      previewlist.$set(previewlist_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(previewlist.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(previewlist.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(previewlist, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_preview_slot$7.name,
    type: "slot",
    source: "(11:2) <svelte:fragment slot=\\\"preview\\\">",
    ctx
  });
  return block;
}

// (18:2) <svelte:fragment slot="item_key" let:key>
function create_item_key_slot$7(ctx) {
  let span;
  let t_value = String( /*key*/ctx[3]) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "property");
      add_location(span, file$g, 17, 43, 716);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*key*/8 && t_value !== (t_value = String( /*key*/ctx[3]) + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_key_slot$7.name,
    type: "slot",
    source: "(18:2) <svelte:fragment slot=\\\"item_key\\\" let:key>",
    ctx
  });
  return block;
}

// (19:2) <svelte:fragment slot="item_value" let:key>
function create_item_value_slot$7(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: /*value*/ctx[0][/*key*/ctx[3]]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const jsonnode_changes = {};
      if (dirty & /*value, key*/9) jsonnode_changes.value = /*value*/ctx[0][/*key*/ctx[3]];
      jsonnode.$set(jsonnode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_value_slot$7.name,
    type: "slot",
    source: "(19:2) <svelte:fragment slot=\\\"item_value\\\" let:key>",
    ctx
  });
  return block;
}
function create_fragment$h(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: /*keys*/ctx[2],
      $$slots: {
        item_value: [create_item_value_slot$7, _ref3 => {
          let {
            key
          } = _ref3;
          return {
            3: key
          };
        }, _ref4 => {
          let {
            key
          } = _ref4;
          return key ? 8 : 0;
        }],
        item_key: [create_item_key_slot$7, _ref5 => {
          let {
            key
          } = _ref5;
          return {
            3: key
          };
        }, _ref6 => {
          let {
            key
          } = _ref6;
          return key ? 8 : 0;
        }],
        preview: [create_preview_slot$7],
        summary: [create_summary_slot$7]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnested.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnested.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p: function update(ctx, _ref7) {
      let [dirty] = _ref7;
      const jsonnested_changes = {};
      if (dirty & /*keys*/4) jsonnested_changes.keys = /*keys*/ctx[2];
      if (dirty & /*$$scope, value, key, preview*/43) {
        jsonnested_changes.$$scope = {
          dirty,
          ctx
        };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$h.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$g($$self, $$props, $$invalidate) {
  let keys;
  let preview;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('JSONArrayNode', slots, []);
  let {
    value
  } = $$props;
  $$self.$$.on_mount.push(function () {
    if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
      console.warn("<JSONArrayNode> was created without expected prop 'value'");
    }
  });
  const writable_props = ['value'];
  Object_1$2.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<JSONArrayNode> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$$set = $$props => {
    if ('value' in $$props) $$invalidate(0, value = $$props.value);
  };
  $$self.$capture_state = () => ({
    JSONNested,
    JSONNode,
    PreviewList,
    value,
    preview,
    keys
  });
  $$self.$inject_state = $$props => {
    if ('value' in $$props) $$invalidate(0, value = $$props.value);
    if ('preview' in $$props) $$invalidate(1, preview = $$props.preview);
    if ('keys' in $$props) $$invalidate(2, keys = $$props.keys);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/1) {
      $$invalidate(2, keys = Object.getOwnPropertyNames(value));
    }
    if ($$self.$$.dirty & /*value*/1) {
      $$invalidate(1, preview = value.slice(0, 5));
    }
  };
  return [value, preview, keys];
}
class JSONArrayNode extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$g, create_fragment$h, safe_not_equal, {
      value: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "JSONArrayNode",
      options,
      id: create_fragment$h.name
    });
  }
  get value() {
    throw new Error("<JSONArrayNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<JSONArrayNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}

/* ../../../node_modules/svelte-json-tree/_/JSONIterableArrayNode.svelte generated by Svelte v3.59.2 */
const file$f = "../../../node_modules/svelte-json-tree/_/JSONIterableArrayNode.svelte";

// (24:2) <svelte:fragment slot="summary">
function create_summary_slot$6(ctx) {
  let span;
  let t0;
  let t1;
  let t2_value = /*indexes*/ctx[3].length + "";
  let t2;
  let t3;
  const block = {
    c: function create() {
      span = element("span");
      t0 = text( /*nodeType*/ctx[1]);
      t1 = text("(");
      t2 = text(t2_value);
      t3 = text(")");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, /*nodeType*/ctx[1]);
      t1 = claim_text(span_nodes, "(");
      t2 = claim_text(span_nodes, t2_value);
      t3 = claim_text(span_nodes, ")");
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "label");
      add_location(span, file$f, 23, 34, 617);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t0);
      append_hydration_dev(span, t1);
      append_hydration_dev(span, t2);
      append_hydration_dev(span, t3);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*nodeType*/2) set_data_dev(t0, /*nodeType*/ctx[1]);
      if (dirty & /*indexes*/8 && t2_value !== (t2_value = /*indexes*/ctx[3].length + "")) set_data_dev(t2, t2_value);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_summary_slot$6.name,
    type: "slot",
    source: "(24:2) <svelte:fragment slot=\\\"summary\\\">",
    ctx
  });
  return block;
}

// (27:6) <svelte:fragment slot="item" let:item>
function create_item_slot$3(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: /*item*/ctx[8]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const jsonnode_changes = {};
      if (dirty & /*item*/256) jsonnode_changes.value = /*item*/ctx[8];
      jsonnode.$set(jsonnode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_slot$3.name,
    type: "slot",
    source: "(27:6) <svelte:fragment slot=\\\"item\\\" let:item>",
    ctx
  });
  return block;
}

// (25:2) <svelte:fragment slot="preview">
function create_preview_slot$6(ctx) {
  let previewlist;
  let current;
  previewlist = new PreviewList({
    props: {
      list: /*previewItems*/ctx[4],
      hasMore: /*previewItems*/ctx[4].length < /*items*/ctx[2].length,
      label: "".concat( /*nodeType*/ctx[1], "(").concat( /*indexes*/ctx[3].length, ") "),
      prefix: '{',
      postfix: "}",
      $$slots: {
        item: [create_item_slot$3, _ref => {
          let {
            item
          } = _ref;
          return {
            8: item
          };
        }, _ref2 => {
          let {
            item
          } = _ref2;
          return item ? 256 : 0;
        }]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(previewlist.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(previewlist.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(previewlist, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const previewlist_changes = {};
      if (dirty & /*previewItems*/16) previewlist_changes.list = /*previewItems*/ctx[4];
      if (dirty & /*previewItems, items*/20) previewlist_changes.hasMore = /*previewItems*/ctx[4].length < /*items*/ctx[2].length;
      if (dirty & /*nodeType, indexes*/10) previewlist_changes.label = "".concat( /*nodeType*/ctx[1], "(").concat( /*indexes*/ctx[3].length, ") ");
      if (dirty & /*$$scope, item*/768) {
        previewlist_changes.$$scope = {
          dirty,
          ctx
        };
      }
      previewlist.$set(previewlist_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(previewlist.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(previewlist.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(previewlist, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_preview_slot$6.name,
    type: "slot",
    source: "(25:2) <svelte:fragment slot=\\\"preview\\\">",
    ctx
  });
  return block;
}

// (33:2) <svelte:fragment slot="item_key" let:key>
function create_item_key_slot_1$1(ctx) {
  let span;
  let t_value = /*key*/ctx[6] + "";
  let t;
  let span_class_value;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*key*/ctx[6] === ENTRIES$1 ? 'internal' : 'property');
      add_location(span, file$f, 32, 43, 1064);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*key*/64 && t_value !== (t_value = /*key*/ctx[6] + "")) set_data_dev(t, t_value);
      if (dirty & /*key*/64 && span_class_value !== (span_class_value = /*key*/ctx[6] === ENTRIES$1 ? 'internal' : 'property')) {
        attr_dev(span, "class", span_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_key_slot_1$1.name,
    type: "slot",
    source: "(33:2) <svelte:fragment slot=\\\"item_key\\\" let:key>",
    ctx
  });
  return block;
}

// (40:4) {:else}
function create_else_block$7(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: /*value*/ctx[0][/*key*/ctx[6]]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const jsonnode_changes = {};
      if (dirty & /*value, key*/65) jsonnode_changes.value = /*value*/ctx[0][/*key*/ctx[6]];
      jsonnode.$set(jsonnode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block$7.name,
    type: "else",
    source: "(40:4) {:else}",
    ctx
  });
  return block;
}

// (35:4) {#if key === ENTRIES}
function create_if_block$a(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: /*indexes*/ctx[3],
      defaultExpanded: true,
      $$slots: {
        item_value: [create_item_value_slot_1$1, _ref3 => {
          let {
            key: index
          } = _ref3;
          return {
            7: index
          };
        }, _ref4 => {
          let {
            key: index
          } = _ref4;
          return index ? 128 : 0;
        }],
        item_key: [create_item_key_slot$6, _ref5 => {
          let {
            key: index
          } = _ref5;
          return {
            7: index
          };
        }, _ref6 => {
          let {
            key: index
          } = _ref6;
          return index ? 128 : 0;
        }]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnested.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnested.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const jsonnested_changes = {};
      if (dirty & /*indexes*/8) jsonnested_changes.keys = /*indexes*/ctx[3];
      if (dirty & /*$$scope, items, index*/644) {
        jsonnested_changes.$$scope = {
          dirty,
          ctx
        };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$a.name,
    type: "if",
    source: "(35:4) {#if key === ENTRIES}",
    ctx
  });
  return block;
}

// (37:8) <svelte:fragment slot="item_key" let:key={index}>
function create_item_key_slot$6(ctx) {
  let span;
  let t_value = /*index*/ctx[7] + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "property");
      add_location(span, file$f, 36, 57, 1330);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*index*/128 && t_value !== (t_value = /*index*/ctx[7] + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_key_slot$6.name,
    type: "slot",
    source: "(37:8) <svelte:fragment slot=\\\"item_key\\\" let:key={index}>",
    ctx
  });
  return block;
}

// (38:8) <svelte:fragment slot="item_value" let:key={index}>
function create_item_value_slot_1$1(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: /*items*/ctx[2][/*index*/ctx[7]]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const jsonnode_changes = {};
      if (dirty & /*items, index*/132) jsonnode_changes.value = /*items*/ctx[2][/*index*/ctx[7]];
      jsonnode.$set(jsonnode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_value_slot_1$1.name,
    type: "slot",
    source: "(38:8) <svelte:fragment slot=\\\"item_value\\\" let:key={index}>",
    ctx
  });
  return block;
}

// (34:2) <svelte:fragment slot="item_value" let:key>
function create_item_value_slot$6(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$a, create_else_block$7];
  const if_blocks = [];
  function select_block_type(ctx, dirty) {
    if ( /*key*/ctx[6] === ENTRIES$1) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching) detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_value_slot$6.name,
    type: "slot",
    source: "(34:2) <svelte:fragment slot=\\\"item_value\\\" let:key>",
    ctx
  });
  return block;
}
function create_fragment$g(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: [ENTRIES$1, 'size'],
      shouldShowColon: /*func*/ctx[5],
      $$slots: {
        item_value: [create_item_value_slot$6, _ref7 => {
          let {
            key
          } = _ref7;
          return {
            6: key
          };
        }, _ref8 => {
          let {
            key
          } = _ref8;
          return key ? 64 : 0;
        }],
        item_key: [create_item_key_slot_1$1, _ref9 => {
          let {
            key
          } = _ref9;
          return {
            6: key
          };
        }, _ref10 => {
          let {
            key
          } = _ref10;
          return key ? 64 : 0;
        }],
        preview: [create_preview_slot$6],
        summary: [create_summary_slot$6]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnested.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnested.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p: function update(ctx, _ref11) {
      let [dirty] = _ref11;
      const jsonnested_changes = {};
      if (dirty & /*$$scope, indexes, items, key, value, previewItems, nodeType*/607) {
        jsonnested_changes.$$scope = {
          dirty,
          ctx
        };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$g.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
const ENTRIES$1 = '[[Entries]]';
function instance$f($$self, $$props, $$invalidate) {
  let previewItems;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('JSONIterableArrayNode', slots, []);
  let {
    value
  } = $$props;
  let {
    nodeType
  } = $$props;
  let indexes = [];
  let items = [];
  $$self.$$.on_mount.push(function () {
    if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
      console.warn("<JSONIterableArrayNode> was created without expected prop 'value'");
    }
    if (nodeType === undefined && !('nodeType' in $$props || $$self.$$.bound[$$self.$$.props['nodeType']])) {
      console.warn("<JSONIterableArrayNode> was created without expected prop 'nodeType'");
    }
  });
  const writable_props = ['value', 'nodeType'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<JSONIterableArrayNode> was created with unknown prop '".concat(key, "'"));
  });
  const func = key => key !== ENTRIES$1;
  $$self.$$set = $$props => {
    if ('value' in $$props) $$invalidate(0, value = $$props.value);
    if ('nodeType' in $$props) $$invalidate(1, nodeType = $$props.nodeType);
  };
  $$self.$capture_state = () => ({
    JSONNested,
    JSONNode,
    PreviewList,
    value,
    nodeType,
    indexes,
    items,
    ENTRIES: ENTRIES$1,
    previewItems
  });
  $$self.$inject_state = $$props => {
    if ('value' in $$props) $$invalidate(0, value = $$props.value);
    if ('nodeType' in $$props) $$invalidate(1, nodeType = $$props.nodeType);
    if ('indexes' in $$props) $$invalidate(3, indexes = $$props.indexes);
    if ('items' in $$props) $$invalidate(2, items = $$props.items);
    if ('previewItems' in $$props) $$invalidate(4, previewItems = $$props.previewItems);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/1) {
      {
        let _indexes = [];
        let _items = [];
        let i = 0;
        for (const entry of value) {
          _indexes.push(i++);
          _items.push(entry);
        }
        $$invalidate(3, indexes = _indexes);
        $$invalidate(2, items = _items);
      }
    }
    if ($$self.$$.dirty & /*items*/4) {
      $$invalidate(4, previewItems = items.slice(0, 5));
    }
  };
  return [value, nodeType, items, indexes, previewItems, func];
}
class JSONIterableArrayNode extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$f, create_fragment$g, safe_not_equal, {
      value: 0,
      nodeType: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "JSONIterableArrayNode",
      options,
      id: create_fragment$g.name
    });
  }
  get value() {
    throw new Error("<JSONIterableArrayNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<JSONIterableArrayNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeType() {
    throw new Error("<JSONIterableArrayNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeType(value) {
    throw new Error("<JSONIterableArrayNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}

/* ../../../node_modules/svelte-json-tree/_/JSONIterableMapNode.svelte generated by Svelte v3.59.2 */
const file$e = "../../../node_modules/svelte-json-tree/_/JSONIterableMapNode.svelte";

// (29:2) <svelte:fragment slot="summary">
function create_summary_slot$5(ctx) {
  let span;
  let t0;
  let t1_value = /*keys*/ctx[2].length + "";
  let t1;
  let t2;
  const block = {
    c: function create() {
      span = element("span");
      t0 = text("Map(");
      t1 = text(t1_value);
      t2 = text(")");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        color: true
      });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, "Map(");
      t1 = claim_text(span_nodes, t1_value);
      t2 = claim_text(span_nodes, ")");
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "color", "label");
      add_location(span, file$e, 28, 34, 761);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t0);
      append_hydration_dev(span, t1);
      append_hydration_dev(span, t2);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*keys*/4 && t1_value !== (t1_value = /*keys*/ctx[2].length + "")) set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_summary_slot$5.name,
    type: "slot",
    source: "(29:2) <svelte:fragment slot=\\\"summary\\\">",
    ctx
  });
  return block;
}

// (32:6) <svelte:fragment slot="item" let:item>
function create_item_slot$2(ctx) {
  let jsonnode0;
  let span;
  let t_value = ' => ' + "";
  let t;
  let jsonnode1;
  let current;
  jsonnode0 = new JSONNode({
    props: {
      value: /*item*/ctx[10]
    },
    $$inline: true
  });
  jsonnode1 = new JSONNode({
    props: {
      value: /*value*/ctx[0].get( /*item*/ctx[10])
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnode0.$$.fragment);
      span = element("span");
      t = text(t_value);
      create_component(jsonnode1.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      claim_component(jsonnode0.$$.fragment, nodes);
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      claim_component(jsonnode1.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "operator");
      add_location(span, file$e, 32, 33, 1073);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnode0, target, anchor);
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
      mount_component(jsonnode1, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const jsonnode0_changes = {};
      if (dirty & /*item*/1024) jsonnode0_changes.value = /*item*/ctx[10];
      jsonnode0.$set(jsonnode0_changes);
      const jsonnode1_changes = {};
      if (dirty & /*value, item*/1025) jsonnode1_changes.value = /*value*/ctx[0].get( /*item*/ctx[10]);
      jsonnode1.$set(jsonnode1_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnode0.$$.fragment, local);
      transition_in(jsonnode1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode0.$$.fragment, local);
      transition_out(jsonnode1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnode0, detaching);
      if (detaching) detach_dev(span);
      destroy_component(jsonnode1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_slot$2.name,
    type: "slot",
    source: "(32:6) <svelte:fragment slot=\\\"item\\\" let:item>",
    ctx
  });
  return block;
}

// (30:2) <svelte:fragment slot="preview">
function create_preview_slot_1(ctx) {
  let previewlist;
  let current;
  previewlist = new PreviewList({
    props: {
      list: /*previewKeys*/ctx[4],
      hasMore: /*previewKeys*/ctx[4].length < /*value*/ctx[0].size,
      label: "Map(".concat( /*keys*/ctx[2].length, ") "),
      prefix: "{",
      postfix: "}",
      $$slots: {
        item: [create_item_slot$2, _ref => {
          let {
            item
          } = _ref;
          return {
            10: item
          };
        }, _ref2 => {
          let {
            item
          } = _ref2;
          return item ? 1024 : 0;
        }]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(previewlist.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(previewlist.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(previewlist, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const previewlist_changes = {};
      if (dirty & /*previewKeys*/16) previewlist_changes.list = /*previewKeys*/ctx[4];
      if (dirty & /*previewKeys, value*/17) previewlist_changes.hasMore = /*previewKeys*/ctx[4].length < /*value*/ctx[0].size;
      if (dirty & /*keys*/4) previewlist_changes.label = "Map(".concat( /*keys*/ctx[2].length, ") ");
      if (dirty & /*$$scope, value, item*/3073) {
        previewlist_changes.$$scope = {
          dirty,
          ctx
        };
      }
      previewlist.$set(previewlist_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(previewlist.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(previewlist.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(previewlist, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_preview_slot_1.name,
    type: "slot",
    source: "(30:2) <svelte:fragment slot=\\\"preview\\\">",
    ctx
  });
  return block;
}

// (38:2) <svelte:fragment slot="item_key" let:key>
function create_item_key_slot_2(ctx) {
  let span;
  let t_value = /*key*/ctx[7] + "";
  let t;
  let span_class_value;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*key*/ctx[7] === ENTRIES ? 'internal' : 'property');
      add_location(span, file$e, 37, 43, 1257);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*key*/128 && t_value !== (t_value = /*key*/ctx[7] + "")) set_data_dev(t, t_value);
      if (dirty & /*key*/128 && span_class_value !== (span_class_value = /*key*/ctx[7] === ENTRIES ? 'internal' : 'property')) {
        attr_dev(span, "class", span_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_key_slot_2.name,
    type: "slot",
    source: "(38:2) <svelte:fragment slot=\\\"item_key\\\" let:key>",
    ctx
  });
  return block;
}

// (56:4) {:else}
function create_else_block$6(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: /*value*/ctx[0][/*key*/ctx[7]]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const jsonnode_changes = {};
      if (dirty & /*value, key*/129) jsonnode_changes.value = /*value*/ctx[0][/*key*/ctx[7]];
      jsonnode.$set(jsonnode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block$6.name,
    type: "else",
    source: "(56:4) {:else}",
    ctx
  });
  return block;
}

// (40:4) {#if key === ENTRIES}
function create_if_block$9(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: /*indexes*/ctx[1],
      expandKey: /*func*/ctx[5],
      defaultExpanded: true,
      $$slots: {
        item_value: [create_item_value_slot_1, _ref3 => {
          let {
            key: index
          } = _ref3;
          return {
            8: index
          };
        }, _ref4 => {
          let {
            key: index
          } = _ref4;
          return index ? 256 : 0;
        }],
        item_key: [create_item_key_slot_1, _ref5 => {
          let {
            key: index
          } = _ref5;
          return {
            8: index
          };
        }, _ref6 => {
          let {
            key: index
          } = _ref6;
          return index ? 256 : 0;
        }]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnested.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnested.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const jsonnested_changes = {};
      if (dirty & /*indexes*/2) jsonnested_changes.keys = /*indexes*/ctx[1];
      if (dirty & /*keys*/4) jsonnested_changes.expandKey = /*func*/ctx[5];
      if (dirty & /*$$scope, keys, index, values*/2316) {
        jsonnested_changes.$$scope = {
          dirty,
          ctx
        };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$9.name,
    type: "if",
    source: "(40:4) {#if key === ENTRIES}",
    ctx
  });
  return block;
}

// (41:8) <svelte:fragment slot="item_key" let:key={index}>
function create_item_key_slot_1(ctx) {
  let span;
  let t_value = /*index*/ctx[8] + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "property");
      add_location(span, file$e, 40, 57, 1551);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*index*/256 && t_value !== (t_value = /*index*/ctx[8] + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_key_slot_1.name,
    type: "slot",
    source: "(41:8) <svelte:fragment slot=\\\"item_key\\\" let:key={index}>",
    ctx
  });
  return block;
}

// (44:12) <svelte:fragment slot="preview"               >
function create_preview_slot$5(ctx) {
  let span0;
  let t0_value = '{ ' + "";
  let t0;
  let jsonnode0;
  let span1;
  let t1_value = ' => ' + "";
  let t1;
  let jsonnode1;
  let span2;
  let t2_value = ' }' + "";
  let t2;
  let current;
  jsonnode0 = new JSONNode({
    props: {
      value: /*keys*/ctx[2][/*index*/ctx[8]]
    },
    $$inline: true
  });
  jsonnode1 = new JSONNode({
    props: {
      value: /*values*/ctx[3][/*index*/ctx[8]]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      span0 = element("span");
      t0 = text(t0_value);
      create_component(jsonnode0.$$.fragment);
      span1 = element("span");
      t1 = text(t1_value);
      create_component(jsonnode1.$$.fragment);
      span2 = element("span");
      t2 = text(t2_value);
      this.h();
    },
    l: function claim(nodes) {
      span0 = claim_element(nodes, "SPAN", {
        class: true
      });
      var span0_nodes = children(span0);
      t0 = claim_text(span0_nodes, t0_value);
      span0_nodes.forEach(detach_dev);
      claim_component(jsonnode0.$$.fragment, nodes);
      span1 = claim_element(nodes, "SPAN", {
        class: true
      });
      var span1_nodes = children(span1);
      t1 = claim_text(span1_nodes, t1_value);
      span1_nodes.forEach(detach_dev);
      claim_component(jsonnode1.$$.fragment, nodes);
      span2 = claim_element(nodes, "SPAN", {
        class: true
      });
      var span2_nodes = children(span2);
      t2 = claim_text(span2_nodes, t2_value);
      span2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "operator");
      add_location(span0, file$e, 44, 15, 1773);
      attr_dev(span1, "class", "operator");
      add_location(span1, file$e, 44, 83, 1841);
      attr_dev(span2, "class", "operator");
      add_location(span2, file$e, 46, 16, 1943);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span0, anchor);
      append_hydration_dev(span0, t0);
      mount_component(jsonnode0, target, anchor);
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, t1);
      mount_component(jsonnode1, target, anchor);
      insert_hydration_dev(target, span2, anchor);
      append_hydration_dev(span2, t2);
      current = true;
    },
    p: function update(ctx, dirty) {
      const jsonnode0_changes = {};
      if (dirty & /*keys, index*/260) jsonnode0_changes.value = /*keys*/ctx[2][/*index*/ctx[8]];
      jsonnode0.$set(jsonnode0_changes);
      const jsonnode1_changes = {};
      if (dirty & /*values, index*/264) jsonnode1_changes.value = /*values*/ctx[3][/*index*/ctx[8]];
      jsonnode1.$set(jsonnode1_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnode0.$$.fragment, local);
      transition_in(jsonnode1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode0.$$.fragment, local);
      transition_out(jsonnode1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span0);
      destroy_component(jsonnode0, detaching);
      if (detaching) detach_dev(span1);
      destroy_component(jsonnode1, detaching);
      if (detaching) detach_dev(span2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_preview_slot$5.name,
    type: "slot",
    source: "(44:12) <svelte:fragment slot=\\\"preview\\\"               >",
    ctx
  });
  return block;
}

// (49:12) <svelte:fragment slot="item_key" let:key={name}>
function create_item_key_slot$5(ctx) {
  let span;
  let t_value = /*name*/ctx[9] + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "property");
      add_location(span, file$e, 48, 60, 2071);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*name*/512 && t_value !== (t_value = /*name*/ctx[9] + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_key_slot$5.name,
    type: "slot",
    source: "(49:12) <svelte:fragment slot=\\\"item_key\\\" let:key={name}>",
    ctx
  });
  return block;
}

// (50:12) <svelte:fragment slot="item_value" let:key={name}               >
function create_item_value_slot_2(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: /*name*/ctx[9] === 'key' ? /*keys*/ctx[2][/*index*/ctx[8]] : /*values*/ctx[3][/*index*/ctx[8]]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const jsonnode_changes = {};
      if (dirty & /*name, keys, index, values*/780) jsonnode_changes.value = /*name*/ctx[9] === 'key' ? /*keys*/ctx[2][/*index*/ctx[8]] : /*values*/ctx[3][/*index*/ctx[8]];
      jsonnode.$set(jsonnode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_value_slot_2.name,
    type: "slot",
    source: "(50:12) <svelte:fragment slot=\\\"item_value\\\" let:key={name}               >",
    ctx
  });
  return block;
}

// (42:8) <svelte:fragment slot="item_value" let:key={index}>
function create_item_value_slot_1(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: ['key', 'value'],
      $$slots: {
        item_value: [create_item_value_slot_2, _ref7 => {
          let {
            key: name
          } = _ref7;
          return {
            9: name
          };
        }, _ref8 => {
          let {
            key: name
          } = _ref8;
          return name ? 512 : 0;
        }],
        item_key: [create_item_key_slot$5, _ref9 => {
          let {
            key: name
          } = _ref9;
          return {
            9: name
          };
        }, _ref10 => {
          let {
            key: name
          } = _ref10;
          return name ? 512 : 0;
        }],
        preview: [create_preview_slot$5]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnested.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnested.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const jsonnested_changes = {};
      if (dirty & /*$$scope, name, keys, index, values*/2828) {
        jsonnested_changes.$$scope = {
          dirty,
          ctx
        };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_value_slot_1.name,
    type: "slot",
    source: "(42:8) <svelte:fragment slot=\\\"item_value\\\" let:key={index}>",
    ctx
  });
  return block;
}

// (39:2) <svelte:fragment slot="item_value" let:key>
function create_item_value_slot$5(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$9, create_else_block$6];
  const if_blocks = [];
  function select_block_type(ctx, dirty) {
    if ( /*key*/ctx[7] === ENTRIES) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching) detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_value_slot$5.name,
    type: "slot",
    source: "(39:2) <svelte:fragment slot=\\\"item_value\\\" let:key>",
    ctx
  });
  return block;
}
function create_fragment$f(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: [ENTRIES, 'size'],
      shouldShowColon: /*func_1*/ctx[6],
      $$slots: {
        item_value: [create_item_value_slot$5, _ref11 => {
          let {
            key
          } = _ref11;
          return {
            7: key
          };
        }, _ref12 => {
          let {
            key
          } = _ref12;
          return key ? 128 : 0;
        }],
        item_key: [create_item_key_slot_2, _ref13 => {
          let {
            key
          } = _ref13;
          return {
            7: key
          };
        }, _ref14 => {
          let {
            key
          } = _ref14;
          return key ? 128 : 0;
        }],
        preview: [create_preview_slot_1],
        summary: [create_summary_slot$5]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnested.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnested.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p: function update(ctx, _ref15) {
      let [dirty] = _ref15;
      const jsonnested_changes = {};
      if (dirty & /*$$scope, indexes, keys, values, key, value, previewKeys*/2207) {
        jsonnested_changes.$$scope = {
          dirty,
          ctx
        };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$f.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
const ENTRIES = '[[Entries]]';
function instance$e($$self, $$props, $$invalidate) {
  let previewKeys;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('JSONIterableMapNode', slots, []);
  let {
    value
  } = $$props;
  useState();
  let indexes = [];
  let keys = [];
  let values = [];
  $$self.$$.on_mount.push(function () {
    if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
      console.warn("<JSONIterableMapNode> was created without expected prop 'value'");
    }
  });
  const writable_props = ['value'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<JSONIterableMapNode> was created with unknown prop '".concat(key, "'"));
  });
  const func = index => keys[index];
  const func_1 = key => key !== ENTRIES;
  $$self.$$set = $$props => {
    if ('value' in $$props) $$invalidate(0, value = $$props.value);
  };
  $$self.$capture_state = () => ({
    useState,
    JSONNested,
    JSONNode,
    PreviewList,
    value,
    indexes,
    keys,
    values,
    ENTRIES,
    previewKeys
  });
  $$self.$inject_state = $$props => {
    if ('value' in $$props) $$invalidate(0, value = $$props.value);
    if ('indexes' in $$props) $$invalidate(1, indexes = $$props.indexes);
    if ('keys' in $$props) $$invalidate(2, keys = $$props.keys);
    if ('values' in $$props) $$invalidate(3, values = $$props.values);
    if ('previewKeys' in $$props) $$invalidate(4, previewKeys = $$props.previewKeys);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/1) {
      {
        let _indexes = [];
        let _keys = [];
        let _values = [];
        let i = 0;
        for (const entry of value) {
          _indexes.push(i++);
          _keys.push(entry[0]);
          _values.push(entry[1]);
        }
        $$invalidate(1, indexes = _indexes);
        $$invalidate(2, keys = _keys);
        $$invalidate(3, values = _values);
      }
    }
    if ($$self.$$.dirty & /*value*/1) {
      $$invalidate(4, previewKeys = Array.from(value.keys()).slice(0, 5));
    }
  };
  return [value, indexes, keys, values, previewKeys, func, func_1];
}
class JSONIterableMapNode extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$e, create_fragment$f, safe_not_equal, {
      value: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "JSONIterableMapNode",
      options,
      id: create_fragment$f.name
    });
  }
  get value() {
    throw new Error("<JSONIterableMapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<JSONIterableMapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}

/* ../../../node_modules/svelte-json-tree/_/JSONValueNode.svelte generated by Svelte v3.59.2 */
const file$d = "../../../node_modules/svelte-json-tree/_/JSONValueNode.svelte";
function create_fragment$e(ctx) {
  let span;
  let t;
  let span_class_value;
  const block = {
    c: function create() {
      span = element("span");
      t = text( /*value*/ctx[0]);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, /*value*/ctx[0]);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = "" + (null_to_empty( /*nodeType*/ctx[1]) + " svelte-l95iub"));
      add_location(span, file$d, 3, 0, 48);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx, _ref) {
      let [dirty] = _ref;
      if (dirty & /*value*/1) set_data_dev(t, /*value*/ctx[0]);
      if (dirty & /*nodeType*/2 && span_class_value !== (span_class_value = "" + (null_to_empty( /*nodeType*/ctx[1]) + " svelte-l95iub"))) {
        attr_dev(span, "class", span_class_value);
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$e.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$d($$self, $$props, $$invalidate) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('JSONValueNode', slots, []);
  let {
    value,
    nodeType
  } = $$props;
  $$self.$$.on_mount.push(function () {
    if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
      console.warn("<JSONValueNode> was created without expected prop 'value'");
    }
    if (nodeType === undefined && !('nodeType' in $$props || $$self.$$.bound[$$self.$$.props['nodeType']])) {
      console.warn("<JSONValueNode> was created without expected prop 'nodeType'");
    }
  });
  const writable_props = ['value', 'nodeType'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<JSONValueNode> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$$set = $$props => {
    if ('value' in $$props) $$invalidate(0, value = $$props.value);
    if ('nodeType' in $$props) $$invalidate(1, nodeType = $$props.nodeType);
  };
  $$self.$capture_state = () => ({
    value,
    nodeType
  });
  $$self.$inject_state = $$props => {
    if ('value' in $$props) $$invalidate(0, value = $$props.value);
    if ('nodeType' in $$props) $$invalidate(1, nodeType = $$props.nodeType);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [value, nodeType];
}
class JSONValueNode extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$d, create_fragment$e, safe_not_equal, {
      value: 0,
      nodeType: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "JSONValueNode",
      options,
      id: create_fragment$e.name
    });
  }
  get value() {
    throw new Error("<JSONValueNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<JSONValueNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeType() {
    throw new Error("<JSONValueNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeType(value) {
    throw new Error("<JSONValueNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}

/* ../../../node_modules/svelte-json-tree/_/ErrorStack.svelte generated by Svelte v3.59.2 */
const file$c = "../../../node_modules/svelte-json-tree/_/ErrorStack.svelte";
function get_each_context$3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[6] = list[i];
  child_ctx[9] = i;
  const constants_0 = /*index*/child_ctx[9] < /*stack*/child_ctx[0].length - 1;
  child_ctx[7] = constants_0;
  return child_ctx;
}

// (14:2) {:else}
function create_else_block$5(ctx) {
  let span;
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: /*stack*/ctx[0][0] + ''
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      span = element("span");
      create_component(jsonnode.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      claim_component(jsonnode.$$.fragment, span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file$c, 14, 4, 535);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      mount_component(jsonnode, span, null);
      current = true;
    },
    p: function update(ctx, dirty) {
      const jsonnode_changes = {};
      if (dirty & /*stack*/1) jsonnode_changes.value = /*stack*/ctx[0][0] + '';
      jsonnode.$set(jsonnode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
      destroy_component(jsonnode);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block$5.name,
    type: "else",
    source: "(14:2) {:else}",
    ctx
  });
  return block;
}

// (9:2) {#if $expanded}
function create_if_block$8(ctx) {
  let each_1_anchor;
  let current;
  let each_value = /*stack*/ctx[0];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
  }
  const out = i => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      if (dirty & /*stack*/1) {
        each_value = /*stack*/ctx[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$3(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block$3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching) detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$8.name,
    type: "if",
    source: "(9:2) {#if $expanded}",
    ctx
  });
  return block;
}

// (10:4) {#each stack as line, index}
function create_each_block$3(ctx) {
  let span1;
  let jsonnode;
  let span0;
  let t_value = ( /*appendNewLine*/ctx[7] ? ' +' : '') + "";
  let t;
  let br;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: /*line*/ctx[6] + ( /*appendNewLine*/ctx[7] ? '\\n' : '')
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      span1 = element("span");
      create_component(jsonnode.$$.fragment);
      span0 = element("span");
      t = text(t_value);
      br = element("br");
      this.h();
    },
    l: function claim(nodes) {
      span1 = claim_element(nodes, "SPAN", {
        class: true
      });
      var span1_nodes = children(span1);
      claim_component(jsonnode.$$.fragment, span1_nodes);
      span0 = claim_element(span1_nodes, "SPAN", {
        class: true
      });
      var span0_nodes = children(span0);
      t = claim_text(span0_nodes, t_value);
      span0_nodes.forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      br = claim_element(nodes, "BR", {});
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "operator");
      add_location(span0, file$c, 11, 93, 438);
      attr_dev(span1, "class", "svelte-1u08yw6");
      toggle_class(span1, "indent", /*index*/ctx[9] > 0);
      add_location(span1, file$c, 11, 6, 351);
      add_location(br, file$c, 11, 157, 502);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span1, anchor);
      mount_component(jsonnode, span1, null);
      append_hydration_dev(span1, span0);
      append_hydration_dev(span0, t);
      insert_hydration_dev(target, br, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const jsonnode_changes = {};
      if (dirty & /*stack*/1) jsonnode_changes.value = /*line*/ctx[6] + ( /*appendNewLine*/ctx[7] ? '\\n' : '');
      jsonnode.$set(jsonnode_changes);
      if ((!current || dirty & /*stack*/1) && t_value !== (t_value = ( /*appendNewLine*/ctx[7] ? ' +' : '') + "")) set_data_dev(t, t_value);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span1);
      destroy_component(jsonnode);
      if (detaching) detach_dev(br);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block$3.name,
    type: "each",
    source: "(10:4) {#each stack as line, index}",
    ctx
  });
  return block;
}
function create_fragment$d(ctx) {
  let span;
  let current_block_type_index;
  let if_block;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$8, create_else_block$5];
  const if_blocks = [];
  function select_block_type(ctx, dirty) {
    if ( /*$expanded*/ctx[1]) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      span = element("span");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {});
      var span_nodes = children(span);
      if_block.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(span, file$c, 7, 0, 189);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if_blocks[current_block_type_index].m(span, null);
      current = true;
      if (!mounted) {
        dispose = listen_dev(span, "click", /*click_handler*/ctx[4], false, false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx, _ref) {
      let [dirty] = _ref;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(span, null);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
      if_blocks[current_block_type_index].d();
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$d.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$c($$self, $$props, $$invalidate) {
  let $expandable;
  let $expanded;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ErrorStack', slots, []);
  let {
    stack
  } = $$props;
  const {
    expanded,
    expandable
  } = useState();
  validate_store(expanded, 'expanded');
  component_subscribe($$self, expanded, value => $$invalidate(1, $expanded = value));
  validate_store(expandable, 'expandable');
  component_subscribe($$self, expandable, value => $$invalidate(5, $expandable = value));
  set_store_value(expandable, $expandable = true, $expandable);
  $$self.$$.on_mount.push(function () {
    if (stack === undefined && !('stack' in $$props || $$self.$$.bound[$$self.$$.props['stack']])) {
      console.warn("<ErrorStack> was created without expected prop 'stack'");
    }
  });
  const writable_props = ['stack'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ErrorStack> was created with unknown prop '".concat(key, "'"));
  });
  const click_handler = () => set_store_value(expanded, $expanded = !$expanded, $expanded);
  $$self.$$set = $$props => {
    if ('stack' in $$props) $$invalidate(0, stack = $$props.stack);
  };
  $$self.$capture_state = () => ({
    JsonNode: JSONNode,
    useState,
    stack,
    expanded,
    expandable,
    $expandable,
    $expanded
  });
  $$self.$inject_state = $$props => {
    if ('stack' in $$props) $$invalidate(0, stack = $$props.stack);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [stack, $expanded, expanded, expandable, click_handler];
}
class ErrorStack extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$c, create_fragment$d, safe_not_equal, {
      stack: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ErrorStack",
      options,
      id: create_fragment$d.name
    });
  }
  get stack() {
    throw new Error("<ErrorStack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stack(value) {
    throw new Error("<ErrorStack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}

/* ../../../node_modules/svelte-json-tree/_/ErrorNode.svelte generated by Svelte v3.59.2 */
const file$b = "../../../node_modules/svelte-json-tree/_/ErrorNode.svelte";

// (9:2) <svelte:fragment slot="summary">
function create_summary_slot$4(ctx) {
  let span;
  let t0;
  let t1_value = String( /*value*/ctx[0].message) + "";
  let t1;
  const block = {
    c: function create() {
      span = element("span");
      t0 = text("Error: ");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, "Error: ");
      t1 = claim_text(span_nodes, t1_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "label");
      add_location(span, file$b, 8, 34, 283);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t0);
      append_hydration_dev(span, t1);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*value*/1 && t1_value !== (t1_value = String( /*value*/ctx[0].message) + "")) set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_summary_slot$4.name,
    type: "slot",
    source: "(9:2) <svelte:fragment slot=\\\"summary\\\">",
    ctx
  });
  return block;
}

// (10:2) <svelte:fragment slot="preview">
function create_preview_slot$4(ctx) {
  let span;
  let t0;
  let t1_value = String( /*value*/ctx[0].message) + "";
  let t1;
  const block = {
    c: function create() {
      span = element("span");
      t0 = text("Error: ");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, "Error: ");
      t1 = claim_text(span_nodes, t1_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "label");
      add_location(span, file$b, 9, 34, 393);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t0);
      append_hydration_dev(span, t1);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*value*/1 && t1_value !== (t1_value = String( /*value*/ctx[0].message) + "")) set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_preview_slot$4.name,
    type: "slot",
    source: "(10:2) <svelte:fragment slot=\\\"preview\\\">",
    ctx
  });
  return block;
}

// (11:2) <svelte:fragment slot="item_key" let:key>
function create_item_key_slot$4(ctx) {
  let span;
  let t_value = /*key*/ctx[2] + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "property");
      add_location(span, file$b, 10, 43, 512);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*key*/4 && t_value !== (t_value = /*key*/ctx[2] + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_key_slot$4.name,
    type: "slot",
    source: "(11:2) <svelte:fragment slot=\\\"item_key\\\" let:key>",
    ctx
  });
  return block;
}

// (15:4) {:else}
function create_else_block$4(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: /*value*/ctx[0][/*key*/ctx[2]]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const jsonnode_changes = {};
      if (dirty & /*value, key*/5) jsonnode_changes.value = /*value*/ctx[0][/*key*/ctx[2]];
      jsonnode.$set(jsonnode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block$4.name,
    type: "else",
    source: "(15:4) {:else}",
    ctx
  });
  return block;
}

// (13:4) {#if key === 'stack'}
function create_if_block$7(ctx) {
  let errorstack;
  let current;
  errorstack = new ErrorStack({
    props: {
      stack: /*stack*/ctx[1]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(errorstack.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(errorstack.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(errorstack, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const errorstack_changes = {};
      if (dirty & /*stack*/2) errorstack_changes.stack = /*stack*/ctx[1];
      errorstack.$set(errorstack_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(errorstack.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(errorstack.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(errorstack, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$7.name,
    type: "if",
    source: "(13:4) {#if key === 'stack'}",
    ctx
  });
  return block;
}

// (12:2) <svelte:fragment slot="item_value" let:key>
function create_item_value_slot$4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$7, create_else_block$4];
  const if_blocks = [];
  function select_block_type(ctx, dirty) {
    if ( /*key*/ctx[2] === 'stack') return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching) detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_value_slot$4.name,
    type: "slot",
    source: "(12:2) <svelte:fragment slot=\\\"item_value\\\" let:key>",
    ctx
  });
  return block;
}
function create_fragment$c(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: ['message', 'stack'],
      $$slots: {
        item_value: [create_item_value_slot$4, _ref => {
          let {
            key
          } = _ref;
          return {
            2: key
          };
        }, _ref2 => {
          let {
            key
          } = _ref2;
          return key ? 4 : 0;
        }],
        item_key: [create_item_key_slot$4, _ref3 => {
          let {
            key
          } = _ref3;
          return {
            2: key
          };
        }, _ref4 => {
          let {
            key
          } = _ref4;
          return key ? 4 : 0;
        }],
        preview: [create_preview_slot$4],
        summary: [create_summary_slot$4]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnested.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnested.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p: function update(ctx, _ref5) {
      let [dirty] = _ref5;
      const jsonnested_changes = {};
      if (dirty & /*$$scope, stack, key, value*/15) {
        jsonnested_changes.$$scope = {
          dirty,
          ctx
        };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$c.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$b($$self, $$props, $$invalidate) {
  let stack;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ErrorNode', slots, []);
  let {
    value
  } = $$props;
  $$self.$$.on_mount.push(function () {
    if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
      console.warn("<ErrorNode> was created without expected prop 'value'");
    }
  });
  const writable_props = ['value'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ErrorNode> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$$set = $$props => {
    if ('value' in $$props) $$invalidate(0, value = $$props.value);
  };
  $$self.$capture_state = () => ({
    ErrorStack,
    JsonNested: JSONNested,
    JSONNode,
    value,
    stack
  });
  $$self.$inject_state = $$props => {
    if ('value' in $$props) $$invalidate(0, value = $$props.value);
    if ('stack' in $$props) $$invalidate(1, stack = $$props.stack);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/1) {
      $$invalidate(1, stack = value.stack.split('\n'));
    }
  };
  return [value, stack];
}
class ErrorNode extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$b, create_fragment$c, safe_not_equal, {
      value: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ErrorNode",
      options,
      id: create_fragment$c.name
    });
  }
  get value() {
    throw new Error("<ErrorNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<ErrorNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}

function objType(obj) {
  const type = Object.prototype.toString.call(obj).slice(8, -1);
  if (type === 'Object') {
    if (typeof obj[Symbol.iterator] === 'function') {
      return 'Iterable';
    }
    return obj.constructor.name;
  }
  return type;
}

/* ../../../node_modules/svelte-json-tree/_/JSONStringNode.svelte generated by Svelte v3.59.2 */
const file$a = "../../../node_modules/svelte-json-tree/_/JSONStringNode.svelte";

// (14:0) {:else}
function create_else_block$3(ctx) {
  let span;
  let t0;
  let t1;
  let t2;
  const block = {
    c: function create() {
      span = element("span");
      t0 = text("\"");
      t1 = text( /*serialised*/ctx[0]);
      t2 = text("\"");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, "\"");
      t1 = claim_text(span_nodes, /*serialised*/ctx[0]);
      t2 = claim_text(span_nodes, "\"");
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "svelte-1fvwa9c");
      add_location(span, file$a, 14, 2, 368);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t0);
      append_hydration_dev(span, t1);
      append_hydration_dev(span, t2);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*serialised*/1) set_data_dev(t1, /*serialised*/ctx[0]);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block$3.name,
    type: "else",
    source: "(14:0) {:else}",
    ctx
  });
  return block;
}

// (12:0) {#if displayMode === 'summary'}
function create_if_block$6(ctx) {
  let span;
  let t0;
  let t1_value = /*serialised*/ctx[0].slice(0, 30) + ( /*serialised*/ctx[0].length > 30 ? '' : '') + "";
  let t1;
  let t2;
  const block = {
    c: function create() {
      span = element("span");
      t0 = text("\"");
      t1 = text(t1_value);
      t2 = text("\"");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, "\"");
      t1 = claim_text(span_nodes, t1_value);
      t2 = claim_text(span_nodes, "\"");
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "svelte-1fvwa9c");
      add_location(span, file$a, 12, 2, 279);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t0);
      append_hydration_dev(span, t1);
      append_hydration_dev(span, t2);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*serialised*/1 && t1_value !== (t1_value = /*serialised*/ctx[0].slice(0, 30) + ( /*serialised*/ctx[0].length > 30 ? '' : '') + "")) set_data_dev(t1, t1_value);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$6.name,
    type: "if",
    source: "(12:0) {#if displayMode === 'summary'}",
    ctx
  });
  return block;
}
function create_fragment$b(ctx) {
  let if_block_anchor;
  function select_block_type(ctx, dirty) {
    if ( /*displayMode*/ctx[1] === 'summary') return create_if_block$6;
    return create_else_block$3;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx, _ref) {
      let [dirty] = _ref;
      if_block.p(ctx, dirty);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if_block.d(detaching);
      if (detaching) detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$b.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$a($$self, $$props, $$invalidate) {
  let serialised;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('JSONStringNode', slots, []);
  let {
    value
  } = $$props;
  const map = {
    '\n': '\\n',
    '\t': '\\t',
    '\r': '\\r'
  };
  const {
    displayMode
  } = useState();
  $$self.$$.on_mount.push(function () {
    if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
      console.warn("<JSONStringNode> was created without expected prop 'value'");
    }
  });
  const writable_props = ['value'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<JSONStringNode> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$$set = $$props => {
    if ('value' in $$props) $$invalidate(2, value = $$props.value);
  };
  $$self.$capture_state = () => ({
    useState,
    value,
    map,
    displayMode,
    serialised
  });
  $$self.$inject_state = $$props => {
    if ('value' in $$props) $$invalidate(2, value = $$props.value);
    if ('serialised' in $$props) $$invalidate(0, serialised = $$props.serialised);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/4) {
      $$invalidate(0, serialised = value.replace(/[\n\t\r]/g, _ => map[_]));
    }
  };
  return [serialised, displayMode, value];
}
class JSONStringNode extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$a, create_fragment$b, safe_not_equal, {
      value: 2
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "JSONStringNode",
      options,
      id: create_fragment$b.name
    });
  }
  get value() {
    throw new Error("<JSONStringNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<JSONStringNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}

/* ../../../node_modules/svelte-json-tree/_/JSONFunctionNode.svelte generated by Svelte v3.59.2 */
const file$9 = "../../../node_modules/svelte-json-tree/_/JSONFunctionNode.svelte";

// (66:2) <svelte:fragment slot="summary">
function create_summary_slot$3(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text("");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, "");
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "i svelte-1eamqdt");
      add_location(span, file$9, 65, 34, 1956);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_summary_slot$3.name,
    type: "slot",
    source: "(66:2) <svelte:fragment slot=\\\"summary\\\">",
    ctx
  });
  return block;
}

// (68:5) {#if !ctx.isArrow}
function create_if_block_3$2(ctx) {
  let span;
  let t_value = getPreview1( /*ctx*/ctx[2]) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "fn i svelte-1eamqdt");
      add_location(span, file$9, 67, 23, 2056);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*ctx*/4 && t_value !== (t_value = getPreview1( /*ctx*/ctx[2]) + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3$2.name,
    type: "if",
    source: "(68:5) {#if !ctx.isArrow}",
    ctx
  });
  return block;
}

// (68:72) {#if !ctx.isClass}
function create_if_block_2$2(ctx) {
  let span;
  let t_value = getPreview2( /*ctx*/ctx[2]) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "i svelte-1eamqdt");
      add_location(span, file$9, 67, 90, 2123);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*ctx*/4 && t_value !== (t_value = getPreview2( /*ctx*/ctx[2]) + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2$2.name,
    type: "if",
    source: "(68:72) {#if !ctx.isClass}",
    ctx
  });
  return block;
}

// (67:2) <svelte:fragment slot="preview"     >
function create_preview_slot$3(ctx) {
  let if_block0_anchor;
  let if_block1_anchor;
  let if_block0 = ! /*ctx*/ctx[2].isArrow && create_if_block_3$2(ctx);
  let if_block1 = ! /*ctx*/ctx[2].isClass && create_if_block_2$2(ctx);
  const block = {
    c: function create() {
      if (if_block0) if_block0.c();
      if_block0_anchor = empty();
      if (if_block1) if_block1.c();
      if_block1_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block0) if_block0.l(nodes);
      if_block0_anchor = empty();
      if (if_block1) if_block1.l(nodes);
      if_block1_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, if_block0_anchor, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, if_block1_anchor, anchor);
    },
    p: function update(ctx, dirty) {
      if (! /*ctx*/ctx[2].isArrow) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_3$2(ctx);
          if_block0.c();
          if_block0.m(if_block0_anchor.parentNode, if_block0_anchor);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (! /*ctx*/ctx[2].isClass) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_2$2(ctx);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d: function destroy(detaching) {
      if (if_block0) if_block0.d(detaching);
      if (detaching) detach_dev(if_block0_anchor);
      if (if_block1) if_block1.d(detaching);
      if (detaching) detach_dev(if_block1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_preview_slot$3.name,
    type: "slot",
    source: "(67:2) <svelte:fragment slot=\\\"preview\\\"     >",
    ctx
  });
  return block;
}

// (71:2) <svelte:fragment slot="item_key" let:key     >
function create_item_key_slot$3(ctx) {
  let span;
  let t_value = /*key*/ctx[7] + "";
  let t;
  let span_class_value;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*key*/ctx[7] === FUNCTION || /*key*/ctx[7] === PROTO ? 'internal' : 'property');
      add_location(span, file$9, 71, 5, 2246);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*key*/128 && t_value !== (t_value = /*key*/ctx[7] + "")) set_data_dev(t, t_value);
      if (dirty & /*key*/128 && span_class_value !== (span_class_value = /*key*/ctx[7] === FUNCTION || /*key*/ctx[7] === PROTO ? 'internal' : 'property')) {
        attr_dev(span, "class", span_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_key_slot$3.name,
    type: "slot",
    source: "(71:2) <svelte:fragment slot=\\\"item_key\\\" let:key     >",
    ctx
  });
  return block;
}

// (77:8) {:else}
function create_else_block$2(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: /*getValue*/ctx[3]( /*key*/ctx[7])
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const jsonnode_changes = {};
      if (dirty & /*key*/128) jsonnode_changes.value = /*getValue*/ctx[3]( /*key*/ctx[7]);
      jsonnode.$set(jsonnode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block$2.name,
    type: "else",
    source: "(77:8) {:else}",
    ctx
  });
  return block;
}

// (75:85) 
function create_if_block_1$4(ctx) {
  let jsonobjectnode;
  let current;
  jsonobjectnode = new JSONObjectNode({
    props: {
      value: /*getValue*/ctx[3]( /*key*/ctx[7])
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonobjectnode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonobjectnode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonobjectnode, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const jsonobjectnode_changes = {};
      if (dirty & /*key*/128) jsonobjectnode_changes.value = /*getValue*/ctx[3]( /*key*/ctx[7]);
      jsonobjectnode.$set(jsonobjectnode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonobjectnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonobjectnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonobjectnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1$4.name,
    type: "if",
    source: "(75:85) ",
    ctx
  });
  return block;
}

// (75:5) {#if key === FUNCTION}
function create_if_block$5(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text( /*str*/ctx[0]);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, /*str*/ctx[0]);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "i svelte-1eamqdt");
      add_location(span, file$9, 74, 27, 2426);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*str*/1) set_data_dev(t, /*str*/ctx[0]);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$5.name,
    type: "if",
    source: "(75:5) {#if key === FUNCTION}",
    ctx
  });
  return block;
}

// (74:2) <svelte:fragment slot="item_value" let:key     >
function create_item_value_slot$3(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$5, create_if_block_1$4, create_else_block$2];
  const if_blocks = [];
  function select_block_type(ctx, dirty) {
    if ( /*key*/ctx[7] === FUNCTION) return 0;
    if ( /*key*/ctx[7] === 'prototype') return 1;
    return 2;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        } else {
          if_block.p(ctx, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching) detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_value_slot$3.name,
    type: "slot",
    source: "(74:2) <svelte:fragment slot=\\\"item_value\\\" let:key     >",
    ctx
  });
  return block;
}
function create_fragment$a(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: /*keys*/ctx[1],
      $$slots: {
        item_value: [create_item_value_slot$3, _ref => {
          let {
            key
          } = _ref;
          return {
            7: key
          };
        }, _ref2 => {
          let {
            key
          } = _ref2;
          return key ? 128 : 0;
        }],
        item_key: [create_item_key_slot$3, _ref3 => {
          let {
            key
          } = _ref3;
          return {
            7: key
          };
        }, _ref4 => {
          let {
            key
          } = _ref4;
          return key ? 128 : 0;
        }],
        preview: [create_preview_slot$3],
        summary: [create_summary_slot$3]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnested.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnested.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p: function update(ctx, _ref5) {
      let [dirty] = _ref5;
      const jsonnested_changes = {};
      if (dirty & /*keys*/2) jsonnested_changes.keys = /*keys*/ctx[1];
      if (dirty & /*$$scope, str, key, ctx*/389) {
        jsonnested_changes.$$scope = {
          dirty,
          ctx
        };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$a.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
const FUNCTION = '[[Function]]';
const PROTO = '[[Prototype]]';
function getPreview1(_ref6) {
  let {
    isGenerator,
    isAsync,
    isClass
  } = _ref6;
  if (isClass) return "class ".concat(isClass);
  return (isAsync ? 'async ' : '') + '' + (isGenerator ? '*' : '');
}
function getPreview2(_ref7) {
  let {
    isAsync,
    isArrow,
    fnName,
    args
  } = _ref7;
  return (isArrow && isAsync ? 'async' : '') + ' ' + (fnName !== null && fnName !== void 0 ? fnName : '') + args + (isArrow ? ' => ' : '');
}
function toString(value) {
  try {
    return value.toString();
  } catch {
    switch (value.constructor.name) {
      case 'AsyncFunction':
        return 'async function () {}';
      case 'AsyncGeneratorFunction':
        return 'async function * () {}';
      case 'GeneratorFunction:':
        return 'function * () {}';
      default:
        return 'function () {}';
    }
  }
}
function instance$9($$self, $$props, $$invalidate) {
  let str;
  let ctx;
  let keys;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('JSONFunctionNode', slots, []);
  let {
    value
  } = $$props;
  function parseFunction(str) {
    const match = str.match(/^(?:(async)\s+)?(?:function)?(\*)?\s*([^(]+)?(\([^)]*\))\s*(=>)?/);
    const isAsync = match === null || match === void 0 ? void 0 : match[1];
    const isGenerator = match === null || match === void 0 ? void 0 : match[2];
    const fnName = match === null || match === void 0 ? void 0 : match[3];
    const args = match === null || match === void 0 ? void 0 : match[4];
    const isArrow = match === null || match === void 0 ? void 0 : match[5];
    const classMatch = str.match(/^class\s+([^\s]+)/);
    const isClass = classMatch === null || classMatch === void 0 ? void 0 : classMatch[1];
    return {
      args,
      isAsync,
      isGenerator,
      fnName,
      isArrow,
      isClass
    };
  }
  function getValue(key) {
    if (key === PROTO) return value.__proto__;
    return value[key];
  }
  function filterKeys(key) {
    if (key === FUNCTION) return true;
    return getValue(key);
  }
  $$self.$$.on_mount.push(function () {
    if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
      console.warn("<JSONFunctionNode> was created without expected prop 'value'");
    }
  });
  const writable_props = ['value'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<JSONFunctionNode> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$$set = $$props => {
    if ('value' in $$props) $$invalidate(4, value = $$props.value);
  };
  $$self.$capture_state = () => ({
    JSONNested,
    JSONNode,
    JsonObjectNode: JSONObjectNode,
    value,
    parseFunction,
    getPreview1,
    getPreview2,
    FUNCTION,
    PROTO,
    getValue,
    filterKeys,
    toString,
    keys,
    str,
    ctx
  });
  $$self.$inject_state = $$props => {
    if ('value' in $$props) $$invalidate(4, value = $$props.value);
    if ('keys' in $$props) $$invalidate(1, keys = $$props.keys);
    if ('str' in $$props) $$invalidate(0, str = $$props.str);
    if ('ctx' in $$props) $$invalidate(2, ctx = $$props.ctx);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/16) {
      $$invalidate(0, str = toString(value));
    }
    if ($$self.$$.dirty & /*str*/1) {
      $$invalidate(2, ctx = parseFunction(str));
    }
  };
  $$invalidate(1, keys = ['length', 'name', 'prototype', FUNCTION, PROTO].filter(filterKeys));
  return [str, keys, ctx, getValue, value];
}
class JSONFunctionNode extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$9, create_fragment$a, safe_not_equal, {
      value: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "JSONFunctionNode",
      options,
      id: create_fragment$a.name
    });
  }
  get value() {
    throw new Error("<JSONFunctionNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<JSONFunctionNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}

/* ../../../node_modules/svelte-json-tree/_/JSONSvelteStoreNode.svelte generated by Svelte v3.59.2 */
const {
  Object: Object_1$1
} = globals;
const file$8 = "../../../node_modules/svelte-json-tree/_/JSONSvelteStoreNode.svelte";

// (19:2) <svelte:fragment slot="summary"     >
function create_summary_slot$2(ctx) {
  let span;
  let t0_value = ( /*isWritableStore*/ctx[3] ? 'writable(' : 'readable(') + "";
  let t0;
  let jsonnode;
  let t1_value = ')' + "";
  let t1;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: /*storeValue*/ctx[2]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      span = element("span");
      t0 = text(t0_value);
      create_component(jsonnode.$$.fragment);
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, t0_value);
      claim_component(jsonnode.$$.fragment, span_nodes);
      t1 = claim_text(span_nodes, t1_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "label");
      add_location(span, file$8, 19, 5, 579);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t0);
      mount_component(jsonnode, span, null);
      append_hydration_dev(span, t1);
      current = true;
    },
    p: function update(ctx, dirty) {
      if ((!current || dirty & /*isWritableStore*/8) && t0_value !== (t0_value = ( /*isWritableStore*/ctx[3] ? 'writable(' : 'readable(') + "")) set_data_dev(t0, t0_value);
      const jsonnode_changes = {};
      if (dirty & /*storeValue*/4) jsonnode_changes.value = /*storeValue*/ctx[2];
      jsonnode.$set(jsonnode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
      destroy_component(jsonnode);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_summary_slot$2.name,
    type: "slot",
    source: "(19:2) <svelte:fragment slot=\\\"summary\\\"     >",
    ctx
  });
  return block;
}

// (24:6) <svelte:fragment slot="item" let:item         >
function create_item_slot$1(ctx) {
  let span0;
  let t0_value = /*item*/ctx[9] + "";
  let t0;
  let span1;
  let t1_value = ': ' + "";
  let t1;
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: /*value*/ctx[0][/*item*/ctx[9]]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      span0 = element("span");
      t0 = text(t0_value);
      span1 = element("span");
      t1 = text(t1_value);
      create_component(jsonnode.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      span0 = claim_element(nodes, "SPAN", {
        class: true
      });
      var span0_nodes = children(span0);
      t0 = claim_text(span0_nodes, t0_value);
      span0_nodes.forEach(detach_dev);
      span1 = claim_element(nodes, "SPAN", {
        class: true
      });
      var span1_nodes = children(span1);
      t1 = claim_text(span1_nodes, t1_value);
      span1_nodes.forEach(detach_dev);
      claim_component(jsonnode.$$.fragment, nodes);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span0, "class", "property");
      add_location(span0, file$8, 24, 9, 910);
      attr_dev(span1, "class", "operator");
      add_location(span1, file$8, 24, 45, 946);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span0, anchor);
      append_hydration_dev(span0, t0);
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, t1);
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      if ((!current || dirty & /*item*/512) && t0_value !== (t0_value = /*item*/ctx[9] + "")) set_data_dev(t0, t0_value);
      const jsonnode_changes = {};
      if (dirty & /*value, item*/513) jsonnode_changes.value = /*value*/ctx[0][/*item*/ctx[9]];
      jsonnode.$set(jsonnode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span0);
      if (detaching) detach_dev(span1);
      destroy_component(jsonnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_slot$1.name,
    type: "slot",
    source: "(24:6) <svelte:fragment slot=\\\"item\\\" let:item         >",
    ctx
  });
  return block;
}

// (22:2) <svelte:fragment slot="preview">
function create_preview_slot$2(ctx) {
  let previewlist;
  let current;
  previewlist = new PreviewList({
    props: {
      list: /*previewKeys*/ctx[4],
      hasMore: /*previewKeys*/ctx[4].length < /*objectKeys*/ctx[1].length,
      prefix: '{',
      postfix: '}',
      $$slots: {
        item: [create_item_slot$1, _ref => {
          let {
            item
          } = _ref;
          return {
            9: item
          };
        }, _ref2 => {
          let {
            item
          } = _ref2;
          return item ? 512 : 0;
        }]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(previewlist.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(previewlist.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(previewlist, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const previewlist_changes = {};
      if (dirty & /*previewKeys*/16) previewlist_changes.list = /*previewKeys*/ctx[4];
      if (dirty & /*previewKeys, objectKeys*/18) previewlist_changes.hasMore = /*previewKeys*/ctx[4].length < /*objectKeys*/ctx[1].length;
      if (dirty & /*$$scope, value, item*/1537) {
        previewlist_changes.$$scope = {
          dirty,
          ctx
        };
      }
      previewlist.$set(previewlist_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(previewlist.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(previewlist.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(previewlist, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_preview_slot$2.name,
    type: "slot",
    source: "(22:2) <svelte:fragment slot=\\\"preview\\\">",
    ctx
  });
  return block;
}

// (29:2) <svelte:fragment slot="item_key" let:key>
function create_item_key_slot$2(ctx) {
  let span;
  let t_value = /*key*/ctx[8] + "";
  let t;
  let span_class_value;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*key*/ctx[8] === STORE_VALUE ? 'internal' : 'property');
      add_location(span, file$8, 28, 43, 1123);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*key*/256 && t_value !== (t_value = /*key*/ctx[8] + "")) set_data_dev(t, t_value);
      if (dirty & /*key*/256 && span_class_value !== (span_class_value = /*key*/ctx[8] === STORE_VALUE ? 'internal' : 'property')) {
        attr_dev(span, "class", span_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_key_slot$2.name,
    type: "slot",
    source: "(29:2) <svelte:fragment slot=\\\"item_key\\\" let:key>",
    ctx
  });
  return block;
}

// (30:2) <svelte:fragment slot="item_value" let:key>
function create_item_value_slot$2(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: /*getValue*/ctx[6]( /*key*/ctx[8])
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const jsonnode_changes = {};
      if (dirty & /*key*/256) jsonnode_changes.value = /*getValue*/ctx[6]( /*key*/ctx[8]);
      jsonnode.$set(jsonnode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_value_slot$2.name,
    type: "slot",
    source: "(30:2) <svelte:fragment slot=\\\"item_value\\\" let:key>",
    ctx
  });
  return block;
}
function create_fragment$9(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: /*keys*/ctx[5],
      $$slots: {
        item_value: [create_item_value_slot$2, _ref3 => {
          let {
            key
          } = _ref3;
          return {
            8: key
          };
        }, _ref4 => {
          let {
            key
          } = _ref4;
          return key ? 256 : 0;
        }],
        item_key: [create_item_key_slot$2, _ref5 => {
          let {
            key
          } = _ref5;
          return {
            8: key
          };
        }, _ref6 => {
          let {
            key
          } = _ref6;
          return key ? 256 : 0;
        }],
        preview: [create_preview_slot$2],
        summary: [create_summary_slot$2]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnested.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnested.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p: function update(ctx, _ref7) {
      let [dirty] = _ref7;
      const jsonnested_changes = {};
      if (dirty & /*keys*/32) jsonnested_changes.keys = /*keys*/ctx[5];
      if (dirty & /*$$scope, key, previewKeys, objectKeys, value, storeValue, isWritableStore*/1311) {
        jsonnested_changes.$$scope = {
          dirty,
          ctx
        };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$9.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
const STORE_VALUE = '$value';
function instance$8($$self, $$props, $$invalidate) {
  let objectKeys;
  let keys;
  let previewKeys;
  let storeValue;
  let isWritableStore;
  let $value,
    $$unsubscribe_value = noop,
    $$subscribe_value = () => ($$unsubscribe_value(), $$unsubscribe_value = subscribe(value, $$value => $$invalidate(7, $value = $$value)), value);
  $$self.$$.on_destroy.push(() => $$unsubscribe_value());
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('JSONSvelteStoreNode', slots, []);
  let {
    value
  } = $$props;
  validate_store(value, 'value');
  $$subscribe_value();
  function getValue(key) {
    if (key === STORE_VALUE) return storeValue;
    return value[key];
  }
  $$self.$$.on_mount.push(function () {
    if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
      console.warn("<JSONSvelteStoreNode> was created without expected prop 'value'");
    }
  });
  const writable_props = ['value'];
  Object_1$1.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<JSONSvelteStoreNode> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$$set = $$props => {
    if ('value' in $$props) $$subscribe_value($$invalidate(0, value = $$props.value));
  };
  $$self.$capture_state = () => ({
    JSONNested,
    JSONNode,
    PreviewList,
    value,
    STORE_VALUE,
    getValue,
    storeValue,
    isWritableStore,
    objectKeys,
    previewKeys,
    keys,
    $value
  });
  $$self.$inject_state = $$props => {
    if ('value' in $$props) $$subscribe_value($$invalidate(0, value = $$props.value));
    if ('storeValue' in $$props) $$invalidate(2, storeValue = $$props.storeValue);
    if ('isWritableStore' in $$props) $$invalidate(3, isWritableStore = $$props.isWritableStore);
    if ('objectKeys' in $$props) $$invalidate(1, objectKeys = $$props.objectKeys);
    if ('previewKeys' in $$props) $$invalidate(4, previewKeys = $$props.previewKeys);
    if ('keys' in $$props) $$invalidate(5, keys = $$props.keys);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/1) {
      $$invalidate(1, objectKeys = Object.getOwnPropertyNames(value));
    }
    if ($$self.$$.dirty & /*objectKeys*/2) {
      $$invalidate(5, keys = [STORE_VALUE, ...objectKeys]);
    }
    if ($$self.$$.dirty & /*objectKeys*/2) {
      $$invalidate(4, previewKeys = objectKeys.slice(0, 5));
    }
    if ($$self.$$.dirty & /*$value*/128) {
      $$invalidate(2, storeValue = $value);
    }
    if ($$self.$$.dirty & /*value*/1) {
      $$invalidate(3, isWritableStore = typeof value.set === 'function');
    }
  };
  return [value, objectKeys, storeValue, isWritableStore, previewKeys, keys, getValue, $value];
}
class JSONSvelteStoreNode extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$8, create_fragment$9, safe_not_equal, {
      value: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "JSONSvelteStoreNode",
      options,
      id: create_fragment$9.name
    });
  }
  get value() {
    throw new Error("<JSONSvelteStoreNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<JSONSvelteStoreNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}

/* ../../../node_modules/svelte-json-tree/_/TypedArrayNode.svelte generated by Svelte v3.59.2 */
const {
  Object: Object_1
} = globals;
const file$7 = "../../../node_modules/svelte-json-tree/_/TypedArrayNode.svelte";

// (19:2) <svelte:fragment slot="summary">
function create_summary_slot$1(ctx) {
  let span;
  let t0;
  let t1;
  let t2_value = /*value*/ctx[0].length + "";
  let t2;
  let t3;
  const block = {
    c: function create() {
      span = element("span");
      t0 = text( /*nodeType*/ctx[1]);
      t1 = text("(");
      t2 = text(t2_value);
      t3 = text(")");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, /*nodeType*/ctx[1]);
      t1 = claim_text(span_nodes, "(");
      t2 = claim_text(span_nodes, t2_value);
      t3 = claim_text(span_nodes, ")");
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "label");
      add_location(span, file$7, 18, 34, 617);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t0);
      append_hydration_dev(span, t1);
      append_hydration_dev(span, t2);
      append_hydration_dev(span, t3);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*nodeType*/2) set_data_dev(t0, /*nodeType*/ctx[1]);
      if (dirty & /*value*/1 && t2_value !== (t2_value = /*value*/ctx[0].length + "")) set_data_dev(t2, t2_value);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_summary_slot$1.name,
    type: "slot",
    source: "(19:2) <svelte:fragment slot=\\\"summary\\\">",
    ctx
  });
  return block;
}

// (22:6) <svelte:fragment slot="item" let:item>
function create_item_slot(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: /*item*/ctx[7]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const jsonnode_changes = {};
      if (dirty & /*item*/128) jsonnode_changes.value = /*item*/ctx[7];
      jsonnode.$set(jsonnode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_slot.name,
    type: "slot",
    source: "(22:6) <svelte:fragment slot=\\\"item\\\" let:item>",
    ctx
  });
  return block;
}

// (20:2) <svelte:fragment slot="preview">
function create_preview_slot$1(ctx) {
  let previewlist;
  let current;
  previewlist = new PreviewList({
    props: {
      list: /*preview*/ctx[2],
      hasMore: /*preview*/ctx[2].length < /*value*/ctx[0].length,
      label: "" + ( /*nodeType*/ctx[1] + "(" + /*value*/ctx[0].length + ") "),
      prefix: "[",
      postfix: "]",
      $$slots: {
        item: [create_item_slot, _ref => {
          let {
            item
          } = _ref;
          return {
            7: item
          };
        }, _ref2 => {
          let {
            item
          } = _ref2;
          return item ? 128 : 0;
        }]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(previewlist.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(previewlist.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(previewlist, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const previewlist_changes = {};
      if (dirty & /*preview*/4) previewlist_changes.list = /*preview*/ctx[2];
      if (dirty & /*preview, value*/5) previewlist_changes.hasMore = /*preview*/ctx[2].length < /*value*/ctx[0].length;
      if (dirty & /*nodeType, value*/3) previewlist_changes.label = "" + ( /*nodeType*/ctx[1] + "(" + /*value*/ctx[0].length + ") ");
      if (dirty & /*$$scope, item*/384) {
        previewlist_changes.$$scope = {
          dirty,
          ctx
        };
      }
      previewlist.$set(previewlist_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(previewlist.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(previewlist.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(previewlist, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_preview_slot$1.name,
    type: "slot",
    source: "(20:2) <svelte:fragment slot=\\\"preview\\\">",
    ctx
  });
  return block;
}

// (27:2) <svelte:fragment slot="item_key" let:key     >
function create_item_key_slot$1(ctx) {
  let span;
  let t_value = String( /*key*/ctx[6]) + "";
  let t;
  let span_class_value;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", span_class_value = /*internalKeys*/ctx[4].includes( /*key*/ctx[6]) ? 'internal' : 'property');
      add_location(span, file$7, 27, 5, 1048);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*key*/64 && t_value !== (t_value = String( /*key*/ctx[6]) + "")) set_data_dev(t, t_value);
      if (dirty & /*key*/64 && span_class_value !== (span_class_value = /*internalKeys*/ctx[4].includes( /*key*/ctx[6]) ? 'internal' : 'property')) {
        attr_dev(span, "class", span_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_key_slot$1.name,
    type: "slot",
    source: "(27:2) <svelte:fragment slot=\\\"item_key\\\" let:key     >",
    ctx
  });
  return block;
}

// (30:2) <svelte:fragment slot="item_value" let:key>
function create_item_value_slot$1(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: /*getValue*/ctx[5]( /*key*/ctx[6])
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const jsonnode_changes = {};
      if (dirty & /*key*/64) jsonnode_changes.value = /*getValue*/ctx[5]( /*key*/ctx[6]);
      jsonnode.$set(jsonnode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_value_slot$1.name,
    type: "slot",
    source: "(30:2) <svelte:fragment slot=\\\"item_value\\\" let:key>",
    ctx
  });
  return block;
}
function create_fragment$8(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: /*keys*/ctx[3],
      $$slots: {
        item_value: [create_item_value_slot$1, _ref3 => {
          let {
            key
          } = _ref3;
          return {
            6: key
          };
        }, _ref4 => {
          let {
            key
          } = _ref4;
          return key ? 64 : 0;
        }],
        item_key: [create_item_key_slot$1, _ref5 => {
          let {
            key
          } = _ref5;
          return {
            6: key
          };
        }, _ref6 => {
          let {
            key
          } = _ref6;
          return key ? 64 : 0;
        }],
        preview: [create_preview_slot$1],
        summary: [create_summary_slot$1]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnested.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnested.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p: function update(ctx, _ref7) {
      let [dirty] = _ref7;
      const jsonnested_changes = {};
      if (dirty & /*keys*/8) jsonnested_changes.keys = /*keys*/ctx[3];
      if (dirty & /*$$scope, key, preview, value, nodeType*/327) {
        jsonnested_changes.$$scope = {
          dirty,
          ctx
        };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
const TO_STRING_TAG = 'Symbol(Symbol.toStringTag)';
function instance$7($$self, $$props, $$invalidate) {
  let keys;
  let preview;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('TypedArrayNode', slots, []);
  let {
    value
  } = $$props;
  let {
    nodeType
  } = $$props;
  const internalKeys = ['buffer', 'byteLength', 'byteOffset', 'length', TO_STRING_TAG];
  function getValue(key) {
    if (key === TO_STRING_TAG) {
      return value[Symbol.toStringTag];
    }
    return value[key];
  }
  $$self.$$.on_mount.push(function () {
    if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
      console.warn("<TypedArrayNode> was created without expected prop 'value'");
    }
    if (nodeType === undefined && !('nodeType' in $$props || $$self.$$.bound[$$self.$$.props['nodeType']])) {
      console.warn("<TypedArrayNode> was created without expected prop 'nodeType'");
    }
  });
  const writable_props = ['value', 'nodeType'];
  Object_1.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<TypedArrayNode> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$$set = $$props => {
    if ('value' in $$props) $$invalidate(0, value = $$props.value);
    if ('nodeType' in $$props) $$invalidate(1, nodeType = $$props.nodeType);
  };
  $$self.$capture_state = () => ({
    JSONNested,
    JSONNode,
    PreviewList,
    value,
    nodeType,
    TO_STRING_TAG,
    internalKeys,
    getValue,
    preview,
    keys
  });
  $$self.$inject_state = $$props => {
    if ('value' in $$props) $$invalidate(0, value = $$props.value);
    if ('nodeType' in $$props) $$invalidate(1, nodeType = $$props.nodeType);
    if ('preview' in $$props) $$invalidate(2, preview = $$props.preview);
    if ('keys' in $$props) $$invalidate(3, keys = $$props.keys);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/1) {
      $$invalidate(3, keys = [...Object.getOwnPropertyNames(value), ...internalKeys]);
    }
    if ($$self.$$.dirty & /*value*/1) {
      $$invalidate(2, preview = value.slice(0, 5));
    }
  };
  return [value, nodeType, preview, keys, internalKeys, getValue];
}
class TypedArrayNode extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$7, create_fragment$8, safe_not_equal, {
      value: 0,
      nodeType: 1
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TypedArrayNode",
      options,
      id: create_fragment$8.name
    });
  }
  get value() {
    throw new Error("<TypedArrayNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<TypedArrayNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nodeType() {
    throw new Error("<TypedArrayNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nodeType(value) {
    throw new Error("<TypedArrayNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}

/* ../../../node_modules/svelte-json-tree/_/RegExpNode.svelte generated by Svelte v3.59.2 */
const file$6 = "../../../node_modules/svelte-json-tree/_/RegExpNode.svelte";

// (9:2) <svelte:fragment slot="summary">
function create_summary_slot(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text( /*str*/ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, /*str*/ctx[1]);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "regex svelte-17k1wqt");
      add_location(span, file$6, 8, 34, 336);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*str*/2) set_data_dev(t, /*str*/ctx[1]);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_summary_slot.name,
    type: "slot",
    source: "(9:2) <svelte:fragment slot=\\\"summary\\\">",
    ctx
  });
  return block;
}

// (10:2) <svelte:fragment slot="preview">
function create_preview_slot(ctx) {
  let span;
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text( /*str*/ctx[1]);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, /*str*/ctx[1]);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "regex svelte-17k1wqt");
      add_location(span, file$6, 9, 34, 421);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*str*/2) set_data_dev(t, /*str*/ctx[1]);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_preview_slot.name,
    type: "slot",
    source: "(10:2) <svelte:fragment slot=\\\"preview\\\">",
    ctx
  });
  return block;
}

// (11:2) <svelte:fragment slot="item_key" let:key>
function create_item_key_slot(ctx) {
  let span;
  let t_value = String( /*key*/ctx[3]) + "";
  let t;
  const block = {
    c: function create() {
      span = element("span");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t = claim_text(span_nodes, t_value);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "internal");
      add_location(span, file$6, 10, 43, 515);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      append_hydration_dev(span, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*key*/8 && t_value !== (t_value = String( /*key*/ctx[3]) + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(span);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_key_slot.name,
    type: "slot",
    source: "(11:2) <svelte:fragment slot=\\\"item_key\\\" let:key>",
    ctx
  });
  return block;
}

// (12:2) <svelte:fragment slot="item_value" let:key>
function create_item_value_slot(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: /*value*/ctx[0][/*key*/ctx[3]]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const jsonnode_changes = {};
      if (dirty & /*value, key*/9) jsonnode_changes.value = /*value*/ctx[0][/*key*/ctx[3]];
      jsonnode.$set(jsonnode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_item_value_slot.name,
    type: "slot",
    source: "(12:2) <svelte:fragment slot=\\\"item_value\\\" let:key>",
    ctx
  });
  return block;
}
function create_fragment$7(ctx) {
  let jsonnested;
  let current;
  jsonnested = new JSONNested({
    props: {
      keys: /*keys*/ctx[2],
      $$slots: {
        item_value: [create_item_value_slot, _ref => {
          let {
            key
          } = _ref;
          return {
            3: key
          };
        }, _ref2 => {
          let {
            key
          } = _ref2;
          return key ? 8 : 0;
        }],
        item_key: [create_item_key_slot, _ref3 => {
          let {
            key
          } = _ref3;
          return {
            3: key
          };
        }, _ref4 => {
          let {
            key
          } = _ref4;
          return key ? 8 : 0;
        }],
        preview: [create_preview_slot],
        summary: [create_summary_slot]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnested.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnested.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnested, target, anchor);
      current = true;
    },
    p: function update(ctx, _ref5) {
      let [dirty] = _ref5;
      const jsonnested_changes = {};
      if (dirty & /*$$scope, value, key, str*/27) {
        jsonnested_changes.$$scope = {
          dirty,
          ctx
        };
      }
      jsonnested.$set(jsonnested_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnested.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnested.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnested, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$6($$self, $$props, $$invalidate) {
  let str;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('RegExpNode', slots, []);
  let {
    value
  } = $$props;
  const keys = ['lastIndex', 'dotAll', 'flags', 'global', 'hasIndices', 'ignoreCase', 'multiline', 'source', 'sticky', 'unicode'];
  $$self.$$.on_mount.push(function () {
    if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
      console.warn("<RegExpNode> was created without expected prop 'value'");
    }
  });
  const writable_props = ['value'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<RegExpNode> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$$set = $$props => {
    if ('value' in $$props) $$invalidate(0, value = $$props.value);
  };
  $$self.$capture_state = () => ({
    JSONNested,
    JSONNode,
    value,
    keys,
    str
  });
  $$self.$inject_state = $$props => {
    if ('value' in $$props) $$invalidate(0, value = $$props.value);
    if ('str' in $$props) $$invalidate(1, str = $$props.str);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/1) {
      $$invalidate(1, str = value.toString());
    }
  };
  return [value, str, keys];
}
class RegExpNode extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$6, create_fragment$7, safe_not_equal, {
      value: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "RegExpNode",
      options,
      id: create_fragment$7.name
    });
  }
  get value() {
    throw new Error("<RegExpNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<RegExpNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}

/* ../../../node_modules/svelte-json-tree/_/JSONNode.svelte generated by Svelte v3.59.2 */
function create_fragment$6(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [{
    value: /*value*/ctx[0]
  }, /*props*/ctx[1]];
  var switch_value = /*componentType*/ctx[2];
  function switch_props(ctx) {
    let switch_instance_props = {};
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props());
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx, _ref) {
      let [dirty] = _ref;
      const switch_instance_changes = dirty & /*value, props*/3 ? get_spread_update(switch_instance_spread_levels, [dirty & /*value*/1 && {
        value: /*value*/ctx[0]
      }, dirty & /*props*/2 && get_spread_object( /*props*/ctx[1])]) : {};
      if (dirty & /*componentType*/4 && switch_value !== (switch_value = /*componentType*/ctx[2])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props());
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(switch_instance_anchor);
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$5($$self, $$props, $$invalidate) {
  let componentType;
  let props;
  let $nodeType;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('JSONNode', slots, []);
  let {
    value
  } = $$props;
  const nodeType = writable();
  validate_store(nodeType, 'nodeType');
  component_subscribe($$self, nodeType, value => $$invalidate(4, $nodeType = value));
  function getComponentAndProps(nodeType, value) {
    switch (nodeType) {
      case 'Object':
        if (typeof value.subscribe === 'function') return [JSONSvelteStoreNode];
        return [JSONObjectNode];
      case 'Error':
        return [ErrorNode];
      case 'Array':
        return [JSONArrayNode];
      case 'Map':
        return [JSONIterableMapNode];
      case 'Iterable':
      case 'Set':
        return [JSONIterableArrayNode, {
          nodeType
        }];
      case 'Number':
        return [JSONValueNode, {
          nodeType
        }];
      case 'String':
        return [JSONStringNode];
      case 'Boolean':
        return [JSONValueNode, {
          nodeType,
          value: value ? 'true' : 'false'
        }];
      case 'Date':
        return [JSONValueNode, {
          nodeType,
          value: value.toISOString()
        }];
      case 'Null':
        return [JSONValueNode, {
          nodeType,
          value: 'null'
        }];
      case 'Undefined':
        return [JSONValueNode, {
          nodeType,
          value: 'undefined'
        }];
      case 'Function':
      case 'AsyncFunction':
      case 'AsyncGeneratorFunction':
      case 'GeneratorFunction':
        return [JSONFunctionNode];
      case 'Symbol':
        return [JSONValueNode, {
          nodeType,
          value: value.toString()
        }];
      case 'BigInt':
        return [JSONValueNode, {
          nodeType,
          value: String(value) + 'n'
        }];
      case 'ArrayBuffer':
        return [JSONValueNode, {
          nodeType,
          value: "ArrayBuffer(".concat(value.byteLength, ")")
        }];
      case 'BigInt64Array':
      case 'BigUint64Array':
      case 'Float32Array':
      case 'Float64Array':
      case 'Int8Array':
      case 'Int16Array':
      case 'Int32Array':
      case 'Uint8Array':
      case 'Uint8ClampedArray':
      case 'Uint16Array':
      case 'Uint32Array':
        return [TypedArrayNode, {
          nodeType
        }];
      case 'RegExp':
        return [RegExpNode];
      default:
        return [JSONValueNode, {
          nodeType,
          value: "<".concat(nodeType, ">")
        }];
    }
  }
  $$self.$$.on_mount.push(function () {
    if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
      console.warn("<JSONNode> was created without expected prop 'value'");
    }
  });
  const writable_props = ['value'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<JSONNode> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$$set = $$props => {
    if ('value' in $$props) $$invalidate(0, value = $$props.value);
  };
  $$self.$capture_state = () => ({
    JSONObjectNode,
    JSONArrayNode,
    JSONIterableArrayNode,
    JSONIterableMapNode,
    JSONValueNode,
    ErrorNode,
    objType,
    writable,
    JsonStringNode: JSONStringNode,
    JsonFunctionNode: JSONFunctionNode,
    JsonSvelteStoreNode: JSONSvelteStoreNode,
    TypedArrayNode,
    RegExpNode,
    value,
    nodeType,
    getComponentAndProps,
    props,
    componentType,
    $nodeType
  });
  $$self.$inject_state = $$props => {
    if ('value' in $$props) $$invalidate(0, value = $$props.value);
    if ('props' in $$props) $$invalidate(1, props = $$props.props);
    if ('componentType' in $$props) $$invalidate(2, componentType = $$props.componentType);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/1) {
      set_store_value(nodeType, $nodeType = objType(value), $nodeType);
    }
    if ($$self.$$.dirty & /*$nodeType, value*/17) {
      $$invalidate(2, [componentType, props] = getComponentAndProps($nodeType, value), componentType, (($$invalidate(1, props), $$invalidate(4, $nodeType)), $$invalidate(0, value)));
    }
  };
  return [value, props, componentType, nodeType, $nodeType];
}
class JSONNode extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$5, create_fragment$6, safe_not_equal, {
      value: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "JSONNode",
      options,
      id: create_fragment$6.name
    });
  }
  get value() {
    throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}

function getShouldExpandNode(_ref) {
  let {
    defaultExpandedPaths,
    defaultExpandedLevel
  } = _ref;
  const defaultExpandedPathsParts = defaultExpandedPaths.map(path => path.split('.'));
  function matchPath(keyPath) {
    outer: for (const parts of defaultExpandedPathsParts) {
      if (keyPath.length > parts.length) continue;
      const length = Math.min(keyPath.length, parts.length);
      for (let i = 0; i < length; i++) {
        if (parts[i] !== '*' && parts[i] !== String(keyPath[i])) continue outer;
      }
      return true;
    }
    return false;
  }
  return function (_ref2) {
    let {
      keyPath,
      level
    } = _ref2;
    return level <= defaultExpandedLevel || matchPath(keyPath);
  };
}

/* ../../../node_modules/svelte-json-tree/_/Root.svelte generated by Svelte v3.59.2 */
const file$5 = "../../../node_modules/svelte-json-tree/_/Root.svelte";

// (22:2) <Expandable key="$" {expanded}>
function create_default_slot$1(ctx) {
  let jsonnode;
  let current;
  jsonnode = new JSONNode({
    props: {
      value: /*value*/ctx[0]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(jsonnode.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(jsonnode.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(jsonnode, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const jsonnode_changes = {};
      if (dirty & /*value*/1) jsonnode_changes.value = /*value*/ctx[0];
      jsonnode.$set(jsonnode_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsonnode.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsonnode.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(jsonnode, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot$1.name,
    type: "slot",
    source: "(22:2) <Expandable key=\\\"$\\\" {expanded}>",
    ctx
  });
  return block;
}
function create_fragment$5(ctx) {
  let ul;
  let expandable;
  let current;
  expandable = new Expandable({
    props: {
      key: "$",
      expanded: /*expanded*/ctx[1],
      $$slots: {
        default: [create_default_slot$1]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      ul = element("ul");
      create_component(expandable.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      ul = claim_element(nodes, "UL", {
        class: true
      });
      var ul_nodes = children(ul);
      claim_component(expandable.$$.fragment, ul_nodes);
      ul_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(ul, "class", "svelte-16cw61f");
      add_location(ul, file$5, 20, 0, 644);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, ul, anchor);
      mount_component(expandable, ul, null);
      current = true;
    },
    p: function update(ctx, _ref) {
      let [dirty] = _ref;
      const expandable_changes = {};
      if (dirty & /*$$scope, value*/33) {
        expandable_changes.$$scope = {
          dirty,
          ctx
        };
      }
      expandable.$set(expandable_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(expandable.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(expandable.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(ul);
      destroy_component(expandable);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$4($$self, $$props, $$invalidate) {
  let shouldExpandNode;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Root', slots, []);
  let {
    value
  } = $$props;
  let {
    defaultExpandedPaths = []
  } = $$props;
  let {
    defaultExpandedLevel = 0
  } = $$props;
  const expanded = writable(true);
  useState({
    expanded,
    isParentExpanded: readable(true),
    root: true,
    shouldExpandNode: opts => shouldExpandNode(opts),
    level: 0,
    keyPath: []
  });
  $$self.$$.on_mount.push(function () {
    if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
      console.warn("<Root> was created without expected prop 'value'");
    }
  });
  const writable_props = ['value', 'defaultExpandedPaths', 'defaultExpandedLevel'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Root> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$$set = $$props => {
    if ('value' in $$props) $$invalidate(0, value = $$props.value);
    if ('defaultExpandedPaths' in $$props) $$invalidate(2, defaultExpandedPaths = $$props.defaultExpandedPaths);
    if ('defaultExpandedLevel' in $$props) $$invalidate(3, defaultExpandedLevel = $$props.defaultExpandedLevel);
  };
  $$self.$capture_state = () => ({
    JSONNode,
    useState,
    readable,
    writable,
    Expandable,
    getShouldExpandNode,
    value,
    defaultExpandedPaths,
    defaultExpandedLevel,
    expanded,
    shouldExpandNode
  });
  $$self.$inject_state = $$props => {
    if ('value' in $$props) $$invalidate(0, value = $$props.value);
    if ('defaultExpandedPaths' in $$props) $$invalidate(2, defaultExpandedPaths = $$props.defaultExpandedPaths);
    if ('defaultExpandedLevel' in $$props) $$invalidate(3, defaultExpandedLevel = $$props.defaultExpandedLevel);
    if ('shouldExpandNode' in $$props) shouldExpandNode = $$props.shouldExpandNode;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*defaultExpandedPaths, defaultExpandedLevel*/12) {
      shouldExpandNode = getShouldExpandNode({
        defaultExpandedPaths,
        defaultExpandedLevel
      });
    }
  };
  return [value, expanded, defaultExpandedPaths, defaultExpandedLevel];
}
class Root extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$4, create_fragment$5, safe_not_equal, {
      value: 0,
      defaultExpandedPaths: 2,
      defaultExpandedLevel: 3
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Root",
      options,
      id: create_fragment$5.name
    });
  }
  get value() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultExpandedPaths() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultExpandedPaths(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get defaultExpandedLevel() {
    throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set defaultExpandedLevel(value) {
    throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}

/* src/lib/components/Elements.svelte generated by Svelte v3.59.2 */
const file$4 = "src/lib/components/Elements.svelte";
function get_each_context$2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[1] = list[i].tag;
  child_ctx[2] = list[i].content;
  return child_ctx;
}

// (8:25) 
function create_if_block_1$3(ctx) {
  let pre;
  let t_value = /*content*/ctx[2] + "";
  let t;
  const block = {
    c: function create() {
      pre = element("pre");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      pre = claim_element(nodes, "PRE", {});
      var pre_nodes = children(pre);
      t = claim_text(pre_nodes, t_value);
      pre_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(pre, file$4, 8, 2, 143);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, pre, anchor);
      append_hydration_dev(pre, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*elements*/1 && t_value !== (t_value = /*content*/ctx[2] + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(pre);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1$3.name,
    type: "if",
    source: "(8:25) ",
    ctx
  });
  return block;
}

// (6:1) {#if tag === 'p'}
function create_if_block$4(ctx) {
  let p;
  let t_value = /*content*/ctx[2] + "";
  let t;
  const block = {
    c: function create() {
      p = element("p");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      p = claim_element(nodes, "P", {});
      var p_nodes = children(p);
      t = claim_text(p_nodes, t_value);
      p_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(p, file$4, 6, 2, 98);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, p, anchor);
      append_hydration_dev(p, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*elements*/1 && t_value !== (t_value = /*content*/ctx[2] + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(p);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$4.name,
    type: "if",
    source: "(6:1) {#if tag === 'p'}",
    ctx
  });
  return block;
}

// (5:0) {#each elements as {tag, content}}
function create_each_block$2(ctx) {
  let if_block_anchor;
  function select_block_type(ctx, dirty) {
    if ( /*tag*/ctx[1] === 'p') return create_if_block$4;
    if ( /*tag*/ctx[1] === 'pre') return create_if_block_1$3;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type && current_block_type(ctx);
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if (if_block) if_block.d(1);
        if_block = current_block_type && current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d: function destroy(detaching) {
      if (if_block) {
        if_block.d(detaching);
      }
      if (detaching) detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block$2.name,
    type: "each",
    source: "(5:0) {#each elements as {tag, content}}",
    ctx
  });
  return block;
}
function create_fragment$4(ctx) {
  let each_1_anchor;
  let each_value = /*elements*/ctx[0];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx, _ref) {
      let [dirty] = _ref;
      if (dirty & /*elements*/1) {
        each_value = /*elements*/ctx[0];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$2(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching) detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$3($$self, $$props, $$invalidate) {
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('Elements', slots, []);
  let {
    elements
  } = $$props;
  $$self.$$.on_mount.push(function () {
    if (elements === undefined && !('elements' in $$props || $$self.$$.bound[$$self.$$.props['elements']])) {
      console.warn("<Elements> was created without expected prop 'elements'");
    }
  });
  const writable_props = ['elements'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<Elements> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$$set = $$props => {
    if ('elements' in $$props) $$invalidate(0, elements = $$props.elements);
  };
  $$self.$capture_state = () => ({
    elements
  });
  $$self.$inject_state = $$props => {
    if ('elements' in $$props) $$invalidate(0, elements = $$props.elements);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [elements];
}
class Elements extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$3, create_fragment$4, safe_not_equal, {
      elements: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Elements",
      options,
      id: create_fragment$4.name
    });
  }
  get elements() {
    throw new Error("<Elements>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set elements(value) {
    throw new Error("<Elements>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}

var barchart = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BarchartVDiv: BarchartVDiv
});

/* ../../components/choropleth/src/ChoroplethDiv.svelte generated by Svelte v3.59.2 */
const file$3 = "../../components/choropleth/src/ChoroplethDiv.svelte";

// (45:1) {#if title}
function create_if_block$3(ctx) {
  let header;
  let h2;
  let t;
  const block = {
    c: function create() {
      header = element("header");
      h2 = element("h2");
      t = text( /*title*/ctx[0]);
      this.h();
    },
    l: function claim(nodes) {
      header = claim_element(nodes, "HEADER", {
        class: true
      });
      var header_nodes = children(header);
      h2 = claim_element(header_nodes, "H2", {
        class: true
      });
      var h2_nodes = children(h2);
      t = claim_text(h2_nodes, /*title*/ctx[0]);
      h2_nodes.forEach(detach_dev);
      header_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h2, "class", "svelte-77ac80");
      add_location(h2, file$3, 46, 3, 1007);
      attr_dev(header, "class", "svelte-77ac80");
      add_location(header, file$3, 45, 2, 995);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, header, anchor);
      append_hydration_dev(header, h2);
      append_hydration_dev(h2, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*title*/1) set_data_dev(t, /*title*/ctx[0]);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(header);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$3.name,
    type: "if",
    source: "(45:1) {#if title}",
    ctx
  });
  return block;
}
function create_fragment$3(ctx) {
  let div;
  let t;
  let main;
  let svg;
  let choroplethg;
  let main_resize_listener;
  let current;
  let if_block = /*title*/ctx[0] && create_if_block$3(ctx);
  choroplethg = new ChoroplethG({
    props: {
      focusedKey: /*focusedKey*/ctx[5],
      geometry: /*geometry*/ctx[6],
      height: /*height*/ctx[16],
      isInteractive: /*isInteractive*/ctx[7],
      key_alt: /*key_alt*/ctx[4],
      key: /*key*/ctx[3],
      keyToColor: /*keyToColor*/ctx[8],
      keyToColorFn: /*keyToColorFn*/ctx[9],
      message: /*message*/ctx[10],
      projection: /*projection*/ctx[11],
      projectionFn: /*projectionFn*/ctx[12],
      projectionId: /*projectionId*/ctx[13],
      selectedKeys: /*selectedKeys*/ctx[14],
      theme: /*theme*/ctx[15],
      topojson: /*topojson*/ctx[1],
      topojsonId: /*topojsonId*/ctx[2],
      width: /*width*/ctx[17]
    },
    $$inline: true
  });
  choroplethg.$on("clicked", /*clicked_handler*/ctx[21]);
  choroplethg.$on("entered", /*entered_handler*/ctx[22]);
  choroplethg.$on("exited", /*exited_handler*/ctx[23]);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block) if_block.c();
      t = space();
      main = element("main");
      svg = svg_element("svg");
      create_component(choroplethg.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        style: true
      });
      var div_nodes = children(div);
      if (if_block) if_block.l(div_nodes);
      t = claim_space(div_nodes);
      main = claim_element(div_nodes, "MAIN", {
        class: true
      });
      var main_nodes = children(main);
      svg = claim_svg_element(main_nodes, "svg", {
        width: true,
        height: true,
        class: true
      });
      var svg_nodes = children(svg);
      claim_component(choroplethg.$$.fragment, svg_nodes);
      svg_nodes.forEach(detach_dev);
      main_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "width", /*width*/ctx[17]);
      attr_dev(svg, "height", /*height*/ctx[16]);
      attr_dev(svg, "class", "svelte-77ac80");
      add_location(svg, file$3, 54, 2, 1150);
      attr_dev(main, "class", "svelte-77ac80");
      add_render_callback(() => /*main_elementresize_handler*/ctx[24].call(main));
      toggle_class(main, "titled", /*title*/ctx[0] && /*title*/ctx[0].length);
      add_location(main, file$3, 49, 1, 1044);
      attr_dev(div, "class", "ChoroplethDiv svelte-77ac80");
      attr_dev(div, "style", /*style*/ctx[18]);
      toggle_class(div, "interactive", /*isInteractive*/ctx[7]);
      add_location(div, file$3, 39, 0, 906);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block) if_block.m(div, null);
      append_hydration_dev(div, t);
      append_hydration_dev(div, main);
      append_hydration_dev(main, svg);
      mount_component(choroplethg, svg, null);
      main_resize_listener = add_iframe_resize_listener(main, /*main_elementresize_handler*/ctx[24].bind(main));
      current = true;
    },
    p: function update(ctx, _ref) {
      let [dirty] = _ref;
      if ( /*title*/ctx[0]) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block$3(ctx);
          if_block.c();
          if_block.m(div, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const choroplethg_changes = {};
      if (dirty & /*focusedKey*/32) choroplethg_changes.focusedKey = /*focusedKey*/ctx[5];
      if (dirty & /*geometry*/64) choroplethg_changes.geometry = /*geometry*/ctx[6];
      if (dirty & /*height*/65536) choroplethg_changes.height = /*height*/ctx[16];
      if (dirty & /*isInteractive*/128) choroplethg_changes.isInteractive = /*isInteractive*/ctx[7];
      if (dirty & /*key_alt*/16) choroplethg_changes.key_alt = /*key_alt*/ctx[4];
      if (dirty & /*key*/8) choroplethg_changes.key = /*key*/ctx[3];
      if (dirty & /*keyToColor*/256) choroplethg_changes.keyToColor = /*keyToColor*/ctx[8];
      if (dirty & /*keyToColorFn*/512) choroplethg_changes.keyToColorFn = /*keyToColorFn*/ctx[9];
      if (dirty & /*message*/1024) choroplethg_changes.message = /*message*/ctx[10];
      if (dirty & /*projection*/2048) choroplethg_changes.projection = /*projection*/ctx[11];
      if (dirty & /*projectionFn*/4096) choroplethg_changes.projectionFn = /*projectionFn*/ctx[12];
      if (dirty & /*projectionId*/8192) choroplethg_changes.projectionId = /*projectionId*/ctx[13];
      if (dirty & /*selectedKeys*/16384) choroplethg_changes.selectedKeys = /*selectedKeys*/ctx[14];
      if (dirty & /*theme*/32768) choroplethg_changes.theme = /*theme*/ctx[15];
      if (dirty & /*topojson*/2) choroplethg_changes.topojson = /*topojson*/ctx[1];
      if (dirty & /*topojsonId*/4) choroplethg_changes.topojsonId = /*topojsonId*/ctx[2];
      if (dirty & /*width*/131072) choroplethg_changes.width = /*width*/ctx[17];
      choroplethg.$set(choroplethg_changes);
      if (!current || dirty & /*width*/131072) {
        attr_dev(svg, "width", /*width*/ctx[17]);
      }
      if (!current || dirty & /*height*/65536) {
        attr_dev(svg, "height", /*height*/ctx[16]);
      }
      if (!current || dirty & /*title*/1) {
        toggle_class(main, "titled", /*title*/ctx[0] && /*title*/ctx[0].length);
      }
      if (!current || dirty & /*style*/262144) {
        attr_dev(div, "style", /*style*/ctx[18]);
      }
      if (!current || dirty & /*isInteractive*/128) {
        toggle_class(div, "interactive", /*isInteractive*/ctx[7]);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(choroplethg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(choroplethg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(div);
      if (if_block) if_block.d();
      destroy_component(choroplethg);
      main_resize_listener();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$2($$self, $$props, $$invalidate) {
  let style;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('ChoroplethDiv', slots, []);
  let {
    headerHeight
  } = $$props;
  let {
    padding
  } = $$props;
  let {
    title
  } = $$props;
  let {
    topojson = null
  } = $$props;
  let {
    topojsonId = null
  } = $$props;
  let {
    key = null
  } = $$props;
  let {
    key_alt = null
  } = $$props;
  let {
    focusedKey = null
  } = $$props;
  let {
    geometry = null
  } = $$props;
  let {
    isInteractive = false
  } = $$props;
  let {
    keyToColor = null
  } = $$props;
  let {
    keyToColorFn = null
  } = $$props;
  let {
    message = null
  } = $$props;
  let {
    projection = null
  } = $$props;
  let {
    projectionFn = null
  } = $$props;
  let {
    projectionId = null
  } = $$props;
  let {
    selectedKeys = []
  } = $$props;
  let {
    theme = null
  } = $$props;
  let height = 0;
  let width = 0;
  $$self.$$.on_mount.push(function () {
    if (headerHeight === undefined && !('headerHeight' in $$props || $$self.$$.bound[$$self.$$.props['headerHeight']])) {
      console.warn("<ChoroplethDiv> was created without expected prop 'headerHeight'");
    }
    if (padding === undefined && !('padding' in $$props || $$self.$$.bound[$$self.$$.props['padding']])) {
      console.warn("<ChoroplethDiv> was created without expected prop 'padding'");
    }
    if (title === undefined && !('title' in $$props || $$self.$$.bound[$$self.$$.props['title']])) {
      console.warn("<ChoroplethDiv> was created without expected prop 'title'");
    }
  });
  const writable_props = ['headerHeight', 'padding', 'title', 'topojson', 'topojsonId', 'key', 'key_alt', 'focusedKey', 'geometry', 'isInteractive', 'keyToColor', 'keyToColorFn', 'message', 'projection', 'projectionFn', 'projectionId', 'selectedKeys', 'theme'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<ChoroplethDiv> was created with unknown prop '".concat(key, "'"));
  });
  function clicked_handler(event) {
    bubble.call(this, $$self, event);
  }
  function entered_handler(event) {
    bubble.call(this, $$self, event);
  }
  function exited_handler(event) {
    bubble.call(this, $$self, event);
  }
  function main_elementresize_handler() {
    width = this.clientWidth;
    height = this.clientHeight;
    $$invalidate(17, width);
    $$invalidate(16, height);
  }
  $$self.$$set = $$props => {
    if ('headerHeight' in $$props) $$invalidate(19, headerHeight = $$props.headerHeight);
    if ('padding' in $$props) $$invalidate(20, padding = $$props.padding);
    if ('title' in $$props) $$invalidate(0, title = $$props.title);
    if ('topojson' in $$props) $$invalidate(1, topojson = $$props.topojson);
    if ('topojsonId' in $$props) $$invalidate(2, topojsonId = $$props.topojsonId);
    if ('key' in $$props) $$invalidate(3, key = $$props.key);
    if ('key_alt' in $$props) $$invalidate(4, key_alt = $$props.key_alt);
    if ('focusedKey' in $$props) $$invalidate(5, focusedKey = $$props.focusedKey);
    if ('geometry' in $$props) $$invalidate(6, geometry = $$props.geometry);
    if ('isInteractive' in $$props) $$invalidate(7, isInteractive = $$props.isInteractive);
    if ('keyToColor' in $$props) $$invalidate(8, keyToColor = $$props.keyToColor);
    if ('keyToColorFn' in $$props) $$invalidate(9, keyToColorFn = $$props.keyToColorFn);
    if ('message' in $$props) $$invalidate(10, message = $$props.message);
    if ('projection' in $$props) $$invalidate(11, projection = $$props.projection);
    if ('projectionFn' in $$props) $$invalidate(12, projectionFn = $$props.projectionFn);
    if ('projectionId' in $$props) $$invalidate(13, projectionId = $$props.projectionId);
    if ('selectedKeys' in $$props) $$invalidate(14, selectedKeys = $$props.selectedKeys);
    if ('theme' in $$props) $$invalidate(15, theme = $$props.theme);
  };
  $$self.$capture_state = () => ({
    makeStyleVars,
    ChoroplethG,
    headerHeight,
    padding,
    title,
    topojson,
    topojsonId,
    key,
    key_alt,
    focusedKey,
    geometry,
    isInteractive,
    keyToColor,
    keyToColorFn,
    message,
    projection,
    projectionFn,
    projectionId,
    selectedKeys,
    theme,
    height,
    width,
    style
  });
  $$self.$inject_state = $$props => {
    if ('headerHeight' in $$props) $$invalidate(19, headerHeight = $$props.headerHeight);
    if ('padding' in $$props) $$invalidate(20, padding = $$props.padding);
    if ('title' in $$props) $$invalidate(0, title = $$props.title);
    if ('topojson' in $$props) $$invalidate(1, topojson = $$props.topojson);
    if ('topojsonId' in $$props) $$invalidate(2, topojsonId = $$props.topojsonId);
    if ('key' in $$props) $$invalidate(3, key = $$props.key);
    if ('key_alt' in $$props) $$invalidate(4, key_alt = $$props.key_alt);
    if ('focusedKey' in $$props) $$invalidate(5, focusedKey = $$props.focusedKey);
    if ('geometry' in $$props) $$invalidate(6, geometry = $$props.geometry);
    if ('isInteractive' in $$props) $$invalidate(7, isInteractive = $$props.isInteractive);
    if ('keyToColor' in $$props) $$invalidate(8, keyToColor = $$props.keyToColor);
    if ('keyToColorFn' in $$props) $$invalidate(9, keyToColorFn = $$props.keyToColorFn);
    if ('message' in $$props) $$invalidate(10, message = $$props.message);
    if ('projection' in $$props) $$invalidate(11, projection = $$props.projection);
    if ('projectionFn' in $$props) $$invalidate(12, projectionFn = $$props.projectionFn);
    if ('projectionId' in $$props) $$invalidate(13, projectionId = $$props.projectionId);
    if ('selectedKeys' in $$props) $$invalidate(14, selectedKeys = $$props.selectedKeys);
    if ('theme' in $$props) $$invalidate(15, theme = $$props.theme);
    if ('height' in $$props) $$invalidate(16, height = $$props.height);
    if ('width' in $$props) $$invalidate(17, width = $$props.width);
    if ('style' in $$props) $$invalidate(18, style = $$props.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*padding*/1048576) {
      $$invalidate(20, padding = padding || '10px');
    }
    if ($$self.$$.dirty & /*headerHeight*/524288) {
      $$invalidate(19, headerHeight = headerHeight || '2rem');
    }
    if ($$self.$$.dirty & /*headerHeight, padding*/1572864) {
      $$invalidate(18, style = makeStyleVars({
        headerHeight,
        padding
      }));
    }
  };
  return [title, topojson, topojsonId, key, key_alt, focusedKey, geometry, isInteractive, keyToColor, keyToColorFn, message, projection, projectionFn, projectionId, selectedKeys, theme, height, width, style, headerHeight, padding, clicked_handler, entered_handler, exited_handler, main_elementresize_handler];
}
class ChoroplethDiv extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$2, create_fragment$3, safe_not_equal, {
      headerHeight: 19,
      padding: 20,
      title: 0,
      topojson: 1,
      topojsonId: 2,
      key: 3,
      key_alt: 4,
      focusedKey: 5,
      geometry: 6,
      isInteractive: 7,
      keyToColor: 8,
      keyToColorFn: 9,
      message: 10,
      projection: 11,
      projectionFn: 12,
      projectionId: 13,
      selectedKeys: 14,
      theme: 15
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "ChoroplethDiv",
      options,
      id: create_fragment$3.name
    });
  }
  get headerHeight() {
    throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headerHeight(value) {
    throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topojson() {
    throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topojson(value) {
    throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get topojsonId() {
    throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set topojsonId(value) {
    throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get key() {
    throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value) {
    throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get key_alt() {
    throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key_alt(value) {
    throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focusedKey() {
    throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set focusedKey(value) {
    throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isInteractive() {
    throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set isInteractive(value) {
    throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keyToColor() {
    throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keyToColor(value) {
    throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get keyToColorFn() {
    throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set keyToColorFn(value) {
    throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get message() {
    throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set message(value) {
    throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get projection() {
    throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set projection(value) {
    throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get projectionFn() {
    throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set projectionFn(value) {
    throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get projectionId() {
    throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set projectionId(value) {
    throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedKeys() {
    throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedKeys(value) {
    throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
var ChoroplethDiv$1 = ChoroplethDiv;

var choropleth = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ChoroplethG: ChoroplethG,
	ChoroplethDiv: ChoroplethDiv$1,
	defaultGeometry: defaultGeometry,
	projections: projections
});

/* ../../components/histogram/src/HistogramG.svelte generated by Svelte v3.59.2 */
const file$2 = "../../components/histogram/src/HistogramG.svelte";
function get_each_context$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[53] = list[i].tick;
  child_ctx[54] = list[i].y;
  return child_ctx;
}
function get_each_context_1$1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[57] = list[i].barLength;
  child_ctx[58] = list[i].barThickness;
  child_ctx[59] = list[i].displayValue;
  child_ctx[60] = list[i].fill;
  child_ctx[61] = list[i].labelAnchor;
  child_ctx[62] = list[i].labelX;
  child_ctx[63] = list[i].selected;
  child_ctx[64] = list[i].x;
  child_ctx[65] = list[i].y1;
  child_ctx[67] = i;
  return child_ctx;
}

// (334:0) {#if height && width}
function create_if_block$2(ctx) {
  let g;
  function select_block_type(ctx, dirty) {
    if ( /*bins*/ctx[0].length === 0) return create_if_block_1$2;
    return create_else_block$1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  const block = {
    c: function create() {
      g = svg_element("g");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      g = claim_svg_element(nodes, "g", {
        style: true,
        class: true
      });
      var g_nodes = children(g);
      if_block.l(g_nodes);
      g_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(g, "style", /*style*/ctx[13]);
      attr_dev(g, "class", "HistogramG svelte-1egg7b");
      toggle_class(g, "interactive", /*flags*/ctx[1].isInteractive);
      add_location(g, file$2, 334, 1, 8113);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, g, anchor);
      if_block.m(g, null);
    },
    p: function update(ctx, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
        if_block.p(ctx, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx);
        if (if_block) {
          if_block.c();
          if_block.m(g, null);
        }
      }
      if (dirty[0] & /*style*/8192) {
        attr_dev(g, "style", /*style*/ctx[13]);
      }
      if (dirty[0] & /*flags*/2) {
        toggle_class(g, "interactive", /*flags*/ctx[1].isInteractive);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(g);
      if_block.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$2.name,
    type: "if",
    source: "(334:0) {#if height && width}",
    ctx
  });
  return block;
}

// (348:2) {:else}
function create_else_block$1(ctx) {
  let if_block0_anchor;
  let g1;
  let g0;
  let line;
  let line_y__value;
  let if_block2_anchor;
  let g0_transform_value;
  let g1_transform_value;
  let if_block0 = /*flags*/ctx[1].withBackground && create_if_block_8$1(ctx);
  let if_block1 = /*flags*/ctx[1].isInteractive && create_if_block_7$1(ctx);
  let each_value_1 = /*bars*/ctx[8];
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
  }
  let if_block2 = ! /*flags*/ctx[1].hideOrigin && create_if_block_4$1(ctx);
  let if_block3 = ! /*flags*/ctx[1].hideTicks && create_if_block_3$1(ctx);
  let if_block4 = /*isBrushing*/ctx[7] && create_if_block_2$1(ctx);
  const block = {
    c: function create() {
      if (if_block0) if_block0.c();
      if_block0_anchor = empty();
      if (if_block1) if_block1.c();
      g1 = svg_element("g");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      g0 = svg_element("g");
      line = svg_element("line");
      if (if_block2) if_block2.c();
      if_block2_anchor = empty();
      if (if_block3) if_block3.c();
      if (if_block4) if_block4.c();
      this.h();
    },
    l: function claim(nodes) {
      if (if_block0) if_block0.l(nodes);
      if_block0_anchor = empty();
      if (if_block1) if_block1.l(nodes);
      g1 = claim_svg_element(nodes, "g", {
        transform: true
      });
      var g1_nodes = children(g1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(g1_nodes);
      }
      g0 = claim_svg_element(g1_nodes, "g", {
        class: true,
        transform: true
      });
      var g0_nodes = children(g0);
      line = claim_svg_element(g0_nodes, "line", {
        y2: true,
        class: true
      });
      children(line).forEach(detach_dev);
      if (if_block2) if_block2.l(g0_nodes);
      if_block2_anchor = empty();
      if (if_block3) if_block3.l(g0_nodes);
      g0_nodes.forEach(detach_dev);
      if (if_block4) if_block4.l(g1_nodes);
      g1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "y2", line_y__value = /*flags*/ctx[1].isTopDown ? /*innerHeight*/ctx[9] : - /*innerHeight*/ctx[9]);
      attr_dev(line, "class", "svelte-1egg7b");
      add_location(line, file$2, 424, 5, 9918);
      attr_dev(g0, "class", "axis svelte-1egg7b");
      attr_dev(g0, "transform", g0_transform_value = "translate(" + /*origin*/ctx[19].x + "," + /*origin*/ctx[19].y + ")");
      add_location(g0, file$2, 420, 4, 9838);
      attr_dev(g1, "transform", g1_transform_value = "translate(" + /*safety*/ctx[11].left + "," + /*safety*/ctx[11].top + ")");
      add_location(g1, file$2, 368, 3, 8711);
    },
    m: function mount(target, anchor) {
      if (if_block0) if_block0.m(target, anchor);
      insert_hydration_dev(target, if_block0_anchor, anchor);
      if (if_block1) if_block1.m(target, anchor);
      insert_hydration_dev(target, g1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(g1, null);
        }
      }
      append_hydration_dev(g1, g0);
      append_hydration_dev(g0, line);
      if (if_block2) if_block2.m(g0, null);
      append_hydration_dev(g0, if_block2_anchor);
      if (if_block3) if_block3.m(g0, null);
      if (if_block4) if_block4.m(g1, null);
    },
    p: function update(ctx, dirty) {
      if ( /*flags*/ctx[1].withBackground) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_8$1(ctx);
          if_block0.c();
          if_block0.m(if_block0_anchor.parentNode, if_block0_anchor);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if ( /*flags*/ctx[1].isInteractive) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_7$1(ctx);
          if_block1.c();
          if_block1.m(g1.parentNode, g1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & /*bars, innerWidth, onMousedown, onMouseenter, onMouseleave, isMousedown, onMousemove, onMouseup, flags, fontSize*/65049858) {
        each_value_1 = /*bars*/ctx[8];
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1$1(ctx, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_1$1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(g1, g0);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty[0] & /*flags, innerHeight*/514 && line_y__value !== (line_y__value = /*flags*/ctx[1].isTopDown ? /*innerHeight*/ctx[9] : - /*innerHeight*/ctx[9])) {
        attr_dev(line, "y2", line_y__value);
      }
      if (! /*flags*/ctx[1].hideOrigin) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
        } else {
          if_block2 = create_if_block_4$1(ctx);
          if_block2.c();
          if_block2.m(g0, if_block2_anchor);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (! /*flags*/ctx[1].hideTicks) {
        if (if_block3) {
          if_block3.p(ctx, dirty);
        } else {
          if_block3 = create_if_block_3$1(ctx);
          if_block3.c();
          if_block3.m(g0, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (dirty[0] & /*origin*/524288 && g0_transform_value !== (g0_transform_value = "translate(" + /*origin*/ctx[19].x + "," + /*origin*/ctx[19].y + ")")) {
        attr_dev(g0, "transform", g0_transform_value);
      }
      if ( /*isBrushing*/ctx[7]) {
        if (if_block4) {
          if_block4.p(ctx, dirty);
        } else {
          if_block4 = create_if_block_2$1(ctx);
          if_block4.c();
          if_block4.m(g1, null);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (dirty[0] & /*safety*/2048 && g1_transform_value !== (g1_transform_value = "translate(" + /*safety*/ctx[11].left + "," + /*safety*/ctx[11].top + ")")) {
        attr_dev(g1, "transform", g1_transform_value);
      }
    },
    d: function destroy(detaching) {
      if (if_block0) if_block0.d(detaching);
      if (detaching) detach_dev(if_block0_anchor);
      if (if_block1) if_block1.d(detaching);
      if (detaching) detach_dev(g1);
      destroy_each(each_blocks, detaching);
      if (if_block2) if_block2.d();
      if (if_block3) if_block3.d();
      if (if_block4) if_block4.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block$1.name,
    type: "else",
    source: "(348:2) {:else}",
    ctx
  });
  return block;
}

// (340:2) {#if bins.length === 0}
function create_if_block_1$2(ctx) {
  let text_1;
  let t;
  let text_1_x_value;
  let text_1_y_value;
  const block = {
    c: function create() {
      text_1 = svg_element("text");
      t = text( /*message*/ctx[3]);
      this.h();
    },
    l: function claim(nodes) {
      text_1 = claim_svg_element(nodes, "text", {
        class: true,
        x: true,
        y: true
      });
      var text_1_nodes = children(text_1);
      t = claim_text(text_1_nodes, /*message*/ctx[3]);
      text_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(text_1, "class", "message svelte-1egg7b");
      attr_dev(text_1, "x", text_1_x_value = /*width*/ctx[6] / 2);
      attr_dev(text_1, "y", text_1_y_value = /*height*/ctx[5] / 2);
      add_location(text_1, file$2, 341, 3, 8222);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, text_1, anchor);
      append_hydration_dev(text_1, t);
    },
    p: function update(ctx, dirty) {
      if (dirty[0] & /*message*/8) set_data_dev(t, /*message*/ctx[3]);
      if (dirty[0] & /*width*/64 && text_1_x_value !== (text_1_x_value = /*width*/ctx[6] / 2)) {
        attr_dev(text_1, "x", text_1_x_value);
      }
      if (dirty[0] & /*height*/32 && text_1_y_value !== (text_1_y_value = /*height*/ctx[5] / 2)) {
        attr_dev(text_1, "y", text_1_y_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(text_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1$2.name,
    type: "if",
    source: "(340:2) {#if bins.length === 0}",
    ctx
  });
  return block;
}

// (351:3) {#if flags.withBackground}
function create_if_block_8$1(ctx) {
  let rect;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        class: true,
        width: true,
        height: true
      });
      children(rect).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "class", "bkg svelte-1egg7b");
      attr_dev(rect, "width", /*width*/ctx[6]);
      attr_dev(rect, "height", /*height*/ctx[5]);
      add_location(rect, file$2, 351, 4, 8371);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
    },
    p: function update(ctx, dirty) {
      if (dirty[0] & /*width*/64) {
        attr_dev(rect, "width", /*width*/ctx[6]);
      }
      if (dirty[0] & /*height*/32) {
        attr_dev(rect, "height", /*height*/ctx[5]);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8$1.name,
    type: "if",
    source: "(351:3) {#if flags.withBackground}",
    ctx
  });
  return block;
}

// (356:3) {#if flags.isInteractive}
function create_if_block_7$1(ctx) {
  let rect;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        height: true,
        width: true,
        class: true,
        role: true,
        tabindex: true
      });
      children(rect).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "height", /*height*/ctx[5]);
      attr_dev(rect, "width", /*width*/ctx[6]);
      attr_dev(rect, "class", "bkgSensor svelte-1egg7b");
      attr_dev(rect, "role", "button");
      attr_dev(rect, "tabindex", "0");
      toggle_class(rect, "reset", /*selectedBins*/ctx[4].length > 0);
      add_location(rect, file$2, 356, 4, 8496);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      if (!mounted) {
        dispose = [listen_dev(rect, "click", /*resetSelection*/ctx[26], false, false, false, false), listen_dev(rect, "keydown", /*onKeyDown*/ctx[27], false, false, false, false)];
        mounted = true;
      }
    },
    p: function update(ctx, dirty) {
      if (dirty[0] & /*height*/32) {
        attr_dev(rect, "height", /*height*/ctx[5]);
      }
      if (dirty[0] & /*width*/64) {
        attr_dev(rect, "width", /*width*/ctx[6]);
      }
      if (dirty[0] & /*selectedBins*/16) {
        toggle_class(rect, "reset", /*selectedBins*/ctx[4].length > 0);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7$1.name,
    type: "if",
    source: "(356:3) {#if flags.isInteractive}",
    ctx
  });
  return block;
}

// (385:6) {#if displayValue}
function create_if_block_6$1(ctx) {
  let rect;
  let rect_fill_value;
  let rect_x_value;
  let rect_height_value;
  let rect_width_value;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        fill: true,
        x: true,
        class: true,
        height: true,
        width: true
      });
      children(rect).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "fill", rect_fill_value = /*fill*/ctx[60]);
      attr_dev(rect, "x", rect_x_value = /*x*/ctx[64]);
      attr_dev(rect, "class", "bar svelte-1egg7b");
      attr_dev(rect, "height", rect_height_value = /*barThickness*/ctx[58]);
      attr_dev(rect, "width", rect_width_value = /*barLength*/ctx[57]);
      toggle_class(rect, "selected", /*selected*/ctx[63]);
      add_location(rect, file$2, 385, 7, 9029);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
    },
    p: function update(ctx, dirty) {
      if (dirty[0] & /*bars*/256 && rect_fill_value !== (rect_fill_value = /*fill*/ctx[60])) {
        attr_dev(rect, "fill", rect_fill_value);
      }
      if (dirty[0] & /*bars*/256 && rect_x_value !== (rect_x_value = /*x*/ctx[64])) {
        attr_dev(rect, "x", rect_x_value);
      }
      if (dirty[0] & /*bars*/256 && rect_height_value !== (rect_height_value = /*barThickness*/ctx[58])) {
        attr_dev(rect, "height", rect_height_value);
      }
      if (dirty[0] & /*bars*/256 && rect_width_value !== (rect_width_value = /*barLength*/ctx[57])) {
        attr_dev(rect, "width", rect_width_value);
      }
      if (dirty[0] & /*bars*/256) {
        toggle_class(rect, "selected", /*selected*/ctx[63]);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6$1.name,
    type: "if",
    source: "(385:6) {#if displayValue}",
    ctx
  });
  return block;
}

// (404:6) {#if flags.isInteractive}
function create_if_block_5$1(ctx) {
  let rect;
  let rect_height_value;
  let mounted;
  let dispose;
  const block = {
    c: function create() {
      rect = svg_element("rect");
      this.h();
    },
    l: function claim(nodes) {
      rect = claim_svg_element(nodes, "rect", {
        class: true,
        height: true,
        role: true,
        width: true
      });
      children(rect).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(rect, "class", "sensor svelte-1egg7b");
      attr_dev(rect, "height", rect_height_value = /*barThickness*/ctx[58]);
      attr_dev(rect, "role", "none");
      attr_dev(rect, "width", /*innerWidth*/ctx[10]);
      add_location(rect, file$2, 405, 7, 9459);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, rect, anchor);
      if (!mounted) {
        dispose = [listen_dev(rect, "mousedown", /*onMousedown*/ctx[22], false, false, false, false), listen_dev(rect, "mouseenter", /*onMouseenter*/ctx[21]( /*index*/ctx[67]), false, false, false, false), listen_dev(rect, "mouseleave", /*onMouseleave*/ctx[25]( /*index*/ctx[67]), false, false, false, false), listen_dev(rect, "mousemove", function () {
          if (is_function( /*isMousedown*/ctx[12] ? /*onMousemove*/ctx[23]( /*index*/ctx[67]) : null)) ( /*isMousedown*/ctx[12] ? /*onMousemove*/ctx[23]( /*index*/ctx[67]) : null).apply(this, arguments);
        }, false, false, false, false), listen_dev(rect, "mouseup", /*onMouseup*/ctx[24]( /*index*/ctx[67]), false, false, false, false)];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*bars*/256 && rect_height_value !== (rect_height_value = /*barThickness*/ctx[58])) {
        attr_dev(rect, "height", rect_height_value);
      }
      if (dirty[0] & /*innerWidth*/1024) {
        attr_dev(rect, "width", /*innerWidth*/ctx[10]);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(rect);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5$1.name,
    type: "if",
    source: "(404:6) {#if flags.isInteractive}",
    ctx
  });
  return block;
}

// (370:4) {#each bars as {      barLength,      barThickness,      displayValue,      fill,      labelAnchor,      labelX,      selected,      x,      y1,     }
function create_each_block_1$1(ctx) {
  let g;
  let text_1;
  let t_value = /*displayValue*/ctx[59] + "";
  let t;
  let text_1_x_value;
  let text_1_y_value;
  let text_1_text_anchor_value;
  let g_transform_value;
  let if_block0 = /*displayValue*/ctx[59] && create_if_block_6$1(ctx);
  let if_block1 = /*flags*/ctx[1].isInteractive && create_if_block_5$1(ctx);
  const block = {
    c: function create() {
      g = svg_element("g");
      if (if_block0) if_block0.c();
      text_1 = svg_element("text");
      t = text(t_value);
      if (if_block1) if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      g = claim_svg_element(nodes, "g", {
        class: true,
        transform: true
      });
      var g_nodes = children(g);
      if (if_block0) if_block0.l(g_nodes);
      text_1 = claim_svg_element(g_nodes, "text", {
        class: true,
        x: true,
        y: true,
        "font-size": true,
        "text-anchor": true
      });
      var text_1_nodes = children(text_1);
      t = claim_text(text_1_nodes, t_value);
      text_1_nodes.forEach(detach_dev);
      if (if_block1) if_block1.l(g_nodes);
      g_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(text_1, "class", "binsize svelte-1egg7b");
      attr_dev(text_1, "x", text_1_x_value = /*labelX*/ctx[62]);
      attr_dev(text_1, "y", text_1_y_value = /*barThickness*/ctx[58] / 2);
      attr_dev(text_1, "font-size", /*fontSize*/ctx[15]);
      attr_dev(text_1, "text-anchor", text_1_text_anchor_value = /*labelAnchor*/ctx[61]);
      add_location(text_1, file$2, 395, 6, 9190);
      attr_dev(g, "class", "bin svelte-1egg7b");
      attr_dev(g, "transform", g_transform_value = "translate(0," + /*y1*/ctx[65] + ")");
      add_location(g, file$2, 380, 5, 8933);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, g, anchor);
      if (if_block0) if_block0.m(g, null);
      append_hydration_dev(g, text_1);
      append_hydration_dev(text_1, t);
      if (if_block1) if_block1.m(g, null);
    },
    p: function update(ctx, dirty) {
      if ( /*displayValue*/ctx[59]) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_6$1(ctx);
          if_block0.c();
          if_block0.m(g, text_1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & /*bars*/256 && t_value !== (t_value = /*displayValue*/ctx[59] + "")) set_data_dev(t, t_value);
      if (dirty[0] & /*bars*/256 && text_1_x_value !== (text_1_x_value = /*labelX*/ctx[62])) {
        attr_dev(text_1, "x", text_1_x_value);
      }
      if (dirty[0] & /*bars*/256 && text_1_y_value !== (text_1_y_value = /*barThickness*/ctx[58] / 2)) {
        attr_dev(text_1, "y", text_1_y_value);
      }
      if (dirty[0] & /*fontSize*/32768) {
        attr_dev(text_1, "font-size", /*fontSize*/ctx[15]);
      }
      if (dirty[0] & /*bars*/256 && text_1_text_anchor_value !== (text_1_text_anchor_value = /*labelAnchor*/ctx[61])) {
        attr_dev(text_1, "text-anchor", text_1_text_anchor_value);
      }
      if ( /*flags*/ctx[1].isInteractive) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_5$1(ctx);
          if_block1.c();
          if_block1.m(g, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & /*bars*/256 && g_transform_value !== (g_transform_value = "translate(0," + /*y1*/ctx[65] + ")")) {
        attr_dev(g, "transform", g_transform_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(g);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1$1.name,
    type: "each",
    source: "(370:4) {#each bars as {      barLength,      barThickness,      displayValue,      fill,      labelAnchor,      labelX,      selected,      x,      y1,     }",
    ctx
  });
  return block;
}

// (429:5) {#if !flags.hideOrigin}
function create_if_block_4$1(ctx) {
  let circle;
  let circle_r_value;
  const block = {
    c: function create() {
      circle = svg_element("circle");
      this.h();
    },
    l: function claim(nodes) {
      circle = claim_svg_element(nodes, "circle", {
        r: true,
        class: true
      });
      children(circle).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle, "r", circle_r_value = /*geometry*/ctx[2].originRadius);
      attr_dev(circle, "class", "svelte-1egg7b");
      add_location(circle, file$2, 429, 6, 10024);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, circle, anchor);
    },
    p: function update(ctx, dirty) {
      if (dirty[0] & /*geometry*/4 && circle_r_value !== (circle_r_value = /*geometry*/ctx[2].originRadius)) {
        attr_dev(circle, "r", circle_r_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(circle);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4$1.name,
    type: "if",
    source: "(429:5) {#if !flags.hideOrigin}",
    ctx
  });
  return block;
}

// (433:5) {#if !flags.hideTicks}
function create_if_block_3$1(ctx) {
  let each_1_anchor;
  let each_value = /*ticks*/ctx[16];
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
    },
    p: function update(ctx, dirty) {
      if (dirty[0] & /*ticksX, ticks, fontSize, ticksAnchor*/491520) {
        each_value = /*ticks*/ctx[16];
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context$1(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block$1(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching) detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3$1.name,
    type: "if",
    source: "(433:5) {#if !flags.hideTicks}",
    ctx
  });
  return block;
}

// (434:6) {#each ticks as {tick, y}}
function create_each_block$1(ctx) {
  let text_1;
  let t_value = /*tick*/ctx[53] + "";
  let t;
  let text_1_y_value;
  const block = {
    c: function create() {
      text_1 = svg_element("text");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      text_1 = claim_svg_element(nodes, "text", {
        class: true,
        x: true,
        y: true,
        "font-size": true,
        "text-anchor": true
      });
      var text_1_nodes = children(text_1);
      t = claim_text(text_1_nodes, t_value);
      text_1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(text_1, "class", "range svelte-1egg7b");
      attr_dev(text_1, "x", /*ticksX*/ctx[18]);
      attr_dev(text_1, "y", text_1_y_value = /*y*/ctx[54]);
      attr_dev(text_1, "font-size", /*fontSize*/ctx[15]);
      attr_dev(text_1, "text-anchor", /*ticksAnchor*/ctx[17]);
      add_location(text_1, file$2, 434, 7, 10141);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, text_1, anchor);
      append_hydration_dev(text_1, t);
    },
    p: function update(ctx, dirty) {
      if (dirty[0] & /*ticks*/65536 && t_value !== (t_value = /*tick*/ctx[53] + "")) set_data_dev(t, t_value);
      if (dirty[0] & /*ticksX*/262144) {
        attr_dev(text_1, "x", /*ticksX*/ctx[18]);
      }
      if (dirty[0] & /*ticks*/65536 && text_1_y_value !== (text_1_y_value = /*y*/ctx[54])) {
        attr_dev(text_1, "y", text_1_y_value);
      }
      if (dirty[0] & /*fontSize*/32768) {
        attr_dev(text_1, "font-size", /*fontSize*/ctx[15]);
      }
      if (dirty[0] & /*ticksAnchor*/131072) {
        attr_dev(text_1, "text-anchor", /*ticksAnchor*/ctx[17]);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(text_1);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block$1.name,
    type: "each",
    source: "(434:6) {#each ticks as {tick, y}}",
    ctx
  });
  return block;
}

// (446:4) {#if isBrushing}
function create_if_block_2$1(ctx) {
  let g;
  let line;
  let line_y__value;
  let line_y__value_1;
  let g_transform_value;
  const block = {
    c: function create() {
      g = svg_element("g");
      line = svg_element("line");
      this.h();
    },
    l: function claim(nodes) {
      g = claim_svg_element(nodes, "g", {
        class: true,
        transform: true
      });
      var g_nodes = children(g);
      line = claim_svg_element(g_nodes, "line", {
        y1: true,
        y2: true,
        class: true
      });
      children(line).forEach(detach_dev);
      g_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(line, "y1", line_y__value = /*brushLine*/ctx[14].y1);
      attr_dev(line, "y2", line_y__value_1 = /*brushLine*/ctx[14].y2);
      attr_dev(line, "class", "svelte-1egg7b");
      add_location(line, file$2, 450, 6, 10422);
      attr_dev(g, "class", "brush svelte-1egg7b");
      attr_dev(g, "transform", g_transform_value = "translate(" + /*origin*/ctx[19].x + ",0)");
      add_location(g, file$2, 446, 5, 10346);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, g, anchor);
      append_hydration_dev(g, line);
    },
    p: function update(ctx, dirty) {
      if (dirty[0] & /*brushLine*/16384 && line_y__value !== (line_y__value = /*brushLine*/ctx[14].y1)) {
        attr_dev(line, "y1", line_y__value);
      }
      if (dirty[0] & /*brushLine*/16384 && line_y__value_1 !== (line_y__value_1 = /*brushLine*/ctx[14].y2)) {
        attr_dev(line, "y2", line_y__value_1);
      }
      if (dirty[0] & /*origin*/524288 && g_transform_value !== (g_transform_value = "translate(" + /*origin*/ctx[19].x + ",0)")) {
        attr_dev(g, "transform", g_transform_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(g);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2$1.name,
    type: "if",
    source: "(446:4) {#if isBrushing}",
    ctx
  });
  return block;
}
function create_fragment$2(ctx) {
  let if_block_anchor;
  let if_block = /*height*/ctx[5] && /*width*/ctx[6] && create_if_block$2(ctx);
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
    },
    p: function update(ctx, dirty) {
      if ( /*height*/ctx[5] && /*width*/ctx[6]) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block$2(ctx);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (if_block) if_block.d(detaching);
      if (detaching) detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance$1($$self, $$props, $$invalidate) {
  let safety;
  let innerWidth;
  let innerHeight;
  let origin;
  let direction;
  let ticksX;
  let ticksAnchor;
  let ticks;
  let useValue;
  let getBinsMax;
  let valuesMax;
  let scales;
  let bars;
  let maxBarThickness;
  let fontSize;
  let isBrushing;
  let isPressed;
  let doesBrushAdd;
  let doesBrushRemove;
  let brushStroke;
  let brushExtent;
  let brushRange;
  let brushExtentBarYs;
  let brushLine;
  let style;
  let $_brush;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('HistogramG', slots, []);
  const dispatch = createEventDispatcher();
  const makeMaxBarThickness = arrayMaxWith(getKey('barThickness'));
  const defaultFlags = {
    hideOrigin: false,
    hideTicks: false,
    isInteractive: false,
    isRightToLeft: false,
    isTopDown: false,
    useLogScale: false,
    withBackground: false
  };
  const defaultGeometry = {
    // exposed but undocumented on the site
    brushThreshold: 10,
    // pixels to trigger brushing
    fontSizeFactor: 0.6,
    maxFontSize: 12,
    textPadding: 5,
    // documented on the site
    originRadius: 2,
    safetyXNoTicks: 20,
    safetyXTicks: 50,
    safetyXValues: 25,
    safetyY: 20
  };
  const defaultTheme = {
    // exposed but undocumented
    backgroundOpacity: 1,
    // exposed and documented but no example
    brushAddStroke: 'rgb(107,248,134)',
    brushRemoveStroke: 'rgb(246,97,20)',
    brushStrokeOpacity: 0.8,
    brushStrokeWidth: 8,
    // exposed but undocumented on the site
    axisStrokeWidth: 1,
    backgroundColor: 'white',
    binFill: 'white',
    binStroke: 'black',
    binStrokeWidth: 1,
    originColor: 'black',
    messageColor: 'black',
    messageFontSize: '1rem',
    selectedBinFill: 'rgb(255, 174, 0)',
    selectedBinStroke: 'black',
    selectedBinStrokeWidth: 2,
    textColor: 'black'
  };
  let {
    height = null
  } = $$props;
  let {
    width = null
  } = $$props;
  let {
    bins = []
  } = $$props;
  let {
    binsFill = null
  } = $$props;
  let {
    flags = null
  } = $$props;
  let {
    geometry = null
  } = $$props;
  let {
    message = 'No data'
  } = $$props;
  let {
    selectedBins = []
  } = $$props;
  let {
    theme = null
  } = $$props;
  let {
    ticksFormatFn = null
  } = $$props;
  let rangesExtent = [];

  /* brushing */
  let isMousedown = false;
  const brushOff = {
    delta: 0,
    end: null,
    origin: {
      x: null,
      y: null
    },
    start: null,
    modifier: null,
    state: 'Off'
  };
  const _brush = writable(brushOff);
  validate_store(_brush, '_brush');
  component_subscribe($$self, _brush, value => $$invalidate(43, $_brush = value));

  /* events */
  const getModifier = event => event.shiftKey ? 'shift' : event.altKey ? 'alt' : null;
  const onMouseenter = index => () => {
    if (isBrushing) {
      _brush.update(mergeObj({
        end: index
      }));
    }
    dispatch('entered', index);
  };
  const onMousedown = event => {
    $$invalidate(12, isMousedown = true);
    _brush.set({
      delta: 0,
      modifier: getModifier(event),
      origin: {
        x: event.offsetX,
        y: event.offsetY
      },
      state: 'Pressed'
    });
  };
  const onMousemove = index => event => {
    if (isPressed) {
      const delta = vectorLength2D(event.offsetX - $_brush.origin.x, event.offsetY - $_brush.origin.y);
      if (delta > geometry.brushThreshold) {
        _brush.update(mergeObj({
          end: index,
          start: index,
          state: 'Brushing'
        }));
        dispatch('brushstart', index);
      } else {
        _brush.update(mergeObj({
          delta
        }));
      }
    }
  };
  const onMouseup = index => () => {
    $$invalidate(12, isMousedown = false);
    if (isPressed) {
      if ($_brush.delta < geometry.brushThreshold) {
        if (doesBrushAdd) {
          $$invalidate(4, selectedBins = uniques(appendTo(selectedBins, index)));
        } else if (doesBrushRemove) {
          $$invalidate(4, selectedBins = pullFrom(selectedBins, [index]));
        } else {
          $$invalidate(4, selectedBins = [index]);
        }
        dispatch('clicked', {
          index,
          selectedBins
        });
      }
    } else if (isBrushing) {
      dispatch('brushend', index);
    }
    _brush.set(brushOff);
  };
  const onMouseleave = index => () => {
    dispatch('exited', index);
  };
  const resetSelection = () => {
    $$invalidate(4, selectedBins = []);
    dispatch('clicked', {
      selectedBins
    });
  };
  const onKeyDown = event => {
    if (event.key === 'Escape') {
      event.preventDefault();
      resetSelection();
    }
  };
  const writable_props = ['height', 'width', 'bins', 'binsFill', 'flags', 'geometry', 'message', 'selectedBins', 'theme', 'ticksFormatFn'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<HistogramG> was created with unknown prop '".concat(key, "'"));
  });
  $$self.$$set = $$props => {
    if ('height' in $$props) $$invalidate(5, height = $$props.height);
    if ('width' in $$props) $$invalidate(6, width = $$props.width);
    if ('bins' in $$props) $$invalidate(0, bins = $$props.bins);
    if ('binsFill' in $$props) $$invalidate(30, binsFill = $$props.binsFill);
    if ('flags' in $$props) $$invalidate(1, flags = $$props.flags);
    if ('geometry' in $$props) $$invalidate(2, geometry = $$props.geometry);
    if ('message' in $$props) $$invalidate(3, message = $$props.message);
    if ('selectedBins' in $$props) $$invalidate(4, selectedBins = $$props.selectedBins);
    if ('theme' in $$props) $$invalidate(28, theme = $$props.theme);
    if ('ticksFormatFn' in $$props) $$invalidate(29, ticksFormatFn = $$props.ticksFormatFn);
  };
  $$self.$capture_state = () => ({
    makeStyleVars,
    vectorLength2D,
    arrayMaxWith,
    concat,
    getValue,
    inclusiveRange,
    mergeObj,
    scaleLinear: linear,
    scaleLog: log,
    appendTo,
    getKey,
    has,
    last,
    pullFrom,
    sort,
    uniques,
    createEventDispatcher,
    writable,
    getBinsTicks,
    getValuesLength,
    dispatch,
    makeMaxBarThickness,
    defaultFlags,
    defaultGeometry,
    defaultTheme,
    height,
    width,
    bins,
    binsFill,
    flags,
    geometry,
    message,
    selectedBins,
    theme,
    ticksFormatFn,
    rangesExtent,
    isMousedown,
    brushOff,
    _brush,
    getModifier,
    onMouseenter,
    onMousedown,
    onMousemove,
    onMouseup,
    onMouseleave,
    resetSelection,
    onKeyDown,
    isBrushing,
    doesBrushRemove,
    doesBrushAdd,
    isPressed,
    brushStroke,
    style,
    brushRange,
    brushExtentBarYs,
    brushLine,
    brushExtent,
    bars,
    maxBarThickness,
    fontSize,
    scales,
    innerHeight,
    innerWidth,
    valuesMax,
    getBinsMax,
    useValue,
    ticks,
    ticksAnchor,
    ticksX,
    direction,
    origin,
    safety,
    $_brush
  });
  $$self.$inject_state = $$props => {
    if ('height' in $$props) $$invalidate(5, height = $$props.height);
    if ('width' in $$props) $$invalidate(6, width = $$props.width);
    if ('bins' in $$props) $$invalidate(0, bins = $$props.bins);
    if ('binsFill' in $$props) $$invalidate(30, binsFill = $$props.binsFill);
    if ('flags' in $$props) $$invalidate(1, flags = $$props.flags);
    if ('geometry' in $$props) $$invalidate(2, geometry = $$props.geometry);
    if ('message' in $$props) $$invalidate(3, message = $$props.message);
    if ('selectedBins' in $$props) $$invalidate(4, selectedBins = $$props.selectedBins);
    if ('theme' in $$props) $$invalidate(28, theme = $$props.theme);
    if ('ticksFormatFn' in $$props) $$invalidate(29, ticksFormatFn = $$props.ticksFormatFn);
    if ('rangesExtent' in $$props) $$invalidate(31, rangesExtent = $$props.rangesExtent);
    if ('isMousedown' in $$props) $$invalidate(12, isMousedown = $$props.isMousedown);
    if ('isBrushing' in $$props) $$invalidate(7, isBrushing = $$props.isBrushing);
    if ('doesBrushRemove' in $$props) $$invalidate(32, doesBrushRemove = $$props.doesBrushRemove);
    if ('doesBrushAdd' in $$props) $$invalidate(33, doesBrushAdd = $$props.doesBrushAdd);
    if ('isPressed' in $$props) isPressed = $$props.isPressed;
    if ('brushStroke' in $$props) $$invalidate(34, brushStroke = $$props.brushStroke);
    if ('style' in $$props) $$invalidate(13, style = $$props.style);
    if ('brushRange' in $$props) $$invalidate(35, brushRange = $$props.brushRange);
    if ('brushExtentBarYs' in $$props) $$invalidate(36, brushExtentBarYs = $$props.brushExtentBarYs);
    if ('brushLine' in $$props) $$invalidate(14, brushLine = $$props.brushLine);
    if ('brushExtent' in $$props) $$invalidate(37, brushExtent = $$props.brushExtent);
    if ('bars' in $$props) $$invalidate(8, bars = $$props.bars);
    if ('maxBarThickness' in $$props) $$invalidate(38, maxBarThickness = $$props.maxBarThickness);
    if ('fontSize' in $$props) $$invalidate(15, fontSize = $$props.fontSize);
    if ('scales' in $$props) $$invalidate(39, scales = $$props.scales);
    if ('innerHeight' in $$props) $$invalidate(9, innerHeight = $$props.innerHeight);
    if ('innerWidth' in $$props) $$invalidate(10, innerWidth = $$props.innerWidth);
    if ('valuesMax' in $$props) $$invalidate(40, valuesMax = $$props.valuesMax);
    if ('getBinsMax' in $$props) $$invalidate(41, getBinsMax = $$props.getBinsMax);
    if ('useValue' in $$props) $$invalidate(42, useValue = $$props.useValue);
    if ('ticks' in $$props) $$invalidate(16, ticks = $$props.ticks);
    if ('ticksAnchor' in $$props) $$invalidate(17, ticksAnchor = $$props.ticksAnchor);
    if ('ticksX' in $$props) $$invalidate(18, ticksX = $$props.ticksX);
    if ('direction' in $$props) direction = $$props.direction;
    if ('origin' in $$props) $$invalidate(19, origin = $$props.origin);
    if ('safety' in $$props) $$invalidate(11, safety = $$props.safety);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*bins*/1) {
      // FIXME https://github.com/sveltejs/svelte/issues/4442
      $$invalidate(0, bins = bins || []);
    }
    if ($$self.$$.dirty[0] & /*flags*/2) {
      $$invalidate(1, flags = flags ? {
        ...defaultFlags,
        ...flags
      } : defaultFlags);
    }
    if ($$self.$$.dirty[0] & /*geometry*/4) {
      $$invalidate(2, geometry = geometry ? {
        ...defaultGeometry,
        ...geometry
      } : defaultGeometry);
    }
    if ($$self.$$.dirty[0] & /*message*/8) {
      $$invalidate(3, message = message || 'No data');
    }
    if ($$self.$$.dirty[0] & /*selectedBins*/16) {
      $$invalidate(4, selectedBins = selectedBins || []);
    }
    if ($$self.$$.dirty[0] & /*theme*/268435456) {
      $$invalidate(28, theme = theme ? {
        ...defaultTheme,
        ...theme
      } : defaultTheme);
    }
    if ($$self.$$.dirty[0] & /*ticksFormatFn*/536870912) {
      $$invalidate(29, ticksFormatFn = ticksFormatFn || (x => x));
    }
    if ($$self.$$.dirty[0] & /*geometry, flags*/6) {
      $$invalidate(11, safety = {
        top: geometry.safetyY,
        right: flags.isRightToLeft ? flags.hideTicks ? geometry.safetyXNoTicks : geometry.safetyXTicks : geometry.safetyXValues,
        bottom: geometry.safetyY,
        left: flags.isRightToLeft ? geometry.safetyXValues : flags.hideTicks ? geometry.safetyXNoTicks : geometry.safetyXTicks
      });
    }
    if ($$self.$$.dirty[0] & /*width, safety*/2112) {
      $$invalidate(10, innerWidth = Math.max(0, width - safety.left - safety.right));
    }
    if ($$self.$$.dirty[0] & /*height, safety, geometry*/2084) {
      $$invalidate(9, innerHeight = Math.max(0, height - safety.top - safety.bottom - geometry.maxFontSize));
    }
    if ($$self.$$.dirty[0] & /*flags, innerWidth, innerHeight*/1538) {
      $$invalidate(19, origin = {
        x: flags.isRightToLeft ? innerWidth : 0,
        y: flags.isTopDown ? 0 : innerHeight
      });
    }
    if ($$self.$$.dirty[0] & /*flags*/2) {
      direction = {
        x: flags.isRightToLeft ? -1 : 1,
        y: flags.isTopDown ? 1 : -1
      };
    }
    if ($$self.$$.dirty[0] & /*flags, geometry*/6) {
      $$invalidate(18, ticksX = flags.isRightToLeft ? geometry.originRadius + geometry.textPadding : -(geometry.originRadius + geometry.textPadding));
    }
    if ($$self.$$.dirty[0] & /*flags*/2) {
      $$invalidate(17, ticksAnchor = flags.isRightToLeft ? 'start' : 'end');
    }
    if ($$self.$$.dirty[0] & /*bins*/1) {
      $$invalidate(42, useValue = bins.length && has(bins[0], 'value'));
    }
    if ($$self.$$.dirty[1] & /*useValue*/2048) {
      $$invalidate(41, getBinsMax = useValue ? arrayMaxWith(getValue) : arrayMaxWith(getValuesLength));
    }
    if ($$self.$$.dirty[0] & /*bins*/1 | $$self.$$.dirty[1] & /*getBinsMax*/1024) {
      $$invalidate(40, valuesMax = getBinsMax(bins));
    }
    if ($$self.$$.dirty[0] & /*bins*/1) {
      $$invalidate(31, rangesExtent = bins.length ? [bins[0].range[0], last(bins).range[1]] : []);
    }
    if ($$self.$$.dirty[0] & /*bins, flags, innerWidth, innerHeight*/1539 | $$self.$$.dirty[1] & /*valuesMax, rangesExtent*/513) {
      /* eslint-disable indent */
      $$invalidate(39, scales = bins.length && {
        x: flags.useLogScale ? log().domain([1, valuesMax]).range([innerWidth / Math.log10(valuesMax), innerWidth]) : linear().domain([0, valuesMax]).range([0, innerWidth]),
        y: linear().domain(rangesExtent).range([0, innerHeight])
      });
    }
    if ($$self.$$.dirty[0] & /*bins, ticksFormatFn, flags*/536870915 | $$self.$$.dirty[1] & /*scales*/256) {
      $$invalidate(16, ticks = getBinsTicks(bins).map(tick => ({
        tick: ticksFormatFn(tick),
        y: flags.isTopDown ? scales.y(tick) : -scales.y(tick)
      })));
    }
    if ($$self.$$.dirty[1] & /*$_brush*/4096) {
      $$invalidate(7, isBrushing = $_brush.state === 'Brushing');
    }
    if ($$self.$$.dirty[1] & /*$_brush*/4096) {
      $$invalidate(33, doesBrushAdd = $_brush.modifier === 'shift');
    }
    if ($$self.$$.dirty[0] & /*isBrushing*/128 | $$self.$$.dirty[1] & /*$_brush*/4096) {
      $$invalidate(37, brushExtent = isBrushing && sort([$_brush.start, $_brush.end]));
    }
    if ($$self.$$.dirty[0] & /*isBrushing*/128 | $$self.$$.dirty[1] & /*brushExtent*/64) {
      $$invalidate(35, brushRange = isBrushing && inclusiveRange(brushExtent));
    }
    if ($$self.$$.dirty[1] & /*$_brush*/4096) {
      $$invalidate(32, doesBrushRemove = $_brush.modifier === 'alt');
    }
    if ($$self.$$.dirty[0] & /*isBrushing, selectedBins*/144 | $$self.$$.dirty[1] & /*doesBrushAdd, brushRange, doesBrushRemove, $_brush*/4118) {
      if (isBrushing) {
        $$invalidate(4, selectedBins = doesBrushAdd ? uniques(concat(selectedBins, brushRange)) : doesBrushRemove ? pullFrom(selectedBins, brushRange) : brushRange);
        dispatch('brushed', {
          end: $_brush.end,
          selectedBins,
          start: $_brush.start
        });
      }
    }
    if ($$self.$$.dirty[0] & /*bins, selectedBins, flags, innerWidth, innerHeight, geometry, binsFill, theme*/1342178839 | $$self.$$.dirty[1] & /*scales*/256) {
      /* eslint-enable indent */
      $$invalidate(8, bars = bins.map((bin, index) => {
        const {
          range,
          values,
          value
        } = bin;
        const selected = selectedBins.length && selectedBins.includes(index);
        const displayValue = values ? values.length : value;
        const barLength = scales.x(displayValue);
        const barThickness = scales.y(range[1]) - scales.y(range[0]);
        const x = flags.isRightToLeft ? innerWidth - barLength : 0;
        const y1 = flags.isTopDown ? scales.y(range[0]) : innerHeight - scales.y(range[0]) - barThickness;
        const y2 = y1 + barThickness;
        const labelX = flags.isRightToLeft ? x - geometry.textPadding : barLength + geometry.textPadding;
        const labelAnchor = flags.isRightToLeft ? 'end' : 'start';
        const fill = bin.color || (binsFill && binsFill[index] ? binsFill[index] : theme.binFill);
        return {
          ...bin,
          ...{
            barLength,
            barThickness,
            displayValue,
            fill,
            labelAnchor,
            labelX,
            selected,
            x,
            y1,
            y2
          }
        };
      }));
    }
    if ($$self.$$.dirty[0] & /*bars*/256) {
      $$invalidate(38, maxBarThickness = makeMaxBarThickness(bars));
    }
    if ($$self.$$.dirty[0] & /*geometry*/4 | $$self.$$.dirty[1] & /*maxBarThickness*/128) {
      $$invalidate(15, fontSize = Math.min(geometry.maxFontSize, geometry.fontSizeFactor * maxBarThickness));
    }
    if ($$self.$$.dirty[1] & /*$_brush*/4096) {
      isPressed = $_brush.state === 'Pressed';
    }
    if ($$self.$$.dirty[0] & /*theme*/268435456 | $$self.$$.dirty[1] & /*doesBrushAdd, doesBrushRemove*/6) {
      $$invalidate(34, brushStroke = doesBrushAdd ? theme.brushAddStroke : doesBrushRemove ? theme.brushRemoveStroke : null);
    }
    if ($$self.$$.dirty[0] & /*isBrushing, bars*/384 | $$self.$$.dirty[1] & /*brushExtent*/64) {
      $$invalidate(36, brushExtentBarYs = isBrushing && sort([bars[brushExtent[0]].y1, bars[brushExtent[0]].y2, bars[brushExtent[1]].y1, bars[brushExtent[1]].y2]));
    }
    if ($$self.$$.dirty[0] & /*isBrushing*/128 | $$self.$$.dirty[1] & /*brushExtentBarYs*/32) {
      $$invalidate(14, brushLine = isBrushing && {
        y1: brushExtentBarYs[0],
        y2: brushExtentBarYs[3]
      });
    }
    if ($$self.$$.dirty[0] & /*theme*/268435456 | $$self.$$.dirty[1] & /*brushStroke*/8) {
      /* style */
      $$invalidate(13, style = makeStyleVars({
        ...theme,
        brushStroke
      }));
    }
  };
  return [bins, flags, geometry, message, selectedBins, height, width, isBrushing, bars, innerHeight, innerWidth, safety, isMousedown, style, brushLine, fontSize, ticks, ticksAnchor, ticksX, origin, _brush, onMouseenter, onMousedown, onMousemove, onMouseup, onMouseleave, resetSelection, onKeyDown, theme, ticksFormatFn, binsFill, rangesExtent, doesBrushRemove, doesBrushAdd, brushStroke, brushRange, brushExtentBarYs, brushExtent, maxBarThickness, scales, valuesMax, getBinsMax, useValue, $_brush];
}
class HistogramG extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance$1, create_fragment$2, safe_not_equal, {
      height: 5,
      width: 6,
      bins: 0,
      binsFill: 30,
      flags: 1,
      geometry: 2,
      message: 3,
      selectedBins: 4,
      theme: 28,
      ticksFormatFn: 29
    }, null, [-1, -1, -1]);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HistogramG",
      options,
      id: create_fragment$2.name
    });
  }
  get height() {
    throw new Error("<HistogramG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set height(value) {
    throw new Error("<HistogramG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get width() {
    throw new Error("<HistogramG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set width(value) {
    throw new Error("<HistogramG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bins() {
    throw new Error("<HistogramG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bins(value) {
    throw new Error("<HistogramG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get binsFill() {
    throw new Error("<HistogramG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set binsFill(value) {
    throw new Error("<HistogramG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flags() {
    throw new Error("<HistogramG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flags(value) {
    throw new Error("<HistogramG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<HistogramG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<HistogramG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get message() {
    throw new Error("<HistogramG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set message(value) {
    throw new Error("<HistogramG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedBins() {
    throw new Error("<HistogramG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedBins(value) {
    throw new Error("<HistogramG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<HistogramG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<HistogramG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ticksFormatFn() {
    throw new Error("<HistogramG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ticksFormatFn(value) {
    throw new Error("<HistogramG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
var HistogramG$1 = HistogramG;

/* ../../components/histogram/src/HistogramDiv.svelte generated by Svelte v3.59.2 */
const file$1 = "../../components/histogram/src/HistogramDiv.svelte";

// (34:1) {#if title}
function create_if_block_1$1(ctx) {
  let header;
  let h2;
  let t;
  const block = {
    c: function create() {
      header = element("header");
      h2 = element("h2");
      t = text( /*title*/ctx[0]);
      this.h();
    },
    l: function claim(nodes) {
      header = claim_element(nodes, "HEADER", {
        class: true
      });
      var header_nodes = children(header);
      h2 = claim_element(header_nodes, "H2", {
        class: true
      });
      var h2_nodes = children(h2);
      t = claim_text(h2_nodes, /*title*/ctx[0]);
      h2_nodes.forEach(detach_dev);
      header_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h2, "class", "svelte-1vbmnpd");
      add_location(h2, file$1, 35, 3, 756);
      attr_dev(header, "class", "svelte-1vbmnpd");
      toggle_class(header, "rightToLeft", /*flags*/ctx[3] && /*flags*/ctx[3].isRightToLeft);
      add_location(header, file$1, 34, 2, 695);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, header, anchor);
      append_hydration_dev(header, h2);
      append_hydration_dev(h2, t);
    },
    p: function update(ctx, dirty) {
      if (dirty & /*title*/1) set_data_dev(t, /*title*/ctx[0]);
      if (dirty & /*flags*/8) {
        toggle_class(header, "rightToLeft", /*flags*/ctx[3] && /*flags*/ctx[3].isRightToLeft);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(header);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1$1.name,
    type: "if",
    source: "(34:1) {#if title}",
    ctx
  });
  return block;
}

// (48:3) {#if bins}
function create_if_block$1(ctx) {
  let histogramg;
  let current;
  histogramg = new HistogramG$1({
    props: {
      bins: /*bins*/ctx[1],
      binsFill: /*binsFill*/ctx[2],
      flags: /*flags*/ctx[3],
      geometry: /*geometry*/ctx[4],
      height: /*height*/ctx[9],
      message: /*message*/ctx[5],
      selectedBins: /*selectedBins*/ctx[6],
      theme: /*theme*/ctx[7],
      ticksFormatFn: /*ticksFormatFn*/ctx[8],
      width: /*width*/ctx[10]
    },
    $$inline: true
  });
  histogramg.$on("brushed", /*brushed_handler*/ctx[14]);
  histogramg.$on("brushend", /*brushend_handler*/ctx[15]);
  histogramg.$on("brushstart", /*brushstart_handler*/ctx[16]);
  histogramg.$on("clicked", /*clicked_handler*/ctx[17]);
  histogramg.$on("entered", /*entered_handler*/ctx[18]);
  histogramg.$on("exited", /*exited_handler*/ctx[19]);
  const block = {
    c: function create() {
      create_component(histogramg.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(histogramg.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(histogramg, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const histogramg_changes = {};
      if (dirty & /*bins*/2) histogramg_changes.bins = /*bins*/ctx[1];
      if (dirty & /*binsFill*/4) histogramg_changes.binsFill = /*binsFill*/ctx[2];
      if (dirty & /*flags*/8) histogramg_changes.flags = /*flags*/ctx[3];
      if (dirty & /*geometry*/16) histogramg_changes.geometry = /*geometry*/ctx[4];
      if (dirty & /*height*/512) histogramg_changes.height = /*height*/ctx[9];
      if (dirty & /*message*/32) histogramg_changes.message = /*message*/ctx[5];
      if (dirty & /*selectedBins*/64) histogramg_changes.selectedBins = /*selectedBins*/ctx[6];
      if (dirty & /*theme*/128) histogramg_changes.theme = /*theme*/ctx[7];
      if (dirty & /*ticksFormatFn*/256) histogramg_changes.ticksFormatFn = /*ticksFormatFn*/ctx[8];
      if (dirty & /*width*/1024) histogramg_changes.width = /*width*/ctx[10];
      histogramg.$set(histogramg_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(histogramg.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(histogramg.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(histogramg, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block$1.name,
    type: "if",
    source: "(48:3) {#if bins}",
    ctx
  });
  return block;
}
function create_fragment$1(ctx) {
  let div;
  let t;
  let main;
  let svg;
  let main_resize_listener;
  let current;
  let if_block0 = /*title*/ctx[0] && create_if_block_1$1(ctx);
  let if_block1 = /*bins*/ctx[1] && create_if_block$1(ctx);
  const block = {
    c: function create() {
      div = element("div");
      if (if_block0) if_block0.c();
      t = space();
      main = element("main");
      svg = svg_element("svg");
      if (if_block1) if_block1.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        style: true
      });
      var div_nodes = children(div);
      if (if_block0) if_block0.l(div_nodes);
      t = claim_space(div_nodes);
      main = claim_element(div_nodes, "MAIN", {
        class: true
      });
      var main_nodes = children(main);
      svg = claim_svg_element(main_nodes, "svg", {
        width: true,
        height: true,
        class: true
      });
      var svg_nodes = children(svg);
      if (if_block1) if_block1.l(svg_nodes);
      svg_nodes.forEach(detach_dev);
      main_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "width", /*width*/ctx[10]);
      attr_dev(svg, "height", /*height*/ctx[9]);
      attr_dev(svg, "class", "svelte-1vbmnpd");
      add_location(svg, file$1, 43, 2, 899);
      attr_dev(main, "class", "svelte-1vbmnpd");
      add_render_callback(() => /*main_elementresize_handler*/ctx[20].call(main));
      toggle_class(main, "titled", /*title*/ctx[0] && /*title*/ctx[0].length);
      add_location(main, file$1, 38, 1, 793);
      attr_dev(div, "class", "HistogramDiv svelte-1vbmnpd");
      attr_dev(div, "style", /*style*/ctx[11]);
      toggle_class(div, "interactive", /*flags*/ctx[3] && /*flags*/ctx[3].isInteractive);
      add_location(div, file$1, 28, 0, 592);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append_hydration_dev(div, t);
      append_hydration_dev(div, main);
      append_hydration_dev(main, svg);
      if (if_block1) if_block1.m(svg, null);
      main_resize_listener = add_iframe_resize_listener(main, /*main_elementresize_handler*/ctx[20].bind(main));
      current = true;
    },
    p: function update(ctx, _ref) {
      let [dirty] = _ref;
      if ( /*title*/ctx[0]) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_1$1(ctx);
          if_block0.c();
          if_block0.m(div, t);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if ( /*bins*/ctx[1]) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
          if (dirty & /*bins*/2) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$1(ctx);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(svg, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*width*/1024) {
        attr_dev(svg, "width", /*width*/ctx[10]);
      }
      if (!current || dirty & /*height*/512) {
        attr_dev(svg, "height", /*height*/ctx[9]);
      }
      if (!current || dirty & /*title*/1) {
        toggle_class(main, "titled", /*title*/ctx[0] && /*title*/ctx[0].length);
      }
      if (!current || dirty & /*style*/2048) {
        attr_dev(div, "style", /*style*/ctx[11]);
      }
      if (!current || dirty & /*flags*/8) {
        toggle_class(div, "interactive", /*flags*/ctx[3] && /*flags*/ctx[3].isInteractive);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(div);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      main_resize_listener();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment$1.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let style;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('HistogramDiv', slots, []);
  let {
    headerHeight
  } = $$props;
  let {
    padding
  } = $$props;
  let {
    title
  } = $$props;
  let {
    bins = []
  } = $$props;
  let {
    binsFill = null
  } = $$props;
  let {
    flags = null
  } = $$props;
  let {
    geometry = null
  } = $$props;
  let {
    message = 'No data'
  } = $$props;
  let {
    selectedBins = []
  } = $$props;
  let {
    theme = null
  } = $$props;
  let {
    ticksFormatFn = null
  } = $$props;
  let height = 0;
  let width = 0;
  $$self.$$.on_mount.push(function () {
    if (headerHeight === undefined && !('headerHeight' in $$props || $$self.$$.bound[$$self.$$.props['headerHeight']])) {
      console.warn("<HistogramDiv> was created without expected prop 'headerHeight'");
    }
    if (padding === undefined && !('padding' in $$props || $$self.$$.bound[$$self.$$.props['padding']])) {
      console.warn("<HistogramDiv> was created without expected prop 'padding'");
    }
    if (title === undefined && !('title' in $$props || $$self.$$.bound[$$self.$$.props['title']])) {
      console.warn("<HistogramDiv> was created without expected prop 'title'");
    }
  });
  const writable_props = ['headerHeight', 'padding', 'title', 'bins', 'binsFill', 'flags', 'geometry', 'message', 'selectedBins', 'theme', 'ticksFormatFn'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<HistogramDiv> was created with unknown prop '".concat(key, "'"));
  });
  function brushed_handler(event) {
    bubble.call(this, $$self, event);
  }
  function brushend_handler(event) {
    bubble.call(this, $$self, event);
  }
  function brushstart_handler(event) {
    bubble.call(this, $$self, event);
  }
  function clicked_handler(event) {
    bubble.call(this, $$self, event);
  }
  function entered_handler(event) {
    bubble.call(this, $$self, event);
  }
  function exited_handler(event) {
    bubble.call(this, $$self, event);
  }
  function main_elementresize_handler() {
    height = this.clientHeight;
    width = this.clientWidth;
    $$invalidate(9, height);
    $$invalidate(10, width);
  }
  $$self.$$set = $$props => {
    if ('headerHeight' in $$props) $$invalidate(12, headerHeight = $$props.headerHeight);
    if ('padding' in $$props) $$invalidate(13, padding = $$props.padding);
    if ('title' in $$props) $$invalidate(0, title = $$props.title);
    if ('bins' in $$props) $$invalidate(1, bins = $$props.bins);
    if ('binsFill' in $$props) $$invalidate(2, binsFill = $$props.binsFill);
    if ('flags' in $$props) $$invalidate(3, flags = $$props.flags);
    if ('geometry' in $$props) $$invalidate(4, geometry = $$props.geometry);
    if ('message' in $$props) $$invalidate(5, message = $$props.message);
    if ('selectedBins' in $$props) $$invalidate(6, selectedBins = $$props.selectedBins);
    if ('theme' in $$props) $$invalidate(7, theme = $$props.theme);
    if ('ticksFormatFn' in $$props) $$invalidate(8, ticksFormatFn = $$props.ticksFormatFn);
  };
  $$self.$capture_state = () => ({
    makeStyleVars,
    HistogramG: HistogramG$1,
    headerHeight,
    padding,
    title,
    bins,
    binsFill,
    flags,
    geometry,
    message,
    selectedBins,
    theme,
    ticksFormatFn,
    height,
    width,
    style
  });
  $$self.$inject_state = $$props => {
    if ('headerHeight' in $$props) $$invalidate(12, headerHeight = $$props.headerHeight);
    if ('padding' in $$props) $$invalidate(13, padding = $$props.padding);
    if ('title' in $$props) $$invalidate(0, title = $$props.title);
    if ('bins' in $$props) $$invalidate(1, bins = $$props.bins);
    if ('binsFill' in $$props) $$invalidate(2, binsFill = $$props.binsFill);
    if ('flags' in $$props) $$invalidate(3, flags = $$props.flags);
    if ('geometry' in $$props) $$invalidate(4, geometry = $$props.geometry);
    if ('message' in $$props) $$invalidate(5, message = $$props.message);
    if ('selectedBins' in $$props) $$invalidate(6, selectedBins = $$props.selectedBins);
    if ('theme' in $$props) $$invalidate(7, theme = $$props.theme);
    if ('ticksFormatFn' in $$props) $$invalidate(8, ticksFormatFn = $$props.ticksFormatFn);
    if ('height' in $$props) $$invalidate(9, height = $$props.height);
    if ('width' in $$props) $$invalidate(10, width = $$props.width);
    if ('style' in $$props) $$invalidate(11, style = $$props.style);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*padding*/8192) {
      $$invalidate(13, padding = padding || '10px');
    }
    if ($$self.$$.dirty & /*headerHeight*/4096) {
      $$invalidate(12, headerHeight = headerHeight || '2rem');
    }
    if ($$self.$$.dirty & /*headerHeight, padding*/12288) {
      $$invalidate(11, style = makeStyleVars({
        headerHeight,
        padding
      }));
    }
  };
  return [title, bins, binsFill, flags, geometry, message, selectedBins, theme, ticksFormatFn, height, width, style, headerHeight, padding, brushed_handler, brushend_handler, brushstart_handler, clicked_handler, entered_handler, exited_handler, main_elementresize_handler];
}
class HistogramDiv extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment$1, safe_not_equal, {
      headerHeight: 12,
      padding: 13,
      title: 0,
      bins: 1,
      binsFill: 2,
      flags: 3,
      geometry: 4,
      message: 5,
      selectedBins: 6,
      theme: 7,
      ticksFormatFn: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HistogramDiv",
      options,
      id: create_fragment$1.name
    });
  }
  get headerHeight() {
    throw new Error("<HistogramDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set headerHeight(value) {
    throw new Error("<HistogramDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padding() {
    throw new Error("<HistogramDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padding(value) {
    throw new Error("<HistogramDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<HistogramDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<HistogramDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get bins() {
    throw new Error("<HistogramDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set bins(value) {
    throw new Error("<HistogramDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get binsFill() {
    throw new Error("<HistogramDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set binsFill(value) {
    throw new Error("<HistogramDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get flags() {
    throw new Error("<HistogramDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set flags(value) {
    throw new Error("<HistogramDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get geometry() {
    throw new Error("<HistogramDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set geometry(value) {
    throw new Error("<HistogramDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get message() {
    throw new Error("<HistogramDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set message(value) {
    throw new Error("<HistogramDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedBins() {
    throw new Error("<HistogramDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedBins(value) {
    throw new Error("<HistogramDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get theme() {
    throw new Error("<HistogramDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set theme(value) {
    throw new Error("<HistogramDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ticksFormatFn() {
    throw new Error("<HistogramDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ticksFormatFn(value) {
    throw new Error("<HistogramDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}
var HistogramDiv$1 = HistogramDiv;

var histogram = /*#__PURE__*/Object.freeze({
	__proto__: null,
	HistogramG: HistogramG$1,
	HistogramDiv: HistogramDiv$1,
	exactAmountBins: exactAmountBins,
	areValidBins: areValidBins,
	getBinsItems: getBinsItems,
	getValuesLength: getValuesLength,
	getBinsMax: getBinsMax,
	getBinsMin: getBinsMin,
	getBinsExtent: getBinsExtent,
	isNonEmptyBin: isNonEmptyBin,
	findFirstNonEmptyBinIndex: findFirstNonEmptyBinIndex,
	findLastNonEmptyBinIndex: findLastNonEmptyBinIndex,
	getTrimmedBinsStats: getTrimmedBinsStats,
	getBinsTicks: getBinsTicks,
	getBinsTicksExtent: getBinsTicksExtent,
	getNonEmptyBinsTicks: getNonEmptyBinsTicks
});

var legend = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ColorBinsG: ColorBinsG,
	ColorBinsDiv: ColorBinsDiv
});

var components = {
  ...barchart,
  ...choropleth,
  ...histogram,
  ...legend,
  ...ui
};

/* src/routes/components/[slug].svelte generated by Svelte v3.59.2 */
const file = "src/routes/components/[slug].svelte";
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i].items;
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i].componentName;
  child_ctx[26] = list[i].content;
  child_ctx[27] = list[i].elementName;
  child_ctx[28] = list[i].props;
  return child_ctx;
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[22] = list[i].items;
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i].componentName;
  child_ctx[26] = list[i].content;
  child_ctx[27] = list[i].elementName;
  child_ctx[28] = list[i].props;
  return child_ctx;
}
function get_each_context_4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[35] = list[i][0];
  child_ctx[36] = list[i][1];
  return child_ctx;
}
function get_each_context_5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[39] = list[i][0];
  child_ctx[40] = list[i][1];
  return child_ctx;
}
function get_each_context_6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[39] = list[i].key;
  child_ctx[44] = i;
  return child_ctx;
}

// (74:2) {#if data.length > 1}
function create_if_block_10(ctx) {
  let div1;
  let h2;
  let t0;
  let t1;
  let div0;
  let select;
  let select_size_value;
  let mounted;
  let dispose;
  let each_value_6 = /*data*/ctx[0];
  validate_each_argument(each_value_6);
  let each_blocks = [];
  for (let i = 0; i < each_value_6.length; i += 1) {
    each_blocks[i] = create_each_block_6(get_each_context_6(ctx, each_value_6, i));
  }
  const block = {
    c: function create() {
      div1 = element("div");
      h2 = element("h2");
      t0 = text("Choose an example");
      t1 = space();
      div0 = element("div");
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", {
        class: true
      });
      var div1_nodes = children(div1);
      h2 = claim_element(div1_nodes, "H2", {});
      var h2_nodes = children(h2);
      t0 = claim_text(h2_nodes, "Choose an example");
      h2_nodes.forEach(detach_dev);
      t1 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", {
        class: true
      });
      var div0_nodes = children(div0);
      select = claim_element(div0_nodes, "SELECT", {
        size: true,
        class: true
      });
      var select_nodes = children(select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(select_nodes);
      }
      select_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(h2, file, 75, 4, 1717);
      attr_dev(select, "size", select_size_value = /*data*/ctx[0].length);
      attr_dev(select, "class", "svelte-w4kafb");
      add_location(select, file, 78, 5, 1822);
      attr_dev(div0, "class", "distancer svelte-w4kafb");
      add_location(div0, file, 76, 4, 1748);
      attr_dev(div1, "class", "distancer svelte-w4kafb");
      add_location(div1, file, 74, 3, 1689);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, h2);
      append_hydration_dev(h2, t0);
      append_hydration_dev(div1, t1);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      if (!mounted) {
        dispose = listen_dev(select, "change", /*change_handler*/ctx[16], false, false, false, false);
        mounted = true;
      }
    },
    p: function update(ctx, dirty) {
      if (dirty[0] & /*selected, data*/65) {
        each_value_6 = /*data*/ctx[0];
        validate_each_argument(each_value_6);
        let i;
        for (i = 0; i < each_value_6.length; i += 1) {
          const child_ctx = get_each_context_6(ctx, each_value_6, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_6(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_6.length;
      }
      if (dirty[0] & /*data*/1 && select_size_value !== (select_size_value = /*data*/ctx[0].length)) {
        attr_dev(select, "size", select_size_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(div1);
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_10.name,
    type: "if",
    source: "(74:2) {#if data.length > 1}",
    ctx
  });
  return block;
}

// (83:6) {#each data as {key}
function create_each_block_6(ctx) {
  let option;
  let t_value = /*key*/ctx[39] + "";
  let t;
  let option_selected_value;
  const block = {
    c: function create() {
      option = element("option");
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      option = claim_element(nodes, "OPTION", {
        class: true
      });
      var option_nodes = children(option);
      t = claim_text(option_nodes, t_value);
      option_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      option.__value = /*index*/ctx[44];
      option.value = option.__value;
      option.selected = option_selected_value = /*index*/ctx[44] === /*selected*/ctx[6];
      attr_dev(option, "class", "svelte-w4kafb");
      add_location(option, file, 83, 7, 1971);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, option, anchor);
      append_hydration_dev(option, t);
    },
    p: function update(ctx, dirty) {
      if (dirty[0] & /*data*/1 && t_value !== (t_value = /*key*/ctx[39] + "")) set_data_dev(t, t_value);
      if (dirty[0] & /*selected*/64 && option_selected_value !== (option_selected_value = /*index*/ctx[44] === /*selected*/ctx[6])) {
        prop_dev(option, "selected", option_selected_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(option);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_6.name,
    type: "each",
    source: "(83:6) {#each data as {key}",
    ctx
  });
  return block;
}

// (95:2) {#if payloads}
function create_if_block_9(ctx) {
  let h2;
  let t0;
  let t1;
  let div;
  let each_value_5 = pairs( /*payloads*/ctx[9]);
  validate_each_argument(each_value_5);
  let each_blocks = [];
  for (let i = 0; i < each_value_5.length; i += 1) {
    each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
  }
  const block = {
    c: function create() {
      h2 = element("h2");
      t0 = text("Events");
      t1 = space();
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      h2 = claim_element(nodes, "H2", {});
      var h2_nodes = children(h2);
      t0 = claim_text(h2_nodes, "Events");
      h2_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      div = claim_element(nodes, "DIV", {
        class: true
      });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(h2, file, 95, 3, 2159);
      attr_dev(div, "class", "distancer svelte-w4kafb");
      add_location(div, file, 96, 3, 2178);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h2, anchor);
      append_hydration_dev(h2, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p: function update(ctx, dirty) {
      if (dirty[0] & /*payloads*/512) {
        each_value_5 = pairs( /*payloads*/ctx[9]);
        validate_each_argument(each_value_5);
        let i;
        for (i = 0; i < each_value_5.length; i += 1) {
          const child_ctx = get_each_context_5(ctx, each_value_5, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_5(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_5.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(h2);
      if (detaching) detach_dev(t1);
      if (detaching) detach_dev(div);
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_9.name,
    type: "if",
    source: "(95:2) {#if payloads}",
    ctx
  });
  return block;
}

// (98:4) {#each _.pairs(payloads) as [key, value]}
function create_each_block_5(ctx) {
  let div;
  let span;
  let t0_value = /*key*/ctx[39] + "";
  let t0;
  let t1;
  let pre;
  let t2_value = ( /*value*/ctx[40] || '[payload]') + "";
  let t2;
  let t3;
  const block = {
    c: function create() {
      div = element("div");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      pre = element("pre");
      t2 = text(t2_value);
      t3 = space();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true
      });
      var div_nodes = children(div);
      span = claim_element(div_nodes, "SPAN", {
        class: true
      });
      var span_nodes = children(span);
      t0 = claim_text(span_nodes, t0_value);
      span_nodes.forEach(detach_dev);
      t1 = claim_space(div_nodes);
      pre = claim_element(div_nodes, "PRE", {
        class: true
      });
      var pre_nodes = children(pre);
      t2 = claim_text(pre_nodes, t2_value);
      pre_nodes.forEach(detach_dev);
      t3 = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "svelte-w4kafb");
      add_location(span, file, 99, 6, 2277);
      attr_dev(pre, "class", "svelte-w4kafb");
      add_location(pre, file, 100, 6, 2302);
      attr_dev(div, "class", "row svelte-w4kafb");
      add_location(div, file, 98, 5, 2253);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, span);
      append_hydration_dev(span, t0);
      append_hydration_dev(div, t1);
      append_hydration_dev(div, pre);
      append_hydration_dev(pre, t2);
      append_hydration_dev(div, t3);
    },
    p: function update(ctx, dirty) {
      if (dirty[0] & /*payloads*/512 && t0_value !== (t0_value = /*key*/ctx[39] + "")) set_data_dev(t0, t0_value);
      if (dirty[0] & /*payloads*/512 && t2_value !== (t2_value = ( /*value*/ctx[40] || '[payload]') + "")) set_data_dev(t2, t2_value);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_5.name,
    type: "each",
    source: "(98:4) {#each _.pairs(payloads) as [key, value]}",
    ctx
  });
  return block;
}

// (116:3) {#each displayProps as [propName, propValue]}
function create_each_block_4(ctx) {
  let h3;
  let code;
  let t0_value = /*propName*/ctx[35] + "";
  let t0;
  let t1;
  let div;
  let jsontree;
  let t2;
  let current;
  jsontree = new Root({
    props: {
      value: /*propValue*/ctx[36]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      h3 = element("h3");
      code = element("code");
      t0 = text(t0_value);
      t1 = space();
      div = element("div");
      create_component(jsontree.$$.fragment);
      t2 = space();
      this.h();
    },
    l: function claim(nodes) {
      h3 = claim_element(nodes, "H3", {});
      var h3_nodes = children(h3);
      code = claim_element(h3_nodes, "CODE", {});
      var code_nodes = children(code);
      t0 = claim_text(code_nodes, t0_value);
      code_nodes.forEach(detach_dev);
      h3_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      div = claim_element(nodes, "DIV", {
        class: true
      });
      var div_nodes = children(div);
      claim_component(jsontree.$$.fragment, div_nodes);
      t2 = claim_space(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      add_location(code, file, 116, 8, 2602);
      add_location(h3, file, 116, 4, 2598);
      attr_dev(div, "class", "distancer svelte-w4kafb");
      add_location(div, file, 117, 4, 2635);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, h3, anchor);
      append_hydration_dev(h3, code);
      append_hydration_dev(code, t0);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, div, anchor);
      mount_component(jsontree, div, null);
      append_hydration_dev(div, t2);
      current = true;
    },
    p: function update(ctx, dirty) {
      if ((!current || dirty[0] & /*displayProps*/1024) && t0_value !== (t0_value = /*propName*/ctx[35] + "")) set_data_dev(t0, t0_value);
      const jsontree_changes = {};
      if (dirty[0] & /*displayProps*/1024) jsontree_changes.value = /*propValue*/ctx[36];
      jsontree.$set(jsontree_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(jsontree.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(jsontree.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(h3);
      if (detaching) detach_dev(t1);
      if (detaching) detach_dev(div);
      destroy_component(jsontree);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_4.name,
    type: "each",
    source: "(116:3) {#each displayProps as [propName, propValue]}",
    ctx
  });
  return block;
}

// (161:2) {:else}
function create_else_block(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [/*currentData*/ctx[5].props];
  var switch_value = /*component*/ctx[11];
  function switch_props(ctx) {
    let switch_instance_props = {
      $$slots: {
        default: [create_default_slot_2]
      },
      $$scope: {
        ctx
      }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    /*switch_instance_binding_1*/
    ctx[19](switch_instance);
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const switch_instance_changes = dirty[0] & /*currentData*/32 ? get_spread_update(switch_instance_spread_levels, [get_spread_object( /*currentData*/ctx[5].props)]) : {};
      if (dirty[0] & /*currentData*/32 | dirty[1] & /*$$scope*/16384) {
        switch_instance_changes.$$scope = {
          dirty,
          ctx
        };
      }
      if (dirty[0] & /*component*/2048 && switch_value !== (switch_value = /*component*/ctx[11])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
          /*switch_instance_binding_1*/
          ctx[19](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      /*switch_instance_binding_1*/ctx[19](null);
      if (detaching) detach_dev(switch_instance_anchor);
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(161:2) {:else}",
    ctx
  });
  return block;
}

// (127:2) {#if isSVG}
function create_if_block(ctx) {
  let div;
  let svg;
  let switch_instance;
  let div_resize_listener;
  let current;
  const switch_instance_spread_levels = [{
    ... /*currentData*/ctx[5].props,
    width: /*width*/ctx[7],
    height: /*height*/ctx[8]
  }];
  var switch_value = /*component*/ctx[11];
  function switch_props(ctx) {
    let switch_instance_props = {
      $$slots: {
        default: [create_default_slot]
      },
      $$scope: {
        ctx
      }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    /*switch_instance_binding*/
    ctx[17](switch_instance);
  }
  const block = {
    c: function create() {
      div = element("div");
      svg = svg_element("svg");
      if (switch_instance) create_component(switch_instance.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true
      });
      var div_nodes = children(div);
      svg = claim_svg_element(div_nodes, "svg", {
        width: true,
        height: true
      });
      var svg_nodes = children(svg);
      if (switch_instance) claim_component(switch_instance.$$.fragment, svg_nodes);
      svg_nodes.forEach(detach_dev);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(svg, "width", /*width*/ctx[7]);
      attr_dev(svg, "height", /*height*/ctx[8]);
      add_location(svg, file, 131, 4, 2874);
      attr_dev(div, "class", "svgwrapper svelte-w4kafb");
      add_render_callback(() => /*div_elementresize_handler*/ctx[18].call(div));
      add_location(div, file, 127, 3, 2777);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      append_hydration_dev(div, svg);
      if (switch_instance) mount_component(switch_instance, svg, null);
      div_resize_listener = add_iframe_resize_listener(div, /*div_elementresize_handler*/ctx[18].bind(div));
      current = true;
    },
    p: function update(ctx, dirty) {
      const switch_instance_changes = dirty[0] & /*currentData, width, height*/416 ? get_spread_update(switch_instance_spread_levels, [{
        ... /*currentData*/ctx[5].props,
        width: /*width*/ctx[7],
        height: /*height*/ctx[8]
      }]) : {};
      if (dirty[0] & /*currentData*/32 | dirty[1] & /*$$scope*/16384) {
        switch_instance_changes.$$scope = {
          dirty,
          ctx
        };
      }
      if (dirty[0] & /*component*/2048 && switch_value !== (switch_value = /*component*/ctx[11])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
          /*switch_instance_binding*/
          ctx[17](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, svg, null);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
      if (!current || dirty[0] & /*width*/128) {
        attr_dev(svg, "width", /*width*/ctx[7]);
      }
      if (!current || dirty[0] & /*height*/256) {
        attr_dev(svg, "height", /*height*/ctx[8]);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(div);
      /*switch_instance_binding*/
      ctx[17](null);
      if (switch_instance) destroy_component(switch_instance);
      div_resize_listener();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(127:2) {#if isSVG}",
    ctx
  });
  return block;
}

// (169:32) 
function create_if_block_6(ctx) {
  let each_1_anchor;
  let current;
  let each_value_2 = /*currentData*/ctx[5].slots;
  validate_each_argument(each_value_2);
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  const out = i => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      if (dirty[0] & /*currentData*/32) {
        each_value_2 = /*currentData*/ctx[5].slots;
        validate_each_argument(each_value_2);
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_2.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching) detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(169:32) ",
    ctx
  });
  return block;
}

// (167:4) {#if currentData.content}
function create_if_block_5(ctx) {
  let t_value = /*currentData*/ctx[5].content + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx, dirty) {
      if (dirty[0] & /*currentData*/32 && t_value !== (t_value = /*currentData*/ctx[5].content + "")) set_data_dev(t, t_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(167:4) {#if currentData.content}",
    ctx
  });
  return block;
}

// (178:31) 
function create_if_block_8(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [/*props*/ctx[28]];
  var switch_value = components[/*componentName*/ctx[25]];
  function switch_props(ctx) {
    let switch_instance_props = {
      $$slots: {
        default: [create_default_slot_3]
      },
      $$scope: {
        ctx
      }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const switch_instance_changes = dirty[0] & /*currentData*/32 ? get_spread_update(switch_instance_spread_levels, [get_spread_object( /*props*/ctx[28])]) : {};
      if (dirty[0] & /*currentData*/32 | dirty[1] & /*$$scope*/16384) {
        switch_instance_changes.$$scope = {
          dirty,
          ctx
        };
      }
      if (dirty[0] & /*currentData*/32 && switch_value !== (switch_value = components[/*componentName*/ctx[25]])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(switch_instance_anchor);
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_8.name,
    type: "if",
    source: "(178:31) ",
    ctx
  });
  return block;
}

// (173:7) {#if elementName}
function create_if_block_7(ctx) {
  let previous_tag = /*elementName*/ctx[27];
  let svelte_element_anchor;
  validate_dynamic_element( /*elementName*/ctx[27]);
  validate_void_dynamic_element( /*elementName*/ctx[27]);
  let svelte_element = /*elementName*/ctx[27] && create_dynamic_element_1(ctx);
  const block = {
    c: function create() {
      if (svelte_element) svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element) svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element) svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
    },
    p: function update(ctx, dirty) {
      if ( /*elementName*/ctx[27]) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element_1(ctx);
          previous_tag = /*elementName*/ctx[27];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(previous_tag, /*elementName*/ctx[27])) {
          svelte_element.d(1);
          validate_dynamic_element( /*elementName*/ctx[27]);
          validate_void_dynamic_element( /*elementName*/ctx[27]);
          svelte_element = create_dynamic_element_1(ctx);
          previous_tag = /*elementName*/ctx[27];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*elementName*/ctx[27];
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(svelte_element_anchor);
      if (svelte_element) svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_7.name,
    type: "if",
    source: "(173:7) {#if elementName}",
    ctx
  });
  return block;
}

// (179:8) <svelte:component          {...props}          this={components[componentName]}         >
function create_default_slot_3(ctx) {
  let t_value = /*content*/ctx[26] + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx, dirty) {
      if (dirty[0] & /*currentData*/32 && t_value !== (t_value = /*content*/ctx[26] + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(179:8) <svelte:component          {...props}          this={components[componentName]}         >",
    ctx
  });
  return block;
}

// (174:8) <svelte:element          {...props}          this={elementName}         >
function create_dynamic_element_1(ctx) {
  let svelte_element;
  let t_value = /*content*/ctx[26] + "";
  let t;
  let svelte_element_levels = [/*props*/ctx[28]];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = element( /*elementName*/ctx[27]);
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_element(nodes, ( /*elementName*/ctx[27] || 'null').toUpperCase(), {});
      var svelte_element_nodes = children(svelte_element);
      t = claim_text(svelte_element_nodes, t_value);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_dynamic_element_data( /*elementName*/ctx[27])(svelte_element, svelte_element_data);
      toggle_class(svelte_element, "svelte-w4kafb", true);
      add_location(svelte_element, file, 173, 8, 4143);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      append_hydration_dev(svelte_element, t);
    },
    p: function update(ctx, dirty) {
      if (dirty[0] & /*currentData*/32 && t_value !== (t_value = /*content*/ctx[26] + "")) set_data_maybe_contenteditable_dev(t, t_value, svelte_element_data['contenteditable']);
      set_dynamic_element_data( /*elementName*/ctx[27])(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [dirty[0] & /*currentData*/32 && /*props*/ctx[28]]));
      toggle_class(svelte_element, "svelte-w4kafb", true);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(svelte_element);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element_1.name,
    type: "child_dynamic_element",
    source: "(174:8) <svelte:element          {...props}          this={elementName}         >",
    ctx
  });
  return block;
}

// (172:6) {#each items as {componentName, content, elementName, props}}
function create_each_block_3(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_7, create_if_block_8];
  const if_blocks = [];
  function select_block_type_4(ctx, dirty) {
    if ( /*elementName*/ctx[27]) return 0;
    if ( /*componentName*/ctx[25]) return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_4(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_4(ctx);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block.c();
          } else {
            if_block.p(ctx, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching) detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_3.name,
    type: "each",
    source: "(172:6) {#each items as {componentName, content, elementName, props}}",
    ctx
  });
  return block;
}

// (170:5) {#each currentData.slots as {items}}
function create_each_block_2(ctx) {
  let each_1_anchor;
  let current;
  let each_value_3 = /*items*/ctx[22];
  validate_each_argument(each_value_3);
  let each_blocks = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  const out = i => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      if (dirty[0] & /*currentData*/32) {
        each_value_3 = /*items*/ctx[22];
        validate_each_argument(each_value_3);
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx, each_value_3, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_3.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value_3.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching) detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_2.name,
    type: "each",
    source: "(170:5) {#each currentData.slots as {items}}",
    ctx
  });
  return block;
}

// (162:3) <svelte:component     {...currentData.props}     bind:this={instance}     this={component}    >
function create_default_slot_2(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_5, create_if_block_6];
  const if_blocks = [];
  function select_block_type_3(ctx, dirty) {
    if ( /*currentData*/ctx[5].content) return 0;
    if ( /*currentData*/ctx[5].slots) return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_3(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_3(ctx);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block.c();
          } else {
            if_block.p(ctx, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching) detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(162:3) <svelte:component     {...currentData.props}     bind:this={instance}     this={component}    >",
    ctx
  });
  return block;
}

// (140:34) 
function create_if_block_2(ctx) {
  let each_1_anchor;
  let current;
  let each_value = /*currentData*/ctx[5].slots;
  validate_each_argument(each_value);
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = i => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      if (dirty[0] & /*currentData*/32) {
        each_value = /*currentData*/ctx[5].slots;
        validate_each_argument(each_value);
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching) detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(140:34) ",
    ctx
  });
  return block;
}

// (138:6) {#if currentData.content}
function create_if_block_1(ctx) {
  let t_value = /*currentData*/ctx[5].content + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx, dirty) {
      if (dirty[0] & /*currentData*/32 && t_value !== (t_value = /*currentData*/ctx[5].content + "")) set_data_dev(t, t_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(138:6) {#if currentData.content}",
    ctx
  });
  return block;
}

// (149:33) 
function create_if_block_4(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [/*props*/ctx[28]];
  var switch_value = components[/*componentName*/ctx[25]];
  function switch_props(ctx) {
    let switch_instance_props = {
      $$slots: {
        default: [create_default_slot_1]
      },
      $$scope: {
        ctx
      }
    };
    for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
      switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
  }
  const block = {
    c: function create() {
      if (switch_instance) create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance) mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const switch_instance_changes = dirty[0] & /*currentData*/32 ? get_spread_update(switch_instance_spread_levels, [get_spread_object( /*props*/ctx[28])]) : {};
      if (dirty[0] & /*currentData*/32 | dirty[1] & /*$$scope*/16384) {
        switch_instance_changes.$$scope = {
          dirty,
          ctx
        };
      }
      if (dirty[0] & /*currentData*/32 && switch_value !== (switch_value = components[/*componentName*/ctx[25]])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current) return;
      if (switch_instance) transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance) transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(switch_instance_anchor);
      if (switch_instance) destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(149:33) ",
    ctx
  });
  return block;
}

// (144:9) {#if elementName}
function create_if_block_3(ctx) {
  let previous_tag = /*elementName*/ctx[27];
  let svelte_element_anchor;
  validate_dynamic_element( /*elementName*/ctx[27]);
  validate_void_dynamic_element( /*elementName*/ctx[27]);
  let svelte_element = /*elementName*/ctx[27] && create_dynamic_element(ctx);
  const block = {
    c: function create() {
      if (svelte_element) svelte_element.c();
      svelte_element_anchor = empty();
    },
    l: function claim(nodes) {
      if (svelte_element) svelte_element.l(nodes);
      svelte_element_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (svelte_element) svelte_element.m(target, anchor);
      insert_hydration_dev(target, svelte_element_anchor, anchor);
    },
    p: function update(ctx, dirty) {
      if ( /*elementName*/ctx[27]) {
        if (!previous_tag) {
          svelte_element = create_dynamic_element(ctx);
          previous_tag = /*elementName*/ctx[27];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else if (safe_not_equal(previous_tag, /*elementName*/ctx[27])) {
          svelte_element.d(1);
          validate_dynamic_element( /*elementName*/ctx[27]);
          validate_void_dynamic_element( /*elementName*/ctx[27]);
          svelte_element = create_dynamic_element(ctx);
          previous_tag = /*elementName*/ctx[27];
          svelte_element.c();
          svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
        } else {
          svelte_element.p(ctx, dirty);
        }
      } else if (previous_tag) {
        svelte_element.d(1);
        svelte_element = null;
        previous_tag = /*elementName*/ctx[27];
      }
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(svelte_element_anchor);
      if (svelte_element) svelte_element.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(144:9) {#if elementName}",
    ctx
  });
  return block;
}

// (150:10) <svelte:component            {...props}            this={components[componentName]}           >
function create_default_slot_1(ctx) {
  let t_value = /*content*/ctx[26] + "";
  let t;
  const block = {
    c: function create() {
      t = text(t_value);
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx, dirty) {
      if (dirty[0] & /*currentData*/32 && t_value !== (t_value = /*content*/ctx[26] + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(t);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(150:10) <svelte:component            {...props}            this={components[componentName]}           >",
    ctx
  });
  return block;
}

// (145:10) <svelte:element            {...props}            this={elementName}           >
function create_dynamic_element(ctx) {
  let svelte_element;
  let t_value = /*content*/ctx[26] + "";
  let t;
  let svelte_element_levels = [/*props*/ctx[28]];
  let svelte_element_data = {};
  for (let i = 0; i < svelte_element_levels.length; i += 1) {
    svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
  }
  const block = {
    c: function create() {
      svelte_element = svg_element( /*elementName*/ctx[27]);
      t = text(t_value);
      this.h();
    },
    l: function claim(nodes) {
      svelte_element = claim_svg_element(nodes, /*elementName*/ctx[27], {});
      var svelte_element_nodes = children(svelte_element);
      t = claim_text(svelte_element_nodes, t_value);
      svelte_element_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_svg_attributes(svelte_element, svelte_element_data);
      toggle_class(svelte_element, "svelte-w4kafb", true);
      add_location(svelte_element, file, 144, 10, 3349);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, svelte_element, anchor);
      append_hydration_dev(svelte_element, t);
    },
    p: function update(ctx, dirty) {
      if (dirty[0] & /*currentData*/32 && t_value !== (t_value = /*content*/ctx[26] + "")) set_data_maybe_contenteditable_dev(t, t_value, svelte_element_data['contenteditable']);
      set_svg_attributes(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [dirty[0] & /*currentData*/32 && /*props*/ctx[28]]));
      toggle_class(svelte_element, "svelte-w4kafb", true);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(svelte_element);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_dynamic_element.name,
    type: "child_dynamic_element",
    source: "(145:10) <svelte:element            {...props}            this={elementName}           >",
    ctx
  });
  return block;
}

// (143:8) {#each items as {componentName, content, elementName, props}}
function create_each_block_1(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_3, create_if_block_4];
  const if_blocks = [];
  function select_block_type_2(ctx, dirty) {
    if ( /*elementName*/ctx[27]) return 0;
    if ( /*componentName*/ctx[25]) return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_2(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block.c();
          } else {
            if_block.p(ctx, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching) detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block_1.name,
    type: "each",
    source: "(143:8) {#each items as {componentName, content, elementName, props}}",
    ctx
  });
  return block;
}

// (141:7) {#each currentData.slots as {items}}
function create_each_block(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = /*items*/ctx[22];
  validate_each_argument(each_value_1);
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = i => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      if (dirty[0] & /*currentData*/32) {
        each_value_1 = /*items*/ctx[22];
        validate_each_argument(each_value_1);
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i: function intro(local) {
      if (current) return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching) detach_dev(each_1_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(141:7) {#each currentData.slots as {items}}",
    ctx
  });
  return block;
}

// (133:5) <svelte:component       bind:this={instance}       this={component}       {...{...currentData.props, width, height}}      >
function create_default_slot(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_1, create_if_block_2];
  const if_blocks = [];
  function select_block_type_1(ctx, dirty) {
    if ( /*currentData*/ctx[5].content) return 0;
    if ( /*currentData*/ctx[5].slots) return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type_1(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  const block = {
    c: function create() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block) if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
            if_block.c();
          } else {
            if_block.p(ctx, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
      if (detaching) detach_dev(if_block_anchor);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(133:5) <svelte:component       bind:this={instance}       this={component}       {...{...currentData.props, width, height}}      >",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let title_value;
  let t0;
  let main;
  let h1;
  let t1;
  let t2;
  let div3;
  let div0;
  let elements;
  let t3;
  let t4;
  let t5;
  let div1;
  let h20;
  let t6;
  let t7;
  let pre;
  let t8_value = /*currentData*/ctx[5].usage + "";
  let t8;
  let t9;
  let div2;
  let h21;
  let t10;
  let t11;
  let t12;
  let div4;
  let current_block_type_index;
  let if_block2;
  let current;
  document.title = title_value = "" + ( /*name*/ctx[2] + ": " + /*title*/ctx[3] + " - Svizzle");
  elements = new Elements({
    props: {
      elements: /*doc*/ctx[1]
    },
    $$inline: true
  });
  let if_block0 = /*data*/ctx[0].length > 1 && create_if_block_10(ctx);
  let if_block1 = /*payloads*/ctx[9] && create_if_block_9(ctx);
  let each_value_4 = /*displayProps*/ctx[10];
  validate_each_argument(each_value_4);
  let each_blocks = [];
  for (let i = 0; i < each_value_4.length; i += 1) {
    each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
  }
  const out = i => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx, dirty) {
    if ( /*isSVG*/ctx[12]) return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      t0 = space();
      main = element("main");
      h1 = element("h1");
      t1 = text( /*title*/ctx[3]);
      t2 = space();
      div3 = element("div");
      div0 = element("div");
      create_component(elements.$$.fragment);
      t3 = space();
      if (if_block0) if_block0.c();
      t4 = space();
      if (if_block1) if_block1.c();
      t5 = space();
      div1 = element("div");
      h20 = element("h2");
      t6 = text("Usage");
      t7 = space();
      pre = element("pre");
      t8 = text(t8_value);
      t9 = space();
      div2 = element("div");
      h21 = element("h2");
      t10 = text("Props");
      t11 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t12 = space();
      div4 = element("div");
      if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      const head_nodes = head_selector('svelte-1sqseen', document.head);
      head_nodes.forEach(detach_dev);
      t0 = claim_space(nodes);
      main = claim_element(nodes, "MAIN", {
        class: true
      });
      var main_nodes = children(main);
      h1 = claim_element(main_nodes, "H1", {
        class: true
      });
      var h1_nodes = children(h1);
      t1 = claim_text(h1_nodes, /*title*/ctx[3]);
      h1_nodes.forEach(detach_dev);
      t2 = claim_space(main_nodes);
      div3 = claim_element(main_nodes, "DIV", {
        class: true
      });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", {
        class: true
      });
      var div0_nodes = children(div0);
      claim_component(elements.$$.fragment, div0_nodes);
      div0_nodes.forEach(detach_dev);
      t3 = claim_space(div3_nodes);
      if (if_block0) if_block0.l(div3_nodes);
      t4 = claim_space(div3_nodes);
      if (if_block1) if_block1.l(div3_nodes);
      t5 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", {
        class: true
      });
      var div1_nodes = children(div1);
      h20 = claim_element(div1_nodes, "H2", {});
      var h20_nodes = children(h20);
      t6 = claim_text(h20_nodes, "Usage");
      h20_nodes.forEach(detach_dev);
      t7 = claim_space(div1_nodes);
      pre = claim_element(div1_nodes, "PRE", {
        class: true
      });
      var pre_nodes = children(pre);
      t8 = claim_text(pre_nodes, t8_value);
      pre_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t9 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", {
        class: true
      });
      var div2_nodes = children(div2);
      h21 = claim_element(div2_nodes, "H2", {});
      var h21_nodes = children(h21);
      t10 = claim_text(h21_nodes, "Props");
      h21_nodes.forEach(detach_dev);
      t11 = claim_space(div2_nodes);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div2_nodes);
      }
      div2_nodes.forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      t12 = claim_space(main_nodes);
      div4 = claim_element(main_nodes, "DIV", {
        class: true
      });
      var div4_nodes = children(div4);
      if_block2.l(div4_nodes);
      div4_nodes.forEach(detach_dev);
      main_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(h1, "class", "svelte-w4kafb");
      add_location(h1, file, 64, 1, 1520);
      attr_dev(div0, "class", "distancer svelte-w4kafb");
      add_location(div0, file, 68, 2, 1579);
      add_location(h20, file, 108, 3, 2425);
      attr_dev(pre, "class", "svelte-w4kafb");
      add_location(pre, file, 109, 3, 2443);
      attr_dev(div1, "class", "distancer svelte-w4kafb");
      add_location(div1, file, 107, 2, 2398);
      add_location(h21, file, 114, 3, 2530);
      attr_dev(div2, "class", "distancer svelte-w4kafb");
      add_location(div2, file, 113, 2, 2503);
      attr_dev(div3, "class", "col col1 svelte-w4kafb");
      add_location(div3, file, 65, 1, 1538);
      attr_dev(div4, "class", "col col2 svelte-w4kafb");
      add_location(div4, file, 125, 1, 2737);
      attr_dev(main, "class", "svelte-w4kafb");
      add_location(main, file, 63, 0, 1512);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t0, anchor);
      insert_hydration_dev(target, main, anchor);
      append_hydration_dev(main, h1);
      append_hydration_dev(h1, t1);
      append_hydration_dev(main, t2);
      append_hydration_dev(main, div3);
      append_hydration_dev(div3, div0);
      mount_component(elements, div0, null);
      append_hydration_dev(div3, t3);
      if (if_block0) if_block0.m(div3, null);
      append_hydration_dev(div3, t4);
      if (if_block1) if_block1.m(div3, null);
      append_hydration_dev(div3, t5);
      append_hydration_dev(div3, div1);
      append_hydration_dev(div1, h20);
      append_hydration_dev(h20, t6);
      append_hydration_dev(div1, t7);
      append_hydration_dev(div1, pre);
      append_hydration_dev(pre, t8);
      append_hydration_dev(div3, t9);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, h21);
      append_hydration_dev(h21, t10);
      append_hydration_dev(div2, t11);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div2, null);
        }
      }
      append_hydration_dev(main, t12);
      append_hydration_dev(main, div4);
      if_blocks[current_block_type_index].m(div4, null);
      current = true;
    },
    p: function update(ctx, dirty) {
      if ((!current || dirty[0] & /*name, title*/12) && title_value !== (title_value = "" + ( /*name*/ctx[2] + ": " + /*title*/ctx[3] + " - Svizzle"))) {
        document.title = title_value;
      }
      if (!current || dirty[0] & /*title*/8) set_data_dev(t1, /*title*/ctx[3]);
      const elements_changes = {};
      if (dirty[0] & /*doc*/2) elements_changes.elements = /*doc*/ctx[1];
      elements.$set(elements_changes);
      if ( /*data*/ctx[0].length > 1) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_10(ctx);
          if_block0.c();
          if_block0.m(div3, t4);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if ( /*payloads*/ctx[9]) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_9(ctx);
          if_block1.c();
          if_block1.m(div3, t5);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if ((!current || dirty[0] & /*currentData*/32) && t8_value !== (t8_value = /*currentData*/ctx[5].usage + "")) set_data_dev(t8, t8_value);
      if (dirty[0] & /*displayProps*/1024) {
        each_value_4 = /*displayProps*/ctx[10];
        validate_each_argument(each_value_4);
        let i;
        for (i = 0; i < each_value_4.length; i += 1) {
          const child_ctx = get_each_context_4(ctx, each_value_4, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_4(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div2, null);
          }
        }
        group_outros();
        for (i = each_value_4.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block2 = if_blocks[current_block_type_index];
        if (!if_block2) {
          if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block2.c();
        } else {
          if_block2.p(ctx, dirty);
        }
        transition_in(if_block2, 1);
        if_block2.m(div4, null);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(elements.$$.fragment, local);
      for (let i = 0; i < each_value_4.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block2);
      current = true;
    },
    o: function outro(local) {
      transition_out(elements.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block2);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(t0);
      if (detaching) detach_dev(main);
      destroy_component(elements);
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      destroy_each(each_blocks, detaching);
      if_blocks[current_block_type_index].d();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function preload(_ref) {
  let {
    params,
    query
  } = _ref;
  return lookup[params.slug];
}
function instance_1($$self, $$props, $$invalidate) {
  let isSVG;
  let component;
  let selected;
  let currentData;
  let payloads;
  let displayProps;
  let {
    $$slots: slots = {},
    $$scope
  } = $$props;
  validate_slots('U5Bslugu5D', slots, []);
  const makeKeyedEmptyString = makeKeyed('');
  let {
    data
  } = $$props;
  let {
    doc
  } = $$props;
  let {
    events
  } = $$props;
  let {
    name
  } = $$props;
  let {
    namespace
  } = $$props;
  let {
    title
  } = $$props;
  let instance;
  let width;
  let height;
  const makeEventHandler = eventName => event => {
    $$invalidate(9, payloads = setIn(payloads, eventName, JSON.stringify(event.detail)));
  };
  let eventRemovers = [];
  $$self.$$.on_mount.push(function () {
    if (data === undefined && !('data' in $$props || $$self.$$.bound[$$self.$$.props['data']])) {
      console.warn("<U5Bslugu5D> was created without expected prop 'data'");
    }
    if (doc === undefined && !('doc' in $$props || $$self.$$.bound[$$self.$$.props['doc']])) {
      console.warn("<U5Bslugu5D> was created without expected prop 'doc'");
    }
    if (events === undefined && !('events' in $$props || $$self.$$.bound[$$self.$$.props['events']])) {
      console.warn("<U5Bslugu5D> was created without expected prop 'events'");
    }
    if (name === undefined && !('name' in $$props || $$self.$$.bound[$$self.$$.props['name']])) {
      console.warn("<U5Bslugu5D> was created without expected prop 'name'");
    }
    if (namespace === undefined && !('namespace' in $$props || $$self.$$.bound[$$self.$$.props['namespace']])) {
      console.warn("<U5Bslugu5D> was created without expected prop 'namespace'");
    }
    if (title === undefined && !('title' in $$props || $$self.$$.bound[$$self.$$.props['title']])) {
      console.warn("<U5Bslugu5D> was created without expected prop 'title'");
    }
  });
  const writable_props = ['data', 'doc', 'events', 'name', 'namespace', 'title'];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn("<U5Bslugu5D> was created with unknown prop '".concat(key, "'"));
  });
  const change_handler = event => {
    $$invalidate(6, selected = Number(event.target.value));
  };
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
      instance = $$value;
      $$invalidate(4, instance);
    });
  }
  function div_elementresize_handler() {
    width = this.clientWidth;
    height = this.clientHeight;
    $$invalidate(7, width);
    $$invalidate(8, height);
  }
  function switch_instance_binding_1($$value) {
    binding_callbacks[$$value ? 'unshift' : 'push'](() => {
      instance = $$value;
      $$invalidate(4, instance);
    });
  }
  $$self.$$set = $$props => {
    if ('data' in $$props) $$invalidate(0, data = $$props.data);
    if ('doc' in $$props) $$invalidate(1, doc = $$props.doc);
    if ('events' in $$props) $$invalidate(14, events = $$props.events);
    if ('name' in $$props) $$invalidate(2, name = $$props.name);
    if ('namespace' in $$props) $$invalidate(13, namespace = $$props.namespace);
    if ('title' in $$props) $$invalidate(3, title = $$props.title);
  };
  $$self.$capture_state = () => ({
    lookup,
    preload,
    makeKeyed,
    _,
    JSONTree: Root,
    Elements,
    components,
    makeKeyedEmptyString,
    data,
    doc,
    events,
    name,
    namespace,
    title,
    instance,
    width,
    height,
    makeEventHandler,
    eventRemovers,
    payloads,
    currentData,
    displayProps,
    selected,
    component,
    isSVG
  });
  $$self.$inject_state = $$props => {
    if ('data' in $$props) $$invalidate(0, data = $$props.data);
    if ('doc' in $$props) $$invalidate(1, doc = $$props.doc);
    if ('events' in $$props) $$invalidate(14, events = $$props.events);
    if ('name' in $$props) $$invalidate(2, name = $$props.name);
    if ('namespace' in $$props) $$invalidate(13, namespace = $$props.namespace);
    if ('title' in $$props) $$invalidate(3, title = $$props.title);
    if ('instance' in $$props) $$invalidate(4, instance = $$props.instance);
    if ('width' in $$props) $$invalidate(7, width = $$props.width);
    if ('height' in $$props) $$invalidate(8, height = $$props.height);
    if ('eventRemovers' in $$props) $$invalidate(15, eventRemovers = $$props.eventRemovers);
    if ('payloads' in $$props) $$invalidate(9, payloads = $$props.payloads);
    if ('currentData' in $$props) $$invalidate(5, currentData = $$props.currentData);
    if ('displayProps' in $$props) $$invalidate(10, displayProps = $$props.displayProps);
    if ('selected' in $$props) $$invalidate(6, selected = $$props.selected);
    if ('component' in $$props) $$invalidate(11, component = $$props.component);
    if ('isSVG' in $$props) $$invalidate(12, isSVG = $$props.isSVG);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*namespace*/8192) {
      // FIXME https://github.com/sveltejs/svelte/issues/4442
      $$invalidate(13, namespace = namespace || 'html');
    }
    if ($$self.$$.dirty[0] & /*namespace*/8192) {
      $$invalidate(12, isSVG = namespace === 'svg');
    }
    if ($$self.$$.dirty[0] & /*name*/4) {
      $$invalidate(11, component = components[name]);
    }
    if ($$self.$$.dirty[0] & /*data*/1) {
      $$invalidate(6, selected = data && 0);
    }
    if ($$self.$$.dirty[0] & /*data, selected*/65) {
      $$invalidate(5, currentData = data[selected]);
    }
    if ($$self.$$.dirty[0] & /*currentData, events*/16416) {
      $$invalidate(9, payloads = currentData && events ? makeKeyedEmptyString(events) : null);
    }
    if ($$self.$$.dirty[0] & /*currentData*/32) {
      $$invalidate(10, displayProps = pairs(currentData.props));
    }
    if ($$self.$$.dirty[0] & /*data, instance, eventRemovers, events*/49169) {
      if (data && instance) {
        eventRemovers.forEach(remove => remove());
        $$invalidate(15, eventRemovers = []);
        events && events.forEach(eventName => {
          const eventHandler = makeEventHandler(eventName);
          const eventRemover = instance.$on(eventName, eventHandler);
          eventRemovers.push(eventRemover);
        });
      }
    }
  };
  return [data, doc, name, title, instance, currentData, selected, width, height, payloads, displayProps, component, isSVG, namespace, events, eventRemovers, change_handler, switch_instance_binding, div_elementresize_handler, switch_instance_binding_1];
}
class U5Bslugu5D extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_1, create_fragment, safe_not_equal, {
      data: 0,
      doc: 1,
      events: 14,
      name: 2,
      namespace: 13,
      title: 3
    }, null, [-1, -1]);
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "U5Bslugu5D",
      options,
      id: create_fragment.name
    });
  }
  get data() {
    throw new Error("<U5Bslugu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set data(value) {
    throw new Error("<U5Bslugu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get doc() {
    throw new Error("<U5Bslugu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set doc(value) {
    throw new Error("<U5Bslugu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get events() {
    throw new Error("<U5Bslugu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set events(value) {
    throw new Error("<U5Bslugu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get name() {
    throw new Error("<U5Bslugu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<U5Bslugu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get namespace() {
    throw new Error("<U5Bslugu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set namespace(value) {
    throw new Error("<U5Bslugu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get title() {
    throw new Error("<U5Bslugu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set title(value) {
    throw new Error("<U5Bslugu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
}

export { U5Bslugu5D as default, preload };
