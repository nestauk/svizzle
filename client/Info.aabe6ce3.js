import { p as pipe, ae as skipIf, af as isNil, D as pairs$1, m as mapWith } from './defaultLocale.f3c5fc93.js';
import { j as joinWithColon, d as joinWithSemicolon } from './ScreenGauge.8c0d1ef1.js';
import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, e as element, z as svg_element, G as create_component, f as claim_element, g as children, H as claim_component, b as detach_dev, j as attr_dev, k as add_location, l as insert_dev, m as append_dev, I as mount_component, K as group_outros, x as transition_out, J as destroy_component, L as check_outros, w as transition_in, n as noop } from './client.ed49fe48.js';

/**
* @module @svizzle/utils/string-[string-string]
*/

/**
 * Return a function that prepends the provided string to the input string
 *
 * @function
 * @arg {string} prefix - The string to be prepended
 * @return {function} - String -> String
 *
 * @example
> prefixed = makePrefixed('---')
> prefixed('A')
'---A'
> prefixed('B')
'---B'
 *
 * @since 0.1.0
 * @see {@link module:@svizzle/utils/string-[string-string].makePostfixed|makePostfixed}
 */
const makePrefixed = prefix => string => prefix + string;

function pairs(values, pairof = pair) {
  const pairs = [];
  let previous;
  let first = false;
  for (const value of values) {
    if (first) pairs.push(pairof(previous, value));
    previous = value;
    first = true;
  }
  return pairs;
}

function pair(a, b) {
  return [a, b];
}

/**
* @module @svizzle/dom/attrs
*/

/**
 * Return a style string from an object
 *
 * @function
 * @arg {object} object
 * @return {string} styleString
 *
 * @example
> makeStyle({color: 'red', 'font-size': '10px'})
'color:red;font-size:10px'
 *
 * @since 0.1.0
 */
const makeStyle = pipe([
	skipIf(isNil),
	pairs$1,
	mapWith(joinWithColon),
	joinWithSemicolon
]);

/**
 * Return a style string with hyphenate CSS variables derived from the keys of the expected object
 *
 * @function
 * @arg {object} object
 * @return {string} styleString
 *
 * @example
> makeStyleVars({foo: 'red', 'bar': '10px'})
'--foo:red;--bar:10px'
 *
 * @since 0.4.0
 */
const makeStyleVars = pipe([
	skipIf(isNil),
	pairs$1,
	mapWith(pipe([joinWithColon, makePrefixed('--')])),
	joinWithSemicolon
]);

/**
 * Return a px representation of the received number.
 * Throws an error if the input is not a number.
 *
 * @function
 * @arg {number} number
 * @return {string}
 *
 * @example
> toPx(10)
'10px'
 *
 * @since 0.1.0
 */
const toPx = number => `${number}px`;

/* ../../components/ui/src/icons/Icon.svelte generated by Svelte v3.38.2 */

const file$1 = "../../components/ui/src/icons/Icon.svelte";

function create_fragment$1(ctx) {
	let div;
	let svg;
	let switch_instance;
	let current;
	var switch_value = /*glyph*/ ctx[1];

	function switch_props(ctx) {
		return { $$inline: true };
	}

	if (switch_value) {
		switch_instance = new switch_value(switch_props());
	}

	const block = {
		c: function create() {
			div = element("div");
			svg = svg_element("svg");
			if (switch_instance) create_component(switch_instance.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			svg = claim_element(
				div_nodes,
				"svg",
				{
					fill: true,
					stroke: true,
					svgXmlns: true,
					viewBox: true,
					height: true,
					"stroke-linecap": true,
					"stroke-linejoin": true,
					"stroke-width": true,
					width: true,
					class: true
				},
				1
			);

			var svg_nodes = children(svg);
			if (switch_instance) claim_component(switch_instance.$$.fragment, svg_nodes);
			svg_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(svg, "fill", /*fill*/ ctx[0]);
			attr_dev(svg, "stroke", /*stroke*/ ctx[3]);
			attr_dev(svg, "svgxmlns", svgXmlns);
			attr_dev(svg, "viewBox", /*viewBox*/ ctx[5]);
			attr_dev(svg, "height", /*size*/ ctx[2]);
			attr_dev(svg, "stroke-linecap", strokeLinecap);
			attr_dev(svg, "stroke-linejoin", strokeLinejoin);
			attr_dev(svg, "stroke-width", /*strokeWidth*/ ctx[4]);
			attr_dev(svg, "width", /*size*/ ctx[2]);
			attr_dev(svg, "class", "svelte-1ase79a");
			add_location(svg, file$1, 28, 1, 834);
			attr_dev(div, "class", "svelte-1ase79a");
			add_location(div, file$1, 27, 0, 827);
		},
		m: function mount(target, anchor) {
			insert_dev(target, div, anchor);
			append_dev(div, svg);

			if (switch_instance) {
				mount_component(switch_instance, svg, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (switch_value !== (switch_value = /*glyph*/ ctx[1])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = new switch_value(switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, svg, null);
				} else {
					switch_instance = null;
				}
			}

			if (!current || dirty & /*fill*/ 1) {
				attr_dev(svg, "fill", /*fill*/ ctx[0]);
			}

			if (!current || dirty & /*stroke*/ 8) {
				attr_dev(svg, "stroke", /*stroke*/ ctx[3]);
			}

			if (!current || dirty & /*viewBox*/ 32) {
				attr_dev(svg, "viewBox", /*viewBox*/ ctx[5]);
			}

			if (!current || dirty & /*size*/ 4) {
				attr_dev(svg, "height", /*size*/ ctx[2]);
			}

			if (!current || dirty & /*strokeWidth*/ 16) {
				attr_dev(svg, "stroke-width", /*strokeWidth*/ ctx[4]);
			}

			if (!current || dirty & /*size*/ 4) {
				attr_dev(svg, "width", /*size*/ ctx[2]);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (switch_instance) destroy_component(switch_instance);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const defaultGlyph = null;
const strokeLinecap = "round";
const strokeLinejoin = "round";
const svgXmlns = "http://www.w3.org/2000/svg";

function instance$1($$self, $$props, $$invalidate) {
	let viewBox;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Icon", slots, []);
	const defaultFill = "none";
	const defaultSize = 24;
	const defaultStroke = "currentColor";
	const defaultStrokeWidth = 2;
	let { fill = defaultFill } = $$props;
	let { glyph = defaultGlyph } = $$props;
	let { size = defaultSize } = $$props;
	let { glyphSize = defaultSize } = $$props;
	let { stroke = defaultStroke } = $$props;
	let { strokeWidth = defaultStrokeWidth } = $$props;
	const writable_props = ["fill", "glyph", "size", "glyphSize", "stroke", "strokeWidth"];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Icon> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ("fill" in $$props) $$invalidate(0, fill = $$props.fill);
		if ("glyph" in $$props) $$invalidate(1, glyph = $$props.glyph);
		if ("size" in $$props) $$invalidate(2, size = $$props.size);
		if ("glyphSize" in $$props) $$invalidate(10, glyphSize = $$props.glyphSize);
		if ("stroke" in $$props) $$invalidate(3, stroke = $$props.stroke);
		if ("strokeWidth" in $$props) $$invalidate(4, strokeWidth = $$props.strokeWidth);
	};

	$$self.$capture_state = () => ({
		defaultFill,
		defaultSize,
		defaultStroke,
		defaultStrokeWidth,
		defaultGlyph,
		strokeLinecap,
		strokeLinejoin,
		svgXmlns,
		fill,
		glyph,
		size,
		glyphSize,
		stroke,
		strokeWidth,
		viewBox
	});

	$$self.$inject_state = $$props => {
		if ("fill" in $$props) $$invalidate(0, fill = $$props.fill);
		if ("glyph" in $$props) $$invalidate(1, glyph = $$props.glyph);
		if ("size" in $$props) $$invalidate(2, size = $$props.size);
		if ("glyphSize" in $$props) $$invalidate(10, glyphSize = $$props.glyphSize);
		if ("stroke" in $$props) $$invalidate(3, stroke = $$props.stroke);
		if ("strokeWidth" in $$props) $$invalidate(4, strokeWidth = $$props.strokeWidth);
		if ("viewBox" in $$props) $$invalidate(5, viewBox = $$props.viewBox);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*fill*/ 1) {
			// FIXME https://github.com/sveltejs/svelte/issues/4442
			$$invalidate(0, fill = fill || defaultFill);
		}

		if ($$self.$$.dirty & /*glyph*/ 2) {
			$$invalidate(1, glyph = glyph || defaultGlyph);
		}

		if ($$self.$$.dirty & /*size*/ 4) {
			$$invalidate(2, size = size || defaultSize);
		}

		if ($$self.$$.dirty & /*stroke*/ 8) {
			$$invalidate(3, stroke = stroke || defaultStroke);
		}

		if ($$self.$$.dirty & /*strokeWidth*/ 16) {
			$$invalidate(4, strokeWidth = strokeWidth || defaultStrokeWidth);
		}

		if ($$self.$$.dirty & /*glyphSize*/ 1024) {
			$$invalidate(5, viewBox = `0 0 ${glyphSize} ${glyphSize}`);
		}
	};

	return [
		fill,
		glyph,
		size,
		stroke,
		strokeWidth,
		viewBox,
		defaultFill,
		defaultSize,
		defaultStroke,
		defaultStrokeWidth,
		glyphSize
	];
}

class Icon extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			defaultFill: 6,
			defaultSize: 7,
			defaultStroke: 8,
			defaultStrokeWidth: 9,
			fill: 0,
			glyph: 1,
			size: 2,
			glyphSize: 10,
			stroke: 3,
			strokeWidth: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Icon",
			options,
			id: create_fragment$1.name
		});
	}

	get defaultFill() {
		return this.$$.ctx[6];
	}

	set defaultFill(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get defaultSize() {
		return this.$$.ctx[7];
	}

	set defaultSize(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get defaultStroke() {
		return this.$$.ctx[8];
	}

	set defaultStroke(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get defaultStrokeWidth() {
		return this.$$.ctx[9];
	}

	set defaultStrokeWidth(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get fill() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set fill(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get glyph() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set glyph(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get size() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set size(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get glyphSize() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set glyphSize(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get stroke() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stroke(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get strokeWidth() {
		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set strokeWidth(value) {
		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* ../../components/ui/src/icons/feather/Info.svelte generated by Svelte v3.38.2 */

const file = "../../components/ui/src/icons/feather/Info.svelte";

function create_fragment(ctx) {
	let circle;
	let line0;
	let line1;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_element(nodes, "circle", { cx: true, cy: true, r: true }, 1);
			children(circle).forEach(detach_dev);
			line0 = claim_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line0).forEach(detach_dev);
			line1 = claim_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true }, 1);
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file, 1, 0, 34);
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "16");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "12");
			add_location(line0, file, 1, 40, 74);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "8");
			attr_dev(line1, "x2", "12.01");
			attr_dev(line1, "y2", "8");
			add_location(line1, file, 1, 85, 119);
		},
		m: function mount(target, anchor) {
			insert_dev(target, circle, anchor);
			insert_dev(target, line0, anchor);
			insert_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots("Info", slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Info> was created with unknown prop '${key}'`);
	});

	return [];
}

class Info extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Info",
			options,
			id: create_fragment.name
		});
	}
}

export { Icon as I, Info as a, makeStyle as b, makeStyleVars as m, pairs as p, toPx as t };
