import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, p as validate_each_argument, aa as validate_store, ab as component_subscribe, v as validate_slots, an as subscribe, bm as onMount, e as element, t as text, a as space, f as claim_element, g as children, h as claim_text, b as detach_dev, c as claim_space, j as attr_dev, l as add_location, m as insert_hydration_dev, n as append_hydration_dev, Z as set_data_dev, u as transition_in, G as group_outros, w as transition_out, x as check_outros, y as destroy_each, a7 as add_render_callback, a8 as add_resize_listener, o as noop, aE as binding_callbacks, C as create_component, D as claim_component, E as mount_component, F as destroy_component, H as toggle_class, bn as action_destroyer, al as is_function, ax as isServerSide, b6 as isNotNil, aA as _, ah as last, bo as findIndex, bp as is, I as svg_element, a1 as empty, J as claim_svg_element, aT as when, aP as always, K as Icon, U as mapValuesWith, $ as listen_dev, am as run_all, aw as ScreenSensor, r as create_slot, z as update_slot_base, A as get_all_dirty_from_scope, B as get_slot_changes, q as query_selector_all } from './client.5c29960b.js';
import { L as LoadingView } from './LoadingView.e85ac4d0.js';
import { L as Link } from './linear.ec33a939.js';
import { _ as _hrefBase, s as setGroups, a as _timelineLayout, b as _yearRange, c as shortenYear, d as _routes, e as _isSmallScreen, f as _screenClasses, g as _viewsClasses, h as _isTimelineHidden, i as _timelineWidth, j as _timelineHeight, k as _selectedYear, l as _navFlags, m as _views, n as showView, o as _groups } from './stores.21551741.js';
import { _ as _theme, a as _style, b as _availableYears, c as _regionSettings, d as customizeTheme } from './indicator.71fade39.js';
import { m as makeURL, f as flags, h as hrefBase, r as regionSettings } from './_config.8a8ee006.js';
import { L as List, A as Activity, B as BarChart, C as Clock, M as MapPin } from './MapPin.c6140e3f.js';
import { I as Info } from './Info.c6802fb5.js';
import { S as Settings } from './Settings.d1e8e800.js';
import { _ as _POIs } from './POIs.bd9c58b6.js';
import './defaultLocale.de695f5f.js';
import './yootils.es.6e4269de.js';

/**
* @module @svizzle/utils/array-[any-any]
*/

/**
 * Return a function that maps the input to the first or the second element of the provided pair: the first if its truthy, the second otherwise.
 *
 * @function
 * @arg {array} pair - Pair of output values
 * @return {function} - Any -> Any
 *
 * @example
> boolToNum = truthynessTo([0, 1])
> boolToNum(true)
0
> boolToNum(false)
1

> boolToString = truthynessTo(['OK!', 'Sorry!'])
> boolToString(true)
'OK!'
> boolToString(false)
'Sorry!'

> numToString = truthynessTo(['OK!', 'Sorry!'])
> numToString(3)
'OK!'
> numToString(0)
'Sorry!'

> stringToString = truthynessTo(['OK!', 'Sorry!'])
> stringToString('hey')
'OK!'
> stringToString('')
'Sorry!'

> stringToObject = truthynessTo([{value: 1}, {value: -1}])
> stringToObject('hey')
{value: 1}
> stringToObject('')
{value: -1}
 *
 * @since 0.14.0
 */
const truthynessTo =
	([valueIfTruthy, valueIfFalsy]) => x => x ? valueIfTruthy : valueIfFalsy;

/* ../../components/time_region_value/src/node_modules/components/Sidebar.svelte generated by Svelte v3.44.2 */
const file$4 = "../../components/time_region_value/src/node_modules/components/Sidebar.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[11] = list[i].label;
	child_ctx[12] = list[i].indicators;
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[15] = list[i].title;
	child_ctx[16] = list[i].schema;
	return child_ctx;
}

// (60:4) <Link      href={makeURL($_hrefBase, schema.value.id)}      rel='prefetch'      theme={{color: $_theme.colorWhite}}     >
function create_default_slot$1(ctx) {
	let p;
	let t_value = /*title*/ ctx[15] + "";
	let t;
	let keepOnScreen_action;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			t = claim_text(p_nodes, t_value);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "class", "svelte-13lnbxn");
			toggle_class(p, "selected", /*schema*/ ctx[16].value.id === /*currentId*/ ctx[1]);
			add_location(p, file$4, 64, 5, 1473);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, p, anchor);
			append_hydration_dev(p, t);

			if (!mounted) {
				dispose = action_destroyer(keepOnScreen_action = /*keepOnScreen*/ ctx[7].call(null, p, {
					id: /*schema*/ ctx[16].value.id,
					currentId: /*currentId*/ ctx[1],
					scrollableHeight: /*scrollableHeight*/ ctx[4]
				}));

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*$_groups*/ 4 && t_value !== (t_value = /*title*/ ctx[15] + "")) set_data_dev(t, t_value);

			if (keepOnScreen_action && is_function(keepOnScreen_action.update) && dirty & /*$_groups, currentId, scrollableHeight*/ 22) keepOnScreen_action.update.call(null, {
				id: /*schema*/ ctx[16].value.id,
				currentId: /*currentId*/ ctx[1],
				scrollableHeight: /*scrollableHeight*/ ctx[4]
			});

			if (dirty & /*$_groups, currentId*/ 6) {
				toggle_class(p, "selected", /*schema*/ ctx[16].value.id === /*currentId*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(60:4) <Link      href={makeURL($_hrefBase, schema.value.id)}      rel='prefetch'      theme={{color: $_theme.colorWhite}}     >",
		ctx
	});

	return block;
}

// (59:3) {#each indicators as {title, schema}}
function create_each_block_1$1(ctx) {
	let link;
	let current;

	link = new Link({
			props: {
				href: makeURL(/*$_hrefBase*/ ctx[5], /*schema*/ ctx[16].value.id),
				rel: "prefetch",
				theme: { color: /*$_theme*/ ctx[6].colorWhite },
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(link.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(link.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(link, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const link_changes = {};
			if (dirty & /*$_hrefBase, $_groups*/ 36) link_changes.href = makeURL(/*$_hrefBase*/ ctx[5], /*schema*/ ctx[16].value.id);
			if (dirty & /*$_theme*/ 64) link_changes.theme = { color: /*$_theme*/ ctx[6].colorWhite };

			if (dirty & /*$$scope, $_groups, currentId, scrollableHeight*/ 524310) {
				link_changes.$$scope = { dirty, ctx };
			}

			link.$set(link_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(link.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(link.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(link, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$1.name,
		type: "each",
		source: "(59:3) {#each indicators as {title, schema}}",
		ctx
	});

	return block;
}

// (56:1) {#each $_groups as {label, indicators}}
function create_each_block$1(ctx) {
	let div;
	let header;
	let t0_value = /*label*/ ctx[11] + "";
	let t0;
	let t1;
	let t2;
	let current;
	let each_value_1 = /*indicators*/ ctx[12];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			div = element("div");
			header = element("header");
			t0 = text(t0_value);
			t1 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t2 = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			header = claim_element(div_nodes, "HEADER", { class: true });
			var header_nodes = children(header);
			t0 = claim_text(header_nodes, t0_value);
			header_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			t2 = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(header, "class", "svelte-13lnbxn");
			add_location(header, file$4, 57, 3, 1276);
			attr_dev(div, "class", "group svelte-13lnbxn");
			add_location(div, file$4, 56, 2, 1253);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, header);
			append_hydration_dev(header, t0);
			append_hydration_dev(div, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(div, null);
			}

			append_hydration_dev(div, t2);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*$_groups*/ 4) && t0_value !== (t0_value = /*label*/ ctx[11] + "")) set_data_dev(t0, t0_value);

			if (dirty & /*makeURL, $_hrefBase, $_groups, $_theme, currentId, scrollableHeight*/ 118) {
				each_value_1 = /*indicators*/ ctx[12];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div, t2);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(56:1) {#each $_groups as {label, indicators}}",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let nav;
	let nav_resize_listener;
	let current;
	let each_value = /*$_groups*/ ctx[2];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			nav = element("nav");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", { class: true });
			var nav_nodes = children(nav);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nav_nodes);
			}

			nav_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(nav, "class", "svelte-13lnbxn");
			add_render_callback(() => /*nav_elementresize_handler*/ ctx[8].call(nav));
			add_location(nav, file$4, 51, 0, 1141);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, nav, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(nav, null);
			}

			nav_resize_listener = add_resize_listener(nav, /*nav_elementresize_handler*/ ctx[8].bind(nav));
			/*nav_binding*/ ctx[9](nav);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*$_groups, makeURL, $_hrefBase, $_theme, currentId, scrollableHeight*/ 118) {
				each_value = /*$_groups*/ ctx[2];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(nav, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			destroy_each(each_blocks, detaching);
			nav_resize_listener();
			/*nav_binding*/ ctx[9](null);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let $_groups,
		$$unsubscribe__groups = noop,
		$$subscribe__groups = () => ($$unsubscribe__groups(), $$unsubscribe__groups = subscribe(_groups, $$value => $$invalidate(2, $_groups = $$value)), _groups);

	let $_hrefBase;
	let $_theme;
	validate_store(_hrefBase, '_hrefBase');
	component_subscribe($$self, _hrefBase, $$value => $$invalidate(5, $_hrefBase = $$value));
	validate_store(_theme, '_theme');
	component_subscribe($$self, _theme, $$value => $$invalidate(6, $_theme = $$value));
	$$self.$$.on_destroy.push(() => $$unsubscribe__groups());
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Sidebar', slots, []);
	let { _groups = null } = $$props;
	validate_store(_groups, '_groups');
	$$subscribe__groups();
	let { currentId = null } = $$props;
	let currentNode;
	let scrollable;
	let scrollableHeight;

	onMount(() => {
		currentNode && currentNode.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
	});

	// eslint-disable-next-line no-shadow,no-unused-vars
	function keepOnScreen(node, { id, currentId, scrollableHeight }) {
		if (id === currentId) {
			currentNode = node;
		}

		return {
			// eslint-disable-next-line no-shadow,no-unused-vars
			update({ id, currentId, scrollableHeight }) {
				if (id === currentId) {
					const { y: Y } = scrollable.getBoundingClientRect();
					const { y } = node.getBoundingClientRect();
					const yRel = y - Y;

					if (yRel < 0 || yRel > scrollableHeight) {
						scrollable.scrollTo({ top: yRel, behavior: 'smooth' });
					}
				}
			}
		};
	}

	const writable_props = ['_groups', 'currentId'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Sidebar> was created with unknown prop '${key}'`);
	});

	function nav_elementresize_handler() {
		scrollableHeight = this.clientHeight;
		$$invalidate(4, scrollableHeight);
	}

	function nav_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			scrollable = $$value;
			$$invalidate(3, scrollable);
		});
	}

	$$self.$$set = $$props => {
		if ('_groups' in $$props) $$subscribe__groups($$invalidate(0, _groups = $$props._groups));
		if ('currentId' in $$props) $$invalidate(1, currentId = $$props.currentId);
	};

	$$self.$capture_state = () => ({
		Link,
		onMount,
		setGroups,
		_hrefBase,
		_theme,
		makeURL,
		_groups,
		currentId,
		currentNode,
		scrollable,
		scrollableHeight,
		keepOnScreen,
		$_groups,
		$_hrefBase,
		$_theme
	});

	$$self.$inject_state = $$props => {
		if ('_groups' in $$props) $$subscribe__groups($$invalidate(0, _groups = $$props._groups));
		if ('currentId' in $$props) $$invalidate(1, currentId = $$props.currentId);
		if ('currentNode' in $$props) currentNode = $$props.currentNode;
		if ('scrollable' in $$props) $$invalidate(3, scrollable = $$props.scrollable);
		if ('scrollableHeight' in $$props) $$invalidate(4, scrollableHeight = $$props.scrollableHeight);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*_groups, $_groups*/ 5) {
			_groups && setGroups($_groups);
		}
	};

	return [
		_groups,
		currentId,
		$_groups,
		scrollable,
		scrollableHeight,
		$_hrefBase,
		$_theme,
		keepOnScreen,
		nav_elementresize_handler,
		nav_binding
	];
}

class Sidebar extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4, create_fragment$4, safe_not_equal, { _groups: 0, currentId: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Sidebar",
			options,
			id: create_fragment$4.name
		});
	}

	get _groups() {
		throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set _groups(value) {
		throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get currentId() {
		throw new Error("<Sidebar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set currentId(value) {
		throw new Error("<Sidebar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* ../../components/time_region_value/src/node_modules/components/Timeline.svelte generated by Svelte v3.44.2 */
const file$3 = "../../components/time_region_value/src/node_modules/components/Timeline.svelte";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[30] = list[i];
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[30] = list[i];
	return child_ctx;
}

// (51:1) {#if width && height && $_layout || isServerSide}
function create_if_block$2(ctx) {
	let svg;
	let if_block0_anchor;
	let if_block0 = /*selectedYear*/ ctx[3] && create_if_block_4(ctx);

	function select_block_type_2(ctx, dirty) {
		if (/*showLess*/ ctx[4] && /*selectedYear*/ ctx[3]) return create_if_block_1$2;
		return create_else_block;
	}

	let current_block_type = select_block_type_2(ctx);
	let if_block1 = current_block_type(ctx);

	const block = {
		c: function create() {
			svg = svg_element("svg");
			if (if_block0) if_block0.c();
			if_block0_anchor = empty();
			if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_svg_element(nodes, "svg", { width: true, height: true, class: true });
			var svg_nodes = children(svg);
			if (if_block0) if_block0.l(svg_nodes);
			if_block0_anchor = empty();
			if_block1.l(svg_nodes);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(svg, "width", /*width*/ ctx[5]);
			attr_dev(svg, "height", /*height*/ ctx[1]);
			attr_dev(svg, "class", "svelte-rmsnzm");
			add_location(svg, file$3, 51, 2, 1769);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, svg, anchor);
			if (if_block0) if_block0.m(svg, null);
			append_hydration_dev(svg, if_block0_anchor);
			if_block1.m(svg, null);
		},
		p: function update(ctx, dirty) {
			if (/*selectedYear*/ ctx[3]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_4(ctx);
					if_block0.c();
					if_block0.m(svg, if_block0_anchor);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (current_block_type === (current_block_type = select_block_type_2(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(svg, null);
				}
			}

			if (dirty[0] & /*width*/ 32) {
				attr_dev(svg, "width", /*width*/ ctx[5]);
			}

			if (dirty[0] & /*height*/ 2) {
				attr_dev(svg, "height", /*height*/ ctx[1]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
			if (if_block0) if_block0.d();
			if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(51:1) {#if width && height && $_layout || isServerSide}",
		ctx
	});

	return block;
}

// (57:3) {#if selectedYear}
function create_if_block_4(ctx) {
	let g0;
	let g0_transform_value;
	let g1;
	let g1_transform_value;

	function select_block_type(ctx, dirty) {
		if (/*hrefPrev*/ ctx[16]) return create_if_block_6;
		return create_else_block_2;
	}

	let current_block_type = select_block_type(ctx);
	let if_block0 = current_block_type(ctx);

	function select_block_type_1(ctx, dirty) {
		if (/*hrefNext*/ ctx[15]) return create_if_block_5;
		return create_else_block_1;
	}

	let current_block_type_1 = select_block_type_1(ctx);
	let if_block1 = current_block_type_1(ctx);

	const block = {
		c: function create() {
			g0 = svg_element("g");
			if_block0.c();
			g1 = svg_element("g");
			if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			g0 = claim_svg_element(nodes, "g", { transform: true, class: true });
			var g0_nodes = children(g0);
			if_block0.l(g0_nodes);
			g0_nodes.forEach(detach_dev);
			g1 = claim_svg_element(nodes, "g", { transform: true, class: true });
			var g1_nodes = children(g1);
			if_block1.l(g1_nodes);
			g1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(g0, "transform", g0_transform_value = "translate(" + /*prevX*/ ctx[22] + "," + /*buttonY*/ ctx[12] + ")");
			attr_dev(g0, "class", "svelte-rmsnzm");
			toggle_class(g0, "active", /*isPrevYearActive*/ ctx[9]);
			add_location(g0, file$3, 59, 4, 1866);
			attr_dev(g1, "transform", g1_transform_value = "translate(" + /*nextX*/ ctx[11] + "," + /*buttonY*/ ctx[12] + ")");
			attr_dev(g1, "class", "svelte-rmsnzm");
			toggle_class(g1, "active", /*isNextYearActive*/ ctx[7]);
			add_location(g1, file$3, 87, 4, 2471);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, g0, anchor);
			if_block0.m(g0, null);
			insert_hydration_dev(target, g1, anchor);
			if_block1.m(g1, null);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
				if_block0.p(ctx, dirty);
			} else {
				if_block0.d(1);
				if_block0 = current_block_type(ctx);

				if (if_block0) {
					if_block0.c();
					if_block0.m(g0, null);
				}
			}

			if (dirty[0] & /*prevX, buttonY*/ 4198400 && g0_transform_value !== (g0_transform_value = "translate(" + /*prevX*/ ctx[22] + "," + /*buttonY*/ ctx[12] + ")")) {
				attr_dev(g0, "transform", g0_transform_value);
			}

			if (dirty[0] & /*isPrevYearActive*/ 512) {
				toggle_class(g0, "active", /*isPrevYearActive*/ ctx[9]);
			}

			if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx)) && if_block1) {
				if_block1.p(ctx, dirty);
			} else {
				if_block1.d(1);
				if_block1 = current_block_type_1(ctx);

				if (if_block1) {
					if_block1.c();
					if_block1.m(g1, null);
				}
			}

			if (dirty[0] & /*nextX, buttonY*/ 6144 && g1_transform_value !== (g1_transform_value = "translate(" + /*nextX*/ ctx[11] + "," + /*buttonY*/ ctx[12] + ")")) {
				attr_dev(g1, "transform", g1_transform_value);
			}

			if (dirty[0] & /*isNextYearActive*/ 128) {
				toggle_class(g1, "active", /*isNextYearActive*/ ctx[7]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(g0);
			if_block0.d();
			if (detaching) detach_dev(g1);
			if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(57:3) {#if selectedYear}",
		ctx
	});

	return block;
}

// (76:5) {:else}
function create_else_block_2(ctx) {
	let g;
	let rect;
	let polyline;

	const block = {
		c: function create() {
			g = svg_element("g");
			rect = svg_element("rect");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			g = claim_svg_element(nodes, "g", { "aria-label": true });
			var g_nodes = children(g);
			rect = claim_svg_element(g_nodes, "rect", { height: true, width: true, class: true });
			children(rect).forEach(detach_dev);
			polyline = claim_svg_element(g_nodes, "polyline", { points: true, class: true });
			children(polyline).forEach(detach_dev);
			g_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "height", /*halfHeight*/ ctx[10]);
			attr_dev(rect, "width", /*halfHeight*/ ctx[10]);
			attr_dev(rect, "class", "svelte-rmsnzm");
			add_location(rect, file$3, 77, 7, 2301);
			attr_dev(polyline, "points", /*chevronLeftPath*/ ctx[18]);
			attr_dev(polyline, "class", "svelte-rmsnzm");
			add_location(polyline, file$3, 81, 7, 2379);
			attr_dev(g, "aria-label", "Previous year not available");
			add_location(g, file$3, 76, 6, 2249);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, g, anchor);
			append_hydration_dev(g, rect);
			append_hydration_dev(g, polyline);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*halfHeight*/ 1024) {
				attr_dev(rect, "height", /*halfHeight*/ ctx[10]);
			}

			if (dirty[0] & /*halfHeight*/ 1024) {
				attr_dev(rect, "width", /*halfHeight*/ ctx[10]);
			}

			if (dirty[0] & /*chevronLeftPath*/ 262144) {
				attr_dev(polyline, "points", /*chevronLeftPath*/ ctx[18]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(g);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_2.name,
		type: "else",
		source: "(76:5) {:else}",
		ctx
	});

	return block;
}

// (64:5) {#if hrefPrev}
function create_if_block_6(ctx) {
	let a;
	let rect;
	let polyline;
	let a_aria_label_value;

	const block = {
		c: function create() {
			a = svg_element("a");
			rect = svg_element("rect");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			a = claim_svg_element(nodes, "a", {
				"aria-label": true,
				href: true,
				rel: true
			});

			var a_nodes = children(a);
			rect = claim_svg_element(a_nodes, "rect", { height: true, width: true, class: true });
			children(rect).forEach(detach_dev);
			polyline = claim_svg_element(a_nodes, "polyline", { points: true, class: true });
			children(polyline).forEach(detach_dev);
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "height", /*halfHeight*/ ctx[10]);
			attr_dev(rect, "width", /*halfHeight*/ ctx[10]);
			attr_dev(rect, "class", "svelte-rmsnzm");
			add_location(rect, file$3, 69, 7, 2103);
			attr_dev(polyline, "points", /*chevronLeftPath*/ ctx[18]);
			attr_dev(polyline, "class", "svelte-rmsnzm");
			add_location(polyline, file$3, 73, 7, 2181);
			attr_dev(a, "aria-label", a_aria_label_value = "Show the previous year (" + /*prevYear*/ ctx[8] + ")");
			attr_dev(a, "href", /*hrefPrev*/ ctx[16]);
			attr_dev(a, "rel", "prefetch");
			add_location(a, file$3, 64, 6, 1984);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, a, anchor);
			append_hydration_dev(a, rect);
			append_hydration_dev(a, polyline);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*halfHeight*/ 1024) {
				attr_dev(rect, "height", /*halfHeight*/ ctx[10]);
			}

			if (dirty[0] & /*halfHeight*/ 1024) {
				attr_dev(rect, "width", /*halfHeight*/ ctx[10]);
			}

			if (dirty[0] & /*chevronLeftPath*/ 262144) {
				attr_dev(polyline, "points", /*chevronLeftPath*/ ctx[18]);
			}

			if (dirty[0] & /*prevYear*/ 256 && a_aria_label_value !== (a_aria_label_value = "Show the previous year (" + /*prevYear*/ ctx[8] + ")")) {
				attr_dev(a, "aria-label", a_aria_label_value);
			}

			if (dirty[0] & /*hrefPrev*/ 65536) {
				attr_dev(a, "href", /*hrefPrev*/ ctx[16]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(64:5) {#if hrefPrev}",
		ctx
	});

	return block;
}

// (104:5) {:else}
function create_else_block_1(ctx) {
	let g;
	let rect;
	let polyline;

	const block = {
		c: function create() {
			g = svg_element("g");
			rect = svg_element("rect");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			g = claim_svg_element(nodes, "g", { "aria-label": true });
			var g_nodes = children(g);
			rect = claim_svg_element(g_nodes, "rect", { height: true, width: true, class: true });
			children(rect).forEach(detach_dev);
			polyline = claim_svg_element(g_nodes, "polyline", { points: true, class: true });
			children(polyline).forEach(detach_dev);
			g_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "height", /*halfHeight*/ ctx[10]);
			attr_dev(rect, "width", /*halfHeight*/ ctx[10]);
			attr_dev(rect, "class", "svelte-rmsnzm");
			add_location(rect, file$3, 105, 7, 2899);
			attr_dev(polyline, "points", /*chevronRightPath*/ ctx[17]);
			attr_dev(polyline, "class", "svelte-rmsnzm");
			add_location(polyline, file$3, 109, 7, 2977);
			attr_dev(g, "aria-label", "Next year not available");
			add_location(g, file$3, 104, 6, 2851);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, g, anchor);
			append_hydration_dev(g, rect);
			append_hydration_dev(g, polyline);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*halfHeight*/ 1024) {
				attr_dev(rect, "height", /*halfHeight*/ ctx[10]);
			}

			if (dirty[0] & /*halfHeight*/ 1024) {
				attr_dev(rect, "width", /*halfHeight*/ ctx[10]);
			}

			if (dirty[0] & /*chevronRightPath*/ 131072) {
				attr_dev(polyline, "points", /*chevronRightPath*/ ctx[17]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(g);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block_1.name,
		type: "else",
		source: "(104:5) {:else}",
		ctx
	});

	return block;
}

// (92:5) {#if hrefNext}
function create_if_block_5(ctx) {
	let a;
	let rect;
	let polyline;
	let a_aria_label_value;

	const block = {
		c: function create() {
			a = svg_element("a");
			rect = svg_element("rect");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			a = claim_svg_element(nodes, "a", {
				"aria-label": true,
				href: true,
				rel: true
			});

			var a_nodes = children(a);
			rect = claim_svg_element(a_nodes, "rect", { height: true, width: true, class: true });
			children(rect).forEach(detach_dev);
			polyline = claim_svg_element(a_nodes, "polyline", { points: true, class: true });
			children(polyline).forEach(detach_dev);
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "height", /*halfHeight*/ ctx[10]);
			attr_dev(rect, "width", /*halfHeight*/ ctx[10]);
			attr_dev(rect, "class", "svelte-rmsnzm");
			add_location(rect, file$3, 97, 7, 2704);
			attr_dev(polyline, "points", /*chevronRightPath*/ ctx[17]);
			attr_dev(polyline, "class", "svelte-rmsnzm");
			add_location(polyline, file$3, 101, 7, 2782);
			attr_dev(a, "aria-label", a_aria_label_value = "Show the next year (" + /*nextYear*/ ctx[6] + ")");
			attr_dev(a, "href", /*hrefNext*/ ctx[15]);
			attr_dev(a, "rel", "prefetch");
			add_location(a, file$3, 92, 6, 2589);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, a, anchor);
			append_hydration_dev(a, rect);
			append_hydration_dev(a, polyline);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*halfHeight*/ 1024) {
				attr_dev(rect, "height", /*halfHeight*/ ctx[10]);
			}

			if (dirty[0] & /*halfHeight*/ 1024) {
				attr_dev(rect, "width", /*halfHeight*/ ctx[10]);
			}

			if (dirty[0] & /*chevronRightPath*/ 131072) {
				attr_dev(polyline, "points", /*chevronRightPath*/ ctx[17]);
			}

			if (dirty[0] & /*nextYear*/ 64 && a_aria_label_value !== (a_aria_label_value = "Show the next year (" + /*nextYear*/ ctx[6] + ")")) {
				attr_dev(a, "aria-label", a_aria_label_value);
			}

			if (dirty[0] & /*hrefNext*/ 32768) {
				attr_dev(a, "href", /*hrefNext*/ ctx[15]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(92:5) {#if hrefNext}",
		ctx
	});

	return block;
}

// (124:3) {:else}
function create_else_block(ctx) {
	let if_block0_anchor;
	let if_block1_anchor;
	let if_block0 = /*availableYears*/ ctx[0] && create_if_block_3$2(ctx);
	let if_block1 = /*$_yearRange*/ ctx[24] && create_if_block_2$2(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			if_block0_anchor = empty();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block0) if_block0.l(nodes);
			if_block0_anchor = empty();
			if (if_block1) if_block1.l(nodes);
			if_block1_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration_dev(target, if_block0_anchor, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_hydration_dev(target, if_block1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (/*availableYears*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3$2(ctx);
					if_block0.c();
					if_block0.m(if_block0_anchor.parentNode, if_block0_anchor);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*$_yearRange*/ ctx[24]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2$2(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(if_block0_anchor);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(124:3) {:else}",
		ctx
	});

	return block;
}

// (117:3) {#if showLess && selectedYear}
function create_if_block_1$2(ctx) {
	let text_1;
	let t;

	const block = {
		c: function create() {
			text_1 = svg_element("text");
			t = text(/*selectedYear*/ ctx[3]);
			this.h();
		},
		l: function claim(nodes) {
			text_1 = claim_svg_element(nodes, "text", { x: true, y: true, class: true });
			var text_1_nodes = children(text_1);
			t = claim_text(text_1_nodes, /*selectedYear*/ ctx[3]);
			text_1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(text_1, "x", /*yearsCenterX*/ ctx[21]);
			attr_dev(text_1, "y", /*halfHeight*/ ctx[10]);
			attr_dev(text_1, "class", "svelte-rmsnzm");
			add_location(text_1, file$3, 118, 4, 3097);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, text_1, anchor);
			append_hydration_dev(text_1, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*selectedYear*/ 8) set_data_dev(t, /*selectedYear*/ ctx[3]);

			if (dirty[0] & /*yearsCenterX*/ 2097152) {
				attr_dev(text_1, "x", /*yearsCenterX*/ ctx[21]);
			}

			if (dirty[0] & /*halfHeight*/ 1024) {
				attr_dev(text_1, "y", /*halfHeight*/ ctx[10]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(text_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(117:3) {#if showLess && selectedYear}",
		ctx
	});

	return block;
}

// (128:4) {#if availableYears}
function create_if_block_3$2(ctx) {
	let g;
	let line;
	let g_transform_value;
	let each_value_1 = /*availableYears*/ ctx[0];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			g = svg_element("g");
			line = svg_element("line");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			g = claim_svg_element(nodes, "g", { transform: true });
			var g_nodes = children(g);
			line = claim_svg_element(g_nodes, "line", { x1: true, x2: true, class: true });
			children(line).forEach(detach_dev);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(g_nodes);
			}

			g_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line, "x1", /*lineX1*/ ctx[20]);
			attr_dev(line, "x2", /*lineX2*/ ctx[19]);
			attr_dev(line, "class", "svelte-rmsnzm");
			add_location(line, file$3, 129, 6, 3283);
			attr_dev(g, "transform", g_transform_value = "translate(0," + /*$_layout*/ ctx[14].y1 + ")");
			add_location(g, file$3, 128, 5, 3234);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, g, anchor);
			append_hydration_dev(g, line);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(g, null);
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*lineX1*/ 1048576) {
				attr_dev(line, "x1", /*lineX1*/ ctx[20]);
			}

			if (dirty[0] & /*lineX2*/ 524288) {
				attr_dev(line, "x2", /*lineX2*/ ctx[19]);
			}

			if (dirty[0] & /*availableYears, $_hrefBase, indicatorId, $_layout, selectedYear*/ 24589) {
				each_value_1 = /*availableYears*/ ctx[0];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(g, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}

			if (dirty[0] & /*$_layout*/ 16384 && g_transform_value !== (g_transform_value = "translate(0," + /*$_layout*/ ctx[14].y1 + ")")) {
				attr_dev(g, "transform", g_transform_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(g);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$2.name,
		type: "if",
		source: "(128:4) {#if availableYears}",
		ctx
	});

	return block;
}

// (134:6) {#each availableYears as year}
function create_each_block_1(ctx) {
	let a;
	let circle;
	let circle_cx_value;
	let circle_r_value;
	let a_aria_label_value;
	let a_href_value;

	const block = {
		c: function create() {
			a = svg_element("a");
			circle = svg_element("circle");
			this.h();
		},
		l: function claim(nodes) {
			a = claim_svg_element(nodes, "a", {
				"aria-label": true,
				href: true,
				rel: true
			});

			var a_nodes = children(a);
			circle = claim_svg_element(a_nodes, "circle", { cx: true, r: true, class: true });
			children(circle).forEach(detach_dev);
			a_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", circle_cx_value = /*$_layout*/ ctx[14].scaleX(/*year*/ ctx[30]));
			attr_dev(circle, "r", circle_r_value = /*$_layout*/ ctx[14].radius);
			attr_dev(circle, "class", "svelte-rmsnzm");
			toggle_class(circle, "selected", /*selectedYear*/ ctx[3] && /*selectedYear*/ ctx[3] === /*year*/ ctx[30]);
			add_location(circle, file$3, 139, 8, 3503);
			attr_dev(a, "aria-label", a_aria_label_value = /*year*/ ctx[30]);
			attr_dev(a, "href", a_href_value = makeURL(/*$_hrefBase*/ ctx[13], /*indicatorId*/ ctx[2], /*year*/ ctx[30]));
			attr_dev(a, "rel", "prefetch");
			add_location(a, file$3, 134, 7, 3380);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, a, anchor);
			append_hydration_dev(a, circle);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*$_layout, availableYears*/ 16385 && circle_cx_value !== (circle_cx_value = /*$_layout*/ ctx[14].scaleX(/*year*/ ctx[30]))) {
				attr_dev(circle, "cx", circle_cx_value);
			}

			if (dirty[0] & /*$_layout*/ 16384 && circle_r_value !== (circle_r_value = /*$_layout*/ ctx[14].radius)) {
				attr_dev(circle, "r", circle_r_value);
			}

			if (dirty[0] & /*selectedYear, availableYears*/ 9) {
				toggle_class(circle, "selected", /*selectedYear*/ ctx[3] && /*selectedYear*/ ctx[3] === /*year*/ ctx[30]);
			}

			if (dirty[0] & /*availableYears*/ 1 && a_aria_label_value !== (a_aria_label_value = /*year*/ ctx[30])) {
				attr_dev(a, "aria-label", a_aria_label_value);
			}

			if (dirty[0] & /*$_hrefBase, indicatorId, availableYears*/ 8197 && a_href_value !== (a_href_value = makeURL(/*$_hrefBase*/ ctx[13], /*indicatorId*/ ctx[2], /*year*/ ctx[30]))) {
				attr_dev(a, "href", a_href_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(a);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(134:6) {#each availableYears as year}",
		ctx
	});

	return block;
}

// (152:4) {#if $_yearRange}
function create_if_block_2$2(ctx) {
	let each_1_anchor;
	let each_value = /*$_yearRange*/ ctx[24];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(target, anchor);
			}

			insert_hydration_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*$_layout, $_yearRange, yearsY*/ 25182208) {
				each_value = /*$_yearRange*/ ctx[24];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$2.name,
		type: "if",
		source: "(152:4) {#if $_yearRange}",
		ctx
	});

	return block;
}

// (153:5) {#each $_yearRange as year}
function create_each_block(ctx) {
	let text_1;

	let t_value = (/*$_layout*/ ctx[14].doShortenYears
	? shortenYear(/*year*/ ctx[30])
	: /*year*/ ctx[30]) + "";

	let t;
	let text_1_font_size_value;
	let text_1_x_value;

	const block = {
		c: function create() {
			text_1 = svg_element("text");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			text_1 = claim_svg_element(nodes, "text", {
				"font-size": true,
				x: true,
				y: true,
				class: true
			});

			var text_1_nodes = children(text_1);
			t = claim_text(text_1_nodes, t_value);
			text_1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(text_1, "font-size", text_1_font_size_value = /*$_layout*/ ctx[14].fontSize);
			attr_dev(text_1, "x", text_1_x_value = /*$_layout*/ ctx[14].scaleX(/*year*/ ctx[30]));
			attr_dev(text_1, "y", /*yearsY*/ ctx[23]);
			attr_dev(text_1, "class", "svelte-rmsnzm");
			add_location(text_1, file$3, 153, 6, 3784);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, text_1, anchor);
			append_hydration_dev(text_1, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*$_layout, $_yearRange*/ 16793600 && t_value !== (t_value = (/*$_layout*/ ctx[14].doShortenYears
			? shortenYear(/*year*/ ctx[30])
			: /*year*/ ctx[30]) + "")) set_data_dev(t, t_value);

			if (dirty[0] & /*$_layout*/ 16384 && text_1_font_size_value !== (text_1_font_size_value = /*$_layout*/ ctx[14].fontSize)) {
				attr_dev(text_1, "font-size", text_1_font_size_value);
			}

			if (dirty[0] & /*$_layout, $_yearRange*/ 16793600 && text_1_x_value !== (text_1_x_value = /*$_layout*/ ctx[14].scaleX(/*year*/ ctx[30]))) {
				attr_dev(text_1, "x", text_1_x_value);
			}

			if (dirty[0] & /*yearsY*/ 8388608) {
				attr_dev(text_1, "y", /*yearsY*/ ctx[23]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(text_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(153:5) {#each $_yearRange as year}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let div;
	let if_block = (/*width*/ ctx[5] && /*height*/ ctx[1] && /*$_layout*/ ctx[14] || isServerSide) && create_if_block$2(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "Timeline svelte-rmsnzm");
			add_location(div, file$3, 49, 0, 1693);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
		},
		p: function update(ctx, dirty) {
			if (/*width*/ ctx[5] && /*height*/ ctx[1] && /*$_layout*/ ctx[14] || isServerSide) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					if_block.m(div, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let yearsY;
	let halfHeight;
	let buttonY;
	let prevX;
	let nextX;
	let yearsCenterX;
	let min;
	let max;
	let med;
	let lineX1;
	let lineX2;
	let chevronLeftPath;
	let chevronRightPath;
	let selectedYearIndex;
	let prevYear;
	let isPrevYearActive;
	let nextYear;
	let isNextYearActive;
	let hrefPrev;
	let hrefNext;
	let $_hrefBase;
	let $_layout;
	let $_yearRange;
	validate_store(_hrefBase, '_hrefBase');
	component_subscribe($$self, _hrefBase, $$value => $$invalidate(13, $_hrefBase = $$value));
	validate_store(_timelineLayout, '_layout');
	component_subscribe($$self, _timelineLayout, $$value => $$invalidate(14, $_layout = $$value));
	validate_store(_yearRange, '_yearRange');
	component_subscribe($$self, _yearRange, $$value => $$invalidate(24, $_yearRange = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Timeline', slots, []);
	const zeroIfNaN = when(isNaN, always(0));
	let { availableYears = null } = $$props;
	let { height = null } = $$props;
	let { indicatorId = null } = $$props;
	let { selectedYear = null } = $$props;
	let { showLess = false } = $$props;
	let { width } = $$props;
	const writable_props = ['availableYears', 'height', 'indicatorId', 'selectedYear', 'showLess', 'width'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Timeline> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('availableYears' in $$props) $$invalidate(0, availableYears = $$props.availableYears);
		if ('height' in $$props) $$invalidate(1, height = $$props.height);
		if ('indicatorId' in $$props) $$invalidate(2, indicatorId = $$props.indicatorId);
		if ('selectedYear' in $$props) $$invalidate(3, selectedYear = $$props.selectedYear);
		if ('showLess' in $$props) $$invalidate(4, showLess = $$props.showLess);
		if ('width' in $$props) $$invalidate(5, width = $$props.width);
	};

	$$self.$capture_state = () => ({
		isServerSide,
		isNotNil,
		_,
		_yearRange,
		_layout: _timelineLayout,
		_hrefBase,
		shortenYear,
		makeURL,
		zeroIfNaN,
		availableYears,
		height,
		indicatorId,
		selectedYear,
		showLess,
		width,
		nextYear,
		isNextYearActive,
		hrefNext,
		prevYear,
		isPrevYearActive,
		hrefPrev,
		selectedYearIndex,
		max,
		min,
		med,
		chevronRightPath,
		chevronLeftPath,
		lineX2,
		lineX1,
		halfHeight,
		nextX,
		yearsCenterX,
		buttonY,
		prevX,
		yearsY,
		$_hrefBase,
		$_layout,
		$_yearRange
	});

	$$self.$inject_state = $$props => {
		if ('availableYears' in $$props) $$invalidate(0, availableYears = $$props.availableYears);
		if ('height' in $$props) $$invalidate(1, height = $$props.height);
		if ('indicatorId' in $$props) $$invalidate(2, indicatorId = $$props.indicatorId);
		if ('selectedYear' in $$props) $$invalidate(3, selectedYear = $$props.selectedYear);
		if ('showLess' in $$props) $$invalidate(4, showLess = $$props.showLess);
		if ('width' in $$props) $$invalidate(5, width = $$props.width);
		if ('nextYear' in $$props) $$invalidate(6, nextYear = $$props.nextYear);
		if ('isNextYearActive' in $$props) $$invalidate(7, isNextYearActive = $$props.isNextYearActive);
		if ('hrefNext' in $$props) $$invalidate(15, hrefNext = $$props.hrefNext);
		if ('prevYear' in $$props) $$invalidate(8, prevYear = $$props.prevYear);
		if ('isPrevYearActive' in $$props) $$invalidate(9, isPrevYearActive = $$props.isPrevYearActive);
		if ('hrefPrev' in $$props) $$invalidate(16, hrefPrev = $$props.hrefPrev);
		if ('selectedYearIndex' in $$props) $$invalidate(25, selectedYearIndex = $$props.selectedYearIndex);
		if ('max' in $$props) $$invalidate(26, max = $$props.max);
		if ('min' in $$props) $$invalidate(27, min = $$props.min);
		if ('med' in $$props) $$invalidate(28, med = $$props.med);
		if ('chevronRightPath' in $$props) $$invalidate(17, chevronRightPath = $$props.chevronRightPath);
		if ('chevronLeftPath' in $$props) $$invalidate(18, chevronLeftPath = $$props.chevronLeftPath);
		if ('lineX2' in $$props) $$invalidate(19, lineX2 = $$props.lineX2);
		if ('lineX1' in $$props) $$invalidate(20, lineX1 = $$props.lineX1);
		if ('halfHeight' in $$props) $$invalidate(10, halfHeight = $$props.halfHeight);
		if ('nextX' in $$props) $$invalidate(11, nextX = $$props.nextX);
		if ('yearsCenterX' in $$props) $$invalidate(21, yearsCenterX = $$props.yearsCenterX);
		if ('buttonY' in $$props) $$invalidate(12, buttonY = $$props.buttonY);
		if ('prevX' in $$props) $$invalidate(22, prevX = $$props.prevX);
		if ('yearsY' in $$props) $$invalidate(23, yearsY = $$props.yearsY);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*availableYears, $_layout*/ 16385) {
			$$invalidate(23, yearsY = availableYears?.length > 0 ? $_layout.y2 : $_layout.ym);
		}

		if ($$self.$$.dirty[0] & /*$_layout*/ 16384) {
			/* buttons */
			$$invalidate(10, halfHeight = $_layout.height / 2);
		}

		if ($$self.$$.dirty[0] & /*halfHeight*/ 1024) {
			$$invalidate(12, buttonY = halfHeight / 2);
		}

		if ($$self.$$.dirty[0] & /*buttonY*/ 4096) {
			$$invalidate(22, prevX = buttonY);
		}

		if ($$self.$$.dirty[0] & /*buttonY, halfHeight*/ 5120) {
			$$invalidate(11, nextX = buttonY + halfHeight + 0.25 * buttonY);
		}

		if ($$self.$$.dirty[0] & /*nextX, halfHeight, width*/ 3104) {
			$$invalidate(21, yearsCenterX = (nextX + halfHeight + width) / 2);
		}

		if ($$self.$$.dirty[0] & /*halfHeight*/ 1024) {
			$$invalidate(27, min = halfHeight / 3);
		}

		if ($$self.$$.dirty[0] & /*min*/ 134217728) {
			$$invalidate(26, max = 2 * min);
		}

		if ($$self.$$.dirty[0] & /*halfHeight*/ 1024) {
			$$invalidate(28, med = halfHeight / 2);
		}

		if ($$self.$$.dirty[0] & /*$_layout, availableYears*/ 16385) {
			$$invalidate(20, lineX1 = zeroIfNaN($_layout.scaleX(availableYears[0]) + $_layout.radius));
		}

		if ($$self.$$.dirty[0] & /*$_layout, availableYears*/ 16385) {
			$$invalidate(19, lineX2 = zeroIfNaN($_layout.scaleX(last(availableYears)) - $_layout.radius));
		}

		if ($$self.$$.dirty[0] & /*max, min, med*/ 469762048) {
			$$invalidate(18, chevronLeftPath = `${max} ${min} ${min} ${med} ${max} ${max}`);
		}

		if ($$self.$$.dirty[0] & /*min, max, med*/ 469762048) {
			$$invalidate(17, chevronRightPath = `${min} ${min} ${max} ${med} ${min} ${max}`);
		}

		if ($$self.$$.dirty[0] & /*availableYears, selectedYear*/ 9) {
			$$invalidate(25, selectedYearIndex = findIndex(availableYears, is(selectedYear)));
		}

		if ($$self.$$.dirty[0] & /*availableYears, selectedYearIndex*/ 33554433) {
			$$invalidate(8, prevYear = availableYears[selectedYearIndex - 1]);
		}

		if ($$self.$$.dirty[0] & /*prevYear*/ 256) {
			$$invalidate(9, isPrevYearActive = isNotNil(prevYear));
		}

		if ($$self.$$.dirty[0] & /*availableYears, selectedYearIndex*/ 33554433) {
			$$invalidate(6, nextYear = availableYears[selectedYearIndex + 1]);
		}

		if ($$self.$$.dirty[0] & /*nextYear*/ 64) {
			$$invalidate(7, isNextYearActive = isNotNil(nextYear));
		}

		if ($$self.$$.dirty[0] & /*isPrevYearActive, $_hrefBase, indicatorId, prevYear*/ 8964) {
			$$invalidate(16, hrefPrev = isPrevYearActive
			? makeURL($_hrefBase, indicatorId, prevYear)
			: null);
		}

		if ($$self.$$.dirty[0] & /*isNextYearActive, $_hrefBase, indicatorId, nextYear*/ 8388) {
			$$invalidate(15, hrefNext = isNextYearActive
			? makeURL($_hrefBase, indicatorId, nextYear)
			: null);
		}
	};

	return [
		availableYears,
		height,
		indicatorId,
		selectedYear,
		showLess,
		width,
		nextYear,
		isNextYearActive,
		prevYear,
		isPrevYearActive,
		halfHeight,
		nextX,
		buttonY,
		$_hrefBase,
		$_layout,
		hrefNext,
		hrefPrev,
		chevronRightPath,
		chevronLeftPath,
		lineX2,
		lineX1,
		yearsCenterX,
		prevX,
		yearsY,
		$_yearRange,
		selectedYearIndex,
		max,
		min,
		med
	];
}

class Timeline extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$3,
			create_fragment$3,
			safe_not_equal,
			{
				availableYears: 0,
				height: 1,
				indicatorId: 2,
				selectedYear: 3,
				showLess: 4,
				width: 5
			},
			null,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Timeline",
			options,
			id: create_fragment$3.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*width*/ ctx[5] === undefined && !('width' in props)) {
			console.warn("<Timeline> was created without expected prop 'width'");
		}
	}

	get availableYears() {
		throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set availableYears(value) {
		throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get height() {
		throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get indicatorId() {
		throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set indicatorId(value) {
		throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selectedYear() {
		throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selectedYear(value) {
		throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get showLess() {
		throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showLess(value) {
		throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<Timeline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<Timeline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* ../../components/time_region_value/src/node_modules/components/ViewSelector.svelte generated by Svelte v3.44.2 */
const file$2 = "../../components/time_region_value/src/node_modules/components/ViewSelector.svelte";

// (57:27) 
function create_if_block_3$1(ctx) {
	let div0;
	let icon0;
	let t;
	let div1;
	let icon1;
	let current;
	let mounted;
	let dispose;

	icon0 = new Icon({
			props: {
				glyph: MapPin,
				stroke: /*strokes*/ ctx[3].map
			},
			$$inline: true
		});

	icon1 = new Icon({
			props: {
				glyph: BarChart,
				stroke: /*strokes*/ ctx[3].barchart
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div0 = element("div");
			create_component(icon0.$$.fragment);
			t = space();
			div1 = element("div");
			create_component(icon1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(icon0.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(icon1.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "button clickable svelte-ghla19");
			add_location(div0, file$2, 57, 2, 1407);
			attr_dev(div1, "class", "button clickable rotated svelte-ghla19");
			add_location(div1, file$2, 66, 2, 1544);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div0, anchor);
			mount_component(icon0, div0, null);
			insert_hydration_dev(target, t, anchor);
			insert_hydration_dev(target, div1, anchor);
			mount_component(icon1, div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(
						div0,
						"click",
						function () {
							if (is_function(/*showView*/ ctx[2]('map'))) /*showView*/ ctx[2]('map').apply(this, arguments);
						},
						false,
						false,
						false
					),
					listen_dev(
						div1,
						"click",
						function () {
							if (is_function(/*showView*/ ctx[2]('barchart'))) /*showView*/ ctx[2]('barchart').apply(this, arguments);
						},
						false,
						false,
						false
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const icon0_changes = {};
			if (dirty & /*strokes*/ 8) icon0_changes.stroke = /*strokes*/ ctx[3].map;
			icon0.$set(icon0_changes);
			const icon1_changes = {};
			if (dirty & /*strokes*/ 8) icon1_changes.stroke = /*strokes*/ ctx[3].barchart;
			icon1.$set(icon1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon0.$$.fragment, local);
			transition_in(icon1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon0.$$.fragment, local);
			transition_out(icon1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			destroy_component(icon0);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(div1);
			destroy_component(icon1);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$1.name,
		type: "if",
		source: "(57:27) ",
		ctx
	});

	return block;
}

// (47:23) 
function create_if_block_2$1(ctx) {
	let div;
	let icon;
	let current;
	let mounted;
	let dispose;

	icon = new Icon({
			props: {
				glyph: Activity,
				stroke: /*strokes*/ ctx[3].trends
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(icon.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(icon.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "button clickable svelte-ghla19");
			add_location(div, file$2, 47, 2, 1234);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			mount_component(icon, div, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(
					div,
					"click",
					function () {
						if (is_function(/*showView*/ ctx[2]('trends'))) /*showView*/ ctx[2]('trends').apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const icon_changes = {};
			if (dirty & /*strokes*/ 8) icon_changes.stroke = /*strokes*/ ctx[3].trends;
			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(icon);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(47:23) ",
		ctx
	});

	return block;
}

// (37:1) {#if $_routes.Index}
function create_if_block_1$1(ctx) {
	let div;
	let icon;
	let current;
	let mounted;
	let dispose;

	icon = new Icon({
			props: {
				glyph: Clock,
				stroke: /*strokes*/ ctx[3].distribution
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(icon.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(icon.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "button clickable svelte-ghla19");
			add_location(div, file$2, 37, 2, 1056);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			mount_component(icon, div, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(
					div,
					"click",
					function () {
						if (is_function(/*showView*/ ctx[2]('distribution'))) /*showView*/ ctx[2]('distribution').apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const icon_changes = {};
			if (dirty & /*strokes*/ 8) icon_changes.stroke = /*strokes*/ ctx[3].distribution;
			icon.$set(icon_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(icon);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(37:1) {#if $_routes.Index}",
		ctx
	});

	return block;
}

// (78:1) {#if $_routes.Id || $_routes.IdYear}
function create_if_block$1(ctx) {
	let div0;
	let icon0;
	let t;
	let div1;
	let icon1;
	let current;
	let mounted;
	let dispose;

	icon0 = new Icon({
			props: {
				glyph: Info,
				stroke: /*strokes*/ ctx[3].info
			},
			$$inline: true
		});

	icon1 = new Icon({
			props: {
				glyph: Settings,
				stroke: /*strokes*/ ctx[3].settings
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div0 = element("div");
			create_component(icon0.$$.fragment);
			t = space();
			div1 = element("div");
			create_component(icon1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div0 = claim_element(nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(icon0.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			claim_component(icon1.$$.fragment, div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "button clickable svelte-ghla19");
			add_location(div0, file$2, 78, 2, 1747);
			attr_dev(div1, "class", "button clickable svelte-ghla19");
			add_location(div1, file$2, 87, 2, 1891);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div0, anchor);
			mount_component(icon0, div0, null);
			insert_hydration_dev(target, t, anchor);
			insert_hydration_dev(target, div1, anchor);
			mount_component(icon1, div1, null);
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(
						div0,
						"click",
						function () {
							if (is_function(/*showView*/ ctx[2]('info'))) /*showView*/ ctx[2]('info').apply(this, arguments);
						},
						false,
						false,
						false
					),
					listen_dev(
						div1,
						"click",
						function () {
							if (is_function(/*showView*/ ctx[2]('settings'))) /*showView*/ ctx[2]('settings').apply(this, arguments);
						},
						false,
						false,
						false
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;
			const icon0_changes = {};
			if (dirty & /*strokes*/ 8) icon0_changes.stroke = /*strokes*/ ctx[3].info;
			icon0.$set(icon0_changes);
			const icon1_changes = {};
			if (dirty & /*strokes*/ 8) icon1_changes.stroke = /*strokes*/ ctx[3].settings;
			icon1.$set(icon1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon0.$$.fragment, local);
			transition_in(icon1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon0.$$.fragment, local);
			transition_out(icon1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div0);
			destroy_component(icon0);
			if (detaching) detach_dev(t);
			if (detaching) detach_dev(div1);
			destroy_component(icon1);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(78:1) {#if $_routes.Id || $_routes.IdYear}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let nav;
	let div;
	let icon;
	let t0;
	let current_block_type_index;
	let if_block0;
	let t1;
	let current;
	let mounted;
	let dispose;

	icon = new Icon({
			props: {
				glyph: List,
				stroke: /*strokes*/ ctx[3].sidebar
			},
			$$inline: true
		});

	const if_block_creators = [create_if_block_1$1, create_if_block_2$1, create_if_block_3$1];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*$_routes*/ ctx[4].Index) return 0;
		if (/*$_routes*/ ctx[4].Id) return 1;
		if (/*$_routes*/ ctx[4].IdYear) return 2;
		return -1;
	}

	if (~(current_block_type_index = select_block_type(ctx))) {
		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	let if_block1 = (/*$_routes*/ ctx[4].Id || /*$_routes*/ ctx[4].IdYear) && create_if_block$1(ctx);

	const block = {
		c: function create() {
			nav = element("nav");
			div = element("div");
			create_component(icon.$$.fragment);
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", { class: true });
			var nav_nodes = children(nav);
			div = claim_element(nav_nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(icon.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			t0 = claim_space(nav_nodes);
			if (if_block0) if_block0.l(nav_nodes);
			t1 = claim_space(nav_nodes);
			if (if_block1) if_block1.l(nav_nodes);
			nav_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "button clickable svelte-ghla19");
			add_location(div, file$2, 26, 1, 898);
			attr_dev(nav, "class", "ViewSelector svelte-ghla19");
			toggle_class(nav, "id", /*$_routes*/ ctx[4].Id);
			toggle_class(nav, "year", /*$_routes*/ ctx[4].IdYear);
			add_location(nav, file$2, 21, 0, 814);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, nav, anchor);
			append_hydration_dev(nav, div);
			mount_component(icon, div, null);
			append_hydration_dev(nav, t0);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(nav, null);
			}

			append_hydration_dev(nav, t1);
			if (if_block1) if_block1.m(nav, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(
					div,
					"click",
					function () {
						if (is_function(/*showView*/ ctx[2]('sidebar'))) /*showView*/ ctx[2]('sidebar').apply(this, arguments);
					},
					false,
					false,
					false
				);

				mounted = true;
			}
		},
		p: function update(new_ctx, [dirty]) {
			ctx = new_ctx;
			const icon_changes = {};
			if (dirty & /*strokes*/ 8) icon_changes.stroke = /*strokes*/ ctx[3].sidebar;
			icon.$set(icon_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block0) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block0 = if_blocks[current_block_type_index];

					if (!if_block0) {
						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block0.c();
					} else {
						if_block0.p(ctx, dirty);
					}

					transition_in(if_block0, 1);
					if_block0.m(nav, t1);
				} else {
					if_block0 = null;
				}
			}

			if (/*$_routes*/ ctx[4].Id || /*$_routes*/ ctx[4].IdYear) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*$_routes*/ 16) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$1(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(nav, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (dirty & /*$_routes*/ 16) {
				toggle_class(nav, "id", /*$_routes*/ ctx[4].Id);
			}

			if (dirty & /*$_routes*/ 16) {
				toggle_class(nav, "year", /*$_routes*/ ctx[4].IdYear);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			destroy_component(icon);

			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d();
			}

			if (if_block1) if_block1.d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let strokes;

	let $_views,
		$$unsubscribe__views = noop,
		$$subscribe__views = () => ($$unsubscribe__views(), $$unsubscribe__views = subscribe(_views, $$value => $$invalidate(5, $_views = $$value)), _views);

	let $_routes,
		$$unsubscribe__routes = noop,
		$$subscribe__routes = () => ($$unsubscribe__routes(), $$unsubscribe__routes = subscribe(_routes, $$value => $$invalidate(4, $_routes = $$value)), _routes);

	$$self.$$.on_destroy.push(() => $$unsubscribe__views());
	$$self.$$.on_destroy.push(() => $$unsubscribe__routes());
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ViewSelector', slots, []);
	const makeStrokes = mapValuesWith(truthynessTo(['black', 'grey']));
	let { _routes = null } = $$props;
	validate_store(_routes, '_routes');
	$$subscribe__routes();
	let { _views = null } = $$props;
	validate_store(_views, '_views');
	$$subscribe__views();
	let { showView = null } = $$props;
	const writable_props = ['_routes', '_views', 'showView'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ViewSelector> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('_routes' in $$props) $$subscribe__routes($$invalidate(0, _routes = $$props._routes));
		if ('_views' in $$props) $$subscribe__views($$invalidate(1, _views = $$props._views));
		if ('showView' in $$props) $$invalidate(2, showView = $$props.showView);
	};

	$$self.$capture_state = () => ({
		_,
		truthynessTo,
		Icon,
		Activity,
		BarChart,
		Clock,
		Info,
		List,
		MapPin,
		Settings,
		makeStrokes,
		_routes,
		_views,
		showView,
		strokes,
		$_views,
		$_routes
	});

	$$self.$inject_state = $$props => {
		if ('_routes' in $$props) $$subscribe__routes($$invalidate(0, _routes = $$props._routes));
		if ('_views' in $$props) $$subscribe__views($$invalidate(1, _views = $$props._views));
		if ('showView' in $$props) $$invalidate(2, showView = $$props.showView);
		if ('strokes' in $$props) $$invalidate(3, strokes = $$props.strokes);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$_views*/ 32) {
			$$invalidate(3, strokes = makeStrokes($_views));
		}
	};

	return [_routes, _views, showView, strokes, $_routes, $_views];
}

class ViewSelector extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { _routes: 0, _views: 1, showView: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ViewSelector",
			options,
			id: create_fragment$2.name
		});
	}

	get _routes() {
		throw new Error("<ViewSelector>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set _routes(value) {
		throw new Error("<ViewSelector>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get _views() {
		throw new Error("<ViewSelector>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set _views(value) {
		throw new Error("<ViewSelector>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get showView() {
		throw new Error("<ViewSelector>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set showView(value) {
		throw new Error("<ViewSelector>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* ../../components/time_region_value/src/routes/_layout.svelte generated by Svelte v3.44.2 */
const file$1 = "../../components/time_region_value/src/routes/_layout.svelte";

// (68:0) {#if $_screenClasses || isServerSide}
function create_if_block_1(ctx) {
	let section1;
	let div2;
	let div0;
	let sidebar;
	let t0;
	let div1;
	let section0;
	let t1;
	let div1_resize_listener;
	let div2_class_value;
	let t2;
	let section1_class_value;
	let current;

	sidebar = new Sidebar({
			props: {
				_groups: /*_groups*/ ctx[0],
				currentId: /*segment*/ ctx[1]
			},
			$$inline: true
		});

	const default_slot_template = /*#slots*/ ctx[22].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);
	let if_block0 = !/*$_isTimelineHidden*/ ctx[8] && create_if_block_3(ctx);
	let if_block1 = /*$_isSmallScreen*/ ctx[2] && create_if_block_2(ctx);

	const block = {
		c: function create() {
			section1 = element("section");
			div2 = element("div");
			div0 = element("div");
			create_component(sidebar.$$.fragment);
			t0 = space();
			div1 = element("div");
			section0 = element("section");
			if (default_slot) default_slot.c();
			t1 = space();
			if (if_block0) if_block0.c();
			t2 = space();
			if (if_block1) if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			section1 = claim_element(nodes, "SECTION", { class: true, style: true });
			var section1_nodes = children(section1);
			div2 = claim_element(section1_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			div0 = claim_element(div2_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(sidebar.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t0 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			section0 = claim_element(div1_nodes, "SECTION", { class: true });
			var section0_nodes = children(section0);
			if (default_slot) default_slot.l(section0_nodes);
			section0_nodes.forEach(detach_dev);
			t1 = claim_space(div1_nodes);
			if (if_block0) if_block0.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			t2 = claim_space(section1_nodes);
			if (if_block1) if_block1.l(section1_nodes);
			section1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "sidebar svelte-dclfdu");
			add_location(div0, file$1, 78, 3, 2583);
			attr_dev(section0, "class", "svelte-dclfdu");
			add_location(section0, file$1, 89, 4, 2799);
			attr_dev(div1, "class", "content svelte-dclfdu");
			add_render_callback(() => /*div1_elementresize_handler*/ ctx[24].call(div1));
			toggle_class(div1, "isTimelineHidden", /*$_isTimelineHidden*/ ctx[8]);
			add_location(div1, file$1, 84, 3, 2678);
			attr_dev(div2, "class", div2_class_value = "viewport " + /*$_viewsClasses*/ ctx[7] + " svelte-dclfdu");
			toggle_class(div2, "routeId", /*routeId*/ ctx[4]);
			toggle_class(div2, "routeIdYear", /*routeIdYear*/ ctx[3]);
			add_location(div2, file$1, 73, 2, 2496);
			attr_dev(section1, "class", section1_class_value = "time_region_value_layout " + /*$_screenClasses*/ ctx[5] + " svelte-dclfdu");
			attr_dev(section1, "style", /*$_style*/ ctx[6]);
			toggle_class(section1, "hidden", !/*$_screenClasses*/ ctx[5]);
			add_location(section1, file$1, 68, 1, 2377);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, section1, anchor);
			append_hydration_dev(section1, div2);
			append_hydration_dev(div2, div0);
			mount_component(sidebar, div0, null);
			append_hydration_dev(div2, t0);
			append_hydration_dev(div2, div1);
			append_hydration_dev(div1, section0);

			if (default_slot) {
				default_slot.m(section0, null);
			}

			append_hydration_dev(div1, t1);
			if (if_block0) if_block0.m(div1, null);
			div1_resize_listener = add_resize_listener(div1, /*div1_elementresize_handler*/ ctx[24].bind(div1));
			append_hydration_dev(section1, t2);
			if (if_block1) if_block1.m(section1, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const sidebar_changes = {};
			if (dirty & /*_groups*/ 1) sidebar_changes._groups = /*_groups*/ ctx[0];
			if (dirty & /*segment*/ 2) sidebar_changes.currentId = /*segment*/ ctx[1];
			sidebar.$set(sidebar_changes);

			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2097152)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[21],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[21])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[21], dirty, null),
						null
					);
				}
			}

			if (!/*$_isTimelineHidden*/ ctx[8]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*$_isTimelineHidden*/ 256) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(div1, null);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (dirty & /*$_isTimelineHidden*/ 256) {
				toggle_class(div1, "isTimelineHidden", /*$_isTimelineHidden*/ ctx[8]);
			}

			if (!current || dirty & /*$_viewsClasses*/ 128 && div2_class_value !== (div2_class_value = "viewport " + /*$_viewsClasses*/ ctx[7] + " svelte-dclfdu")) {
				attr_dev(div2, "class", div2_class_value);
			}

			if (dirty & /*$_viewsClasses, routeId*/ 144) {
				toggle_class(div2, "routeId", /*routeId*/ ctx[4]);
			}

			if (dirty & /*$_viewsClasses, routeIdYear*/ 136) {
				toggle_class(div2, "routeIdYear", /*routeIdYear*/ ctx[3]);
			}

			if (/*$_isSmallScreen*/ ctx[2]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*$_isSmallScreen*/ 4) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(section1, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*$_screenClasses*/ 32 && section1_class_value !== (section1_class_value = "time_region_value_layout " + /*$_screenClasses*/ ctx[5] + " svelte-dclfdu")) {
				attr_dev(section1, "class", section1_class_value);
			}

			if (!current || dirty & /*$_style*/ 64) {
				attr_dev(section1, "style", /*$_style*/ ctx[6]);
			}

			if (dirty & /*$_screenClasses, $_screenClasses*/ 32) {
				toggle_class(section1, "hidden", !/*$_screenClasses*/ ctx[5]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(sidebar.$$.fragment, local);
			transition_in(default_slot, local);
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(sidebar.$$.fragment, local);
			transition_out(default_slot, local);
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(section1);
			destroy_component(sidebar);
			if (default_slot) default_slot.d(detaching);
			if (if_block0) if_block0.d();
			div1_resize_listener();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(68:0) {#if $_screenClasses || isServerSide}",
		ctx
	});

	return block;
}

// (93:4) {#if !$_isTimelineHidden}
function create_if_block_3(ctx) {
	let nav;
	let timeline;
	let nav_resize_listener;
	let current;

	timeline = new Timeline({
			props: {
				availableYears: /*$_availableYears*/ ctx[11],
				height: /*$_timelineHeight*/ ctx[10],
				indicatorId: /*segment*/ ctx[1],
				selectedYear: /*$_selectedYear*/ ctx[12],
				showLess: /*$_isSmallScreen*/ ctx[2],
				width: /*$_timelineWidth*/ ctx[9]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			nav = element("nav");
			create_component(timeline.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			nav = claim_element(nodes, "NAV", { class: true });
			var nav_nodes = children(nav);
			claim_component(timeline.$$.fragment, nav_nodes);
			nav_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(nav, "class", "svelte-dclfdu");
			add_render_callback(() => /*nav_elementresize_handler*/ ctx[23].call(nav));
			add_location(nav, file$1, 93, 5, 2873);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, nav, anchor);
			mount_component(timeline, nav, null);
			nav_resize_listener = add_resize_listener(nav, /*nav_elementresize_handler*/ ctx[23].bind(nav));
			current = true;
		},
		p: function update(ctx, dirty) {
			const timeline_changes = {};
			if (dirty & /*$_availableYears*/ 2048) timeline_changes.availableYears = /*$_availableYears*/ ctx[11];
			if (dirty & /*$_timelineHeight*/ 1024) timeline_changes.height = /*$_timelineHeight*/ ctx[10];
			if (dirty & /*segment*/ 2) timeline_changes.indicatorId = /*segment*/ ctx[1];
			if (dirty & /*$_selectedYear*/ 4096) timeline_changes.selectedYear = /*$_selectedYear*/ ctx[12];
			if (dirty & /*$_isSmallScreen*/ 4) timeline_changes.showLess = /*$_isSmallScreen*/ ctx[2];
			if (dirty & /*$_timelineWidth*/ 512) timeline_changes.width = /*$_timelineWidth*/ ctx[9];
			timeline.$set(timeline_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(timeline.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(timeline.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(nav);
			destroy_component(timeline);
			nav_resize_listener();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(93:4) {#if !$_isTimelineHidden}",
		ctx
	});

	return block;
}

// (110:2) {#if $_isSmallScreen}
function create_if_block_2(ctx) {
	let viewselector;
	let current;

	viewselector = new ViewSelector({
			props: { _routes, _views, showView },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(viewselector.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(viewselector.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(viewselector, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(viewselector.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(viewselector.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(viewselector, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(110:2) {#if $_isSmallScreen}",
		ctx
	});

	return block;
}

// (120:0) {#if !$_screenClasses}
function create_if_block(ctx) {
	let loadingview;
	let current;

	loadingview = new LoadingView({
			props: { stroke: /*$_theme*/ ctx[13].colorMain },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(loadingview.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(loadingview.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(loadingview, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const loadingview_changes = {};
			if (dirty & /*$_theme*/ 8192) loadingview_changes.stroke = /*$_theme*/ ctx[13].colorMain;
			loadingview.$set(loadingview_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(loadingview.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(loadingview.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(loadingview, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(120:0) {#if !$_screenClasses}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let screensensor;
	let t0;
	let t1;
	let if_block1_anchor;
	let current;
	screensensor = new ScreenSensor({ $$inline: true });
	let if_block0 = (/*$_screenClasses*/ ctx[5] || isServerSide) && create_if_block_1(ctx);
	let if_block1 = !/*$_screenClasses*/ ctx[5] && create_if_block(ctx);

	const block = {
		c: function create() {
			create_component(screensensor.$$.fragment);
			t0 = space();
			if (if_block0) if_block0.c();
			t1 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		l: function claim(nodes) {
			claim_component(screensensor.$$.fragment, nodes);
			t0 = claim_space(nodes);
			if (if_block0) if_block0.l(nodes);
			t1 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			if_block1_anchor = empty();
		},
		m: function mount(target, anchor) {
			mount_component(screensensor, target, anchor);
			insert_hydration_dev(target, t0, anchor);
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration_dev(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_hydration_dev(target, if_block1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*$_screenClasses*/ ctx[5] || isServerSide) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty & /*$_screenClasses*/ 32) {
						transition_in(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_1(ctx);
					if_block0.c();
					transition_in(if_block0, 1);
					if_block0.m(t1.parentNode, t1);
				}
			} else if (if_block0) {
				group_outros();

				transition_out(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (!/*$_screenClasses*/ ctx[5]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*$_screenClasses*/ 32) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(screensensor.$$.fragment, local);
			transition_in(if_block0);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(screensensor.$$.fragment, local);
			transition_out(if_block0);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(screensensor, detaching);
			if (detaching) detach_dev(t0);
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t1);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let routeId;
	let routeIdYear;
	let $_routes;
	let $_isSmallScreen;

	let $_groups,
		$$unsubscribe__groups = noop,
		$$subscribe__groups = () => ($$unsubscribe__groups(), $$unsubscribe__groups = subscribe(_groups, $$value => $$invalidate(20, $_groups = $$value)), _groups);

	let $_screenClasses;
	let $_style;
	let $_viewsClasses;
	let $_isTimelineHidden;
	let $_timelineWidth;
	let $_timelineHeight;
	let $_availableYears;
	let $_selectedYear;
	let $_theme;
	validate_store(_routes, '_routes');
	component_subscribe($$self, _routes, $$value => $$invalidate(19, $_routes = $$value));
	validate_store(_isSmallScreen, '_isSmallScreen');
	component_subscribe($$self, _isSmallScreen, $$value => $$invalidate(2, $_isSmallScreen = $$value));
	validate_store(_screenClasses, '_screenClasses');
	component_subscribe($$self, _screenClasses, $$value => $$invalidate(5, $_screenClasses = $$value));
	validate_store(_style, '_style');
	component_subscribe($$self, _style, $$value => $$invalidate(6, $_style = $$value));
	validate_store(_viewsClasses, '_viewsClasses');
	component_subscribe($$self, _viewsClasses, $$value => $$invalidate(7, $_viewsClasses = $$value));
	validate_store(_isTimelineHidden, '_isTimelineHidden');
	component_subscribe($$self, _isTimelineHidden, $$value => $$invalidate(8, $_isTimelineHidden = $$value));
	validate_store(_timelineWidth, '_timelineWidth');
	component_subscribe($$self, _timelineWidth, $$value => $$invalidate(9, $_timelineWidth = $$value));
	validate_store(_timelineHeight, '_timelineHeight');
	component_subscribe($$self, _timelineHeight, $$value => $$invalidate(10, $_timelineHeight = $$value));
	validate_store(_availableYears, '_availableYears');
	component_subscribe($$self, _availableYears, $$value => $$invalidate(11, $_availableYears = $$value));
	validate_store(_selectedYear, '_selectedYear');
	component_subscribe($$self, _selectedYear, $$value => $$invalidate(12, $_selectedYear = $$value));
	validate_store(_theme, '_theme');
	component_subscribe($$self, _theme, $$value => $$invalidate(13, $_theme = $$value));
	$$self.$$.on_destroy.push(() => $$unsubscribe__groups());
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Layout', slots, ['default']);
	let { _groups = null } = $$props;
	validate_store(_groups, '_groups');
	$$subscribe__groups();
	let { flags = null } = $$props;
	let { hrefBase = '' } = $$props;
	let { POIs = null } = $$props;
	let { regionSettings = null } = $$props;
	let { segment = null } = $$props;
	let { theme = null } = $$props;
	const writable_props = ['_groups', 'flags', 'hrefBase', 'POIs', 'regionSettings', 'segment', 'theme'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Layout> was created with unknown prop '${key}'`);
	});

	function nav_elementresize_handler() {
		$_timelineHeight = this.clientHeight;
		_timelineHeight.set($_timelineHeight);
	}

	function div1_elementresize_handler() {
		$_timelineWidth = this.clientWidth;
		_timelineWidth.set($_timelineWidth);
	}

	$$self.$$set = $$props => {
		if ('_groups' in $$props) $$subscribe__groups($$invalidate(0, _groups = $$props._groups));
		if ('flags' in $$props) $$invalidate(14, flags = $$props.flags);
		if ('hrefBase' in $$props) $$invalidate(15, hrefBase = $$props.hrefBase);
		if ('POIs' in $$props) $$invalidate(16, POIs = $$props.POIs);
		if ('regionSettings' in $$props) $$invalidate(17, regionSettings = $$props.regionSettings);
		if ('segment' in $$props) $$invalidate(1, segment = $$props.segment);
		if ('theme' in $$props) $$invalidate(18, theme = $$props.theme);
		if ('$$scope' in $$props) $$invalidate(21, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		LoadingView,
		ScreenSensor,
		isServerSide,
		Sidebar,
		Timeline,
		ViewSelector,
		setGroups,
		_availableYears,
		_isSmallScreen,
		_screenClasses,
		_timelineHeight,
		_timelineWidth,
		_hrefBase,
		_isTimelineHidden,
		_navFlags,
		_routes,
		_views,
		_viewsClasses,
		showView,
		_POIs,
		_regionSettings,
		_selectedYear,
		_style,
		_theme,
		customizeTheme,
		_groups,
		flags,
		hrefBase,
		POIs,
		regionSettings,
		segment,
		theme,
		routeIdYear,
		routeId,
		$_routes,
		$_isSmallScreen,
		$_groups,
		$_screenClasses,
		$_style,
		$_viewsClasses,
		$_isTimelineHidden,
		$_timelineWidth,
		$_timelineHeight,
		$_availableYears,
		$_selectedYear,
		$_theme
	});

	$$self.$inject_state = $$props => {
		if ('_groups' in $$props) $$subscribe__groups($$invalidate(0, _groups = $$props._groups));
		if ('flags' in $$props) $$invalidate(14, flags = $$props.flags);
		if ('hrefBase' in $$props) $$invalidate(15, hrefBase = $$props.hrefBase);
		if ('POIs' in $$props) $$invalidate(16, POIs = $$props.POIs);
		if ('regionSettings' in $$props) $$invalidate(17, regionSettings = $$props.regionSettings);
		if ('segment' in $$props) $$invalidate(1, segment = $$props.segment);
		if ('theme' in $$props) $$invalidate(18, theme = $$props.theme);
		if ('routeIdYear' in $$props) $$invalidate(3, routeIdYear = $$props.routeIdYear);
		if ('routeId' in $$props) $$invalidate(4, routeId = $$props.routeId);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*_groups, $_groups*/ 1048577) {
			_groups && setGroups($_groups);
		}

		if ($$self.$$.dirty & /*flags*/ 16384) {
			flags && _navFlags.set(flags);
		}

		if ($$self.$$.dirty & /*hrefBase*/ 32768) {
			hrefBase && _hrefBase.set(hrefBase);
		}

		if ($$self.$$.dirty & /*POIs*/ 65536) {
			POIs && _POIs.set(POIs);
		}

		if ($$self.$$.dirty & /*regionSettings*/ 131072) {
			regionSettings && _regionSettings.set(regionSettings);
		}

		if ($$self.$$.dirty & /*theme*/ 262144) {
			theme && customizeTheme(theme);
		}

		if ($$self.$$.dirty & /*$_isSmallScreen, $_routes*/ 524292) {
			$$invalidate(4, routeId = $_isSmallScreen && $_routes.Id);
		}

		if ($$self.$$.dirty & /*$_isSmallScreen, $_routes*/ 524292) {
			$$invalidate(3, routeIdYear = $_isSmallScreen && $_routes.IdYear);
		}
	};

	return [
		_groups,
		segment,
		$_isSmallScreen,
		routeIdYear,
		routeId,
		$_screenClasses,
		$_style,
		$_viewsClasses,
		$_isTimelineHidden,
		$_timelineWidth,
		$_timelineHeight,
		$_availableYears,
		$_selectedYear,
		$_theme,
		flags,
		hrefBase,
		POIs,
		regionSettings,
		theme,
		$_routes,
		$_groups,
		$$scope,
		slots,
		nav_elementresize_handler,
		div1_elementresize_handler
	];
}

class Layout extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$1, create_fragment$1, safe_not_equal, {
			_groups: 0,
			flags: 14,
			hrefBase: 15,
			POIs: 16,
			regionSettings: 17,
			segment: 1,
			theme: 18
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Layout",
			options,
			id: create_fragment$1.name
		});
	}

	get _groups() {
		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set _groups(value) {
		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get flags() {
		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set flags(value) {
		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hrefBase() {
		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hrefBase(value) {
		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get POIs() {
		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set POIs(value) {
		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get regionSettings() {
		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set regionSettings(value) {
		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get segment() {
		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set segment(value) {
		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get theme() {
		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set theme(value) {
		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var Layout$1 = Layout;

/* src/routes/compounds/time_region_value/_layout.svelte generated by Svelte v3.44.2 */
const file = "src/routes/compounds/time_region_value/_layout.svelte";

// (17:2) <Link    href='/svizzle/compounds/time_region_value'    rel='prefetch'   >
function create_default_slot_1(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("@svizzle/time_region_value");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			t = claim_text(span_nodes, "@svizzle/time_region_value");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(span, file, 20, 3, 439);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(17:2) <Link    href='/svizzle/compounds/time_region_value'    rel='prefetch'   >",
		ctx
	});

	return block;
}

// (25:2) <Layout    {_groups}    {flags}    {hrefBase}    {regionSettings}    {segment}   >
function create_default_slot(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(25:2) <Layout    {_groups}    {flags}    {hrefBase}    {regionSettings}    {segment}   >",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let t0;
	let section;
	let nav;
	let link;
	let t1;
	let main;
	let layout;
	let current;

	link = new Link({
			props: {
				href: "/svizzle/compounds/time_region_value",
				rel: "prefetch",
				$$slots: { default: [create_default_slot_1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	layout = new Layout$1({
			props: {
				_groups,
				flags,
				hrefBase,
				regionSettings,
				segment: /*segment*/ ctx[0],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			t0 = space();
			section = element("section");
			nav = element("nav");
			create_component(link.$$.fragment);
			t1 = space();
			main = element("main");
			create_component(layout.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all('[data-svelte=\"svelte-d9xgiw\"]', document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			section = claim_element(nodes, "SECTION", { class: true });
			var section_nodes = children(section);
			nav = claim_element(section_nodes, "NAV", { class: true });
			var nav_nodes = children(nav);
			claim_component(link.$$.fragment, nav_nodes);
			nav_nodes.forEach(detach_dev);
			t1 = claim_space(section_nodes);
			main = claim_element(section_nodes, "MAIN", { class: true });
			var main_nodes = children(main);
			claim_component(layout.$$.fragment, main_nodes);
			main_nodes.forEach(detach_dev);
			section_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			document.title = "@svizzle/time_region_value";
			attr_dev(nav, "class", "svelte-1fphwp9");
			add_location(nav, file, 15, 1, 353);
			attr_dev(main, "class", "svelte-1fphwp9");
			add_location(main, file, 23, 1, 498);
			attr_dev(section, "class", "svelte-1fphwp9");
			add_location(section, file, 14, 0, 342);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t0, anchor);
			insert_hydration_dev(target, section, anchor);
			append_hydration_dev(section, nav);
			mount_component(link, nav, null);
			append_hydration_dev(section, t1);
			append_hydration_dev(section, main);
			mount_component(layout, main, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const link_changes = {};

			if (dirty & /*$$scope*/ 4) {
				link_changes.$$scope = { dirty, ctx };
			}

			link.$set(link_changes);
			const layout_changes = {};
			if (dirty & /*segment*/ 1) layout_changes.segment = /*segment*/ ctx[0];

			if (dirty & /*$$scope*/ 4) {
				layout_changes.$$scope = { dirty, ctx };
			}

			layout.$set(layout_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(link.$$.fragment, local);
			transition_in(layout.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(link.$$.fragment, local);
			transition_out(layout.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(section);
			destroy_component(link);
			destroy_component(layout);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Layout', slots, ['default']);
	let { segment } = $$props;
	const writable_props = ['segment'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Layout> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('segment' in $$props) $$invalidate(0, segment = $$props.segment);
		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		Layout: Layout$1,
		Link,
		_groups,
		flags,
		hrefBase,
		regionSettings,
		segment
	});

	$$self.$inject_state = $$props => {
		if ('segment' in $$props) $$invalidate(0, segment = $$props.segment);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [segment, slots, $$scope];
}

class Layout_1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, { segment: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Layout_1",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*segment*/ ctx[0] === undefined && !('segment' in props)) {
			console.warn("<Layout> was created without expected prop 'segment'");
		}
	}

	get segment() {
		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set segment(value) {
		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { Layout_1 as default };
