import { ai as generic, aj as curry, ak as curryRight, W as pipe, al as splitBy, U as mapWith, am as debounce, an as filterWith, ao as isIterableNotEmpty, ap as find, aq as hasKeyValue, ar as some, a6 as collect, as as getPath, at as fromPairs, au as reduceWith, av as hasPathValue, _ as getKey, R as keys, S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, v as validate_slots, aw as isClientSide, p as noop, I as svg_element, J as claim_svg_element, g as children, b as detach_dev, k as attr_dev, m as add_location, n as insert_hydration_dev, r as create_slot, ax as validate_store, N as createEventDispatcher, K as makeStyleVars, e as element, f as claim_element, H as toggle_class, o as append_hydration_dev, M as listen_dev, ay as stop_propagation, y as update_slot_base, z as get_all_dirty_from_scope, A as get_slot_changes, u as transition_in, B as transition_out, az as run_all, aA as subscribe, aB as bubble, q as validate_each_argument, aC as _, aD as tick, aE as empty, C as destroy_each, ag as zip, t as text, j as claim_text, ah as set_data_dev, aF as onMount, L as Icon, a as space, c as claim_space, P as prop_dev, w as group_outros, x as check_outros, aG as binding_callbacks, D as create_component, E as claim_component, F as mount_component, G as destroy_component, aH as compute_slots, aI as construct_svelte_component_dev, aJ as component_subscribe, aK as setupResizeObserver, aL as action_destroyer, aM as _screen, aN as onDestroy, aO as ChevronLeft, aP as ChevronRight, aQ as toPx, aR as isNotNil, aS as findIndex, aT as add_render_callback, aU as add_iframe_resize_listener, aV as is_function, aW as is, aX as StorageIO, aY as NoScript, aZ as Switch, a_ as A11yMenu, a$ as A11yMenuDriver, b0 as ColorCorrection, b1 as _a11ySettings, b2 as _currentId, b3 as _currentSetting, b4 as _formatValue, b5 as setNextId, b6 as setPrevId, b7 as _hasPrev, b8 as _hasNext, b9 as updateCurrentValue, ba as mergeDefaultSettings, bb as _groupsResetStatus, bc as _isA11yDirty, bd as resetGroup, be as _a11yColorStyles, bf as _a11yTextStyles, bg as applyStyles, bh as FontsLoader, bi as getFamily, bj as getFamilies, bk as isFamilyEqualTo, bl as createFontFaces, bm as loadFontFaces, bn as ArrowLeftCircle, a1 as ArrowRightCircle, bo as MinusCircle, bp as PlusCircle, bq as A11yPerson, br as ScreenSensor, bs as isServerSide, bt as PLATFORM, bu as isPlatformIn, bv as getContext, bw as setContext, bx as set_store_value, by as writable, O as globals, bz as null_to_empty, bA as assign, bB as get_spread_update, bC as get_spread_object, bD as readable, bE as identity, Y as map, bF as prevent_default, bG as concat, bH as mergeObj, a9 as appendTo, bI as has, a8 as last, bJ as pullFrom, bK as sort, bL as uniques, X as sortWith, $ as head, bM as filter, bN as validate_each_keys, bO as update_keyed_each, bP as destroy_block, bQ as groupBy, T as values, bR as keyValueArrayToObject, bS as makeKeyedZeroes, a5 as objectToKeyValueArray, bT as objectToKeyValuesArray, V as transformValues, aa as sorterDesc, bU as merge, bV as reduce, bW as flatMapWith, a4 as mapValuesWith, bX as isIterableLongerThan1, bY as setKey, bZ as flatMap, b_ as makeKeyed, b$ as pairs$1, h as head_selector, ac as setIn, c0 as validate_dynamic_element, c1 as validate_void_dynamic_element, c2 as set_dynamic_element_data, c3 as set_data_maybe_contenteditable_dev, c4 as set_svg_attributes } from './client.7dada05b.js';
import { A as AlphabetPicker, C as CopyToClipboard, a as AlertTriangle, b as Clipboard, c as Copy, S as Sun, o as ordinal, l as lookup } from './_utils.0d9018f4.js';
import { S as Scroller, B as BarchartVDiv, C as ChoroplethG, p as projections, d as defaultGeometry } from './ChoroplethG.eba760be.js';
import { f as formatSpecifier, c as format, d as getKey$1, g as getValue, i as inclusiveRange, p as pluckKey, h as getValues } from './defaultLocale.f67da403.js';
import { C as CenteredView, L as LinkButton, M as MessageView, X as XorSelector, a as CheckSquare, b as ChevronDown, c as ChevronUp, G as Globe, d as MinusSquare, S as Square, v as vectorLength2D, g as getBinsTicks, e as getValuesLength, f as exactAmountBins, h as areValidBins, i as getBinsItems, j as getBinsMax, k as getBinsMin, l as getBinsExtent, m as isNonEmptyBin, n as findFirstNonEmptyBinIndex, o as findLastNonEmptyBinIndex, p as getTrimmedBinsStats, q as getBinsTicksExtent, r as getNonEmptyBinsTicks, s as ColorBinsG, t as ColorBinsDiv, u as pairs } from './ColorBinsDiv.bc9cc7a8.js';
import { D as Download, i as initRange, t as transformer, c as copy, a as ticks, b as bisector, d as tickStep, f as continuous, l as linear } from './quantize.fda9d0b5.js';
import { t as trim, a as arrayMaxWith, b as arrayMinWith, c as arraySumWith } from './linear.8db0ea93.js';
import { w as withPath, c as constant$1, a as curveLinear, x, y, b as array, l as line, m as monotoneX, q as quadtree } from './quadtree.bffffd8c.js';
import { A as Activity, B as BarChart, C as Clock, L as List, M as MapPin, r as rxStreamToSvReadable, a as rxStreamToSvWritable } from './rx.d88d7f70.js';
import { H as HyperLink, E as ExternalLink, d as defaultRel } from './HyperLink.24c4b6ad.js';
import { L as LoadingView, a as Loader } from './topojson.9579d61f.js';
import { V as View } from './View.f93383aa.js';
import { V as ViewsSlider } from './ViewsSlider.2037f48b.js';
import { V as ViewsXor } from './ViewsXor.b9f4fe7f.js';
import { I as Info } from './Info.20f3ea4d.js';
import { S as Settings } from './Settings.d39fcac3.js';
import './rgb.a3878736.js';
import './equalEarth.d678dfdc.js';
import './index.2a4e05c3.js';
import './any-undefined.7e669ab1.js';

/**
 * Returns true if the provided RegExp is empty
 * @arg {RegExp} regexp
 * @return {boolean} - true if RegExp is empty
 */

/**
 * Returns true if the provided RegExp is not empty
 * @arg {RegExp} regexp
 * @return {boolean} - true if RegExp is not empty
 */
const isRegexpNotEmpty = regexp => regexp.source !== '(?:)';

/**
* @module @svizzle/utils/string_proto-array
*/

/**
 * Return an array splitting the input string with the provided separator or regex
 * @see
 {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split|String.prototype.split},
 {@link module:@svizzle/utils/string-[string-array].makeSplitBy|makeSplitBy},
 {@link module:@svizzle/utils/string-[string-array].makeSplitStringBy|makeSplitStringBy},
 {@link module:@svizzle/utils/string-array.splitByDot|splitByDot},
 {@link module:@svizzle/utils/string-array.splitByEOL|splitByEOL},
 {@link module:@svizzle/utils/string-array.splitBySemiColon|splitBySemiColon}
 *
 * @function
 * @arg {string} string - The input string
 * @arg {stringOrRegex} stringOrRegex - Separator or regex
 * @return {array}
 *
 * @example
> split('a-b-c', '-')
['a', 'b', 'c']
 *
 * @since 0.1.0
 */
const split = generic(String.prototype.split);

/**
* @module @svizzle/utils/string-[string-array]
*/

/**
 * Return a function expecting a separator or regex to split the provided string
 *
 * @function
 * @arg {string} string - String to split
 * @return {function} - String -> Array
 *
 * @example
> splitStringBy = makeSplitStringBy('a.b-c,d:e')
> splitStringBy(':')
['a.b-c,d', 'e']
> splitStringBy('-')
['a.b', 'c,d:e']
 *
 * @since 0.1.0
 */
curry(split, 2);

/**
 * Return a function expecting a string to be split using the provided separator or regex
 * @see
 {@link module:@svizzle/utils/string-array.splitByDot|splitByDot},
 {@link module:@svizzle/utils/string-array.splitByEOL|splitByEOL},
 {@link module:@svizzle/utils/string-array.splitBySemiColon|splitBySemiColon},
 *
 * @function
 * @arg {stringOrRegex} stringOrRegex - Separator or regex
 * @return {function} - String -> Array
 *
 * @example
> splitByDoubleDot = makeSplitBy('..')
> splitByDoubleDot('aa...a..a.a.aa.....aa..')
> ['aa', '.a', 'a.a.aa', '', '.aa', '']
 *
 * @since 0.1.0
 */
curryRight(split, 2);

/**
 * Return a function that splits the expected string and trims all the elements
 * of the returned array
 * @see {@link module:@svizzle/utils/string-[string-array].makeSplitBy|makeSplitBy}
 *
 * @function
 * @arg {string} separator
 * @return {function} - String -> Array
 *
 * @example
> trimSplitByDoubleDot = makeTrimmedSplitBy('..')
>
> trimSplitByDoubleDot('  aa ..\ta\n..a')
['aa', 'a', 'a']
>
> trimSplitByDoubleDot('  aa ...\na..a.a.aa\n.....\taa..\n')
['aa', '.\na', 'a.a.aa', '', '.\taa', '']
 *
 * @since 0.19.0
 */
const makeTrimmedSplitBy = separator => pipe([
	trim,
	splitBy(separator),
	mapWith(trim)
]);

const resizeHandler = (
	node,
	{
		onResize,
		onResizeEnd,
		onResizeStart,
		timeout = 500
	} = {}
) => {
	let resizing = false;

	const started = size => {
		resizing = true;
		onResizeStart?.(size);
	};
	const scheduleEnded = debounce(size => {
		resizing = false;
		onResizeEnd?.(size);
	}, timeout);

	const observer = new ResizeObserver(entries => {
		const [size] = entries[0].borderBoxSize;
		!resizing && started(size);

		onResize?.(size);

		scheduleEnded(size);
	});
	observer.observe(node);

	return () => {
		observer.disconnect();
	}
};

const parseCssText = pipe([
	splitBy(';'),
	filterWith(isIterableNotEmpty),
	mapWith(makeTrimmedSplitBy(':'))
]);

const getStylesheet = href => find(
	[...document.styleSheets], // convert collection to array
	hasKeyValue('href', href)
);

const getSelectorText = getKey('selectorText');

const makeGetStyleRulesObj = selectorRegex => pipe([
	filterWith(pipe([
		getSelectorText,
		makeTrimmedSplitBy(','),
		some(selectorRegex.test.bind(selectorRegex))
	])),
	mapWith(collect([
		getSelectorText,
		pipe([
			getPath('style.cssText'),
			parseCssText,
			fromPairs
		])
	])),
	reduceWith(
		(themes, [selector, rules]) => {
			const themeEntry = find(
				themes,
				hasPathValue('0', selector)
			);
			if (themeEntry) {
				const [, existingRules] = themeEntry;
				themeEntry[1] = {...existingRules, ...rules};
			} else {
				themes.push([selector, rules]);
			}
			return themes;
		},
		[]
	),
	fromPairs
]);

const getAllStylesBySelector = pipe([
	mapWith(collect([
		getSelectorText,
		getKey('style')
	])),
	fromPairs
]);

const setStyleRules = (targetRules, srcRules) => {
	const selectors = keys(srcRules);
	selectors.forEach(selector => {
		if (selector in targetRules) {
			const style = srcRules[selector];
			const properties = keys(style);
			properties.forEach(prop => {
				targetRules[selector].setProperty(prop, style[prop]);
			});
		}
	});
};

const absoluteURLRegex = /^(?:[a-z+]+:)?\/\//iu;

const getURL = href => new URL(
	href,
	absoluteURLRegex.test(href)
		? undefined
		: location.origin
);

/* ../../components/ui/src/drivers/style/StyleDriver.svelte generated by Svelte v3.59.2 */

function create_fragment$4I(ctx) {
	const block = {
		c: noop,
		l: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4I.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4H($$self, $$props, $$invalidate) {
	let hrefURL;
	let allStyleRules;
	let styleRulesObj;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('StyleDriver', slots, []);
	let { href } = $$props;
	let { styleRules } = $$props;

	$$self.$$.on_mount.push(function () {
		if (href === undefined && !('href' in $$props || $$self.$$.bound[$$self.$$.props['href']])) {
			console.warn("<StyleDriver> was created without expected prop 'href'");
		}

		if (styleRules === undefined && !('styleRules' in $$props || $$self.$$.bound[$$self.$$.props['styleRules']])) {
			console.warn("<StyleDriver> was created without expected prop 'styleRules'");
		}
	});

	const writable_props = ['href', 'styleRules'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<StyleDriver> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('href' in $$props) $$invalidate(0, href = $$props.href);
		if ('styleRules' in $$props) $$invalidate(1, styleRules = $$props.styleRules);
	};

	$$self.$capture_state = () => ({
		isClientSide,
		getAllStylesBySelector,
		getStylesheet,
		setStyleRules,
		getURL,
		href,
		styleRules,
		styleRulesObj,
		allStyleRules,
		hrefURL
	});

	$$self.$inject_state = $$props => {
		if ('href' in $$props) $$invalidate(0, href = $$props.href);
		if ('styleRules' in $$props) $$invalidate(1, styleRules = $$props.styleRules);
		if ('styleRulesObj' in $$props) $$invalidate(2, styleRulesObj = $$props.styleRulesObj);
		if ('allStyleRules' in $$props) $$invalidate(3, allStyleRules = $$props.allStyleRules);
		if ('hrefURL' in $$props) $$invalidate(4, hrefURL = $$props.hrefURL);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*href*/ 1) {
			$$invalidate(4, hrefURL = isClientSide && href && getURL(href).toString());
		}

		if ($$self.$$.dirty & /*hrefURL*/ 16) {
			$$invalidate(3, allStyleRules = hrefURL ? [...getStylesheet(hrefURL).cssRules] : []); // convert collection to array
		}

		if ($$self.$$.dirty & /*allStyleRules*/ 8) {
			$$invalidate(2, styleRulesObj = getAllStylesBySelector(allStyleRules));
		}

		if ($$self.$$.dirty & /*styleRulesObj, styleRules*/ 6) {
			setStyleRules(styleRulesObj, styleRules);
		}
	};

	return [href, styleRules, styleRulesObj, allStyleRules, hrefURL];
}

class StyleDriver extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4H, create_fragment$4I, safe_not_equal, { href: 0, styleRules: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "StyleDriver",
			options,
			id: create_fragment$4I.name
		});
	}

	get href() {
		throw new Error("<StyleDriver>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<StyleDriver>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get styleRules() {
		throw new Error("<StyleDriver>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set styleRules(value) {
		throw new Error("<StyleDriver>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var StyleDriver$1 = StyleDriver;

/* ../../components/ui/src/icons/feather/Airplay.svelte generated by Svelte v3.59.2 */

const file$4D = "../../components/ui/src/icons/feather/Airplay.svelte";

function create_fragment$4H(ctx) {
	let path;
	let polygon;

	const block = {
		c: function create() {
			path = svg_element("path");
			polygon = svg_element("polygon");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1");
			add_location(path, file$4D, 1, 0, 34);
			attr_dev(polygon, "points", "12 15 17 21 7 21 12 15");
			add_location(polygon, file$4D, 1, 92, 126);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, polygon, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(polygon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4H.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4G($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Airplay', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Airplay> was created with unknown prop '${key}'`);
	});

	return [];
}

class Airplay extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4G, create_fragment$4H, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Airplay",
			options,
			id: create_fragment$4H.name
		});
	}
}

var Airplay$1 = Airplay;

/* ../../components/ui/src/icons/feather/AlertCircle.svelte generated by Svelte v3.59.2 */

const file$4C = "../../components/ui/src/icons/feather/AlertCircle.svelte";

function create_fragment$4G(ctx) {
	let circle;
	let line0;
	let line1;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$4C, 1, 0, 34);
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "8");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "12");
			add_location(line0, file$4C, 1, 40, 74);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "16");
			attr_dev(line1, "x2", "12.01");
			attr_dev(line1, "y2", "16");
			add_location(line1, file$4C, 1, 84, 118);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4G.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4F($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('AlertCircle', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AlertCircle> was created with unknown prop '${key}'`);
	});

	return [];
}

class AlertCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4F, create_fragment$4G, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AlertCircle",
			options,
			id: create_fragment$4G.name
		});
	}
}

var AlertCircle$1 = AlertCircle;

/* ../../components/ui/src/icons/feather/AlertOctagon.svelte generated by Svelte v3.59.2 */

const file$4B = "../../components/ui/src/icons/feather/AlertOctagon.svelte";

function create_fragment$4F(ctx) {
	let polygon;
	let line0;
	let line1;

	const block = {
		c: function create() {
			polygon = svg_element("polygon");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polygon, "points", "7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2");
			add_location(polygon, file$4B, 1, 0, 34);
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "8");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "12");
			add_location(line0, file$4B, 1, 99, 133);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "16");
			attr_dev(line1, "x2", "12.01");
			attr_dev(line1, "y2", "16");
			add_location(line1, file$4B, 1, 143, 177);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polygon, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polygon);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4F.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4E($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('AlertOctagon', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AlertOctagon> was created with unknown prop '${key}'`);
	});

	return [];
}

class AlertOctagon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4E, create_fragment$4F, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AlertOctagon",
			options,
			id: create_fragment$4F.name
		});
	}
}

var AlertOctagon$1 = AlertOctagon;

/* ../../components/ui/src/icons/feather/AlignCenter.svelte generated by Svelte v3.59.2 */

const file$4A = "../../components/ui/src/icons/feather/AlignCenter.svelte";

function create_fragment$4E(ctx) {
	let line0;
	let line1;
	let line2;
	let line3;

	const block = {
		c: function create() {
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			line3 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line3).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line0, "x1", "18");
			attr_dev(line0, "y1", "10");
			attr_dev(line0, "x2", "6");
			attr_dev(line0, "y2", "10");
			add_location(line0, file$4A, 1, 0, 34);
			attr_dev(line1, "x1", "21");
			attr_dev(line1, "y1", "6");
			attr_dev(line1, "x2", "3");
			attr_dev(line1, "y2", "6");
			add_location(line1, file$4A, 1, 44, 78);
			attr_dev(line2, "x1", "21");
			attr_dev(line2, "y1", "14");
			attr_dev(line2, "x2", "3");
			attr_dev(line2, "y2", "14");
			add_location(line2, file$4A, 1, 86, 120);
			attr_dev(line3, "x1", "18");
			attr_dev(line3, "y1", "18");
			attr_dev(line3, "x2", "6");
			attr_dev(line3, "y2", "18");
			add_location(line3, file$4A, 1, 130, 164);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
			insert_hydration_dev(target, line3, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
			if (detaching) detach_dev(line3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4E.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4D($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('AlignCenter', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AlignCenter> was created with unknown prop '${key}'`);
	});

	return [];
}

class AlignCenter extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4D, create_fragment$4E, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AlignCenter",
			options,
			id: create_fragment$4E.name
		});
	}
}

var AlignCenter$1 = AlignCenter;

/* ../../components/ui/src/icons/feather/AlignJustify.svelte generated by Svelte v3.59.2 */

const file$4z = "../../components/ui/src/icons/feather/AlignJustify.svelte";

function create_fragment$4D(ctx) {
	let line0;
	let line1;
	let line2;
	let line3;

	const block = {
		c: function create() {
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			line3 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line3).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line0, "x1", "21");
			attr_dev(line0, "y1", "10");
			attr_dev(line0, "x2", "3");
			attr_dev(line0, "y2", "10");
			add_location(line0, file$4z, 1, 0, 34);
			attr_dev(line1, "x1", "21");
			attr_dev(line1, "y1", "6");
			attr_dev(line1, "x2", "3");
			attr_dev(line1, "y2", "6");
			add_location(line1, file$4z, 1, 44, 78);
			attr_dev(line2, "x1", "21");
			attr_dev(line2, "y1", "14");
			attr_dev(line2, "x2", "3");
			attr_dev(line2, "y2", "14");
			add_location(line2, file$4z, 1, 86, 120);
			attr_dev(line3, "x1", "21");
			attr_dev(line3, "y1", "18");
			attr_dev(line3, "x2", "3");
			attr_dev(line3, "y2", "18");
			add_location(line3, file$4z, 1, 130, 164);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
			insert_hydration_dev(target, line3, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
			if (detaching) detach_dev(line3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4D.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4C($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('AlignJustify', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AlignJustify> was created with unknown prop '${key}'`);
	});

	return [];
}

class AlignJustify extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4C, create_fragment$4D, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AlignJustify",
			options,
			id: create_fragment$4D.name
		});
	}
}

var AlignJustify$1 = AlignJustify;

/* ../../components/ui/src/icons/feather/AlignLeft.svelte generated by Svelte v3.59.2 */

const file$4y = "../../components/ui/src/icons/feather/AlignLeft.svelte";

function create_fragment$4C(ctx) {
	let line0;
	let line1;
	let line2;
	let line3;

	const block = {
		c: function create() {
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			line3 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line3).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line0, "x1", "17");
			attr_dev(line0, "y1", "10");
			attr_dev(line0, "x2", "3");
			attr_dev(line0, "y2", "10");
			add_location(line0, file$4y, 1, 0, 34);
			attr_dev(line1, "x1", "21");
			attr_dev(line1, "y1", "6");
			attr_dev(line1, "x2", "3");
			attr_dev(line1, "y2", "6");
			add_location(line1, file$4y, 1, 44, 78);
			attr_dev(line2, "x1", "21");
			attr_dev(line2, "y1", "14");
			attr_dev(line2, "x2", "3");
			attr_dev(line2, "y2", "14");
			add_location(line2, file$4y, 1, 86, 120);
			attr_dev(line3, "x1", "17");
			attr_dev(line3, "y1", "18");
			attr_dev(line3, "x2", "3");
			attr_dev(line3, "y2", "18");
			add_location(line3, file$4y, 1, 130, 164);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
			insert_hydration_dev(target, line3, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
			if (detaching) detach_dev(line3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4C.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4B($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('AlignLeft', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AlignLeft> was created with unknown prop '${key}'`);
	});

	return [];
}

class AlignLeft extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4B, create_fragment$4C, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AlignLeft",
			options,
			id: create_fragment$4C.name
		});
	}
}

var AlignLeft$1 = AlignLeft;

/* ../../components/ui/src/icons/feather/AlignRight.svelte generated by Svelte v3.59.2 */

const file$4x = "../../components/ui/src/icons/feather/AlignRight.svelte";

function create_fragment$4B(ctx) {
	let line0;
	let line1;
	let line2;
	let line3;

	const block = {
		c: function create() {
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			line3 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line3).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line0, "x1", "21");
			attr_dev(line0, "y1", "10");
			attr_dev(line0, "x2", "7");
			attr_dev(line0, "y2", "10");
			add_location(line0, file$4x, 1, 0, 34);
			attr_dev(line1, "x1", "21");
			attr_dev(line1, "y1", "6");
			attr_dev(line1, "x2", "3");
			attr_dev(line1, "y2", "6");
			add_location(line1, file$4x, 1, 44, 78);
			attr_dev(line2, "x1", "21");
			attr_dev(line2, "y1", "14");
			attr_dev(line2, "x2", "3");
			attr_dev(line2, "y2", "14");
			add_location(line2, file$4x, 1, 86, 120);
			attr_dev(line3, "x1", "21");
			attr_dev(line3, "y1", "18");
			attr_dev(line3, "x2", "7");
			attr_dev(line3, "y2", "18");
			add_location(line3, file$4x, 1, 130, 164);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
			insert_hydration_dev(target, line3, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
			if (detaching) detach_dev(line3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4B.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4A($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('AlignRight', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AlignRight> was created with unknown prop '${key}'`);
	});

	return [];
}

class AlignRight extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4A, create_fragment$4B, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AlignRight",
			options,
			id: create_fragment$4B.name
		});
	}
}

var AlignRight$1 = AlignRight;

/* ../../components/ui/src/icons/feather/Anchor.svelte generated by Svelte v3.59.2 */

const file$4w = "../../components/ui/src/icons/feather/Anchor.svelte";

function create_fragment$4A(ctx) {
	let circle;
	let line;
	let path;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			line = svg_element("line");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "5");
			attr_dev(circle, "r", "3");
			add_location(circle, file$4w, 1, 0, 34);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "22");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "8");
			add_location(line, file$4w, 1, 38, 72);
			attr_dev(path, "d", "M5 12H2a10 10 0 0 0 20 0h-3");
			add_location(path, file$4w, 1, 82, 116);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, line, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(line);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4A.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4z($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Anchor', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Anchor> was created with unknown prop '${key}'`);
	});

	return [];
}

class Anchor extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4z, create_fragment$4A, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Anchor",
			options,
			id: create_fragment$4A.name
		});
	}
}

var Anchor$1 = Anchor;

/* ../../components/ui/src/icons/feather/Aperture.svelte generated by Svelte v3.59.2 */

const file$4v = "../../components/ui/src/icons/feather/Aperture.svelte";

function create_fragment$4z(ctx) {
	let circle;
	let line0;
	let line1;
	let line2;
	let line3;
	let line4;
	let line5;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			line4 = svg_element("line");
			line5 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			line3 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line3).forEach(detach_dev);
			line4 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line4).forEach(detach_dev);
			line5 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line5).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$4v, 1, 0, 34);
			attr_dev(line0, "x1", "14.31");
			attr_dev(line0, "y1", "8");
			attr_dev(line0, "x2", "20.05");
			attr_dev(line0, "y2", "17.94");
			add_location(line0, file$4v, 1, 40, 74);
			attr_dev(line1, "x1", "9.69");
			attr_dev(line1, "y1", "8");
			attr_dev(line1, "x2", "21.17");
			attr_dev(line1, "y2", "8");
			add_location(line1, file$4v, 1, 93, 127);
			attr_dev(line2, "x1", "7.38");
			attr_dev(line2, "y1", "12");
			attr_dev(line2, "x2", "13.12");
			attr_dev(line2, "y2", "2.06");
			add_location(line2, file$4v, 1, 141, 175);
			attr_dev(line3, "x1", "9.69");
			attr_dev(line3, "y1", "16");
			attr_dev(line3, "x2", "3.95");
			attr_dev(line3, "y2", "6.06");
			add_location(line3, file$4v, 1, 193, 227);
			attr_dev(line4, "x1", "14.31");
			attr_dev(line4, "y1", "16");
			attr_dev(line4, "x2", "2.83");
			attr_dev(line4, "y2", "16");
			add_location(line4, file$4v, 1, 244, 278);
			attr_dev(line5, "x1", "16.62");
			attr_dev(line5, "y1", "12");
			attr_dev(line5, "x2", "10.88");
			attr_dev(line5, "y2", "21.94");
			add_location(line5, file$4v, 1, 294, 328);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
			insert_hydration_dev(target, line3, anchor);
			insert_hydration_dev(target, line4, anchor);
			insert_hydration_dev(target, line5, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
			if (detaching) detach_dev(line3);
			if (detaching) detach_dev(line4);
			if (detaching) detach_dev(line5);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4y($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Aperture', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Aperture> was created with unknown prop '${key}'`);
	});

	return [];
}

class Aperture extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4y, create_fragment$4z, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Aperture",
			options,
			id: create_fragment$4z.name
		});
	}
}

var Aperture$1 = Aperture;

/* ../../components/ui/src/icons/feather/Archive.svelte generated by Svelte v3.59.2 */

const file$4u = "../../components/ui/src/icons/feather/Archive.svelte";

function create_fragment$4y(ctx) {
	let polyline;
	let rect;
	let line;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			rect = svg_element("rect");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);

			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true
			});

			children(rect).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "21 8 21 21 3 21 3 8");
			add_location(polyline, file$4u, 1, 0, 34);
			attr_dev(rect, "x", "1");
			attr_dev(rect, "y", "3");
			attr_dev(rect, "width", "22");
			attr_dev(rect, "height", "5");
			add_location(rect, file$4u, 1, 50, 84);
			attr_dev(line, "x1", "10");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "14");
			attr_dev(line, "y2", "12");
			add_location(line, file$4u, 1, 97, 131);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4x($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Archive', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Archive> was created with unknown prop '${key}'`);
	});

	return [];
}

class Archive extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4x, create_fragment$4y, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Archive",
			options,
			id: create_fragment$4y.name
		});
	}
}

var Archive$1 = Archive;

/* ../../components/ui/src/icons/feather/ArrowDownCircle.svelte generated by Svelte v3.59.2 */

const file$4t = "../../components/ui/src/icons/feather/ArrowDownCircle.svelte";

function create_fragment$4x(ctx) {
	let circle;
	let polyline;
	let line;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			polyline = svg_element("polyline");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$4t, 1, 0, 34);
			attr_dev(polyline, "points", "8 12 12 16 16 12");
			add_location(polyline, file$4t, 1, 40, 74);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "8");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "16");
			add_location(line, file$4t, 1, 87, 121);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4x.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4w($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ArrowDownCircle', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ArrowDownCircle> was created with unknown prop '${key}'`);
	});

	return [];
}

class ArrowDownCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4w, create_fragment$4x, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ArrowDownCircle",
			options,
			id: create_fragment$4x.name
		});
	}
}

var ArrowDownCircle$1 = ArrowDownCircle;

/* ../../components/ui/src/icons/feather/ArrowDownLeft.svelte generated by Svelte v3.59.2 */

const file$4s = "../../components/ui/src/icons/feather/ArrowDownLeft.svelte";

function create_fragment$4w(ctx) {
	let line;
	let polyline;

	const block = {
		c: function create() {
			line = svg_element("line");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line, "x1", "17");
			attr_dev(line, "y1", "7");
			attr_dev(line, "x2", "7");
			attr_dev(line, "y2", "17");
			add_location(line, file$4s, 1, 0, 34);
			attr_dev(polyline, "points", "17 17 7 17 7 7");
			add_location(polyline, file$4s, 1, 43, 77);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line, anchor);
			insert_hydration_dev(target, polyline, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line);
			if (detaching) detach_dev(polyline);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4w.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4v($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ArrowDownLeft', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ArrowDownLeft> was created with unknown prop '${key}'`);
	});

	return [];
}

class ArrowDownLeft extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4v, create_fragment$4w, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ArrowDownLeft",
			options,
			id: create_fragment$4w.name
		});
	}
}

var ArrowDownLeft$1 = ArrowDownLeft;

/* ../../components/ui/src/icons/feather/ArrowDownRight.svelte generated by Svelte v3.59.2 */

const file$4r = "../../components/ui/src/icons/feather/ArrowDownRight.svelte";

function create_fragment$4v(ctx) {
	let line;
	let polyline;

	const block = {
		c: function create() {
			line = svg_element("line");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line, "x1", "7");
			attr_dev(line, "y1", "7");
			attr_dev(line, "x2", "17");
			attr_dev(line, "y2", "17");
			add_location(line, file$4r, 1, 0, 34);
			attr_dev(polyline, "points", "17 7 17 17 7 17");
			add_location(polyline, file$4r, 1, 43, 77);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line, anchor);
			insert_hydration_dev(target, polyline, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line);
			if (detaching) detach_dev(polyline);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4v.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4u($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ArrowDownRight', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ArrowDownRight> was created with unknown prop '${key}'`);
	});

	return [];
}

class ArrowDownRight extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4u, create_fragment$4v, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ArrowDownRight",
			options,
			id: create_fragment$4v.name
		});
	}
}

var ArrowDownRight$1 = ArrowDownRight;

/* ../../components/ui/src/icons/feather/ArrowDown.svelte generated by Svelte v3.59.2 */

const file$4q = "../../components/ui/src/icons/feather/ArrowDown.svelte";

function create_fragment$4u(ctx) {
	let line;
	let polyline;

	const block = {
		c: function create() {
			line = svg_element("line");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "5");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "19");
			add_location(line, file$4q, 1, 0, 34);
			attr_dev(polyline, "points", "19 12 12 19 5 12");
			add_location(polyline, file$4q, 1, 44, 78);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line, anchor);
			insert_hydration_dev(target, polyline, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line);
			if (detaching) detach_dev(polyline);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4u.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4t($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ArrowDown', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ArrowDown> was created with unknown prop '${key}'`);
	});

	return [];
}

class ArrowDown extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4t, create_fragment$4u, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ArrowDown",
			options,
			id: create_fragment$4u.name
		});
	}
}

var ArrowDown$1 = ArrowDown;

/* ../../components/ui/src/icons/feather/ArrowLeft.svelte generated by Svelte v3.59.2 */

const file$4p = "../../components/ui/src/icons/feather/ArrowLeft.svelte";

function create_fragment$4t(ctx) {
	let line;
	let polyline;

	const block = {
		c: function create() {
			line = svg_element("line");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line, "x1", "19");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "5");
			attr_dev(line, "y2", "12");
			add_location(line, file$4p, 1, 0, 34);
			attr_dev(polyline, "points", "12 19 5 12 12 5");
			add_location(polyline, file$4p, 1, 44, 78);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line, anchor);
			insert_hydration_dev(target, polyline, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line);
			if (detaching) detach_dev(polyline);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4t.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4s($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ArrowLeft', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ArrowLeft> was created with unknown prop '${key}'`);
	});

	return [];
}

class ArrowLeft extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4s, create_fragment$4t, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ArrowLeft",
			options,
			id: create_fragment$4t.name
		});
	}
}

var ArrowLeft$1 = ArrowLeft;

/* ../../components/ui/src/icons/feather/ArrowRight.svelte generated by Svelte v3.59.2 */

const file$4o = "../../components/ui/src/icons/feather/ArrowRight.svelte";

function create_fragment$4s(ctx) {
	let line;
	let polyline;

	const block = {
		c: function create() {
			line = svg_element("line");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line, "x1", "5");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "19");
			attr_dev(line, "y2", "12");
			add_location(line, file$4o, 1, 0, 34);
			attr_dev(polyline, "points", "12 5 19 12 12 19");
			add_location(polyline, file$4o, 1, 44, 78);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line, anchor);
			insert_hydration_dev(target, polyline, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line);
			if (detaching) detach_dev(polyline);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4s.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4r($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ArrowRight', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ArrowRight> was created with unknown prop '${key}'`);
	});

	return [];
}

class ArrowRight extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4r, create_fragment$4s, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ArrowRight",
			options,
			id: create_fragment$4s.name
		});
	}
}

var ArrowRight$1 = ArrowRight;

/* ../../components/ui/src/icons/feather/ArrowUpCircle.svelte generated by Svelte v3.59.2 */

const file$4n = "../../components/ui/src/icons/feather/ArrowUpCircle.svelte";

function create_fragment$4r(ctx) {
	let circle;
	let polyline;
	let line;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			polyline = svg_element("polyline");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$4n, 1, 0, 34);
			attr_dev(polyline, "points", "16 12 12 8 8 12");
			add_location(polyline, file$4n, 1, 40, 74);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "16");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "8");
			add_location(line, file$4n, 1, 86, 120);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4r.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4q($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ArrowUpCircle', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ArrowUpCircle> was created with unknown prop '${key}'`);
	});

	return [];
}

class ArrowUpCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4q, create_fragment$4r, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ArrowUpCircle",
			options,
			id: create_fragment$4r.name
		});
	}
}

var ArrowUpCircle$1 = ArrowUpCircle;

/* ../../components/ui/src/icons/feather/ArrowUpLeft.svelte generated by Svelte v3.59.2 */

const file$4m = "../../components/ui/src/icons/feather/ArrowUpLeft.svelte";

function create_fragment$4q(ctx) {
	let line;
	let polyline;

	const block = {
		c: function create() {
			line = svg_element("line");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line, "x1", "17");
			attr_dev(line, "y1", "17");
			attr_dev(line, "x2", "7");
			attr_dev(line, "y2", "7");
			add_location(line, file$4m, 1, 0, 34);
			attr_dev(polyline, "points", "7 17 7 7 17 7");
			add_location(polyline, file$4m, 1, 43, 77);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line, anchor);
			insert_hydration_dev(target, polyline, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line);
			if (detaching) detach_dev(polyline);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4p($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ArrowUpLeft', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ArrowUpLeft> was created with unknown prop '${key}'`);
	});

	return [];
}

class ArrowUpLeft extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4p, create_fragment$4q, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ArrowUpLeft",
			options,
			id: create_fragment$4q.name
		});
	}
}

var ArrowUpLeft$1 = ArrowUpLeft;

/* ../../components/ui/src/icons/feather/ArrowUpRight.svelte generated by Svelte v3.59.2 */

const file$4l = "../../components/ui/src/icons/feather/ArrowUpRight.svelte";

function create_fragment$4p(ctx) {
	let line;
	let polyline;

	const block = {
		c: function create() {
			line = svg_element("line");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line, "x1", "7");
			attr_dev(line, "y1", "17");
			attr_dev(line, "x2", "17");
			attr_dev(line, "y2", "7");
			add_location(line, file$4l, 1, 0, 34);
			attr_dev(polyline, "points", "7 7 17 7 17 17");
			add_location(polyline, file$4l, 1, 43, 77);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line, anchor);
			insert_hydration_dev(target, polyline, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line);
			if (detaching) detach_dev(polyline);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4p.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4o($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ArrowUpRight', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ArrowUpRight> was created with unknown prop '${key}'`);
	});

	return [];
}

class ArrowUpRight extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4o, create_fragment$4p, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ArrowUpRight",
			options,
			id: create_fragment$4p.name
		});
	}
}

var ArrowUpRight$1 = ArrowUpRight;

/* ../../components/ui/src/icons/feather/ArrowUp.svelte generated by Svelte v3.59.2 */

const file$4k = "../../components/ui/src/icons/feather/ArrowUp.svelte";

function create_fragment$4o(ctx) {
	let line;
	let polyline;

	const block = {
		c: function create() {
			line = svg_element("line");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "19");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "5");
			add_location(line, file$4k, 1, 0, 34);
			attr_dev(polyline, "points", "5 12 12 5 19 12");
			add_location(polyline, file$4k, 1, 44, 78);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line, anchor);
			insert_hydration_dev(target, polyline, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line);
			if (detaching) detach_dev(polyline);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4o.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4n($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ArrowUp', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ArrowUp> was created with unknown prop '${key}'`);
	});

	return [];
}

class ArrowUp extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4n, create_fragment$4o, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ArrowUp",
			options,
			id: create_fragment$4o.name
		});
	}
}

var ArrowUp$1 = ArrowUp;

/* ../../components/ui/src/icons/feather/AtSign.svelte generated by Svelte v3.59.2 */

const file$4j = "../../components/ui/src/icons/feather/AtSign.svelte";

function create_fragment$4n(ctx) {
	let circle;
	let path;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "4");
			add_location(circle, file$4j, 1, 0, 34);
			attr_dev(path, "d", "M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94");
			add_location(path, file$4j, 1, 39, 73);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4n.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4m($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('AtSign', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AtSign> was created with unknown prop '${key}'`);
	});

	return [];
}

class AtSign extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4m, create_fragment$4n, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "AtSign",
			options,
			id: create_fragment$4n.name
		});
	}
}

var AtSign$1 = AtSign;

/* ../../components/ui/src/icons/feather/Award.svelte generated by Svelte v3.59.2 */

const file$4i = "../../components/ui/src/icons/feather/Award.svelte";

function create_fragment$4m(ctx) {
	let circle;
	let polyline;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "8");
			attr_dev(circle, "r", "7");
			add_location(circle, file$4i, 1, 0, 34);
			attr_dev(polyline, "points", "8.21 13.89 7 23 12 20 17 23 15.79 13.88");
			add_location(polyline, file$4i, 1, 38, 72);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, polyline, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(polyline);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4m.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4l($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Award', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Award> was created with unknown prop '${key}'`);
	});

	return [];
}

class Award extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4l, create_fragment$4m, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Award",
			options,
			id: create_fragment$4m.name
		});
	}
}

var Award$1 = Award;

/* ../../components/ui/src/icons/feather/BarChart2.svelte generated by Svelte v3.59.2 */

const file$4h = "../../components/ui/src/icons/feather/BarChart2.svelte";

function create_fragment$4l(ctx) {
	let line0;
	let line1;
	let line2;

	const block = {
		c: function create() {
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line0, "x1", "18");
			attr_dev(line0, "y1", "20");
			attr_dev(line0, "x2", "18");
			attr_dev(line0, "y2", "10");
			add_location(line0, file$4h, 1, 0, 34);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "20");
			attr_dev(line1, "x2", "12");
			attr_dev(line1, "y2", "4");
			add_location(line1, file$4h, 1, 45, 79);
			attr_dev(line2, "x1", "6");
			attr_dev(line2, "y1", "20");
			attr_dev(line2, "x2", "6");
			attr_dev(line2, "y2", "14");
			add_location(line2, file$4h, 1, 89, 123);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4l.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4k($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('BarChart2', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BarChart2> was created with unknown prop '${key}'`);
	});

	return [];
}

class BarChart2 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4k, create_fragment$4l, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "BarChart2",
			options,
			id: create_fragment$4l.name
		});
	}
}

var BarChart2$1 = BarChart2;

/* ../../components/ui/src/icons/feather/BatteryCharging.svelte generated by Svelte v3.59.2 */

const file$4g = "../../components/ui/src/icons/feather/BatteryCharging.svelte";

function create_fragment$4k(ctx) {
	let path;
	let line;
	let polyline;

	const block = {
		c: function create() {
			path = svg_element("path");
			line = svg_element("line");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M5 18H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3.19M15 6h2a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-3.19");
			add_location(path, file$4g, 1, 0, 34);
			attr_dev(line, "x1", "23");
			attr_dev(line, "y1", "13");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "11");
			add_location(line, file$4g, 1, 103, 137);
			attr_dev(polyline, "points", "11 6 7 12 13 12 9 18");
			add_location(polyline, file$4g, 1, 148, 182);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line, anchor);
			insert_hydration_dev(target, polyline, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line);
			if (detaching) detach_dev(polyline);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4j($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('BatteryCharging', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BatteryCharging> was created with unknown prop '${key}'`);
	});

	return [];
}

class BatteryCharging extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4j, create_fragment$4k, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "BatteryCharging",
			options,
			id: create_fragment$4k.name
		});
	}
}

var BatteryCharging$1 = BatteryCharging;

/* ../../components/ui/src/icons/feather/Battery.svelte generated by Svelte v3.59.2 */

const file$4f = "../../components/ui/src/icons/feather/Battery.svelte";

function create_fragment$4j(ctx) {
	let rect;
	let line;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "1");
			attr_dev(rect, "y", "6");
			attr_dev(rect, "width", "18");
			attr_dev(rect, "height", "12");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$4f, 1, 0, 34);
			attr_dev(line, "x1", "23");
			attr_dev(line, "y1", "13");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "11");
			add_location(line, file$4f, 1, 62, 96);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4i($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Battery', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Battery> was created with unknown prop '${key}'`);
	});

	return [];
}

class Battery extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4i, create_fragment$4j, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Battery",
			options,
			id: create_fragment$4j.name
		});
	}
}

var Battery$1 = Battery;

/* ../../components/ui/src/icons/feather/BellOff.svelte generated by Svelte v3.59.2 */

const file$4e = "../../components/ui/src/icons/feather/BellOff.svelte";

function create_fragment$4i(ctx) {
	let path0;
	let path1;
	let path2;
	let path3;
	let line;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			path2 = claim_svg_element(nodes, "path", { d: true });
			children(path2).forEach(detach_dev);
			path3 = claim_svg_element(nodes, "path", { d: true });
			children(path3).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M13.73 21a2 2 0 0 1-3.46 0");
			add_location(path0, file$4e, 1, 0, 34);
			attr_dev(path1, "d", "M18.63 13A17.89 17.89 0 0 1 18 8");
			add_location(path1, file$4e, 1, 44, 78);
			attr_dev(path2, "d", "M6.26 6.26A5.86 5.86 0 0 0 6 8c0 7-3 9-3 9h14");
			add_location(path2, file$4e, 1, 94, 128);
			attr_dev(path3, "d", "M18 8a6 6 0 0 0-9.33-5");
			add_location(path3, file$4e, 1, 157, 191);
			attr_dev(line, "x1", "1");
			attr_dev(line, "y1", "1");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "23");
			add_location(line, file$4e, 1, 197, 231);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
			insert_hydration_dev(target, path2, anchor);
			insert_hydration_dev(target, path3, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
			if (detaching) detach_dev(path2);
			if (detaching) detach_dev(path3);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4h($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('BellOff', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BellOff> was created with unknown prop '${key}'`);
	});

	return [];
}

class BellOff extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4h, create_fragment$4i, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "BellOff",
			options,
			id: create_fragment$4i.name
		});
	}
}

var BellOff$1 = BellOff;

/* ../../components/ui/src/icons/feather/Bell.svelte generated by Svelte v3.59.2 */

const file$4d = "../../components/ui/src/icons/feather/Bell.svelte";

function create_fragment$4h(ctx) {
	let path0;
	let path1;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9");
			add_location(path0, file$4d, 1, 0, 34);
			attr_dev(path1, "d", "M13.73 21a2 2 0 0 1-3.46 0");
			add_location(path1, file$4d, 1, 61, 95);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4g($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Bell', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Bell> was created with unknown prop '${key}'`);
	});

	return [];
}

class Bell extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4g, create_fragment$4h, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Bell",
			options,
			id: create_fragment$4h.name
		});
	}
}

var Bell$1 = Bell;

/* ../../components/ui/src/icons/feather/Bluetooth.svelte generated by Svelte v3.59.2 */

const file$4c = "../../components/ui/src/icons/feather/Bluetooth.svelte";

function create_fragment$4g(ctx) {
	let polyline;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "6.5 6.5 17.5 17.5 12 23 12 1 17.5 6.5 6.5 17.5");
			add_location(polyline, file$4c, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4f($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Bluetooth', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Bluetooth> was created with unknown prop '${key}'`);
	});

	return [];
}

class Bluetooth extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4f, create_fragment$4g, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Bluetooth",
			options,
			id: create_fragment$4g.name
		});
	}
}

var Bluetooth$1 = Bluetooth;

/* ../../components/ui/src/icons/feather/Bold.svelte generated by Svelte v3.59.2 */

const file$4b = "../../components/ui/src/icons/feather/Bold.svelte";

function create_fragment$4f(ctx) {
	let path0;
	let path1;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z");
			add_location(path0, file$4b, 1, 0, 34);
			attr_dev(path1, "d", "M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z");
			add_location(path1, file$4b, 1, 55, 89);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4e($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Bold', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Bold> was created with unknown prop '${key}'`);
	});

	return [];
}

class Bold extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4e, create_fragment$4f, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Bold",
			options,
			id: create_fragment$4f.name
		});
	}
}

var Bold$1 = Bold;

/* ../../components/ui/src/icons/feather/BookOpen.svelte generated by Svelte v3.59.2 */

const file$4a = "../../components/ui/src/icons/feather/BookOpen.svelte";

function create_fragment$4e(ctx) {
	let path0;
	let path1;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z");
			add_location(path0, file$4a, 1, 0, 34);
			attr_dev(path1, "d", "M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z");
			add_location(path1, file$4a, 1, 58, 92);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4d($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('BookOpen', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BookOpen> was created with unknown prop '${key}'`);
	});

	return [];
}

class BookOpen extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4d, create_fragment$4e, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "BookOpen",
			options,
			id: create_fragment$4e.name
		});
	}
}

var BookOpen$1 = BookOpen;

/* ../../components/ui/src/icons/feather/Book.svelte generated by Svelte v3.59.2 */

const file$49 = "../../components/ui/src/icons/feather/Book.svelte";

function create_fragment$4d(ctx) {
	let path0;
	let path1;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M4 19.5A2.5 2.5 0 0 1 6.5 17H20");
			add_location(path0, file$49, 1, 0, 34);
			attr_dev(path1, "d", "M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z");
			add_location(path1, file$49, 1, 49, 83);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4c($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Book', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Book> was created with unknown prop '${key}'`);
	});

	return [];
}

class Book extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4c, create_fragment$4d, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Book",
			options,
			id: create_fragment$4d.name
		});
	}
}

var Book$1 = Book;

/* ../../components/ui/src/icons/feather/Bookmark.svelte generated by Svelte v3.59.2 */

const file$48 = "../../components/ui/src/icons/feather/Bookmark.svelte";

function create_fragment$4c(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z");
			add_location(path, file$48, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4b($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Bookmark', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Bookmark> was created with unknown prop '${key}'`);
	});

	return [];
}

class Bookmark extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4b, create_fragment$4c, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Bookmark",
			options,
			id: create_fragment$4c.name
		});
	}
}

var Bookmark$1 = Bookmark;

/* ../../components/ui/src/icons/feather/Box.svelte generated by Svelte v3.59.2 */

const file$47 = "../../components/ui/src/icons/feather/Box.svelte";

function create_fragment$4b(ctx) {
	let path;
	let polyline;
	let line;

	const block = {
		c: function create() {
			path = svg_element("path");
			polyline = svg_element("polyline");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z");
			add_location(path, file$47, 1, 0, 34);
			attr_dev(polyline, "points", "3.27 6.96 12 12.01 20.73 6.96");
			add_location(polyline, file$47, 1, 139, 173);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "22.08");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "12");
			add_location(line, file$47, 1, 199, 233);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4a($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Box', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Box> was created with unknown prop '${key}'`);
	});

	return [];
}

class Box extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$4a, create_fragment$4b, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Box",
			options,
			id: create_fragment$4b.name
		});
	}
}

var Box$1 = Box;

/* ../../components/ui/src/icons/feather/Briefcase.svelte generated by Svelte v3.59.2 */

const file$46 = "../../components/ui/src/icons/feather/Briefcase.svelte";

function create_fragment$4a(ctx) {
	let rect;
	let path;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "2");
			attr_dev(rect, "y", "7");
			attr_dev(rect, "width", "20");
			attr_dev(rect, "height", "14");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$46, 1, 0, 34);
			attr_dev(path, "d", "M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16");
			add_location(path, file$46, 1, 62, 96);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$49($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Briefcase', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Briefcase> was created with unknown prop '${key}'`);
	});

	return [];
}

class Briefcase extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$49, create_fragment$4a, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Briefcase",
			options,
			id: create_fragment$4a.name
		});
	}
}

var Briefcase$1 = Briefcase;

/* ../../components/ui/src/icons/feather/Calendar.svelte generated by Svelte v3.59.2 */

const file$45 = "../../components/ui/src/icons/feather/Calendar.svelte";

function create_fragment$49(ctx) {
	let rect;
	let line0;
	let line1;
	let line2;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "3");
			attr_dev(rect, "y", "4");
			attr_dev(rect, "width", "18");
			attr_dev(rect, "height", "18");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$45, 1, 0, 34);
			attr_dev(line0, "x1", "16");
			attr_dev(line0, "y1", "2");
			attr_dev(line0, "x2", "16");
			attr_dev(line0, "y2", "6");
			add_location(line0, file$45, 1, 62, 96);
			attr_dev(line1, "x1", "8");
			attr_dev(line1, "y1", "2");
			attr_dev(line1, "x2", "8");
			attr_dev(line1, "y2", "6");
			add_location(line1, file$45, 1, 105, 139);
			attr_dev(line2, "x1", "3");
			attr_dev(line2, "y1", "10");
			attr_dev(line2, "x2", "21");
			attr_dev(line2, "y2", "10");
			add_location(line2, file$45, 1, 146, 180);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$49.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$48($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Calendar', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Calendar> was created with unknown prop '${key}'`);
	});

	return [];
}

class Calendar extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$48, create_fragment$49, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Calendar",
			options,
			id: create_fragment$49.name
		});
	}
}

var Calendar$1 = Calendar;

/* ../../components/ui/src/icons/feather/CameraOff.svelte generated by Svelte v3.59.2 */

const file$44 = "../../components/ui/src/icons/feather/CameraOff.svelte";

function create_fragment$48(ctx) {
	let line;
	let path;

	const block = {
		c: function create() {
			line = svg_element("line");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line, "x1", "1");
			attr_dev(line, "y1", "1");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "23");
			add_location(line, file$44, 1, 0, 34);
			attr_dev(path, "d", "M21 21H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3m3-3h6l2 3h4a2 2 0 0 1 2 2v9.34m-7.72-2.06a4 4 0 1 1-5.56-5.56");
			add_location(path, file$44, 1, 43, 77);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$48.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$47($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('CameraOff', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CameraOff> was created with unknown prop '${key}'`);
	});

	return [];
}

class CameraOff extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$47, create_fragment$48, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CameraOff",
			options,
			id: create_fragment$48.name
		});
	}
}

var CameraOff$1 = CameraOff;

/* ../../components/ui/src/icons/feather/Camera.svelte generated by Svelte v3.59.2 */

const file$43 = "../../components/ui/src/icons/feather/Camera.svelte";

function create_fragment$47(ctx) {
	let path;
	let circle;

	const block = {
		c: function create() {
			path = svg_element("path");
			circle = svg_element("circle");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z");
			add_location(path, file$43, 1, 0, 34);
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "13");
			attr_dev(circle, "r", "4");
			add_location(circle, file$43, 1, 99, 133);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, circle, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(circle);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$47.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$46($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Camera', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Camera> was created with unknown prop '${key}'`);
	});

	return [];
}

class Camera extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$46, create_fragment$47, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Camera",
			options,
			id: create_fragment$47.name
		});
	}
}

var Camera$1 = Camera;

/* ../../components/ui/src/icons/feather/Cast.svelte generated by Svelte v3.59.2 */

const file$42 = "../../components/ui/src/icons/feather/Cast.svelte";

function create_fragment$46(ctx) {
	let path;
	let line;

	const block = {
		c: function create() {
			path = svg_element("path");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6");
			add_location(path, file$42, 1, 0, 34);
			attr_dev(line, "x1", "2");
			attr_dev(line, "y1", "20");
			attr_dev(line, "x2", "2.01");
			attr_dev(line, "y2", "20");
			add_location(line, file$42, 1, 125, 159);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$46.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$45($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Cast', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Cast> was created with unknown prop '${key}'`);
	});

	return [];
}

class Cast extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$45, create_fragment$46, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Cast",
			options,
			id: create_fragment$46.name
		});
	}
}

var Cast$1 = Cast;

/* ../../components/ui/src/icons/feather/CheckCircle.svelte generated by Svelte v3.59.2 */

const file$41 = "../../components/ui/src/icons/feather/CheckCircle.svelte";

function create_fragment$45(ctx) {
	let path;
	let polyline;

	const block = {
		c: function create() {
			path = svg_element("path");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M22 11.08V12a10 10 0 1 1-5.93-9.14");
			add_location(path, file$41, 1, 0, 34);
			attr_dev(polyline, "points", "22 4 12 14.01 9 11.01");
			add_location(polyline, file$41, 1, 52, 86);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, polyline, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(polyline);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$45.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$44($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('CheckCircle', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CheckCircle> was created with unknown prop '${key}'`);
	});

	return [];
}

class CheckCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$44, create_fragment$45, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CheckCircle",
			options,
			id: create_fragment$45.name
		});
	}
}

var CheckCircle$1 = CheckCircle;

/* ../../components/ui/src/icons/feather/Check.svelte generated by Svelte v3.59.2 */

const file$40 = "../../components/ui/src/icons/feather/Check.svelte";

function create_fragment$44(ctx) {
	let polyline;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "20 6 9 17 4 12");
			add_location(polyline, file$40, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$44.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$43($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Check', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Check> was created with unknown prop '${key}'`);
	});

	return [];
}

class Check extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$43, create_fragment$44, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Check",
			options,
			id: create_fragment$44.name
		});
	}
}

var Check$1 = Check;

/* ../../components/ui/src/icons/feather/ChevronsDown.svelte generated by Svelte v3.59.2 */

const file$3$ = "../../components/ui/src/icons/feather/ChevronsDown.svelte";

function create_fragment$43(ctx) {
	let polyline0;
	let polyline1;

	const block = {
		c: function create() {
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			polyline0 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline0).forEach(detach_dev);
			polyline1 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline0, "points", "7 13 12 18 17 13");
			add_location(polyline0, file$3$, 1, 0, 34);
			attr_dev(polyline1, "points", "7 6 12 11 17 6");
			add_location(polyline1, file$3$, 1, 47, 81);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline0, anchor);
			insert_hydration_dev(target, polyline1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline0);
			if (detaching) detach_dev(polyline1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$43.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$42($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ChevronsDown', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ChevronsDown> was created with unknown prop '${key}'`);
	});

	return [];
}

class ChevronsDown extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$42, create_fragment$43, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ChevronsDown",
			options,
			id: create_fragment$43.name
		});
	}
}

var ChevronsDown$1 = ChevronsDown;

/* ../../components/ui/src/icons/feather/ChevronsLeft.svelte generated by Svelte v3.59.2 */

const file$3_ = "../../components/ui/src/icons/feather/ChevronsLeft.svelte";

function create_fragment$42(ctx) {
	let polyline0;
	let polyline1;

	const block = {
		c: function create() {
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			polyline0 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline0).forEach(detach_dev);
			polyline1 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline0, "points", "11 17 6 12 11 7");
			add_location(polyline0, file$3_, 1, 0, 34);
			attr_dev(polyline1, "points", "18 17 13 12 18 7");
			add_location(polyline1, file$3_, 1, 46, 80);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline0, anchor);
			insert_hydration_dev(target, polyline1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline0);
			if (detaching) detach_dev(polyline1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$42.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$41($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ChevronsLeft', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ChevronsLeft> was created with unknown prop '${key}'`);
	});

	return [];
}

class ChevronsLeft extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$41, create_fragment$42, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ChevronsLeft",
			options,
			id: create_fragment$42.name
		});
	}
}

var ChevronsLeft$1 = ChevronsLeft;

/* ../../components/ui/src/icons/feather/ChevronsRight.svelte generated by Svelte v3.59.2 */

const file$3Z = "../../components/ui/src/icons/feather/ChevronsRight.svelte";

function create_fragment$41(ctx) {
	let polyline0;
	let polyline1;

	const block = {
		c: function create() {
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			polyline0 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline0).forEach(detach_dev);
			polyline1 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline0, "points", "13 17 18 12 13 7");
			add_location(polyline0, file$3Z, 1, 0, 34);
			attr_dev(polyline1, "points", "6 17 11 12 6 7");
			add_location(polyline1, file$3Z, 1, 47, 81);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline0, anchor);
			insert_hydration_dev(target, polyline1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline0);
			if (detaching) detach_dev(polyline1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$41.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$40($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ChevronsRight', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ChevronsRight> was created with unknown prop '${key}'`);
	});

	return [];
}

class ChevronsRight extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$40, create_fragment$41, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ChevronsRight",
			options,
			id: create_fragment$41.name
		});
	}
}

var ChevronsRight$1 = ChevronsRight;

/* ../../components/ui/src/icons/feather/ChevronsUp.svelte generated by Svelte v3.59.2 */

const file$3Y = "../../components/ui/src/icons/feather/ChevronsUp.svelte";

function create_fragment$40(ctx) {
	let polyline0;
	let polyline1;

	const block = {
		c: function create() {
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			polyline0 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline0).forEach(detach_dev);
			polyline1 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline0, "points", "17 11 12 6 7 11");
			add_location(polyline0, file$3Y, 1, 0, 34);
			attr_dev(polyline1, "points", "17 18 12 13 7 18");
			add_location(polyline1, file$3Y, 1, 46, 80);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline0, anchor);
			insert_hydration_dev(target, polyline1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline0);
			if (detaching) detach_dev(polyline1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$40.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3$($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ChevronsUp', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ChevronsUp> was created with unknown prop '${key}'`);
	});

	return [];
}

class ChevronsUp extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3$, create_fragment$40, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ChevronsUp",
			options,
			id: create_fragment$40.name
		});
	}
}

var ChevronsUp$1 = ChevronsUp;

/* ../../components/ui/src/icons/feather/Chrome.svelte generated by Svelte v3.59.2 */

const file$3X = "../../components/ui/src/icons/feather/Chrome.svelte";

function create_fragment$3$(ctx) {
	let circle0;
	let circle1;
	let line0;
	let line1;
	let line2;

	const block = {
		c: function create() {
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			circle0 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle0).forEach(detach_dev);
			circle1 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle1).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle0, "cx", "12");
			attr_dev(circle0, "cy", "12");
			attr_dev(circle0, "r", "10");
			add_location(circle0, file$3X, 1, 0, 34);
			attr_dev(circle1, "cx", "12");
			attr_dev(circle1, "cy", "12");
			attr_dev(circle1, "r", "4");
			add_location(circle1, file$3X, 1, 40, 74);
			attr_dev(line0, "x1", "21.17");
			attr_dev(line0, "y1", "8");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "8");
			add_location(line0, file$3X, 1, 79, 113);
			attr_dev(line1, "x1", "3.95");
			attr_dev(line1, "y1", "6.06");
			attr_dev(line1, "x2", "8.54");
			attr_dev(line1, "y2", "14");
			add_location(line1, file$3X, 1, 125, 159);
			attr_dev(line2, "x1", "10.88");
			attr_dev(line2, "y1", "21.94");
			attr_dev(line2, "x2", "15.46");
			attr_dev(line2, "y2", "14");
			add_location(line2, file$3X, 1, 176, 210);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle0, anchor);
			insert_hydration_dev(target, circle1, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle0);
			if (detaching) detach_dev(circle1);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3$.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3_($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Chrome', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Chrome> was created with unknown prop '${key}'`);
	});

	return [];
}

class Chrome extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3_, create_fragment$3$, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Chrome",
			options,
			id: create_fragment$3$.name
		});
	}
}

var Chrome$1 = Chrome;

/* ../../components/ui/src/icons/feather/Circle.svelte generated by Svelte v3.59.2 */

const file$3W = "../../components/ui/src/icons/feather/Circle.svelte";

function create_fragment$3_(ctx) {
	let circle;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$3W, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3_.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3Z($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Circle', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Circle> was created with unknown prop '${key}'`);
	});

	return [];
}

class Circle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3Z, create_fragment$3_, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Circle",
			options,
			id: create_fragment$3_.name
		});
	}
}

var Circle$1 = Circle;

/* ../../components/ui/src/icons/feather/CloudDrizzle.svelte generated by Svelte v3.59.2 */

const file$3V = "../../components/ui/src/icons/feather/CloudDrizzle.svelte";

function create_fragment$3Z(ctx) {
	let line0;
	let line1;
	let line2;
	let line3;
	let line4;
	let line5;
	let path;

	const block = {
		c: function create() {
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			line4 = svg_element("line");
			line5 = svg_element("line");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			line3 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line3).forEach(detach_dev);
			line4 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line4).forEach(detach_dev);
			line5 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line5).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line0, "x1", "8");
			attr_dev(line0, "y1", "19");
			attr_dev(line0, "x2", "8");
			attr_dev(line0, "y2", "21");
			add_location(line0, file$3V, 1, 0, 34);
			attr_dev(line1, "x1", "8");
			attr_dev(line1, "y1", "13");
			attr_dev(line1, "x2", "8");
			attr_dev(line1, "y2", "15");
			add_location(line1, file$3V, 1, 43, 77);
			attr_dev(line2, "x1", "16");
			attr_dev(line2, "y1", "19");
			attr_dev(line2, "x2", "16");
			attr_dev(line2, "y2", "21");
			add_location(line2, file$3V, 1, 86, 120);
			attr_dev(line3, "x1", "16");
			attr_dev(line3, "y1", "13");
			attr_dev(line3, "x2", "16");
			attr_dev(line3, "y2", "15");
			add_location(line3, file$3V, 1, 131, 165);
			attr_dev(line4, "x1", "12");
			attr_dev(line4, "y1", "21");
			attr_dev(line4, "x2", "12");
			attr_dev(line4, "y2", "23");
			add_location(line4, file$3V, 1, 176, 210);
			attr_dev(line5, "x1", "12");
			attr_dev(line5, "y1", "15");
			attr_dev(line5, "x2", "12");
			attr_dev(line5, "y2", "17");
			add_location(line5, file$3V, 1, 221, 255);
			attr_dev(path, "d", "M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25");
			add_location(path, file$3V, 1, 266, 300);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
			insert_hydration_dev(target, line3, anchor);
			insert_hydration_dev(target, line4, anchor);
			insert_hydration_dev(target, line5, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
			if (detaching) detach_dev(line3);
			if (detaching) detach_dev(line4);
			if (detaching) detach_dev(line5);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3Z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3Y($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('CloudDrizzle', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CloudDrizzle> was created with unknown prop '${key}'`);
	});

	return [];
}

class CloudDrizzle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3Y, create_fragment$3Z, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CloudDrizzle",
			options,
			id: create_fragment$3Z.name
		});
	}
}

var CloudDrizzle$1 = CloudDrizzle;

/* ../../components/ui/src/icons/feather/CloudLightning.svelte generated by Svelte v3.59.2 */

const file$3U = "../../components/ui/src/icons/feather/CloudLightning.svelte";

function create_fragment$3Y(ctx) {
	let path;
	let polyline;

	const block = {
		c: function create() {
			path = svg_element("path");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M19 16.9A5 5 0 0 0 18 7h-1.26a8 8 0 1 0-11.62 9");
			add_location(path, file$3U, 1, 0, 34);
			attr_dev(polyline, "points", "13 11 9 17 15 17 11 23");
			add_location(polyline, file$3U, 1, 65, 99);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, polyline, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(polyline);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3Y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3X($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('CloudLightning', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CloudLightning> was created with unknown prop '${key}'`);
	});

	return [];
}

class CloudLightning extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3X, create_fragment$3Y, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CloudLightning",
			options,
			id: create_fragment$3Y.name
		});
	}
}

var CloudLightning$1 = CloudLightning;

/* ../../components/ui/src/icons/feather/CloudOff.svelte generated by Svelte v3.59.2 */

const file$3T = "../../components/ui/src/icons/feather/CloudOff.svelte";

function create_fragment$3X(ctx) {
	let path;
	let line;

	const block = {
		c: function create() {
			path = svg_element("path");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3");
			add_location(path, file$3T, 1, 0, 34);
			attr_dev(line, "x1", "1");
			attr_dev(line, "y1", "1");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "23");
			add_location(line, file$3T, 1, 107, 141);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3X.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3W($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('CloudOff', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CloudOff> was created with unknown prop '${key}'`);
	});

	return [];
}

class CloudOff extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3W, create_fragment$3X, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CloudOff",
			options,
			id: create_fragment$3X.name
		});
	}
}

var CloudOff$1 = CloudOff;

/* ../../components/ui/src/icons/feather/CloudRain.svelte generated by Svelte v3.59.2 */

const file$3S = "../../components/ui/src/icons/feather/CloudRain.svelte";

function create_fragment$3W(ctx) {
	let line0;
	let line1;
	let line2;
	let path;

	const block = {
		c: function create() {
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line0, "x1", "16");
			attr_dev(line0, "y1", "13");
			attr_dev(line0, "x2", "16");
			attr_dev(line0, "y2", "21");
			add_location(line0, file$3S, 1, 0, 34);
			attr_dev(line1, "x1", "8");
			attr_dev(line1, "y1", "13");
			attr_dev(line1, "x2", "8");
			attr_dev(line1, "y2", "21");
			add_location(line1, file$3S, 1, 45, 79);
			attr_dev(line2, "x1", "12");
			attr_dev(line2, "y1", "15");
			attr_dev(line2, "x2", "12");
			attr_dev(line2, "y2", "23");
			add_location(line2, file$3S, 1, 88, 122);
			attr_dev(path, "d", "M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25");
			add_location(path, file$3S, 1, 133, 167);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3W.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3V($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('CloudRain', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CloudRain> was created with unknown prop '${key}'`);
	});

	return [];
}

class CloudRain extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3V, create_fragment$3W, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CloudRain",
			options,
			id: create_fragment$3W.name
		});
	}
}

var CloudRain$1 = CloudRain;

/* ../../components/ui/src/icons/feather/CloudSnow.svelte generated by Svelte v3.59.2 */

const file$3R = "../../components/ui/src/icons/feather/CloudSnow.svelte";

function create_fragment$3V(ctx) {
	let path;
	let line0;
	let line1;
	let line2;
	let line3;
	let line4;
	let line5;

	const block = {
		c: function create() {
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			line4 = svg_element("line");
			line5 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			line3 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line3).forEach(detach_dev);
			line4 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line4).forEach(detach_dev);
			line5 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line5).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M20 17.58A5 5 0 0 0 18 8h-1.26A8 8 0 1 0 4 16.25");
			add_location(path, file$3R, 1, 0, 34);
			attr_dev(line0, "x1", "8");
			attr_dev(line0, "y1", "16");
			attr_dev(line0, "x2", "8.01");
			attr_dev(line0, "y2", "16");
			add_location(line0, file$3R, 1, 66, 100);
			attr_dev(line1, "x1", "8");
			attr_dev(line1, "y1", "20");
			attr_dev(line1, "x2", "8.01");
			attr_dev(line1, "y2", "20");
			add_location(line1, file$3R, 1, 112, 146);
			attr_dev(line2, "x1", "12");
			attr_dev(line2, "y1", "18");
			attr_dev(line2, "x2", "12.01");
			attr_dev(line2, "y2", "18");
			add_location(line2, file$3R, 1, 158, 192);
			attr_dev(line3, "x1", "12");
			attr_dev(line3, "y1", "22");
			attr_dev(line3, "x2", "12.01");
			attr_dev(line3, "y2", "22");
			add_location(line3, file$3R, 1, 206, 240);
			attr_dev(line4, "x1", "16");
			attr_dev(line4, "y1", "16");
			attr_dev(line4, "x2", "16.01");
			attr_dev(line4, "y2", "16");
			add_location(line4, file$3R, 1, 254, 288);
			attr_dev(line5, "x1", "16");
			attr_dev(line5, "y1", "20");
			attr_dev(line5, "x2", "16.01");
			attr_dev(line5, "y2", "20");
			add_location(line5, file$3R, 1, 302, 336);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
			insert_hydration_dev(target, line3, anchor);
			insert_hydration_dev(target, line4, anchor);
			insert_hydration_dev(target, line5, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
			if (detaching) detach_dev(line3);
			if (detaching) detach_dev(line4);
			if (detaching) detach_dev(line5);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3V.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3U($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('CloudSnow', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CloudSnow> was created with unknown prop '${key}'`);
	});

	return [];
}

class CloudSnow extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3U, create_fragment$3V, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CloudSnow",
			options,
			id: create_fragment$3V.name
		});
	}
}

var CloudSnow$1 = CloudSnow;

/* ../../components/ui/src/icons/feather/Cloud.svelte generated by Svelte v3.59.2 */

const file$3Q = "../../components/ui/src/icons/feather/Cloud.svelte";

function create_fragment$3U(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z");
			add_location(path, file$3Q, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3U.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3T($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Cloud', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Cloud> was created with unknown prop '${key}'`);
	});

	return [];
}

class Cloud extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3T, create_fragment$3U, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Cloud",
			options,
			id: create_fragment$3U.name
		});
	}
}

var Cloud$1 = Cloud;

/* ../../components/ui/src/icons/feather/Code.svelte generated by Svelte v3.59.2 */

const file$3P = "../../components/ui/src/icons/feather/Code.svelte";

function create_fragment$3T(ctx) {
	let polyline0;
	let polyline1;

	const block = {
		c: function create() {
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			polyline0 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline0).forEach(detach_dev);
			polyline1 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline0, "points", "16 18 22 12 16 6");
			add_location(polyline0, file$3P, 1, 0, 34);
			attr_dev(polyline1, "points", "8 6 2 12 8 18");
			add_location(polyline1, file$3P, 1, 47, 81);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline0, anchor);
			insert_hydration_dev(target, polyline1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline0);
			if (detaching) detach_dev(polyline1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3T.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3S($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Code', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Code> was created with unknown prop '${key}'`);
	});

	return [];
}

class Code extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3S, create_fragment$3T, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Code",
			options,
			id: create_fragment$3T.name
		});
	}
}

var Code$1 = Code;

/* ../../components/ui/src/icons/feather/Codepen.svelte generated by Svelte v3.59.2 */

const file$3O = "../../components/ui/src/icons/feather/Codepen.svelte";

function create_fragment$3S(ctx) {
	let polygon;
	let line0;
	let polyline0;
	let polyline1;
	let line1;

	const block = {
		c: function create() {
			polygon = svg_element("polygon");
			line0 = svg_element("line");
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			polyline0 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline0).forEach(detach_dev);
			polyline1 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline1).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polygon, "points", "12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2");
			add_location(polygon, file$3O, 1, 0, 34);
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "22");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "15.5");
			add_location(line0, file$3O, 1, 72, 106);
			attr_dev(polyline0, "points", "22 8.5 12 15.5 2 8.5");
			add_location(polyline0, file$3O, 1, 119, 153);
			attr_dev(polyline1, "points", "2 15.5 12 8.5 22 15.5");
			add_location(polyline1, file$3O, 1, 170, 204);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "2");
			attr_dev(line1, "x2", "12");
			attr_dev(line1, "y2", "8.5");
			add_location(line1, file$3O, 1, 222, 256);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polygon, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, polyline0, anchor);
			insert_hydration_dev(target, polyline1, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polygon);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(polyline0);
			if (detaching) detach_dev(polyline1);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3S.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3R($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Codepen', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Codepen> was created with unknown prop '${key}'`);
	});

	return [];
}

class Codepen extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3R, create_fragment$3S, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Codepen",
			options,
			id: create_fragment$3S.name
		});
	}
}

var Codepen$1 = Codepen;

/* ../../components/ui/src/icons/feather/Codesandbox.svelte generated by Svelte v3.59.2 */

const file$3N = "../../components/ui/src/icons/feather/Codesandbox.svelte";

function create_fragment$3R(ctx) {
	let path;
	let polyline0;
	let polyline1;
	let polyline2;
	let polyline3;
	let line;

	const block = {
		c: function create() {
			path = svg_element("path");
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			polyline2 = svg_element("polyline");
			polyline3 = svg_element("polyline");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			polyline0 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline0).forEach(detach_dev);
			polyline1 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline1).forEach(detach_dev);
			polyline2 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline2).forEach(detach_dev);
			polyline3 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline3).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z");
			add_location(path, file$3N, 1, 0, 34);
			attr_dev(polyline0, "points", "7.5 4.21 12 6.81 16.5 4.21");
			add_location(polyline0, file$3N, 1, 139, 173);
			attr_dev(polyline1, "points", "7.5 19.79 7.5 14.6 3 12");
			add_location(polyline1, file$3N, 1, 196, 230);
			attr_dev(polyline2, "points", "21 12 16.5 14.6 16.5 19.79");
			add_location(polyline2, file$3N, 1, 250, 284);
			attr_dev(polyline3, "points", "3.27 6.96 12 12.01 20.73 6.96");
			add_location(polyline3, file$3N, 1, 307, 341);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "22.08");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "12");
			add_location(line, file$3N, 1, 367, 401);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, polyline0, anchor);
			insert_hydration_dev(target, polyline1, anchor);
			insert_hydration_dev(target, polyline2, anchor);
			insert_hydration_dev(target, polyline3, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(polyline0);
			if (detaching) detach_dev(polyline1);
			if (detaching) detach_dev(polyline2);
			if (detaching) detach_dev(polyline3);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3R.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3Q($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Codesandbox', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Codesandbox> was created with unknown prop '${key}'`);
	});

	return [];
}

class Codesandbox extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3Q, create_fragment$3R, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Codesandbox",
			options,
			id: create_fragment$3R.name
		});
	}
}

var Codesandbox$1 = Codesandbox;

/* ../../components/ui/src/icons/feather/Coffee.svelte generated by Svelte v3.59.2 */

const file$3M = "../../components/ui/src/icons/feather/Coffee.svelte";

function create_fragment$3Q(ctx) {
	let path0;
	let path1;
	let line0;
	let line1;
	let line2;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M18 8h1a4 4 0 0 1 0 8h-1");
			add_location(path0, file$3M, 1, 0, 34);
			attr_dev(path1, "d", "M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z");
			add_location(path1, file$3M, 1, 42, 76);
			attr_dev(line0, "x1", "6");
			attr_dev(line0, "y1", "1");
			attr_dev(line0, "x2", "6");
			attr_dev(line0, "y2", "4");
			add_location(line0, file$3M, 1, 102, 136);
			attr_dev(line1, "x1", "10");
			attr_dev(line1, "y1", "1");
			attr_dev(line1, "x2", "10");
			attr_dev(line1, "y2", "4");
			add_location(line1, file$3M, 1, 143, 177);
			attr_dev(line2, "x1", "14");
			attr_dev(line2, "y1", "1");
			attr_dev(line2, "x2", "14");
			attr_dev(line2, "y2", "4");
			add_location(line2, file$3M, 1, 186, 220);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3Q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3P($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Coffee', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Coffee> was created with unknown prop '${key}'`);
	});

	return [];
}

class Coffee extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3P, create_fragment$3Q, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Coffee",
			options,
			id: create_fragment$3Q.name
		});
	}
}

var Coffee$1 = Coffee;

/* ../../components/ui/src/icons/feather/Columns.svelte generated by Svelte v3.59.2 */

const file$3L = "../../components/ui/src/icons/feather/Columns.svelte";

function create_fragment$3P(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18");
			add_location(path, file$3L, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3P.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3O($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Columns', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Columns> was created with unknown prop '${key}'`);
	});

	return [];
}

class Columns extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3O, create_fragment$3P, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Columns",
			options,
			id: create_fragment$3P.name
		});
	}
}

var Columns$1 = Columns;

/* ../../components/ui/src/icons/feather/Command.svelte generated by Svelte v3.59.2 */

const file$3K = "../../components/ui/src/icons/feather/Command.svelte";

function create_fragment$3O(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z");
			add_location(path, file$3K, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3O.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3N($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Command', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Command> was created with unknown prop '${key}'`);
	});

	return [];
}

class Command extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3N, create_fragment$3O, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Command",
			options,
			id: create_fragment$3O.name
		});
	}
}

var Command$1 = Command;

/* ../../components/ui/src/icons/feather/Compass.svelte generated by Svelte v3.59.2 */

const file$3J = "../../components/ui/src/icons/feather/Compass.svelte";

function create_fragment$3N(ctx) {
	let circle;
	let polygon;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			polygon = svg_element("polygon");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$3J, 1, 0, 34);
			attr_dev(polygon, "points", "16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76");
			add_location(polygon, file$3J, 1, 40, 74);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, polygon, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(polygon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3N.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3M($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Compass', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Compass> was created with unknown prop '${key}'`);
	});

	return [];
}

class Compass extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3M, create_fragment$3N, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Compass",
			options,
			id: create_fragment$3N.name
		});
	}
}

var Compass$1 = Compass;

/* ../../components/ui/src/icons/feather/CornerDownLeft.svelte generated by Svelte v3.59.2 */

const file$3I = "../../components/ui/src/icons/feather/CornerDownLeft.svelte";

function create_fragment$3M(ctx) {
	let polyline;
	let path;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "9 10 4 15 9 20");
			add_location(polyline, file$3I, 1, 0, 34);
			attr_dev(path, "d", "M20 4v7a4 4 0 0 1-4 4H4");
			add_location(path, file$3I, 1, 45, 79);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3M.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3L($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('CornerDownLeft', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CornerDownLeft> was created with unknown prop '${key}'`);
	});

	return [];
}

class CornerDownLeft extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3L, create_fragment$3M, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CornerDownLeft",
			options,
			id: create_fragment$3M.name
		});
	}
}

var CornerDownLeft$1 = CornerDownLeft;

/* ../../components/ui/src/icons/feather/CornerDownRight.svelte generated by Svelte v3.59.2 */

const file$3H = "../../components/ui/src/icons/feather/CornerDownRight.svelte";

function create_fragment$3L(ctx) {
	let polyline;
	let path;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "15 10 20 15 15 20");
			add_location(polyline, file$3H, 1, 0, 34);
			attr_dev(path, "d", "M4 4v7a4 4 0 0 0 4 4h12");
			add_location(path, file$3H, 1, 48, 82);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3L.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3K($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('CornerDownRight', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CornerDownRight> was created with unknown prop '${key}'`);
	});

	return [];
}

class CornerDownRight extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3K, create_fragment$3L, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CornerDownRight",
			options,
			id: create_fragment$3L.name
		});
	}
}

var CornerDownRight$1 = CornerDownRight;

/* ../../components/ui/src/icons/feather/CornerLeftDown.svelte generated by Svelte v3.59.2 */

const file$3G = "../../components/ui/src/icons/feather/CornerLeftDown.svelte";

function create_fragment$3K(ctx) {
	let polyline;
	let path;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "14 15 9 20 4 15");
			add_location(polyline, file$3G, 1, 0, 34);
			attr_dev(path, "d", "M20 4h-7a4 4 0 0 0-4 4v12");
			add_location(path, file$3G, 1, 46, 80);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3K.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3J($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('CornerLeftDown', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CornerLeftDown> was created with unknown prop '${key}'`);
	});

	return [];
}

class CornerLeftDown extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3J, create_fragment$3K, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CornerLeftDown",
			options,
			id: create_fragment$3K.name
		});
	}
}

var CornerLeftDown$1 = CornerLeftDown;

/* ../../components/ui/src/icons/feather/CornerLeftUp.svelte generated by Svelte v3.59.2 */

const file$3F = "../../components/ui/src/icons/feather/CornerLeftUp.svelte";

function create_fragment$3J(ctx) {
	let polyline;
	let path;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "14 9 9 4 4 9");
			add_location(polyline, file$3F, 1, 0, 34);
			attr_dev(path, "d", "M20 20h-7a4 4 0 0 1-4-4V4");
			add_location(path, file$3F, 1, 43, 77);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3J.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3I($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('CornerLeftUp', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CornerLeftUp> was created with unknown prop '${key}'`);
	});

	return [];
}

class CornerLeftUp extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3I, create_fragment$3J, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CornerLeftUp",
			options,
			id: create_fragment$3J.name
		});
	}
}

var CornerLeftUp$1 = CornerLeftUp;

/* ../../components/ui/src/icons/feather/CornerRightDown.svelte generated by Svelte v3.59.2 */

const file$3E = "../../components/ui/src/icons/feather/CornerRightDown.svelte";

function create_fragment$3I(ctx) {
	let polyline;
	let path;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "10 15 15 20 20 15");
			add_location(polyline, file$3E, 1, 0, 34);
			attr_dev(path, "d", "M4 4h7a4 4 0 0 1 4 4v12");
			add_location(path, file$3E, 1, 48, 82);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3I.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3H($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('CornerRightDown', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CornerRightDown> was created with unknown prop '${key}'`);
	});

	return [];
}

class CornerRightDown extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3H, create_fragment$3I, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CornerRightDown",
			options,
			id: create_fragment$3I.name
		});
	}
}

var CornerRightDown$1 = CornerRightDown;

/* ../../components/ui/src/icons/feather/CornerRightUp.svelte generated by Svelte v3.59.2 */

const file$3D = "../../components/ui/src/icons/feather/CornerRightUp.svelte";

function create_fragment$3H(ctx) {
	let polyline;
	let path;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "10 9 15 4 20 9");
			add_location(polyline, file$3D, 1, 0, 34);
			attr_dev(path, "d", "M4 20h7a4 4 0 0 0 4-4V4");
			add_location(path, file$3D, 1, 45, 79);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3H.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3G($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('CornerRightUp', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CornerRightUp> was created with unknown prop '${key}'`);
	});

	return [];
}

class CornerRightUp extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3G, create_fragment$3H, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CornerRightUp",
			options,
			id: create_fragment$3H.name
		});
	}
}

var CornerRightUp$1 = CornerRightUp;

/* ../../components/ui/src/icons/feather/CornerUpLeft.svelte generated by Svelte v3.59.2 */

const file$3C = "../../components/ui/src/icons/feather/CornerUpLeft.svelte";

function create_fragment$3G(ctx) {
	let polyline;
	let path;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "9 14 4 9 9 4");
			add_location(polyline, file$3C, 1, 0, 34);
			attr_dev(path, "d", "M20 20v-7a4 4 0 0 0-4-4H4");
			add_location(path, file$3C, 1, 43, 77);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3G.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3F($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('CornerUpLeft', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CornerUpLeft> was created with unknown prop '${key}'`);
	});

	return [];
}

class CornerUpLeft extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3F, create_fragment$3G, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CornerUpLeft",
			options,
			id: create_fragment$3G.name
		});
	}
}

var CornerUpLeft$1 = CornerUpLeft;

/* ../../components/ui/src/icons/feather/CornerUpRight.svelte generated by Svelte v3.59.2 */

const file$3B = "../../components/ui/src/icons/feather/CornerUpRight.svelte";

function create_fragment$3F(ctx) {
	let polyline;
	let path;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "15 14 20 9 15 4");
			add_location(polyline, file$3B, 1, 0, 34);
			attr_dev(path, "d", "M4 20v-7a4 4 0 0 1 4-4h12");
			add_location(path, file$3B, 1, 46, 80);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3F.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3E($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('CornerUpRight', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CornerUpRight> was created with unknown prop '${key}'`);
	});

	return [];
}

class CornerUpRight extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3E, create_fragment$3F, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CornerUpRight",
			options,
			id: create_fragment$3F.name
		});
	}
}

var CornerUpRight$1 = CornerUpRight;

/* ../../components/ui/src/icons/feather/Cpu.svelte generated by Svelte v3.59.2 */

const file$3A = "../../components/ui/src/icons/feather/Cpu.svelte";

function create_fragment$3E(ctx) {
	let rect0;
	let rect1;
	let line0;
	let line1;
	let line2;
	let line3;
	let line4;
	let line5;
	let line6;
	let line7;

	const block = {
		c: function create() {
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			line4 = svg_element("line");
			line5 = svg_element("line");
			line6 = svg_element("line");
			line7 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			rect0 = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect0).forEach(detach_dev);

			rect1 = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true
			});

			children(rect1).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			line3 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line3).forEach(detach_dev);
			line4 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line4).forEach(detach_dev);
			line5 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line5).forEach(detach_dev);
			line6 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line6).forEach(detach_dev);
			line7 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line7).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect0, "x", "4");
			attr_dev(rect0, "y", "4");
			attr_dev(rect0, "width", "16");
			attr_dev(rect0, "height", "16");
			attr_dev(rect0, "rx", "2");
			attr_dev(rect0, "ry", "2");
			add_location(rect0, file$3A, 1, 0, 34);
			attr_dev(rect1, "x", "9");
			attr_dev(rect1, "y", "9");
			attr_dev(rect1, "width", "6");
			attr_dev(rect1, "height", "6");
			add_location(rect1, file$3A, 1, 62, 96);
			attr_dev(line0, "x1", "9");
			attr_dev(line0, "y1", "1");
			attr_dev(line0, "x2", "9");
			attr_dev(line0, "y2", "4");
			add_location(line0, file$3A, 1, 108, 142);
			attr_dev(line1, "x1", "15");
			attr_dev(line1, "y1", "1");
			attr_dev(line1, "x2", "15");
			attr_dev(line1, "y2", "4");
			add_location(line1, file$3A, 1, 149, 183);
			attr_dev(line2, "x1", "9");
			attr_dev(line2, "y1", "20");
			attr_dev(line2, "x2", "9");
			attr_dev(line2, "y2", "23");
			add_location(line2, file$3A, 1, 192, 226);
			attr_dev(line3, "x1", "15");
			attr_dev(line3, "y1", "20");
			attr_dev(line3, "x2", "15");
			attr_dev(line3, "y2", "23");
			add_location(line3, file$3A, 1, 235, 269);
			attr_dev(line4, "x1", "20");
			attr_dev(line4, "y1", "9");
			attr_dev(line4, "x2", "23");
			attr_dev(line4, "y2", "9");
			add_location(line4, file$3A, 1, 280, 314);
			attr_dev(line5, "x1", "20");
			attr_dev(line5, "y1", "14");
			attr_dev(line5, "x2", "23");
			attr_dev(line5, "y2", "14");
			add_location(line5, file$3A, 1, 323, 357);
			attr_dev(line6, "x1", "1");
			attr_dev(line6, "y1", "9");
			attr_dev(line6, "x2", "4");
			attr_dev(line6, "y2", "9");
			add_location(line6, file$3A, 1, 368, 402);
			attr_dev(line7, "x1", "1");
			attr_dev(line7, "y1", "14");
			attr_dev(line7, "x2", "4");
			attr_dev(line7, "y2", "14");
			add_location(line7, file$3A, 1, 409, 443);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect0, anchor);
			insert_hydration_dev(target, rect1, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
			insert_hydration_dev(target, line3, anchor);
			insert_hydration_dev(target, line4, anchor);
			insert_hydration_dev(target, line5, anchor);
			insert_hydration_dev(target, line6, anchor);
			insert_hydration_dev(target, line7, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect0);
			if (detaching) detach_dev(rect1);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
			if (detaching) detach_dev(line3);
			if (detaching) detach_dev(line4);
			if (detaching) detach_dev(line5);
			if (detaching) detach_dev(line6);
			if (detaching) detach_dev(line7);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3E.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3D($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Cpu', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Cpu> was created with unknown prop '${key}'`);
	});

	return [];
}

class Cpu extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3D, create_fragment$3E, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Cpu",
			options,
			id: create_fragment$3E.name
		});
	}
}

var Cpu$1 = Cpu;

/* ../../components/ui/src/icons/feather/CreditCard.svelte generated by Svelte v3.59.2 */

const file$3z = "../../components/ui/src/icons/feather/CreditCard.svelte";

function create_fragment$3D(ctx) {
	let rect;
	let line;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "1");
			attr_dev(rect, "y", "4");
			attr_dev(rect, "width", "22");
			attr_dev(rect, "height", "16");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$3z, 1, 0, 34);
			attr_dev(line, "x1", "1");
			attr_dev(line, "y1", "10");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "10");
			add_location(line, file$3z, 1, 62, 96);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3D.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3C($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('CreditCard', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CreditCard> was created with unknown prop '${key}'`);
	});

	return [];
}

class CreditCard extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3C, create_fragment$3D, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "CreditCard",
			options,
			id: create_fragment$3D.name
		});
	}
}

var CreditCard$1 = CreditCard;

/* ../../components/ui/src/icons/feather/Crop.svelte generated by Svelte v3.59.2 */

const file$3y = "../../components/ui/src/icons/feather/Crop.svelte";

function create_fragment$3C(ctx) {
	let path0;
	let path1;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M6.13 1L6 16a2 2 0 0 0 2 2h15");
			add_location(path0, file$3y, 1, 0, 34);
			attr_dev(path1, "d", "M1 6.13L16 6a2 2 0 0 1 2 2v15");
			add_location(path1, file$3y, 1, 47, 81);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3C.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3B($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Crop', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Crop> was created with unknown prop '${key}'`);
	});

	return [];
}

class Crop extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3B, create_fragment$3C, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Crop",
			options,
			id: create_fragment$3C.name
		});
	}
}

var Crop$1 = Crop;

/* ../../components/ui/src/icons/feather/Crosshair.svelte generated by Svelte v3.59.2 */

const file$3x = "../../components/ui/src/icons/feather/Crosshair.svelte";

function create_fragment$3B(ctx) {
	let circle;
	let line0;
	let line1;
	let line2;
	let line3;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			line3 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line3).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$3x, 1, 0, 34);
			attr_dev(line0, "x1", "22");
			attr_dev(line0, "y1", "12");
			attr_dev(line0, "x2", "18");
			attr_dev(line0, "y2", "12");
			add_location(line0, file$3x, 1, 40, 74);
			attr_dev(line1, "x1", "6");
			attr_dev(line1, "y1", "12");
			attr_dev(line1, "x2", "2");
			attr_dev(line1, "y2", "12");
			add_location(line1, file$3x, 1, 85, 119);
			attr_dev(line2, "x1", "12");
			attr_dev(line2, "y1", "6");
			attr_dev(line2, "x2", "12");
			attr_dev(line2, "y2", "2");
			add_location(line2, file$3x, 1, 128, 162);
			attr_dev(line3, "x1", "12");
			attr_dev(line3, "y1", "22");
			attr_dev(line3, "x2", "12");
			attr_dev(line3, "y2", "18");
			add_location(line3, file$3x, 1, 171, 205);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
			insert_hydration_dev(target, line3, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
			if (detaching) detach_dev(line3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3B.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3A($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Crosshair', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Crosshair> was created with unknown prop '${key}'`);
	});

	return [];
}

class Crosshair extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3A, create_fragment$3B, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Crosshair",
			options,
			id: create_fragment$3B.name
		});
	}
}

var Crosshair$1 = Crosshair;

/* ../../components/ui/src/icons/feather/Database.svelte generated by Svelte v3.59.2 */

const file$3w = "../../components/ui/src/icons/feather/Database.svelte";

function create_fragment$3A(ctx) {
	let ellipse;
	let path0;
	let path1;

	const block = {
		c: function create() {
			ellipse = svg_element("ellipse");
			path0 = svg_element("path");
			path1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			ellipse = claim_svg_element(nodes, "ellipse", { cx: true, cy: true, rx: true, ry: true });
			children(ellipse).forEach(detach_dev);
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ellipse, "cx", "12");
			attr_dev(ellipse, "cy", "5");
			attr_dev(ellipse, "rx", "9");
			attr_dev(ellipse, "ry", "3");
			add_location(ellipse, file$3w, 1, 0, 34);
			attr_dev(path0, "d", "M21 12c0 1.66-4 3-9 3s-9-1.34-9-3");
			add_location(path0, file$3w, 1, 48, 82);
			attr_dev(path1, "d", "M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5");
			add_location(path1, file$3w, 1, 99, 133);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, ellipse, anchor);
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(ellipse);
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3A.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3z($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Database', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Database> was created with unknown prop '${key}'`);
	});

	return [];
}

class Database extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3z, create_fragment$3A, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Database",
			options,
			id: create_fragment$3A.name
		});
	}
}

var Database$1 = Database;

/* ../../components/ui/src/icons/feather/Delete.svelte generated by Svelte v3.59.2 */

const file$3v = "../../components/ui/src/icons/feather/Delete.svelte";

function create_fragment$3z(ctx) {
	let path;
	let line0;
	let line1;

	const block = {
		c: function create() {
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z");
			add_location(path, file$3v, 1, 0, 34);
			attr_dev(line0, "x1", "18");
			attr_dev(line0, "y1", "9");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "15");
			add_location(line0, file$3v, 1, 68, 102);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "9");
			attr_dev(line1, "x2", "18");
			attr_dev(line1, "y2", "15");
			add_location(line1, file$3v, 1, 112, 146);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3y($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Delete', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Delete> was created with unknown prop '${key}'`);
	});

	return [];
}

class Delete extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3y, create_fragment$3z, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Delete",
			options,
			id: create_fragment$3z.name
		});
	}
}

var Delete$1 = Delete;

/* ../../components/ui/src/icons/feather/Disc.svelte generated by Svelte v3.59.2 */

const file$3u = "../../components/ui/src/icons/feather/Disc.svelte";

function create_fragment$3y(ctx) {
	let circle0;
	let circle1;

	const block = {
		c: function create() {
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			this.h();
		},
		l: function claim(nodes) {
			circle0 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle0).forEach(detach_dev);
			circle1 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle0, "cx", "12");
			attr_dev(circle0, "cy", "12");
			attr_dev(circle0, "r", "10");
			add_location(circle0, file$3u, 1, 0, 34);
			attr_dev(circle1, "cx", "12");
			attr_dev(circle1, "cy", "12");
			attr_dev(circle1, "r", "3");
			add_location(circle1, file$3u, 1, 40, 74);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle0, anchor);
			insert_hydration_dev(target, circle1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle0);
			if (detaching) detach_dev(circle1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3x($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Disc', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Disc> was created with unknown prop '${key}'`);
	});

	return [];
}

class Disc extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3x, create_fragment$3y, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Disc",
			options,
			id: create_fragment$3y.name
		});
	}
}

var Disc$1 = Disc;

/* ../../components/ui/src/icons/feather/DivideCircle.svelte generated by Svelte v3.59.2 */

const file$3t = "../../components/ui/src/icons/feather/DivideCircle.svelte";

function create_fragment$3x(ctx) {
	let line0;
	let line1;
	let line2;
	let circle;

	const block = {
		c: function create() {
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			circle = svg_element("circle");
			this.h();
		},
		l: function claim(nodes) {
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line0, "x1", "8");
			attr_dev(line0, "y1", "12");
			attr_dev(line0, "x2", "16");
			attr_dev(line0, "y2", "12");
			add_location(line0, file$3t, 1, 0, 34);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "16");
			attr_dev(line1, "x2", "12");
			attr_dev(line1, "y2", "16");
			add_location(line1, file$3t, 1, 44, 78);
			attr_dev(line2, "x1", "12");
			attr_dev(line2, "y1", "8");
			attr_dev(line2, "x2", "12");
			attr_dev(line2, "y2", "8");
			add_location(line2, file$3t, 1, 89, 123);
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$3t, 1, 132, 166);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
			insert_hydration_dev(target, circle, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
			if (detaching) detach_dev(circle);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3x.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3w($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('DivideCircle', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DivideCircle> was created with unknown prop '${key}'`);
	});

	return [];
}

class DivideCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3w, create_fragment$3x, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DivideCircle",
			options,
			id: create_fragment$3x.name
		});
	}
}

var DivideCircle$1 = DivideCircle;

/* ../../components/ui/src/icons/feather/DivideSquare.svelte generated by Svelte v3.59.2 */

const file$3s = "../../components/ui/src/icons/feather/DivideSquare.svelte";

function create_fragment$3w(ctx) {
	let rect;
	let line0;
	let line1;
	let line2;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "3");
			attr_dev(rect, "y", "3");
			attr_dev(rect, "width", "18");
			attr_dev(rect, "height", "18");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$3s, 1, 0, 34);
			attr_dev(line0, "x1", "8");
			attr_dev(line0, "y1", "12");
			attr_dev(line0, "x2", "16");
			attr_dev(line0, "y2", "12");
			add_location(line0, file$3s, 1, 62, 96);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "16");
			attr_dev(line1, "x2", "12");
			attr_dev(line1, "y2", "16");
			add_location(line1, file$3s, 1, 106, 140);
			attr_dev(line2, "x1", "12");
			attr_dev(line2, "y1", "8");
			attr_dev(line2, "x2", "12");
			attr_dev(line2, "y2", "8");
			add_location(line2, file$3s, 1, 151, 185);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3w.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3v($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('DivideSquare', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DivideSquare> was created with unknown prop '${key}'`);
	});

	return [];
}

class DivideSquare extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3v, create_fragment$3w, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DivideSquare",
			options,
			id: create_fragment$3w.name
		});
	}
}

var DivideSquare$1 = DivideSquare;

/* ../../components/ui/src/icons/feather/Divide.svelte generated by Svelte v3.59.2 */

const file$3r = "../../components/ui/src/icons/feather/Divide.svelte";

function create_fragment$3v(ctx) {
	let circle0;
	let line;
	let circle1;

	const block = {
		c: function create() {
			circle0 = svg_element("circle");
			line = svg_element("line");
			circle1 = svg_element("circle");
			this.h();
		},
		l: function claim(nodes) {
			circle0 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle0).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			circle1 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle0, "cx", "12");
			attr_dev(circle0, "cy", "6");
			attr_dev(circle0, "r", "2");
			add_location(circle0, file$3r, 1, 0, 34);
			attr_dev(line, "x1", "5");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "19");
			attr_dev(line, "y2", "12");
			add_location(line, file$3r, 1, 38, 72);
			attr_dev(circle1, "cx", "12");
			attr_dev(circle1, "cy", "18");
			attr_dev(circle1, "r", "2");
			add_location(circle1, file$3r, 1, 82, 116);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle0, anchor);
			insert_hydration_dev(target, line, anchor);
			insert_hydration_dev(target, circle1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle0);
			if (detaching) detach_dev(line);
			if (detaching) detach_dev(circle1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3v.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3u($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Divide', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Divide> was created with unknown prop '${key}'`);
	});

	return [];
}

class Divide extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3u, create_fragment$3v, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Divide",
			options,
			id: create_fragment$3v.name
		});
	}
}

var Divide$1 = Divide;

/* ../../components/ui/src/icons/feather/DollarSign.svelte generated by Svelte v3.59.2 */

const file$3q = "../../components/ui/src/icons/feather/DollarSign.svelte";

function create_fragment$3u(ctx) {
	let line;
	let path;

	const block = {
		c: function create() {
			line = svg_element("line");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "1");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "23");
			add_location(line, file$3q, 1, 0, 34);
			attr_dev(path, "d", "M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6");
			add_location(path, file$3q, 1, 44, 78);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3u.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3t($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('DollarSign', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DollarSign> was created with unknown prop '${key}'`);
	});

	return [];
}

class DollarSign extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3t, create_fragment$3u, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DollarSign",
			options,
			id: create_fragment$3u.name
		});
	}
}

var DollarSign$1 = DollarSign;

/* ../../components/ui/src/icons/feather/DownloadCloud.svelte generated by Svelte v3.59.2 */

const file$3p = "../../components/ui/src/icons/feather/DownloadCloud.svelte";

function create_fragment$3t(ctx) {
	let polyline;
	let line;
	let path;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			line = svg_element("line");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "8 17 12 21 16 17");
			add_location(polyline, file$3p, 1, 0, 34);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "21");
			add_location(line, file$3p, 1, 47, 81);
			attr_dev(path, "d", "M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29");
			add_location(path, file$3p, 1, 92, 126);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, line, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(line);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3t.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3s($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('DownloadCloud', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DownloadCloud> was created with unknown prop '${key}'`);
	});

	return [];
}

class DownloadCloud extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3s, create_fragment$3t, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DownloadCloud",
			options,
			id: create_fragment$3t.name
		});
	}
}

var DownloadCloud$1 = DownloadCloud;

/* ../../components/ui/src/icons/feather/Dribbble.svelte generated by Svelte v3.59.2 */

const file$3o = "../../components/ui/src/icons/feather/Dribbble.svelte";

function create_fragment$3s(ctx) {
	let circle;
	let path;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$3o, 1, 0, 34);
			attr_dev(path, "d", "M8.56 2.75c4.37 6.03 6.02 9.42 8.03 17.72m2.54-15.38c-3.72 4.35-8.94 5.66-16.88 5.85m19.5 1.9c-3.5-.93-6.63-.82-8.94 0-2.58.92-5.01 2.86-7.44 6.32");
			add_location(path, file$3o, 1, 40, 74);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3s.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3r($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Dribbble', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Dribbble> was created with unknown prop '${key}'`);
	});

	return [];
}

class Dribbble extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3r, create_fragment$3s, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Dribbble",
			options,
			id: create_fragment$3s.name
		});
	}
}

var Dribbble$1 = Dribbble;

/* ../../components/ui/src/icons/feather/Droplet.svelte generated by Svelte v3.59.2 */

const file$3n = "../../components/ui/src/icons/feather/Droplet.svelte";

function create_fragment$3r(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z");
			add_location(path, file$3n, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3r.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3q($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Droplet', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Droplet> was created with unknown prop '${key}'`);
	});

	return [];
}

class Droplet extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3q, create_fragment$3r, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Droplet",
			options,
			id: create_fragment$3r.name
		});
	}
}

var Droplet$1 = Droplet;

/* ../../components/ui/src/icons/feather/Edit2.svelte generated by Svelte v3.59.2 */

const file$3m = "../../components/ui/src/icons/feather/Edit2.svelte";

function create_fragment$3q(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z");
			add_location(path, file$3m, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3p($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Edit2', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Edit2> was created with unknown prop '${key}'`);
	});

	return [];
}

class Edit2 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3p, create_fragment$3q, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Edit2",
			options,
			id: create_fragment$3q.name
		});
	}
}

var Edit2$1 = Edit2;

/* ../../components/ui/src/icons/feather/Edit3.svelte generated by Svelte v3.59.2 */

const file$3l = "../../components/ui/src/icons/feather/Edit3.svelte";

function create_fragment$3p(ctx) {
	let path0;
	let path1;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M12 20h9");
			add_location(path0, file$3l, 1, 0, 34);
			attr_dev(path1, "d", "M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z");
			add_location(path1, file$3l, 1, 26, 60);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3p.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3o($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Edit3', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Edit3> was created with unknown prop '${key}'`);
	});

	return [];
}

class Edit3 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3o, create_fragment$3p, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Edit3",
			options,
			id: create_fragment$3p.name
		});
	}
}

var Edit3$1 = Edit3;

/* ../../components/ui/src/icons/feather/Edit.svelte generated by Svelte v3.59.2 */

const file$3k = "../../components/ui/src/icons/feather/Edit.svelte";

function create_fragment$3o(ctx) {
	let path0;
	let path1;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7");
			add_location(path0, file$3k, 1, 0, 34);
			attr_dev(path1, "d", "M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z");
			add_location(path1, file$3k, 1, 76, 110);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3o.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3n($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Edit', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Edit> was created with unknown prop '${key}'`);
	});

	return [];
}

class Edit extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3n, create_fragment$3o, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Edit",
			options,
			id: create_fragment$3o.name
		});
	}
}

var Edit$1 = Edit;

/* ../../components/ui/src/icons/feather/EyeOff.svelte generated by Svelte v3.59.2 */

const file$3j = "../../components/ui/src/icons/feather/EyeOff.svelte";

function create_fragment$3n(ctx) {
	let path;
	let line;

	const block = {
		c: function create() {
			path = svg_element("path");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24");
			add_location(path, file$3j, 1, 0, 34);
			attr_dev(line, "x1", "1");
			attr_dev(line, "y1", "1");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "23");
			add_location(line, file$3j, 1, 198, 232);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3n.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3m($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('EyeOff', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EyeOff> was created with unknown prop '${key}'`);
	});

	return [];
}

class EyeOff extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3m, create_fragment$3n, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "EyeOff",
			options,
			id: create_fragment$3n.name
		});
	}
}

var EyeOff$1 = EyeOff;

/* ../../components/ui/src/icons/feather/Eye.svelte generated by Svelte v3.59.2 */

const file$3i = "../../components/ui/src/icons/feather/Eye.svelte";

function create_fragment$3m(ctx) {
	let path;
	let circle;

	const block = {
		c: function create() {
			path = svg_element("path");
			circle = svg_element("circle");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z");
			add_location(path, file$3i, 1, 0, 34);
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "3");
			add_location(circle, file$3i, 1, 62, 96);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, circle, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(circle);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3m.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3l($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Eye', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Eye> was created with unknown prop '${key}'`);
	});

	return [];
}

class Eye extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3l, create_fragment$3m, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Eye",
			options,
			id: create_fragment$3m.name
		});
	}
}

var Eye$1 = Eye;

/* ../../components/ui/src/icons/feather/Facebook.svelte generated by Svelte v3.59.2 */

const file$3h = "../../components/ui/src/icons/feather/Facebook.svelte";

function create_fragment$3l(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z");
			add_location(path, file$3h, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3l.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3k($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Facebook', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Facebook> was created with unknown prop '${key}'`);
	});

	return [];
}

class Facebook extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3k, create_fragment$3l, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Facebook",
			options,
			id: create_fragment$3l.name
		});
	}
}

var Facebook$1 = Facebook;

/* ../../components/ui/src/icons/feather/FastForward.svelte generated by Svelte v3.59.2 */

const file$3g = "../../components/ui/src/icons/feather/FastForward.svelte";

function create_fragment$3k(ctx) {
	let polygon0;
	let polygon1;

	const block = {
		c: function create() {
			polygon0 = svg_element("polygon");
			polygon1 = svg_element("polygon");
			this.h();
		},
		l: function claim(nodes) {
			polygon0 = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon0).forEach(detach_dev);
			polygon1 = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polygon0, "points", "13 19 22 12 13 5 13 19");
			add_location(polygon0, file$3g, 1, 0, 34);
			attr_dev(polygon1, "points", "2 19 11 12 2 5 2 19");
			add_location(polygon1, file$3g, 1, 51, 85);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polygon0, anchor);
			insert_hydration_dev(target, polygon1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polygon0);
			if (detaching) detach_dev(polygon1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3j($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('FastForward', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FastForward> was created with unknown prop '${key}'`);
	});

	return [];
}

class FastForward extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3j, create_fragment$3k, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FastForward",
			options,
			id: create_fragment$3k.name
		});
	}
}

var FastForward$1 = FastForward;

/* ../../components/ui/src/icons/feather/Feather.svelte generated by Svelte v3.59.2 */

const file$3f = "../../components/ui/src/icons/feather/Feather.svelte";

function create_fragment$3j(ctx) {
	let path;
	let line0;
	let line1;

	const block = {
		c: function create() {
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z");
			add_location(path, file$3f, 1, 0, 34);
			attr_dev(line0, "x1", "16");
			attr_dev(line0, "y1", "8");
			attr_dev(line0, "x2", "2");
			attr_dev(line0, "y2", "22");
			add_location(line0, file$3f, 1, 65, 99);
			attr_dev(line1, "x1", "17.5");
			attr_dev(line1, "y1", "15");
			attr_dev(line1, "x2", "9");
			attr_dev(line1, "y2", "15");
			add_location(line1, file$3f, 1, 108, 142);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3i($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Feather', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Feather> was created with unknown prop '${key}'`);
	});

	return [];
}

class Feather extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3i, create_fragment$3j, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Feather",
			options,
			id: create_fragment$3j.name
		});
	}
}

var Feather$1 = Feather;

/* ../../components/ui/src/icons/feather/Figma.svelte generated by Svelte v3.59.2 */

const file$3e = "../../components/ui/src/icons/feather/Figma.svelte";

function create_fragment$3i(ctx) {
	let path0;
	let path1;
	let path2;
	let path3;
	let path4;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			path4 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			path2 = claim_svg_element(nodes, "path", { d: true });
			children(path2).forEach(detach_dev);
			path3 = claim_svg_element(nodes, "path", { d: true });
			children(path3).forEach(detach_dev);
			path4 = claim_svg_element(nodes, "path", { d: true });
			children(path4).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M5 5.5A3.5 3.5 0 0 1 8.5 2H12v7H8.5A3.5 3.5 0 0 1 5 5.5z");
			add_location(path0, file$3e, 1, 0, 34);
			attr_dev(path1, "d", "M12 2h3.5a3.5 3.5 0 1 1 0 7H12V2z");
			add_location(path1, file$3e, 1, 74, 108);
			attr_dev(path2, "d", "M12 12.5a3.5 3.5 0 1 1 7 0 3.5 3.5 0 1 1-7 0z");
			add_location(path2, file$3e, 1, 125, 159);
			attr_dev(path3, "d", "M5 19.5A3.5 3.5 0 0 1 8.5 16H12v3.5a3.5 3.5 0 1 1-7 0z");
			add_location(path3, file$3e, 1, 188, 222);
			attr_dev(path4, "d", "M5 12.5A3.5 3.5 0 0 1 8.5 9H12v7H8.5A3.5 3.5 0 0 1 5 12.5z");
			add_location(path4, file$3e, 1, 260, 294);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
			insert_hydration_dev(target, path2, anchor);
			insert_hydration_dev(target, path3, anchor);
			insert_hydration_dev(target, path4, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
			if (detaching) detach_dev(path2);
			if (detaching) detach_dev(path3);
			if (detaching) detach_dev(path4);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3h($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Figma', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Figma> was created with unknown prop '${key}'`);
	});

	return [];
}

class Figma extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3h, create_fragment$3i, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Figma",
			options,
			id: create_fragment$3i.name
		});
	}
}

var Figma$1 = Figma;

/* ../../components/ui/src/icons/feather/FileMinus.svelte generated by Svelte v3.59.2 */

const file$3d = "../../components/ui/src/icons/feather/FileMinus.svelte";

function create_fragment$3h(ctx) {
	let path;
	let polyline;
	let line;

	const block = {
		c: function create() {
			path = svg_element("path");
			polyline = svg_element("polyline");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z");
			add_location(path, file$3d, 1, 0, 34);
			attr_dev(polyline, "points", "14 2 14 8 20 8");
			add_location(polyline, file$3d, 1, 76, 110);
			attr_dev(line, "x1", "9");
			attr_dev(line, "y1", "15");
			attr_dev(line, "x2", "15");
			attr_dev(line, "y2", "15");
			add_location(line, file$3d, 1, 121, 155);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3g($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('FileMinus', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FileMinus> was created with unknown prop '${key}'`);
	});

	return [];
}

class FileMinus extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3g, create_fragment$3h, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FileMinus",
			options,
			id: create_fragment$3h.name
		});
	}
}

var FileMinus$1 = FileMinus;

/* ../../components/ui/src/icons/feather/FilePlus.svelte generated by Svelte v3.59.2 */

const file$3c = "../../components/ui/src/icons/feather/FilePlus.svelte";

function create_fragment$3g(ctx) {
	let path;
	let polyline;
	let line0;
	let line1;

	const block = {
		c: function create() {
			path = svg_element("path");
			polyline = svg_element("polyline");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z");
			add_location(path, file$3c, 1, 0, 34);
			attr_dev(polyline, "points", "14 2 14 8 20 8");
			add_location(polyline, file$3c, 1, 76, 110);
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "18");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "12");
			add_location(line0, file$3c, 1, 121, 155);
			attr_dev(line1, "x1", "9");
			attr_dev(line1, "y1", "15");
			attr_dev(line1, "x2", "15");
			attr_dev(line1, "y2", "15");
			add_location(line1, file$3c, 1, 166, 200);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3f($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('FilePlus', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FilePlus> was created with unknown prop '${key}'`);
	});

	return [];
}

class FilePlus extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3f, create_fragment$3g, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FilePlus",
			options,
			id: create_fragment$3g.name
		});
	}
}

var FilePlus$1 = FilePlus;

/* ../../components/ui/src/icons/feather/FileText.svelte generated by Svelte v3.59.2 */

const file$3b = "../../components/ui/src/icons/feather/FileText.svelte";

function create_fragment$3f(ctx) {
	let path;
	let polyline0;
	let line0;
	let line1;
	let polyline1;

	const block = {
		c: function create() {
			path = svg_element("path");
			polyline0 = svg_element("polyline");
			line0 = svg_element("line");
			line1 = svg_element("line");
			polyline1 = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			polyline0 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline0).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			polyline1 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z");
			add_location(path, file$3b, 1, 0, 34);
			attr_dev(polyline0, "points", "14 2 14 8 20 8");
			add_location(polyline0, file$3b, 1, 76, 110);
			attr_dev(line0, "x1", "16");
			attr_dev(line0, "y1", "13");
			attr_dev(line0, "x2", "8");
			attr_dev(line0, "y2", "13");
			add_location(line0, file$3b, 1, 121, 155);
			attr_dev(line1, "x1", "16");
			attr_dev(line1, "y1", "17");
			attr_dev(line1, "x2", "8");
			attr_dev(line1, "y2", "17");
			add_location(line1, file$3b, 1, 165, 199);
			attr_dev(polyline1, "points", "10 9 9 9 8 9");
			add_location(polyline1, file$3b, 1, 209, 243);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, polyline0, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, polyline1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(polyline0);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(polyline1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3e($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('FileText', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FileText> was created with unknown prop '${key}'`);
	});

	return [];
}

class FileText extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3e, create_fragment$3f, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FileText",
			options,
			id: create_fragment$3f.name
		});
	}
}

var FileText$1 = FileText;

/* ../../components/ui/src/icons/feather/File.svelte generated by Svelte v3.59.2 */

const file$3a = "../../components/ui/src/icons/feather/File.svelte";

function create_fragment$3e(ctx) {
	let path;
	let polyline;

	const block = {
		c: function create() {
			path = svg_element("path");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z");
			add_location(path, file$3a, 1, 0, 34);
			attr_dev(polyline, "points", "13 2 13 9 20 9");
			add_location(polyline, file$3a, 1, 76, 110);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, polyline, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(polyline);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3d($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('File', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<File> was created with unknown prop '${key}'`);
	});

	return [];
}

class File extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3d, create_fragment$3e, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "File",
			options,
			id: create_fragment$3e.name
		});
	}
}

var File$1 = File;

/* ../../components/ui/src/icons/feather/Film.svelte generated by Svelte v3.59.2 */

const file$39 = "../../components/ui/src/icons/feather/Film.svelte";

function create_fragment$3d(ctx) {
	let rect;
	let line0;
	let line1;
	let line2;
	let line3;
	let line4;
	let line5;
	let line6;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			line4 = svg_element("line");
			line5 = svg_element("line");
			line6 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			line3 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line3).forEach(detach_dev);
			line4 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line4).forEach(detach_dev);
			line5 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line5).forEach(detach_dev);
			line6 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line6).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "2");
			attr_dev(rect, "y", "2");
			attr_dev(rect, "width", "20");
			attr_dev(rect, "height", "20");
			attr_dev(rect, "rx", "2.18");
			attr_dev(rect, "ry", "2.18");
			add_location(rect, file$39, 1, 0, 34);
			attr_dev(line0, "x1", "7");
			attr_dev(line0, "y1", "2");
			attr_dev(line0, "x2", "7");
			attr_dev(line0, "y2", "22");
			add_location(line0, file$39, 1, 68, 102);
			attr_dev(line1, "x1", "17");
			attr_dev(line1, "y1", "2");
			attr_dev(line1, "x2", "17");
			attr_dev(line1, "y2", "22");
			add_location(line1, file$39, 1, 110, 144);
			attr_dev(line2, "x1", "2");
			attr_dev(line2, "y1", "12");
			attr_dev(line2, "x2", "22");
			attr_dev(line2, "y2", "12");
			add_location(line2, file$39, 1, 154, 188);
			attr_dev(line3, "x1", "2");
			attr_dev(line3, "y1", "7");
			attr_dev(line3, "x2", "7");
			attr_dev(line3, "y2", "7");
			add_location(line3, file$39, 1, 198, 232);
			attr_dev(line4, "x1", "2");
			attr_dev(line4, "y1", "17");
			attr_dev(line4, "x2", "7");
			attr_dev(line4, "y2", "17");
			add_location(line4, file$39, 1, 239, 273);
			attr_dev(line5, "x1", "17");
			attr_dev(line5, "y1", "17");
			attr_dev(line5, "x2", "22");
			attr_dev(line5, "y2", "17");
			add_location(line5, file$39, 1, 282, 316);
			attr_dev(line6, "x1", "17");
			attr_dev(line6, "y1", "7");
			attr_dev(line6, "x2", "22");
			attr_dev(line6, "y2", "7");
			add_location(line6, file$39, 1, 327, 361);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
			insert_hydration_dev(target, line3, anchor);
			insert_hydration_dev(target, line4, anchor);
			insert_hydration_dev(target, line5, anchor);
			insert_hydration_dev(target, line6, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
			if (detaching) detach_dev(line3);
			if (detaching) detach_dev(line4);
			if (detaching) detach_dev(line5);
			if (detaching) detach_dev(line6);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3c($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Film', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Film> was created with unknown prop '${key}'`);
	});

	return [];
}

class Film extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3c, create_fragment$3d, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Film",
			options,
			id: create_fragment$3d.name
		});
	}
}

var Film$1 = Film;

/* ../../components/ui/src/icons/feather/Filter.svelte generated by Svelte v3.59.2 */

const file$38 = "../../components/ui/src/icons/feather/Filter.svelte";

function create_fragment$3c(ctx) {
	let polygon;

	const block = {
		c: function create() {
			polygon = svg_element("polygon");
			this.h();
		},
		l: function claim(nodes) {
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polygon, "points", "22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3");
			add_location(polygon, file$38, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polygon, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polygon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3b($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Filter', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Filter> was created with unknown prop '${key}'`);
	});

	return [];
}

class Filter extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3b, create_fragment$3c, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Filter",
			options,
			id: create_fragment$3c.name
		});
	}
}

var Filter$1 = Filter;

/* ../../components/ui/src/icons/feather/Flag.svelte generated by Svelte v3.59.2 */

const file$37 = "../../components/ui/src/icons/feather/Flag.svelte";

function create_fragment$3b(ctx) {
	let path;
	let line;

	const block = {
		c: function create() {
			path = svg_element("path");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z");
			add_location(path, file$37, 1, 0, 34);
			attr_dev(line, "x1", "4");
			attr_dev(line, "y1", "22");
			attr_dev(line, "x2", "4");
			attr_dev(line, "y2", "15");
			add_location(line, file$37, 1, 75, 109);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3a($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Flag', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Flag> was created with unknown prop '${key}'`);
	});

	return [];
}

class Flag extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$3a, create_fragment$3b, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Flag",
			options,
			id: create_fragment$3b.name
		});
	}
}

var Flag$1 = Flag;

/* ../../components/ui/src/icons/feather/FolderMinus.svelte generated by Svelte v3.59.2 */

const file$36 = "../../components/ui/src/icons/feather/FolderMinus.svelte";

function create_fragment$3a(ctx) {
	let path;
	let line;

	const block = {
		c: function create() {
			path = svg_element("path");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z");
			add_location(path, file$36, 1, 0, 34);
			attr_dev(line, "x1", "9");
			attr_dev(line, "y1", "14");
			attr_dev(line, "x2", "15");
			attr_dev(line, "y2", "14");
			add_location(line, file$36, 1, 93, 127);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$39($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('FolderMinus', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FolderMinus> was created with unknown prop '${key}'`);
	});

	return [];
}

class FolderMinus extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$39, create_fragment$3a, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FolderMinus",
			options,
			id: create_fragment$3a.name
		});
	}
}

var FolderMinus$1 = FolderMinus;

/* ../../components/ui/src/icons/feather/FolderPlus.svelte generated by Svelte v3.59.2 */

const file$35 = "../../components/ui/src/icons/feather/FolderPlus.svelte";

function create_fragment$39(ctx) {
	let path;
	let line0;
	let line1;

	const block = {
		c: function create() {
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z");
			add_location(path, file$35, 1, 0, 34);
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "11");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "17");
			add_location(line0, file$35, 1, 93, 127);
			attr_dev(line1, "x1", "9");
			attr_dev(line1, "y1", "14");
			attr_dev(line1, "x2", "15");
			attr_dev(line1, "y2", "14");
			add_location(line1, file$35, 1, 138, 172);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$39.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$38($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('FolderPlus', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FolderPlus> was created with unknown prop '${key}'`);
	});

	return [];
}

class FolderPlus extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$38, create_fragment$39, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "FolderPlus",
			options,
			id: create_fragment$39.name
		});
	}
}

var FolderPlus$1 = FolderPlus;

/* ../../components/ui/src/icons/feather/Folder.svelte generated by Svelte v3.59.2 */

const file$34 = "../../components/ui/src/icons/feather/Folder.svelte";

function create_fragment$38(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z");
			add_location(path, file$34, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$38.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$37($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Folder', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Folder> was created with unknown prop '${key}'`);
	});

	return [];
}

class Folder extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$37, create_fragment$38, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Folder",
			options,
			id: create_fragment$38.name
		});
	}
}

var Folder$1 = Folder;

/* ../../components/ui/src/icons/feather/Framer.svelte generated by Svelte v3.59.2 */

const file$33 = "../../components/ui/src/icons/feather/Framer.svelte";

function create_fragment$37(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M5 16V9h14V2H5l14 14h-7m-7 0l7 7v-7m-7 0h7");
			add_location(path, file$33, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$37.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$36($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Framer', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Framer> was created with unknown prop '${key}'`);
	});

	return [];
}

class Framer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$36, create_fragment$37, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Framer",
			options,
			id: create_fragment$37.name
		});
	}
}

var Framer$1 = Framer;

/* ../../components/ui/src/icons/feather/Frown.svelte generated by Svelte v3.59.2 */

const file$32 = "../../components/ui/src/icons/feather/Frown.svelte";

function create_fragment$36(ctx) {
	let circle;
	let path;
	let line0;
	let line1;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$32, 1, 0, 34);
			attr_dev(path, "d", "M16 16s-1.5-2-4-2-4 2-4 2");
			add_location(path, file$32, 1, 40, 74);
			attr_dev(line0, "x1", "9");
			attr_dev(line0, "y1", "9");
			attr_dev(line0, "x2", "9.01");
			attr_dev(line0, "y2", "9");
			add_location(line0, file$32, 1, 83, 117);
			attr_dev(line1, "x1", "15");
			attr_dev(line1, "y1", "9");
			attr_dev(line1, "x2", "15.01");
			attr_dev(line1, "y2", "9");
			add_location(line1, file$32, 1, 127, 161);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$36.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$35($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Frown', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Frown> was created with unknown prop '${key}'`);
	});

	return [];
}

class Frown extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$35, create_fragment$36, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Frown",
			options,
			id: create_fragment$36.name
		});
	}
}

var Frown$1 = Frown;

/* ../../components/ui/src/icons/feather/Gift.svelte generated by Svelte v3.59.2 */

const file$31 = "../../components/ui/src/icons/feather/Gift.svelte";

function create_fragment$35(ctx) {
	let polyline;
	let rect;
	let line;
	let path0;
	let path1;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			rect = svg_element("rect");
			line = svg_element("line");
			path0 = svg_element("path");
			path1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);

			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true
			});

			children(rect).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "20 12 20 22 4 22 4 12");
			add_location(polyline, file$31, 1, 0, 34);
			attr_dev(rect, "x", "2");
			attr_dev(rect, "y", "7");
			attr_dev(rect, "width", "20");
			attr_dev(rect, "height", "5");
			add_location(rect, file$31, 1, 52, 86);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "22");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "7");
			add_location(line, file$31, 1, 99, 133);
			attr_dev(path0, "d", "M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z");
			add_location(path0, file$31, 1, 143, 177);
			attr_dev(path1, "d", "M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z");
			add_location(path1, file$31, 1, 204, 238);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, line, anchor);
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(line);
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$35.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$34($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Gift', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Gift> was created with unknown prop '${key}'`);
	});

	return [];
}

class Gift extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$34, create_fragment$35, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Gift",
			options,
			id: create_fragment$35.name
		});
	}
}

var Gift$1 = Gift;

/* ../../components/ui/src/icons/feather/GitBranch.svelte generated by Svelte v3.59.2 */

const file$30 = "../../components/ui/src/icons/feather/GitBranch.svelte";

function create_fragment$34(ctx) {
	let line;
	let circle0;
	let circle1;
	let path;

	const block = {
		c: function create() {
			line = svg_element("line");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			circle0 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle0).forEach(detach_dev);
			circle1 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle1).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line, "x1", "6");
			attr_dev(line, "y1", "3");
			attr_dev(line, "x2", "6");
			attr_dev(line, "y2", "15");
			add_location(line, file$30, 1, 0, 34);
			attr_dev(circle0, "cx", "18");
			attr_dev(circle0, "cy", "6");
			attr_dev(circle0, "r", "3");
			add_location(circle0, file$30, 1, 42, 76);
			attr_dev(circle1, "cx", "6");
			attr_dev(circle1, "cy", "18");
			attr_dev(circle1, "r", "3");
			add_location(circle1, file$30, 1, 80, 114);
			attr_dev(path, "d", "M18 9a9 9 0 0 1-9 9");
			add_location(path, file$30, 1, 118, 152);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line, anchor);
			insert_hydration_dev(target, circle0, anchor);
			insert_hydration_dev(target, circle1, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line);
			if (detaching) detach_dev(circle0);
			if (detaching) detach_dev(circle1);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$34.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$33($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('GitBranch', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<GitBranch> was created with unknown prop '${key}'`);
	});

	return [];
}

class GitBranch extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$33, create_fragment$34, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GitBranch",
			options,
			id: create_fragment$34.name
		});
	}
}

var GitBranch$1 = GitBranch;

/* ../../components/ui/src/icons/feather/GitCommit.svelte generated by Svelte v3.59.2 */

const file$2$ = "../../components/ui/src/icons/feather/GitCommit.svelte";

function create_fragment$33(ctx) {
	let circle;
	let line0;
	let line1;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "4");
			add_location(circle, file$2$, 1, 0, 34);
			attr_dev(line0, "x1", "1.05");
			attr_dev(line0, "y1", "12");
			attr_dev(line0, "x2", "7");
			attr_dev(line0, "y2", "12");
			add_location(line0, file$2$, 1, 39, 73);
			attr_dev(line1, "x1", "17.01");
			attr_dev(line1, "y1", "12");
			attr_dev(line1, "x2", "22.96");
			attr_dev(line1, "y2", "12");
			add_location(line1, file$2$, 1, 85, 119);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$33.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$32($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('GitCommit', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<GitCommit> was created with unknown prop '${key}'`);
	});

	return [];
}

class GitCommit extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$32, create_fragment$33, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GitCommit",
			options,
			id: create_fragment$33.name
		});
	}
}

var GitCommit$1 = GitCommit;

/* ../../components/ui/src/icons/feather/GitMerge.svelte generated by Svelte v3.59.2 */

const file$2_ = "../../components/ui/src/icons/feather/GitMerge.svelte";

function create_fragment$32(ctx) {
	let circle0;
	let circle1;
	let path;

	const block = {
		c: function create() {
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			circle0 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle0).forEach(detach_dev);
			circle1 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle1).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle0, "cx", "18");
			attr_dev(circle0, "cy", "18");
			attr_dev(circle0, "r", "3");
			add_location(circle0, file$2_, 1, 0, 34);
			attr_dev(circle1, "cx", "6");
			attr_dev(circle1, "cy", "6");
			attr_dev(circle1, "r", "3");
			add_location(circle1, file$2_, 1, 39, 73);
			attr_dev(path, "d", "M6 21V9a9 9 0 0 0 9 9");
			add_location(path, file$2_, 1, 76, 110);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle0, anchor);
			insert_hydration_dev(target, circle1, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle0);
			if (detaching) detach_dev(circle1);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$32.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$31($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('GitMerge', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<GitMerge> was created with unknown prop '${key}'`);
	});

	return [];
}

class GitMerge extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$31, create_fragment$32, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GitMerge",
			options,
			id: create_fragment$32.name
		});
	}
}

var GitMerge$1 = GitMerge;

/* ../../components/ui/src/icons/feather/GitPullRequest.svelte generated by Svelte v3.59.2 */

const file$2Z = "../../components/ui/src/icons/feather/GitPullRequest.svelte";

function create_fragment$31(ctx) {
	let circle0;
	let circle1;
	let path;
	let line;

	const block = {
		c: function create() {
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			path = svg_element("path");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			circle0 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle0).forEach(detach_dev);
			circle1 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle1).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle0, "cx", "18");
			attr_dev(circle0, "cy", "18");
			attr_dev(circle0, "r", "3");
			add_location(circle0, file$2Z, 1, 0, 34);
			attr_dev(circle1, "cx", "6");
			attr_dev(circle1, "cy", "6");
			attr_dev(circle1, "r", "3");
			add_location(circle1, file$2Z, 1, 39, 73);
			attr_dev(path, "d", "M13 6h3a2 2 0 0 1 2 2v7");
			add_location(path, file$2Z, 1, 76, 110);
			attr_dev(line, "x1", "6");
			attr_dev(line, "y1", "9");
			attr_dev(line, "x2", "6");
			attr_dev(line, "y2", "21");
			add_location(line, file$2Z, 1, 117, 151);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle0, anchor);
			insert_hydration_dev(target, circle1, anchor);
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle0);
			if (detaching) detach_dev(circle1);
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$31.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$30($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('GitPullRequest', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<GitPullRequest> was created with unknown prop '${key}'`);
	});

	return [];
}

class GitPullRequest extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$30, create_fragment$31, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "GitPullRequest",
			options,
			id: create_fragment$31.name
		});
	}
}

var GitPullRequest$1 = GitPullRequest;

/* ../../components/ui/src/icons/feather/Github.svelte generated by Svelte v3.59.2 */

const file$2Y = "../../components/ui/src/icons/feather/Github.svelte";

function create_fragment$30(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22");
			add_location(path, file$2Y, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$30.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2$($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Github', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Github> was created with unknown prop '${key}'`);
	});

	return [];
}

class Github extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2$, create_fragment$30, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Github",
			options,
			id: create_fragment$30.name
		});
	}
}

var Github$1 = Github;

/* ../../components/ui/src/icons/feather/Gitlab.svelte generated by Svelte v3.59.2 */

const file$2X = "../../components/ui/src/icons/feather/Gitlab.svelte";

function create_fragment$2$(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M22.65 14.39L12 22.13 1.35 14.39a.84.84 0 0 1-.3-.94l1.22-3.78 2.44-7.51A.42.42 0 0 1 4.82 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.49h8.1l2.44-7.51A.42.42 0 0 1 18.6 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.51L23 13.45a.84.84 0 0 1-.35.94z");
			add_location(path, file$2X, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2$.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2_($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Gitlab', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Gitlab> was created with unknown prop '${key}'`);
	});

	return [];
}

class Gitlab extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2_, create_fragment$2$, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Gitlab",
			options,
			id: create_fragment$2$.name
		});
	}
}

var Gitlab$1 = Gitlab;

/* ../../components/ui/src/icons/feather/Grid.svelte generated by Svelte v3.59.2 */

const file$2W = "../../components/ui/src/icons/feather/Grid.svelte";

function create_fragment$2_(ctx) {
	let rect0;
	let rect1;
	let rect2;
	let rect3;

	const block = {
		c: function create() {
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			rect3 = svg_element("rect");
			this.h();
		},
		l: function claim(nodes) {
			rect0 = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true
			});

			children(rect0).forEach(detach_dev);

			rect1 = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true
			});

			children(rect1).forEach(detach_dev);

			rect2 = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true
			});

			children(rect2).forEach(detach_dev);

			rect3 = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true
			});

			children(rect3).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect0, "x", "3");
			attr_dev(rect0, "y", "3");
			attr_dev(rect0, "width", "7");
			attr_dev(rect0, "height", "7");
			add_location(rect0, file$2W, 1, 0, 34);
			attr_dev(rect1, "x", "14");
			attr_dev(rect1, "y", "3");
			attr_dev(rect1, "width", "7");
			attr_dev(rect1, "height", "7");
			add_location(rect1, file$2W, 1, 46, 80);
			attr_dev(rect2, "x", "14");
			attr_dev(rect2, "y", "14");
			attr_dev(rect2, "width", "7");
			attr_dev(rect2, "height", "7");
			add_location(rect2, file$2W, 1, 93, 127);
			attr_dev(rect3, "x", "3");
			attr_dev(rect3, "y", "14");
			attr_dev(rect3, "width", "7");
			attr_dev(rect3, "height", "7");
			add_location(rect3, file$2W, 1, 141, 175);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect0, anchor);
			insert_hydration_dev(target, rect1, anchor);
			insert_hydration_dev(target, rect2, anchor);
			insert_hydration_dev(target, rect3, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect0);
			if (detaching) detach_dev(rect1);
			if (detaching) detach_dev(rect2);
			if (detaching) detach_dev(rect3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2_.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2Z($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Grid', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Grid> was created with unknown prop '${key}'`);
	});

	return [];
}

class Grid extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2Z, create_fragment$2_, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Grid",
			options,
			id: create_fragment$2_.name
		});
	}
}

var Grid$1 = Grid;

/* ../../components/ui/src/icons/feather/HardDrive.svelte generated by Svelte v3.59.2 */

const file$2V = "../../components/ui/src/icons/feather/HardDrive.svelte";

function create_fragment$2Z(ctx) {
	let line0;
	let path;
	let line1;
	let line2;

	const block = {
		c: function create() {
			line0 = svg_element("line");
			path = svg_element("path");
			line1 = svg_element("line");
			line2 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line0, "x1", "22");
			attr_dev(line0, "y1", "12");
			attr_dev(line0, "x2", "2");
			attr_dev(line0, "y2", "12");
			add_location(line0, file$2V, 1, 0, 34);
			attr_dev(path, "d", "M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z");
			add_location(path, file$2V, 1, 44, 78);
			attr_dev(line1, "x1", "6");
			attr_dev(line1, "y1", "16");
			attr_dev(line1, "x2", "6.01");
			attr_dev(line1, "y2", "16");
			add_location(line1, file$2V, 1, 168, 202);
			attr_dev(line2, "x1", "10");
			attr_dev(line2, "y1", "16");
			attr_dev(line2, "x2", "10.01");
			attr_dev(line2, "y2", "16");
			add_location(line2, file$2V, 1, 214, 248);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2Z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2Y($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('HardDrive', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<HardDrive> was created with unknown prop '${key}'`);
	});

	return [];
}

class HardDrive extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2Y, create_fragment$2Z, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "HardDrive",
			options,
			id: create_fragment$2Z.name
		});
	}
}

var HardDrive$1 = HardDrive;

/* ../../components/ui/src/icons/feather/Hash.svelte generated by Svelte v3.59.2 */

const file$2U = "../../components/ui/src/icons/feather/Hash.svelte";

function create_fragment$2Y(ctx) {
	let line0;
	let line1;
	let line2;
	let line3;

	const block = {
		c: function create() {
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			line3 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line3).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line0, "x1", "4");
			attr_dev(line0, "y1", "9");
			attr_dev(line0, "x2", "20");
			attr_dev(line0, "y2", "9");
			add_location(line0, file$2U, 1, 0, 34);
			attr_dev(line1, "x1", "4");
			attr_dev(line1, "y1", "15");
			attr_dev(line1, "x2", "20");
			attr_dev(line1, "y2", "15");
			add_location(line1, file$2U, 1, 42, 76);
			attr_dev(line2, "x1", "10");
			attr_dev(line2, "y1", "3");
			attr_dev(line2, "x2", "8");
			attr_dev(line2, "y2", "21");
			add_location(line2, file$2U, 1, 86, 120);
			attr_dev(line3, "x1", "16");
			attr_dev(line3, "y1", "3");
			attr_dev(line3, "x2", "14");
			attr_dev(line3, "y2", "21");
			add_location(line3, file$2U, 1, 129, 163);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
			insert_hydration_dev(target, line3, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
			if (detaching) detach_dev(line3);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2Y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2X($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Hash', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Hash> was created with unknown prop '${key}'`);
	});

	return [];
}

class Hash extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2X, create_fragment$2Y, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Hash",
			options,
			id: create_fragment$2Y.name
		});
	}
}

var Hash$1 = Hash;

/* ../../components/ui/src/icons/feather/Headphones.svelte generated by Svelte v3.59.2 */

const file$2T = "../../components/ui/src/icons/feather/Headphones.svelte";

function create_fragment$2X(ctx) {
	let path0;
	let path1;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M3 18v-6a9 9 0 0 1 18 0v6");
			add_location(path0, file$2T, 1, 0, 34);
			attr_dev(path1, "d", "M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z");
			add_location(path1, file$2T, 1, 43, 77);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2X.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2W($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Headphones', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Headphones> was created with unknown prop '${key}'`);
	});

	return [];
}

class Headphones extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2W, create_fragment$2X, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Headphones",
			options,
			id: create_fragment$2X.name
		});
	}
}

var Headphones$1 = Headphones;

/* ../../components/ui/src/icons/feather/Heart.svelte generated by Svelte v3.59.2 */

const file$2S = "../../components/ui/src/icons/feather/Heart.svelte";

function create_fragment$2W(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z");
			add_location(path, file$2S, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2W.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2V($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Heart', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Heart> was created with unknown prop '${key}'`);
	});

	return [];
}

class Heart extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2V, create_fragment$2W, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Heart",
			options,
			id: create_fragment$2W.name
		});
	}
}

var Heart$1 = Heart;

/* ../../components/ui/src/icons/feather/HelpCircle.svelte generated by Svelte v3.59.2 */

const file$2R = "../../components/ui/src/icons/feather/HelpCircle.svelte";

function create_fragment$2V(ctx) {
	let circle;
	let path;
	let line;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			path = svg_element("path");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$2R, 1, 0, 34);
			attr_dev(path, "d", "M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3");
			add_location(path, file$2R, 1, 40, 74);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "17");
			attr_dev(line, "x2", "12.01");
			attr_dev(line, "y2", "17");
			add_location(line, file$2R, 1, 94, 128);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2V.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2U($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('HelpCircle', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<HelpCircle> was created with unknown prop '${key}'`);
	});

	return [];
}

class HelpCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2U, create_fragment$2V, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "HelpCircle",
			options,
			id: create_fragment$2V.name
		});
	}
}

var HelpCircle$1 = HelpCircle;

/* ../../components/ui/src/icons/feather/Hexagon.svelte generated by Svelte v3.59.2 */

const file$2Q = "../../components/ui/src/icons/feather/Hexagon.svelte";

function create_fragment$2U(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z");
			add_location(path, file$2Q, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2U.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2T($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Hexagon', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Hexagon> was created with unknown prop '${key}'`);
	});

	return [];
}

class Hexagon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2T, create_fragment$2U, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Hexagon",
			options,
			id: create_fragment$2U.name
		});
	}
}

var Hexagon$1 = Hexagon;

/* ../../components/ui/src/icons/feather/Home.svelte generated by Svelte v3.59.2 */

const file$2P = "../../components/ui/src/icons/feather/Home.svelte";

function create_fragment$2T(ctx) {
	let path;
	let polyline;

	const block = {
		c: function create() {
			path = svg_element("path");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z");
			add_location(path, file$2P, 1, 0, 34);
			attr_dev(polyline, "points", "9 22 9 12 15 12 15 22");
			add_location(polyline, file$2P, 1, 64, 98);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, polyline, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(polyline);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2T.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2S($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Home', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Home> was created with unknown prop '${key}'`);
	});

	return [];
}

class Home extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2S, create_fragment$2T, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Home",
			options,
			id: create_fragment$2T.name
		});
	}
}

var Home$1 = Home;

/* ../../components/ui/src/icons/feather/Image.svelte generated by Svelte v3.59.2 */

const file$2O = "../../components/ui/src/icons/feather/Image.svelte";

function create_fragment$2S(ctx) {
	let rect;
	let circle;
	let polyline;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			circle = svg_element("circle");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect).forEach(detach_dev);
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "3");
			attr_dev(rect, "y", "3");
			attr_dev(rect, "width", "18");
			attr_dev(rect, "height", "18");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$2O, 1, 0, 34);
			attr_dev(circle, "cx", "8.5");
			attr_dev(circle, "cy", "8.5");
			attr_dev(circle, "r", "1.5");
			add_location(circle, file$2O, 1, 62, 96);
			attr_dev(polyline, "points", "21 15 16 10 5 21");
			add_location(polyline, file$2O, 1, 105, 139);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, polyline, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(polyline);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2S.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2R($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Image', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Image> was created with unknown prop '${key}'`);
	});

	return [];
}

class Image extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2R, create_fragment$2S, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Image",
			options,
			id: create_fragment$2S.name
		});
	}
}

var Image$1 = Image;

/* ../../components/ui/src/icons/feather/Inbox.svelte generated by Svelte v3.59.2 */

const file$2N = "../../components/ui/src/icons/feather/Inbox.svelte";

function create_fragment$2R(ctx) {
	let polyline;
	let path;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "22 12 16 12 14 15 10 15 8 12 2 12");
			add_location(polyline, file$2N, 1, 0, 34);
			attr_dev(path, "d", "M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z");
			add_location(path, file$2N, 1, 64, 98);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2R.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2Q($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Inbox', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Inbox> was created with unknown prop '${key}'`);
	});

	return [];
}

class Inbox extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2Q, create_fragment$2R, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Inbox",
			options,
			id: create_fragment$2R.name
		});
	}
}

var Inbox$1 = Inbox;

/* ../../components/ui/src/icons/feather/Instagram.svelte generated by Svelte v3.59.2 */

const file$2M = "../../components/ui/src/icons/feather/Instagram.svelte";

function create_fragment$2Q(ctx) {
	let rect;
	let path;
	let line;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			path = svg_element("path");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "2");
			attr_dev(rect, "y", "2");
			attr_dev(rect, "width", "20");
			attr_dev(rect, "height", "20");
			attr_dev(rect, "rx", "5");
			attr_dev(rect, "ry", "5");
			add_location(rect, file$2M, 1, 0, 34);
			attr_dev(path, "d", "M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z");
			add_location(path, file$2M, 1, 62, 96);
			attr_dev(line, "x1", "17.5");
			attr_dev(line, "y1", "6.5");
			attr_dev(line, "x2", "17.51");
			attr_dev(line, "y2", "6.5");
			add_location(line, file$2M, 1, 127, 161);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2Q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2P($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Instagram', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Instagram> was created with unknown prop '${key}'`);
	});

	return [];
}

class Instagram extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2P, create_fragment$2Q, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Instagram",
			options,
			id: create_fragment$2Q.name
		});
	}
}

var Instagram$1 = Instagram;

/* ../../components/ui/src/icons/feather/Italic.svelte generated by Svelte v3.59.2 */

const file$2L = "../../components/ui/src/icons/feather/Italic.svelte";

function create_fragment$2P(ctx) {
	let line0;
	let line1;
	let line2;

	const block = {
		c: function create() {
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line0, "x1", "19");
			attr_dev(line0, "y1", "4");
			attr_dev(line0, "x2", "10");
			attr_dev(line0, "y2", "4");
			add_location(line0, file$2L, 1, 0, 34);
			attr_dev(line1, "x1", "14");
			attr_dev(line1, "y1", "20");
			attr_dev(line1, "x2", "5");
			attr_dev(line1, "y2", "20");
			add_location(line1, file$2L, 1, 43, 77);
			attr_dev(line2, "x1", "15");
			attr_dev(line2, "y1", "4");
			attr_dev(line2, "x2", "9");
			attr_dev(line2, "y2", "20");
			add_location(line2, file$2L, 1, 87, 121);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2P.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2O($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Italic', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Italic> was created with unknown prop '${key}'`);
	});

	return [];
}

class Italic extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2O, create_fragment$2P, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Italic",
			options,
			id: create_fragment$2P.name
		});
	}
}

var Italic$1 = Italic;

/* ../../components/ui/src/icons/feather/Key.svelte generated by Svelte v3.59.2 */

const file$2K = "../../components/ui/src/icons/feather/Key.svelte";

function create_fragment$2O(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4");
			add_location(path, file$2K, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2O.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2N($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Key', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Key> was created with unknown prop '${key}'`);
	});

	return [];
}

class Key extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2N, create_fragment$2O, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Key",
			options,
			id: create_fragment$2O.name
		});
	}
}

var Key$1 = Key;

/* ../../components/ui/src/icons/feather/Layers.svelte generated by Svelte v3.59.2 */

const file$2J = "../../components/ui/src/icons/feather/Layers.svelte";

function create_fragment$2N(ctx) {
	let polygon;
	let polyline0;
	let polyline1;

	const block = {
		c: function create() {
			polygon = svg_element("polygon");
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			polyline0 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline0).forEach(detach_dev);
			polyline1 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polygon, "points", "12 2 2 7 12 12 22 7 12 2");
			add_location(polygon, file$2J, 1, 0, 34);
			attr_dev(polyline0, "points", "2 17 12 22 22 17");
			add_location(polyline0, file$2J, 1, 53, 87);
			attr_dev(polyline1, "points", "2 12 12 17 22 12");
			add_location(polyline1, file$2J, 1, 100, 134);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polygon, anchor);
			insert_hydration_dev(target, polyline0, anchor);
			insert_hydration_dev(target, polyline1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polygon);
			if (detaching) detach_dev(polyline0);
			if (detaching) detach_dev(polyline1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2N.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2M($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Layers', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Layers> was created with unknown prop '${key}'`);
	});

	return [];
}

class Layers extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2M, create_fragment$2N, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Layers",
			options,
			id: create_fragment$2N.name
		});
	}
}

var Layers$1 = Layers;

/* ../../components/ui/src/icons/feather/Layout.svelte generated by Svelte v3.59.2 */

const file$2I = "../../components/ui/src/icons/feather/Layout.svelte";

function create_fragment$2M(ctx) {
	let rect;
	let line0;
	let line1;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "3");
			attr_dev(rect, "y", "3");
			attr_dev(rect, "width", "18");
			attr_dev(rect, "height", "18");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$2I, 1, 0, 34);
			attr_dev(line0, "x1", "3");
			attr_dev(line0, "y1", "9");
			attr_dev(line0, "x2", "21");
			attr_dev(line0, "y2", "9");
			add_location(line0, file$2I, 1, 62, 96);
			attr_dev(line1, "x1", "9");
			attr_dev(line1, "y1", "21");
			attr_dev(line1, "x2", "9");
			attr_dev(line1, "y2", "9");
			add_location(line1, file$2I, 1, 104, 138);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2M.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2L($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Layout', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Layout> was created with unknown prop '${key}'`);
	});

	return [];
}

class Layout extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2L, create_fragment$2M, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Layout",
			options,
			id: create_fragment$2M.name
		});
	}
}

var Layout$1 = Layout;

/* ../../components/ui/src/icons/feather/LifeBuoy.svelte generated by Svelte v3.59.2 */

const file$2H = "../../components/ui/src/icons/feather/LifeBuoy.svelte";

function create_fragment$2L(ctx) {
	let circle0;
	let circle1;
	let line0;
	let line1;
	let line2;
	let line3;
	let line4;

	const block = {
		c: function create() {
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			line4 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			circle0 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle0).forEach(detach_dev);
			circle1 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle1).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			line3 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line3).forEach(detach_dev);
			line4 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line4).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle0, "cx", "12");
			attr_dev(circle0, "cy", "12");
			attr_dev(circle0, "r", "10");
			add_location(circle0, file$2H, 1, 0, 34);
			attr_dev(circle1, "cx", "12");
			attr_dev(circle1, "cy", "12");
			attr_dev(circle1, "r", "4");
			add_location(circle1, file$2H, 1, 40, 74);
			attr_dev(line0, "x1", "4.93");
			attr_dev(line0, "y1", "4.93");
			attr_dev(line0, "x2", "9.17");
			attr_dev(line0, "y2", "9.17");
			add_location(line0, file$2H, 1, 79, 113);
			attr_dev(line1, "x1", "14.83");
			attr_dev(line1, "y1", "14.83");
			attr_dev(line1, "x2", "19.07");
			attr_dev(line1, "y2", "19.07");
			add_location(line1, file$2H, 1, 132, 166);
			attr_dev(line2, "x1", "14.83");
			attr_dev(line2, "y1", "9.17");
			attr_dev(line2, "x2", "19.07");
			attr_dev(line2, "y2", "4.93");
			add_location(line2, file$2H, 1, 189, 223);
			attr_dev(line3, "x1", "14.83");
			attr_dev(line3, "y1", "9.17");
			attr_dev(line3, "x2", "18.36");
			attr_dev(line3, "y2", "5.64");
			add_location(line3, file$2H, 1, 244, 278);
			attr_dev(line4, "x1", "4.93");
			attr_dev(line4, "y1", "19.07");
			attr_dev(line4, "x2", "9.17");
			attr_dev(line4, "y2", "14.83");
			add_location(line4, file$2H, 1, 299, 333);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle0, anchor);
			insert_hydration_dev(target, circle1, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
			insert_hydration_dev(target, line3, anchor);
			insert_hydration_dev(target, line4, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle0);
			if (detaching) detach_dev(circle1);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
			if (detaching) detach_dev(line3);
			if (detaching) detach_dev(line4);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2L.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2K($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('LifeBuoy', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LifeBuoy> was created with unknown prop '${key}'`);
	});

	return [];
}

class LifeBuoy extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2K, create_fragment$2L, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LifeBuoy",
			options,
			id: create_fragment$2L.name
		});
	}
}

var LifeBuoy$1 = LifeBuoy;

/* ../../components/ui/src/icons/feather/Link2.svelte generated by Svelte v3.59.2 */

const file$2G = "../../components/ui/src/icons/feather/Link2.svelte";

function create_fragment$2K(ctx) {
	let path;
	let line;

	const block = {
		c: function create() {
			path = svg_element("path");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3");
			add_location(path, file$2G, 1, 0, 34);
			attr_dev(line, "x1", "8");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "16");
			attr_dev(line, "y2", "12");
			add_location(line, file$2G, 1, 93, 127);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2K.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2J($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Link2', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Link2> was created with unknown prop '${key}'`);
	});

	return [];
}

class Link2 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2J, create_fragment$2K, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Link2",
			options,
			id: create_fragment$2K.name
		});
	}
}

var Link2$1 = Link2;

/* ../../components/ui/src/icons/feather/Link.svelte generated by Svelte v3.59.2 */

const file$2F = "../../components/ui/src/icons/feather/Link.svelte";

function create_fragment$2J(ctx) {
	let path0;
	let path1;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71");
			add_location(path0, file$2F, 1, 0, 34);
			attr_dev(path1, "d", "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71");
			add_location(path1, file$2F, 1, 77, 111);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2J.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2I($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Link', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Link> was created with unknown prop '${key}'`);
	});

	return [];
}

class Link extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2I, create_fragment$2J, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Link",
			options,
			id: create_fragment$2J.name
		});
	}
}

var Link$1 = Link;

/* ../../components/ui/src/icons/feather/Linkedin.svelte generated by Svelte v3.59.2 */

const file$2E = "../../components/ui/src/icons/feather/Linkedin.svelte";

function create_fragment$2I(ctx) {
	let path;
	let rect;
	let circle;

	const block = {
		c: function create() {
			path = svg_element("path");
			rect = svg_element("rect");
			circle = svg_element("circle");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);

			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true
			});

			children(rect).forEach(detach_dev);
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z");
			add_location(path, file$2E, 1, 0, 34);
			attr_dev(rect, "x", "2");
			attr_dev(rect, "y", "9");
			attr_dev(rect, "width", "4");
			attr_dev(rect, "height", "12");
			add_location(rect, file$2E, 1, 96, 130);
			attr_dev(circle, "cx", "4");
			attr_dev(circle, "cy", "4");
			attr_dev(circle, "r", "2");
			add_location(circle, file$2E, 1, 143, 177);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, circle, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(circle);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2I.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2H($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Linkedin', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Linkedin> was created with unknown prop '${key}'`);
	});

	return [];
}

class Linkedin extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2H, create_fragment$2I, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Linkedin",
			options,
			id: create_fragment$2I.name
		});
	}
}

var Linkedin$1 = Linkedin;

/* ../../components/ui/src/icons/feather/Lock.svelte generated by Svelte v3.59.2 */

const file$2D = "../../components/ui/src/icons/feather/Lock.svelte";

function create_fragment$2H(ctx) {
	let rect;
	let path;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "3");
			attr_dev(rect, "y", "11");
			attr_dev(rect, "width", "18");
			attr_dev(rect, "height", "11");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$2D, 1, 0, 34);
			attr_dev(path, "d", "M7 11V7a5 5 0 0 1 10 0v4");
			add_location(path, file$2D, 1, 63, 97);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2H.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2G($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Lock', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Lock> was created with unknown prop '${key}'`);
	});

	return [];
}

class Lock extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2G, create_fragment$2H, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Lock",
			options,
			id: create_fragment$2H.name
		});
	}
}

var Lock$1 = Lock;

/* ../../components/ui/src/icons/feather/LogIn.svelte generated by Svelte v3.59.2 */

const file$2C = "../../components/ui/src/icons/feather/LogIn.svelte";

function create_fragment$2G(ctx) {
	let path;
	let polyline;
	let line;

	const block = {
		c: function create() {
			path = svg_element("path");
			polyline = svg_element("polyline");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4");
			add_location(path, file$2C, 1, 0, 34);
			attr_dev(polyline, "points", "10 17 15 12 10 7");
			add_location(polyline, file$2C, 1, 59, 93);
			attr_dev(line, "x1", "15");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "3");
			attr_dev(line, "y2", "12");
			add_location(line, file$2C, 1, 106, 140);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2G.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2F($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('LogIn', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LogIn> was created with unknown prop '${key}'`);
	});

	return [];
}

class LogIn extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2F, create_fragment$2G, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LogIn",
			options,
			id: create_fragment$2G.name
		});
	}
}

var LogIn$1 = LogIn;

/* ../../components/ui/src/icons/feather/LogOut.svelte generated by Svelte v3.59.2 */

const file$2B = "../../components/ui/src/icons/feather/LogOut.svelte";

function create_fragment$2F(ctx) {
	let path;
	let polyline;
	let line;

	const block = {
		c: function create() {
			path = svg_element("path");
			polyline = svg_element("polyline");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4");
			add_location(path, file$2B, 1, 0, 34);
			attr_dev(polyline, "points", "16 17 21 12 16 7");
			add_location(polyline, file$2B, 1, 57, 91);
			attr_dev(line, "x1", "21");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "9");
			attr_dev(line, "y2", "12");
			add_location(line, file$2B, 1, 104, 138);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2F.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2E($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('LogOut', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LogOut> was created with unknown prop '${key}'`);
	});

	return [];
}

class LogOut extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2E, create_fragment$2F, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LogOut",
			options,
			id: create_fragment$2F.name
		});
	}
}

var LogOut$1 = LogOut;

/* ../../components/ui/src/icons/feather/Mail.svelte generated by Svelte v3.59.2 */

const file$2A = "../../components/ui/src/icons/feather/Mail.svelte";

function create_fragment$2E(ctx) {
	let path;
	let polyline;

	const block = {
		c: function create() {
			path = svg_element("path");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z");
			add_location(path, file$2A, 1, 0, 34);
			attr_dev(polyline, "points", "22,6 12,13 2,6");
			add_location(polyline, file$2A, 1, 93, 127);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, polyline, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(polyline);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2E.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2D($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Mail', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Mail> was created with unknown prop '${key}'`);
	});

	return [];
}

class Mail extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2D, create_fragment$2E, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Mail",
			options,
			id: create_fragment$2E.name
		});
	}
}

var Mail$1 = Mail;

/* ../../components/ui/src/icons/feather/Map.svelte generated by Svelte v3.59.2 */

const file$2z = "../../components/ui/src/icons/feather/Map.svelte";

function create_fragment$2D(ctx) {
	let polygon;
	let line0;
	let line1;

	const block = {
		c: function create() {
			polygon = svg_element("polygon");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polygon, "points", "1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6");
			add_location(polygon, file$2z, 1, 0, 34);
			attr_dev(line0, "x1", "8");
			attr_dev(line0, "y1", "2");
			attr_dev(line0, "x2", "8");
			attr_dev(line0, "y2", "18");
			add_location(line0, file$2z, 1, 72, 106);
			attr_dev(line1, "x1", "16");
			attr_dev(line1, "y1", "6");
			attr_dev(line1, "x2", "16");
			attr_dev(line1, "y2", "22");
			add_location(line1, file$2z, 1, 114, 148);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polygon, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polygon);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2D.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2C($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Map', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Map> was created with unknown prop '${key}'`);
	});

	return [];
}

class Map$1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2C, create_fragment$2D, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Map",
			options,
			id: create_fragment$2D.name
		});
	}
}

var Map$2 = Map$1;

/* ../../components/ui/src/icons/feather/Maximize2.svelte generated by Svelte v3.59.2 */

const file$2y = "../../components/ui/src/icons/feather/Maximize2.svelte";

function create_fragment$2C(ctx) {
	let polyline0;
	let polyline1;
	let line0;
	let line1;

	const block = {
		c: function create() {
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			polyline0 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline0).forEach(detach_dev);
			polyline1 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline1).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline0, "points", "15 3 21 3 21 9");
			add_location(polyline0, file$2y, 1, 0, 34);
			attr_dev(polyline1, "points", "9 21 3 21 3 15");
			add_location(polyline1, file$2y, 1, 45, 79);
			attr_dev(line0, "x1", "21");
			attr_dev(line0, "y1", "3");
			attr_dev(line0, "x2", "14");
			attr_dev(line0, "y2", "10");
			add_location(line0, file$2y, 1, 90, 124);
			attr_dev(line1, "x1", "3");
			attr_dev(line1, "y1", "21");
			attr_dev(line1, "x2", "10");
			attr_dev(line1, "y2", "14");
			add_location(line1, file$2y, 1, 134, 168);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline0, anchor);
			insert_hydration_dev(target, polyline1, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline0);
			if (detaching) detach_dev(polyline1);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2C.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2B($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Maximize2', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Maximize2> was created with unknown prop '${key}'`);
	});

	return [];
}

class Maximize2 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2B, create_fragment$2C, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Maximize2",
			options,
			id: create_fragment$2C.name
		});
	}
}

var Maximize2$1 = Maximize2;

/* ../../components/ui/src/icons/feather/Maximize.svelte generated by Svelte v3.59.2 */

const file$2x = "../../components/ui/src/icons/feather/Maximize.svelte";

function create_fragment$2B(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3");
			add_location(path, file$2x, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2B.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2A($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Maximize', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Maximize> was created with unknown prop '${key}'`);
	});

	return [];
}

class Maximize extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2A, create_fragment$2B, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Maximize",
			options,
			id: create_fragment$2B.name
		});
	}
}

var Maximize$1 = Maximize;

/* ../../components/ui/src/icons/feather/Meh.svelte generated by Svelte v3.59.2 */

const file$2w = "../../components/ui/src/icons/feather/Meh.svelte";

function create_fragment$2A(ctx) {
	let circle;
	let line0;
	let line1;
	let line2;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$2w, 1, 0, 34);
			attr_dev(line0, "x1", "8");
			attr_dev(line0, "y1", "15");
			attr_dev(line0, "x2", "16");
			attr_dev(line0, "y2", "15");
			add_location(line0, file$2w, 1, 40, 74);
			attr_dev(line1, "x1", "9");
			attr_dev(line1, "y1", "9");
			attr_dev(line1, "x2", "9.01");
			attr_dev(line1, "y2", "9");
			add_location(line1, file$2w, 1, 84, 118);
			attr_dev(line2, "x1", "15");
			attr_dev(line2, "y1", "9");
			attr_dev(line2, "x2", "15.01");
			attr_dev(line2, "y2", "9");
			add_location(line2, file$2w, 1, 128, 162);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2A.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2z($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Meh', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Meh> was created with unknown prop '${key}'`);
	});

	return [];
}

class Meh extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2z, create_fragment$2A, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Meh",
			options,
			id: create_fragment$2A.name
		});
	}
}

var Meh$1 = Meh;

/* ../../components/ui/src/icons/feather/Menu.svelte generated by Svelte v3.59.2 */

const file$2v = "../../components/ui/src/icons/feather/Menu.svelte";

function create_fragment$2z(ctx) {
	let line0;
	let line1;
	let line2;

	const block = {
		c: function create() {
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line0, "x1", "3");
			attr_dev(line0, "y1", "12");
			attr_dev(line0, "x2", "21");
			attr_dev(line0, "y2", "12");
			add_location(line0, file$2v, 1, 0, 34);
			attr_dev(line1, "x1", "3");
			attr_dev(line1, "y1", "6");
			attr_dev(line1, "x2", "21");
			attr_dev(line1, "y2", "6");
			add_location(line1, file$2v, 1, 44, 78);
			attr_dev(line2, "x1", "3");
			attr_dev(line2, "y1", "18");
			attr_dev(line2, "x2", "21");
			attr_dev(line2, "y2", "18");
			add_location(line2, file$2v, 1, 86, 120);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2y($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Menu', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Menu> was created with unknown prop '${key}'`);
	});

	return [];
}

class Menu extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2y, create_fragment$2z, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Menu",
			options,
			id: create_fragment$2z.name
		});
	}
}

var Menu$1 = Menu;

/* ../../components/ui/src/icons/feather/MessageCircle.svelte generated by Svelte v3.59.2 */

const file$2u = "../../components/ui/src/icons/feather/MessageCircle.svelte";

function create_fragment$2y(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z");
			add_location(path, file$2u, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2x($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('MessageCircle', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageCircle> was created with unknown prop '${key}'`);
	});

	return [];
}

class MessageCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2x, create_fragment$2y, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MessageCircle",
			options,
			id: create_fragment$2y.name
		});
	}
}

var MessageCircle$1 = MessageCircle;

/* ../../components/ui/src/icons/feather/MessageSquare.svelte generated by Svelte v3.59.2 */

const file$2t = "../../components/ui/src/icons/feather/MessageSquare.svelte";

function create_fragment$2x(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z");
			add_location(path, file$2t, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2x.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2w($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('MessageSquare', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MessageSquare> was created with unknown prop '${key}'`);
	});

	return [];
}

class MessageSquare extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2w, create_fragment$2x, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MessageSquare",
			options,
			id: create_fragment$2x.name
		});
	}
}

var MessageSquare$1 = MessageSquare;

/* ../../components/ui/src/icons/feather/MicOff.svelte generated by Svelte v3.59.2 */

const file$2s = "../../components/ui/src/icons/feather/MicOff.svelte";

function create_fragment$2w(ctx) {
	let line0;
	let path0;
	let path1;
	let line1;
	let line2;

	const block = {
		c: function create() {
			line0 = svg_element("line");
			path0 = svg_element("path");
			path1 = svg_element("path");
			line1 = svg_element("line");
			line2 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line0, "x1", "1");
			attr_dev(line0, "y1", "1");
			attr_dev(line0, "x2", "23");
			attr_dev(line0, "y2", "23");
			add_location(line0, file$2s, 1, 0, 34);
			attr_dev(path0, "d", "M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6");
			add_location(path0, file$2s, 1, 43, 77);
			attr_dev(path1, "d", "M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23");
			add_location(path1, file$2s, 1, 115, 149);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "19");
			attr_dev(line1, "x2", "12");
			attr_dev(line1, "y2", "23");
			add_location(line1, file$2s, 1, 186, 220);
			attr_dev(line2, "x1", "8");
			attr_dev(line2, "y1", "23");
			attr_dev(line2, "x2", "16");
			attr_dev(line2, "y2", "23");
			add_location(line2, file$2s, 1, 231, 265);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2w.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2v($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('MicOff', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MicOff> was created with unknown prop '${key}'`);
	});

	return [];
}

class MicOff extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2v, create_fragment$2w, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MicOff",
			options,
			id: create_fragment$2w.name
		});
	}
}

var MicOff$1 = MicOff;

/* ../../components/ui/src/icons/feather/Mic.svelte generated by Svelte v3.59.2 */

const file$2r = "../../components/ui/src/icons/feather/Mic.svelte";

function create_fragment$2v(ctx) {
	let path0;
	let path1;
	let line0;
	let line1;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z");
			add_location(path0, file$2r, 1, 0, 34);
			attr_dev(path1, "d", "M19 10v2a7 7 0 0 1-14 0v-2");
			add_location(path1, file$2r, 1, 70, 104);
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "19");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "23");
			add_location(line0, file$2r, 1, 114, 148);
			attr_dev(line1, "x1", "8");
			attr_dev(line1, "y1", "23");
			attr_dev(line1, "x2", "16");
			attr_dev(line1, "y2", "23");
			add_location(line1, file$2r, 1, 159, 193);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2v.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2u($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Mic', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Mic> was created with unknown prop '${key}'`);
	});

	return [];
}

class Mic extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2u, create_fragment$2v, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Mic",
			options,
			id: create_fragment$2v.name
		});
	}
}

var Mic$1 = Mic;

/* ../../components/ui/src/icons/feather/Minimize2.svelte generated by Svelte v3.59.2 */

const file$2q = "../../components/ui/src/icons/feather/Minimize2.svelte";

function create_fragment$2u(ctx) {
	let polyline0;
	let polyline1;
	let line0;
	let line1;

	const block = {
		c: function create() {
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			polyline0 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline0).forEach(detach_dev);
			polyline1 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline1).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline0, "points", "4 14 10 14 10 20");
			add_location(polyline0, file$2q, 1, 0, 34);
			attr_dev(polyline1, "points", "20 10 14 10 14 4");
			add_location(polyline1, file$2q, 1, 47, 81);
			attr_dev(line0, "x1", "14");
			attr_dev(line0, "y1", "10");
			attr_dev(line0, "x2", "21");
			attr_dev(line0, "y2", "3");
			add_location(line0, file$2q, 1, 94, 128);
			attr_dev(line1, "x1", "3");
			attr_dev(line1, "y1", "21");
			attr_dev(line1, "x2", "10");
			attr_dev(line1, "y2", "14");
			add_location(line1, file$2q, 1, 138, 172);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline0, anchor);
			insert_hydration_dev(target, polyline1, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline0);
			if (detaching) detach_dev(polyline1);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2u.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2t($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Minimize2', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Minimize2> was created with unknown prop '${key}'`);
	});

	return [];
}

class Minimize2 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2t, create_fragment$2u, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Minimize2",
			options,
			id: create_fragment$2u.name
		});
	}
}

var Minimize2$1 = Minimize2;

/* ../../components/ui/src/icons/feather/Minimize.svelte generated by Svelte v3.59.2 */

const file$2p = "../../components/ui/src/icons/feather/Minimize.svelte";

function create_fragment$2t(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3");
			add_location(path, file$2p, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2t.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2s($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Minimize', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Minimize> was created with unknown prop '${key}'`);
	});

	return [];
}

class Minimize extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2s, create_fragment$2t, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Minimize",
			options,
			id: create_fragment$2t.name
		});
	}
}

var Minimize$1 = Minimize;

/* ../../components/ui/src/icons/feather/Minus.svelte generated by Svelte v3.59.2 */

const file$2o = "../../components/ui/src/icons/feather/Minus.svelte";

function create_fragment$2s(ctx) {
	let line;

	const block = {
		c: function create() {
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line, "x1", "5");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "19");
			attr_dev(line, "y2", "12");
			add_location(line, file$2o, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2s.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2r($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Minus', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Minus> was created with unknown prop '${key}'`);
	});

	return [];
}

class Minus extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2r, create_fragment$2s, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Minus",
			options,
			id: create_fragment$2s.name
		});
	}
}

var Minus$1 = Minus;

/* ../../components/ui/src/icons/feather/Monitor.svelte generated by Svelte v3.59.2 */

const file$2n = "../../components/ui/src/icons/feather/Monitor.svelte";

function create_fragment$2r(ctx) {
	let rect;
	let line0;
	let line1;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "2");
			attr_dev(rect, "y", "3");
			attr_dev(rect, "width", "20");
			attr_dev(rect, "height", "14");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$2n, 1, 0, 34);
			attr_dev(line0, "x1", "8");
			attr_dev(line0, "y1", "21");
			attr_dev(line0, "x2", "16");
			attr_dev(line0, "y2", "21");
			add_location(line0, file$2n, 1, 62, 96);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "17");
			attr_dev(line1, "x2", "12");
			attr_dev(line1, "y2", "21");
			add_location(line1, file$2n, 1, 106, 140);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2r.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2q($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Monitor', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Monitor> was created with unknown prop '${key}'`);
	});

	return [];
}

class Monitor extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2q, create_fragment$2r, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Monitor",
			options,
			id: create_fragment$2r.name
		});
	}
}

var Monitor$1 = Monitor;

/* ../../components/ui/src/icons/feather/Moon.svelte generated by Svelte v3.59.2 */

const file$2m = "../../components/ui/src/icons/feather/Moon.svelte";

function create_fragment$2q(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z");
			add_location(path, file$2m, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2p($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Moon', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Moon> was created with unknown prop '${key}'`);
	});

	return [];
}

class Moon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2p, create_fragment$2q, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Moon",
			options,
			id: create_fragment$2q.name
		});
	}
}

var Moon$1 = Moon;

/* ../../components/ui/src/icons/feather/MoreHorizontal.svelte generated by Svelte v3.59.2 */

const file$2l = "../../components/ui/src/icons/feather/MoreHorizontal.svelte";

function create_fragment$2p(ctx) {
	let circle0;
	let circle1;
	let circle2;

	const block = {
		c: function create() {
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			this.h();
		},
		l: function claim(nodes) {
			circle0 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle0).forEach(detach_dev);
			circle1 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle1).forEach(detach_dev);
			circle2 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle2).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle0, "cx", "12");
			attr_dev(circle0, "cy", "12");
			attr_dev(circle0, "r", "1");
			add_location(circle0, file$2l, 1, 0, 34);
			attr_dev(circle1, "cx", "19");
			attr_dev(circle1, "cy", "12");
			attr_dev(circle1, "r", "1");
			add_location(circle1, file$2l, 1, 39, 73);
			attr_dev(circle2, "cx", "5");
			attr_dev(circle2, "cy", "12");
			attr_dev(circle2, "r", "1");
			add_location(circle2, file$2l, 1, 78, 112);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle0, anchor);
			insert_hydration_dev(target, circle1, anchor);
			insert_hydration_dev(target, circle2, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle0);
			if (detaching) detach_dev(circle1);
			if (detaching) detach_dev(circle2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2p.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2o($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('MoreHorizontal', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MoreHorizontal> was created with unknown prop '${key}'`);
	});

	return [];
}

class MoreHorizontal extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2o, create_fragment$2p, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MoreHorizontal",
			options,
			id: create_fragment$2p.name
		});
	}
}

var MoreHorizontal$1 = MoreHorizontal;

/* ../../components/ui/src/icons/feather/MoreVertical.svelte generated by Svelte v3.59.2 */

const file$2k = "../../components/ui/src/icons/feather/MoreVertical.svelte";

function create_fragment$2o(ctx) {
	let circle0;
	let circle1;
	let circle2;

	const block = {
		c: function create() {
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			this.h();
		},
		l: function claim(nodes) {
			circle0 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle0).forEach(detach_dev);
			circle1 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle1).forEach(detach_dev);
			circle2 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle2).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle0, "cx", "12");
			attr_dev(circle0, "cy", "12");
			attr_dev(circle0, "r", "1");
			add_location(circle0, file$2k, 1, 0, 34);
			attr_dev(circle1, "cx", "12");
			attr_dev(circle1, "cy", "5");
			attr_dev(circle1, "r", "1");
			add_location(circle1, file$2k, 1, 39, 73);
			attr_dev(circle2, "cx", "12");
			attr_dev(circle2, "cy", "19");
			attr_dev(circle2, "r", "1");
			add_location(circle2, file$2k, 1, 77, 111);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle0, anchor);
			insert_hydration_dev(target, circle1, anchor);
			insert_hydration_dev(target, circle2, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle0);
			if (detaching) detach_dev(circle1);
			if (detaching) detach_dev(circle2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2o.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2n($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('MoreVertical', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MoreVertical> was created with unknown prop '${key}'`);
	});

	return [];
}

class MoreVertical extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2n, create_fragment$2o, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MoreVertical",
			options,
			id: create_fragment$2o.name
		});
	}
}

var MoreVertical$1 = MoreVertical;

/* ../../components/ui/src/icons/feather/MousePointer.svelte generated by Svelte v3.59.2 */

const file$2j = "../../components/ui/src/icons/feather/MousePointer.svelte";

function create_fragment$2n(ctx) {
	let path0;
	let path1;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z");
			add_location(path0, file$2j, 1, 0, 34);
			attr_dev(path1, "d", "M13 13l6 6");
			add_location(path1, file$2j, 1, 58, 92);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2n.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2m($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('MousePointer', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MousePointer> was created with unknown prop '${key}'`);
	});

	return [];
}

class MousePointer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2m, create_fragment$2n, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MousePointer",
			options,
			id: create_fragment$2n.name
		});
	}
}

var MousePointer$1 = MousePointer;

/* ../../components/ui/src/icons/feather/Move.svelte generated by Svelte v3.59.2 */

const file$2i = "../../components/ui/src/icons/feather/Move.svelte";

function create_fragment$2m(ctx) {
	let polyline0;
	let polyline1;
	let polyline2;
	let polyline3;
	let line0;
	let line1;

	const block = {
		c: function create() {
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			polyline2 = svg_element("polyline");
			polyline3 = svg_element("polyline");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			polyline0 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline0).forEach(detach_dev);
			polyline1 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline1).forEach(detach_dev);
			polyline2 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline2).forEach(detach_dev);
			polyline3 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline3).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline0, "points", "5 9 2 12 5 15");
			add_location(polyline0, file$2i, 1, 0, 34);
			attr_dev(polyline1, "points", "9 5 12 2 15 5");
			add_location(polyline1, file$2i, 1, 44, 78);
			attr_dev(polyline2, "points", "15 19 12 22 9 19");
			add_location(polyline2, file$2i, 1, 88, 122);
			attr_dev(polyline3, "points", "19 9 22 12 19 15");
			add_location(polyline3, file$2i, 1, 135, 169);
			attr_dev(line0, "x1", "2");
			attr_dev(line0, "y1", "12");
			attr_dev(line0, "x2", "22");
			attr_dev(line0, "y2", "12");
			add_location(line0, file$2i, 1, 182, 216);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "2");
			attr_dev(line1, "x2", "12");
			attr_dev(line1, "y2", "22");
			add_location(line1, file$2i, 1, 226, 260);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline0, anchor);
			insert_hydration_dev(target, polyline1, anchor);
			insert_hydration_dev(target, polyline2, anchor);
			insert_hydration_dev(target, polyline3, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline0);
			if (detaching) detach_dev(polyline1);
			if (detaching) detach_dev(polyline2);
			if (detaching) detach_dev(polyline3);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2m.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2l($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Move', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Move> was created with unknown prop '${key}'`);
	});

	return [];
}

class Move extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2l, create_fragment$2m, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Move",
			options,
			id: create_fragment$2m.name
		});
	}
}

var Move$1 = Move;

/* ../../components/ui/src/icons/feather/Music.svelte generated by Svelte v3.59.2 */

const file$2h = "../../components/ui/src/icons/feather/Music.svelte";

function create_fragment$2l(ctx) {
	let path;
	let circle0;
	let circle1;

	const block = {
		c: function create() {
			path = svg_element("path");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			circle0 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle0).forEach(detach_dev);
			circle1 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M9 18V5l12-2v13");
			add_location(path, file$2h, 1, 0, 34);
			attr_dev(circle0, "cx", "6");
			attr_dev(circle0, "cy", "18");
			attr_dev(circle0, "r", "3");
			add_location(circle0, file$2h, 1, 33, 67);
			attr_dev(circle1, "cx", "18");
			attr_dev(circle1, "cy", "16");
			attr_dev(circle1, "r", "3");
			add_location(circle1, file$2h, 1, 71, 105);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, circle0, anchor);
			insert_hydration_dev(target, circle1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(circle0);
			if (detaching) detach_dev(circle1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2l.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2k($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Music', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Music> was created with unknown prop '${key}'`);
	});

	return [];
}

class Music extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2k, create_fragment$2l, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Music",
			options,
			id: create_fragment$2l.name
		});
	}
}

var Music$1 = Music;

/* ../../components/ui/src/icons/feather/Navigation2.svelte generated by Svelte v3.59.2 */

const file$2g = "../../components/ui/src/icons/feather/Navigation2.svelte";

function create_fragment$2k(ctx) {
	let polygon;

	const block = {
		c: function create() {
			polygon = svg_element("polygon");
			this.h();
		},
		l: function claim(nodes) {
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polygon, "points", "12 2 19 21 12 17 5 21 12 2");
			add_location(polygon, file$2g, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polygon, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polygon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2j($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Navigation2', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Navigation2> was created with unknown prop '${key}'`);
	});

	return [];
}

class Navigation2 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2j, create_fragment$2k, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Navigation2",
			options,
			id: create_fragment$2k.name
		});
	}
}

var Navigation2$1 = Navigation2;

/* ../../components/ui/src/icons/feather/Navigation.svelte generated by Svelte v3.59.2 */

const file$2f = "../../components/ui/src/icons/feather/Navigation.svelte";

function create_fragment$2j(ctx) {
	let polygon;

	const block = {
		c: function create() {
			polygon = svg_element("polygon");
			this.h();
		},
		l: function claim(nodes) {
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polygon, "points", "3 11 22 2 13 21 11 13 3 11");
			add_location(polygon, file$2f, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polygon, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polygon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2i($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Navigation', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Navigation> was created with unknown prop '${key}'`);
	});

	return [];
}

class Navigation extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2i, create_fragment$2j, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Navigation",
			options,
			id: create_fragment$2j.name
		});
	}
}

var Navigation$1 = Navigation;

/* ../../components/ui/src/icons/feather/Octagon.svelte generated by Svelte v3.59.2 */

const file$2e = "../../components/ui/src/icons/feather/Octagon.svelte";

function create_fragment$2i(ctx) {
	let polygon;

	const block = {
		c: function create() {
			polygon = svg_element("polygon");
			this.h();
		},
		l: function claim(nodes) {
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polygon, "points", "7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2");
			add_location(polygon, file$2e, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polygon, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polygon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2h($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Octagon', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Octagon> was created with unknown prop '${key}'`);
	});

	return [];
}

class Octagon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2h, create_fragment$2i, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Octagon",
			options,
			id: create_fragment$2i.name
		});
	}
}

var Octagon$1 = Octagon;

/* ../../components/ui/src/icons/feather/Package.svelte generated by Svelte v3.59.2 */

const file$2d = "../../components/ui/src/icons/feather/Package.svelte";

function create_fragment$2h(ctx) {
	let line0;
	let path;
	let polyline;
	let line1;

	const block = {
		c: function create() {
			line0 = svg_element("line");
			path = svg_element("path");
			polyline = svg_element("polyline");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line0, "x1", "16.5");
			attr_dev(line0, "y1", "9.4");
			attr_dev(line0, "x2", "7.5");
			attr_dev(line0, "y2", "4.21");
			add_location(line0, file$2d, 1, 0, 34);
			attr_dev(path, "d", "M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z");
			add_location(path, file$2d, 1, 51, 85);
			attr_dev(polyline, "points", "3.27 6.96 12 12.01 20.73 6.96");
			add_location(polyline, file$2d, 1, 190, 224);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "22.08");
			attr_dev(line1, "x2", "12");
			attr_dev(line1, "y2", "12");
			add_location(line1, file$2d, 1, 250, 284);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2g($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Package', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Package> was created with unknown prop '${key}'`);
	});

	return [];
}

class Package extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2g, create_fragment$2h, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Package",
			options,
			id: create_fragment$2h.name
		});
	}
}

var Package$1 = Package;

/* ../../components/ui/src/icons/feather/Paperclip.svelte generated by Svelte v3.59.2 */

const file$2c = "../../components/ui/src/icons/feather/Paperclip.svelte";

function create_fragment$2g(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48");
			add_location(path, file$2c, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2f($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Paperclip', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Paperclip> was created with unknown prop '${key}'`);
	});

	return [];
}

class Paperclip extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2f, create_fragment$2g, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Paperclip",
			options,
			id: create_fragment$2g.name
		});
	}
}

var Paperclip$1 = Paperclip;

/* ../../components/ui/src/icons/feather/PauseCircle.svelte generated by Svelte v3.59.2 */

const file$2b = "../../components/ui/src/icons/feather/PauseCircle.svelte";

function create_fragment$2f(ctx) {
	let circle;
	let line0;
	let line1;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$2b, 1, 0, 34);
			attr_dev(line0, "x1", "10");
			attr_dev(line0, "y1", "15");
			attr_dev(line0, "x2", "10");
			attr_dev(line0, "y2", "9");
			add_location(line0, file$2b, 1, 40, 74);
			attr_dev(line1, "x1", "14");
			attr_dev(line1, "y1", "15");
			attr_dev(line1, "x2", "14");
			attr_dev(line1, "y2", "9");
			add_location(line1, file$2b, 1, 84, 118);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2e($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('PauseCircle', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PauseCircle> was created with unknown prop '${key}'`);
	});

	return [];
}

class PauseCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2e, create_fragment$2f, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PauseCircle",
			options,
			id: create_fragment$2f.name
		});
	}
}

var PauseCircle$1 = PauseCircle;

/* ../../components/ui/src/icons/feather/Pause.svelte generated by Svelte v3.59.2 */

const file$2a = "../../components/ui/src/icons/feather/Pause.svelte";

function create_fragment$2e(ctx) {
	let rect0;
	let rect1;

	const block = {
		c: function create() {
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			this.h();
		},
		l: function claim(nodes) {
			rect0 = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true
			});

			children(rect0).forEach(detach_dev);

			rect1 = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true
			});

			children(rect1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect0, "x", "6");
			attr_dev(rect0, "y", "4");
			attr_dev(rect0, "width", "4");
			attr_dev(rect0, "height", "16");
			add_location(rect0, file$2a, 1, 0, 34);
			attr_dev(rect1, "x", "14");
			attr_dev(rect1, "y", "4");
			attr_dev(rect1, "width", "4");
			attr_dev(rect1, "height", "16");
			add_location(rect1, file$2a, 1, 47, 81);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect0, anchor);
			insert_hydration_dev(target, rect1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect0);
			if (detaching) detach_dev(rect1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2d($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Pause', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Pause> was created with unknown prop '${key}'`);
	});

	return [];
}

class Pause extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2d, create_fragment$2e, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Pause",
			options,
			id: create_fragment$2e.name
		});
	}
}

var Pause$1 = Pause;

/* ../../components/ui/src/icons/feather/PenTool.svelte generated by Svelte v3.59.2 */

const file$29 = "../../components/ui/src/icons/feather/PenTool.svelte";

function create_fragment$2d(ctx) {
	let path0;
	let path1;
	let path2;
	let circle;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			circle = svg_element("circle");
			this.h();
		},
		l: function claim(nodes) {
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			path2 = claim_svg_element(nodes, "path", { d: true });
			children(path2).forEach(detach_dev);
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M12 19l7-7 3 3-7 7-3-3z");
			add_location(path0, file$29, 1, 0, 34);
			attr_dev(path1, "d", "M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z");
			add_location(path1, file$29, 1, 41, 75);
			attr_dev(path2, "d", "M2 2l7.586 7.586");
			add_location(path2, file$29, 1, 98, 132);
			attr_dev(circle, "cx", "11");
			attr_dev(circle, "cy", "11");
			attr_dev(circle, "r", "2");
			add_location(circle, file$29, 1, 132, 166);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
			insert_hydration_dev(target, path2, anchor);
			insert_hydration_dev(target, circle, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
			if (detaching) detach_dev(path2);
			if (detaching) detach_dev(circle);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2c($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('PenTool', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PenTool> was created with unknown prop '${key}'`);
	});

	return [];
}

class PenTool extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2c, create_fragment$2d, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PenTool",
			options,
			id: create_fragment$2d.name
		});
	}
}

var PenTool$1 = PenTool;

/* ../../components/ui/src/icons/feather/Percent.svelte generated by Svelte v3.59.2 */

const file$28 = "../../components/ui/src/icons/feather/Percent.svelte";

function create_fragment$2c(ctx) {
	let line;
	let circle0;
	let circle1;

	const block = {
		c: function create() {
			line = svg_element("line");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			this.h();
		},
		l: function claim(nodes) {
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			circle0 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle0).forEach(detach_dev);
			circle1 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line, "x1", "19");
			attr_dev(line, "y1", "5");
			attr_dev(line, "x2", "5");
			attr_dev(line, "y2", "19");
			add_location(line, file$28, 1, 0, 34);
			attr_dev(circle0, "cx", "6.5");
			attr_dev(circle0, "cy", "6.5");
			attr_dev(circle0, "r", "2.5");
			add_location(circle0, file$28, 1, 43, 77);
			attr_dev(circle1, "cx", "17.5");
			attr_dev(circle1, "cy", "17.5");
			attr_dev(circle1, "r", "2.5");
			add_location(circle1, file$28, 1, 86, 120);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line, anchor);
			insert_hydration_dev(target, circle0, anchor);
			insert_hydration_dev(target, circle1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line);
			if (detaching) detach_dev(circle0);
			if (detaching) detach_dev(circle1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2b($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Percent', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Percent> was created with unknown prop '${key}'`);
	});

	return [];
}

class Percent extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2b, create_fragment$2c, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Percent",
			options,
			id: create_fragment$2c.name
		});
	}
}

var Percent$1 = Percent;

/* ../../components/ui/src/icons/feather/PhoneCall.svelte generated by Svelte v3.59.2 */

const file$27 = "../../components/ui/src/icons/feather/PhoneCall.svelte";

function create_fragment$2b(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.98v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
			add_location(path, file$27, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2a($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('PhoneCall', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PhoneCall> was created with unknown prop '${key}'`);
	});

	return [];
}

class PhoneCall extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2a, create_fragment$2b, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PhoneCall",
			options,
			id: create_fragment$2b.name
		});
	}
}

var PhoneCall$1 = PhoneCall;

/* ../../components/ui/src/icons/feather/PhoneForwarded.svelte generated by Svelte v3.59.2 */

const file$26 = "../../components/ui/src/icons/feather/PhoneForwarded.svelte";

function create_fragment$2a(ctx) {
	let polyline;
	let line;
	let path;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			line = svg_element("line");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "19 1 23 5 19 9");
			add_location(polyline, file$26, 1, 0, 34);
			attr_dev(line, "x1", "15");
			attr_dev(line, "y1", "5");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "5");
			add_location(line, file$26, 1, 45, 79);
			attr_dev(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
			add_location(path, file$26, 1, 88, 122);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, line, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(line);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$29($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('PhoneForwarded', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PhoneForwarded> was created with unknown prop '${key}'`);
	});

	return [];
}

class PhoneForwarded extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$29, create_fragment$2a, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PhoneForwarded",
			options,
			id: create_fragment$2a.name
		});
	}
}

var PhoneForwarded$1 = PhoneForwarded;

/* ../../components/ui/src/icons/feather/PhoneIncoming.svelte generated by Svelte v3.59.2 */

const file$25 = "../../components/ui/src/icons/feather/PhoneIncoming.svelte";

function create_fragment$29(ctx) {
	let polyline;
	let line;
	let path;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			line = svg_element("line");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "16 2 16 8 22 8");
			add_location(polyline, file$25, 1, 0, 34);
			attr_dev(line, "x1", "23");
			attr_dev(line, "y1", "1");
			attr_dev(line, "x2", "16");
			attr_dev(line, "y2", "8");
			add_location(line, file$25, 1, 45, 79);
			attr_dev(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
			add_location(path, file$25, 1, 88, 122);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, line, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(line);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$29.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$28($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('PhoneIncoming', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PhoneIncoming> was created with unknown prop '${key}'`);
	});

	return [];
}

class PhoneIncoming extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$28, create_fragment$29, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PhoneIncoming",
			options,
			id: create_fragment$29.name
		});
	}
}

var PhoneIncoming$1 = PhoneIncoming;

/* ../../components/ui/src/icons/feather/PhoneMissed.svelte generated by Svelte v3.59.2 */

const file$24 = "../../components/ui/src/icons/feather/PhoneMissed.svelte";

function create_fragment$28(ctx) {
	let line0;
	let line1;
	let path;

	const block = {
		c: function create() {
			line0 = svg_element("line");
			line1 = svg_element("line");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line0, "x1", "23");
			attr_dev(line0, "y1", "1");
			attr_dev(line0, "x2", "17");
			attr_dev(line0, "y2", "7");
			add_location(line0, file$24, 1, 0, 34);
			attr_dev(line1, "x1", "17");
			attr_dev(line1, "y1", "1");
			attr_dev(line1, "x2", "23");
			attr_dev(line1, "y2", "7");
			add_location(line1, file$24, 1, 43, 77);
			attr_dev(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
			add_location(path, file$24, 1, 86, 120);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$28.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$27($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('PhoneMissed', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PhoneMissed> was created with unknown prop '${key}'`);
	});

	return [];
}

class PhoneMissed extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$27, create_fragment$28, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PhoneMissed",
			options,
			id: create_fragment$28.name
		});
	}
}

var PhoneMissed$1 = PhoneMissed;

/* ../../components/ui/src/icons/feather/PhoneOff.svelte generated by Svelte v3.59.2 */

const file$23 = "../../components/ui/src/icons/feather/PhoneOff.svelte";

function create_fragment$27(ctx) {
	let path;
	let line;

	const block = {
		c: function create() {
			path = svg_element("path");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91");
			add_location(path, file$23, 1, 0, 34);
			attr_dev(line, "x1", "23");
			attr_dev(line, "y1", "1");
			attr_dev(line, "x2", "1");
			attr_dev(line, "y2", "23");
			add_location(line, file$23, 1, 327, 361);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$27.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$26($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('PhoneOff', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PhoneOff> was created with unknown prop '${key}'`);
	});

	return [];
}

class PhoneOff extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$26, create_fragment$27, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PhoneOff",
			options,
			id: create_fragment$27.name
		});
	}
}

var PhoneOff$1 = PhoneOff;

/* ../../components/ui/src/icons/feather/PhoneOutgoing.svelte generated by Svelte v3.59.2 */

const file$22 = "../../components/ui/src/icons/feather/PhoneOutgoing.svelte";

function create_fragment$26(ctx) {
	let polyline;
	let line;
	let path;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			line = svg_element("line");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "23 7 23 1 17 1");
			add_location(polyline, file$22, 1, 0, 34);
			attr_dev(line, "x1", "16");
			attr_dev(line, "y1", "8");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "1");
			add_location(line, file$22, 1, 45, 79);
			attr_dev(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
			add_location(path, file$22, 1, 88, 122);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, line, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(line);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$26.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$25($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('PhoneOutgoing', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PhoneOutgoing> was created with unknown prop '${key}'`);
	});

	return [];
}

class PhoneOutgoing extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$25, create_fragment$26, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PhoneOutgoing",
			options,
			id: create_fragment$26.name
		});
	}
}

var PhoneOutgoing$1 = PhoneOutgoing;

/* ../../components/ui/src/icons/feather/Phone.svelte generated by Svelte v3.59.2 */

const file$21 = "../../components/ui/src/icons/feather/Phone.svelte";

function create_fragment$25(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z");
			add_location(path, file$21, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$25.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$24($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Phone', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Phone> was created with unknown prop '${key}'`);
	});

	return [];
}

class Phone extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$24, create_fragment$25, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Phone",
			options,
			id: create_fragment$25.name
		});
	}
}

var Phone$1 = Phone;

/* ../../components/ui/src/icons/feather/PieChart.svelte generated by Svelte v3.59.2 */

const file$20 = "../../components/ui/src/icons/feather/PieChart.svelte";

function create_fragment$24(ctx) {
	let path0;
	let path1;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M21.21 15.89A10 10 0 1 1 8 2.83");
			add_location(path0, file$20, 1, 0, 34);
			attr_dev(path1, "d", "M22 12A10 10 0 0 0 12 2v10z");
			add_location(path1, file$20, 1, 49, 83);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$24.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$23($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('PieChart', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PieChart> was created with unknown prop '${key}'`);
	});

	return [];
}

class PieChart extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$23, create_fragment$24, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PieChart",
			options,
			id: create_fragment$24.name
		});
	}
}

var PieChart$1 = PieChart;

/* ../../components/ui/src/icons/feather/PlayCircle.svelte generated by Svelte v3.59.2 */

const file$1$ = "../../components/ui/src/icons/feather/PlayCircle.svelte";

function create_fragment$23(ctx) {
	let circle;
	let polygon;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			polygon = svg_element("polygon");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$1$, 1, 0, 34);
			attr_dev(polygon, "points", "10 8 16 12 10 16 10 8");
			add_location(polygon, file$1$, 1, 40, 74);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, polygon, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(polygon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$23.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$22($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('PlayCircle', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PlayCircle> was created with unknown prop '${key}'`);
	});

	return [];
}

class PlayCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$22, create_fragment$23, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PlayCircle",
			options,
			id: create_fragment$23.name
		});
	}
}

var PlayCircle$1 = PlayCircle;

/* ../../components/ui/src/icons/feather/Play.svelte generated by Svelte v3.59.2 */

const file$1_ = "../../components/ui/src/icons/feather/Play.svelte";

function create_fragment$22(ctx) {
	let polygon;

	const block = {
		c: function create() {
			polygon = svg_element("polygon");
			this.h();
		},
		l: function claim(nodes) {
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polygon, "points", "5 3 19 12 5 21 5 3");
			add_location(polygon, file$1_, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polygon, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polygon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$22.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$21($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Play', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Play> was created with unknown prop '${key}'`);
	});

	return [];
}

class Play extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$21, create_fragment$22, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Play",
			options,
			id: create_fragment$22.name
		});
	}
}

var Play$1 = Play;

/* ../../components/ui/src/icons/feather/PlusSquare.svelte generated by Svelte v3.59.2 */

const file$1Z = "../../components/ui/src/icons/feather/PlusSquare.svelte";

function create_fragment$21(ctx) {
	let rect;
	let line0;
	let line1;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "3");
			attr_dev(rect, "y", "3");
			attr_dev(rect, "width", "18");
			attr_dev(rect, "height", "18");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$1Z, 1, 0, 34);
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "8");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "16");
			add_location(line0, file$1Z, 1, 62, 96);
			attr_dev(line1, "x1", "8");
			attr_dev(line1, "y1", "12");
			attr_dev(line1, "x2", "16");
			attr_dev(line1, "y2", "12");
			add_location(line1, file$1Z, 1, 106, 140);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$21.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$20($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('PlusSquare', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PlusSquare> was created with unknown prop '${key}'`);
	});

	return [];
}

class PlusSquare extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$20, create_fragment$21, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PlusSquare",
			options,
			id: create_fragment$21.name
		});
	}
}

var PlusSquare$1 = PlusSquare;

/* ../../components/ui/src/icons/feather/Plus.svelte generated by Svelte v3.59.2 */

const file$1Y = "../../components/ui/src/icons/feather/Plus.svelte";

function create_fragment$20(ctx) {
	let line0;
	let line1;

	const block = {
		c: function create() {
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "5");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "19");
			add_location(line0, file$1Y, 1, 0, 34);
			attr_dev(line1, "x1", "5");
			attr_dev(line1, "y1", "12");
			attr_dev(line1, "x2", "19");
			attr_dev(line1, "y2", "12");
			add_location(line1, file$1Y, 1, 44, 78);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$20.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1$($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Plus', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Plus> was created with unknown prop '${key}'`);
	});

	return [];
}

class Plus extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1$, create_fragment$20, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Plus",
			options,
			id: create_fragment$20.name
		});
	}
}

var Plus$1 = Plus;

/* ../../components/ui/src/icons/feather/Pocket.svelte generated by Svelte v3.59.2 */

const file$1X = "../../components/ui/src/icons/feather/Pocket.svelte";

function create_fragment$1$(ctx) {
	let path;
	let polyline;

	const block = {
		c: function create() {
			path = svg_element("path");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M4 3h16a2 2 0 0 1 2 2v6a10 10 0 0 1-10 10A10 10 0 0 1 2 11V5a2 2 0 0 1 2-2z");
			add_location(path, file$1X, 1, 0, 34);
			attr_dev(polyline, "points", "8 10 12 14 16 10");
			add_location(polyline, file$1X, 1, 93, 127);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, polyline, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(polyline);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1$.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1_($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Pocket', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Pocket> was created with unknown prop '${key}'`);
	});

	return [];
}

class Pocket extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1_, create_fragment$1$, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Pocket",
			options,
			id: create_fragment$1$.name
		});
	}
}

var Pocket$1 = Pocket;

/* ../../components/ui/src/icons/feather/Power.svelte generated by Svelte v3.59.2 */

const file$1W = "../../components/ui/src/icons/feather/Power.svelte";

function create_fragment$1_(ctx) {
	let path;
	let line;

	const block = {
		c: function create() {
			path = svg_element("path");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M18.36 6.64a9 9 0 1 1-12.73 0");
			add_location(path, file$1W, 1, 0, 34);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "2");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "12");
			add_location(line, file$1W, 1, 47, 81);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1_.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1Z($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Power', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Power> was created with unknown prop '${key}'`);
	});

	return [];
}

class Power extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1Z, create_fragment$1_, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Power",
			options,
			id: create_fragment$1_.name
		});
	}
}

var Power$1 = Power;

/* ../../components/ui/src/icons/feather/Printer.svelte generated by Svelte v3.59.2 */

const file$1V = "../../components/ui/src/icons/feather/Printer.svelte";

function create_fragment$1Z(ctx) {
	let polyline;
	let path;
	let rect;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			path = svg_element("path");
			rect = svg_element("rect");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);

			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true
			});

			children(rect).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "6 9 6 2 18 2 18 9");
			add_location(polyline, file$1V, 1, 0, 34);
			attr_dev(path, "d", "M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2");
			add_location(path, file$1V, 1, 48, 82);
			attr_dev(rect, "x", "6");
			attr_dev(rect, "y", "14");
			attr_dev(rect, "width", "12");
			attr_dev(rect, "height", "8");
			add_location(rect, file$1V, 1, 140, 174);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, rect, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(rect);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1Z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1Y($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Printer', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Printer> was created with unknown prop '${key}'`);
	});

	return [];
}

class Printer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1Y, create_fragment$1Z, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Printer",
			options,
			id: create_fragment$1Z.name
		});
	}
}

var Printer$1 = Printer;

/* ../../components/ui/src/icons/feather/Radio.svelte generated by Svelte v3.59.2 */

const file$1U = "../../components/ui/src/icons/feather/Radio.svelte";

function create_fragment$1Y(ctx) {
	let circle;
	let path;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "2");
			add_location(circle, file$1U, 1, 0, 34);
			attr_dev(path, "d", "M16.24 7.76a6 6 0 0 1 0 8.49m-8.48-.01a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0 14.14m-14.14 0a10 10 0 0 1 0-14.14");
			add_location(path, file$1U, 1, 39, 73);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1Y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1X($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Radio', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Radio> was created with unknown prop '${key}'`);
	});

	return [];
}

class Radio extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1X, create_fragment$1Y, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Radio",
			options,
			id: create_fragment$1Y.name
		});
	}
}

var Radio$1 = Radio;

/* ../../components/ui/src/icons/feather/RefreshCcw.svelte generated by Svelte v3.59.2 */

const file$1T = "../../components/ui/src/icons/feather/RefreshCcw.svelte";

function create_fragment$1X(ctx) {
	let polyline0;
	let polyline1;
	let path;

	const block = {
		c: function create() {
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			polyline0 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline0).forEach(detach_dev);
			polyline1 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline1).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline0, "points", "1 4 1 10 7 10");
			add_location(polyline0, file$1T, 1, 0, 34);
			attr_dev(polyline1, "points", "23 20 23 14 17 14");
			add_location(polyline1, file$1T, 1, 44, 78);
			attr_dev(path, "d", "M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15");
			add_location(path, file$1T, 1, 92, 126);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline0, anchor);
			insert_hydration_dev(target, polyline1, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline0);
			if (detaching) detach_dev(polyline1);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1X.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1W($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('RefreshCcw', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RefreshCcw> was created with unknown prop '${key}'`);
	});

	return [];
}

class RefreshCcw extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1W, create_fragment$1X, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "RefreshCcw",
			options,
			id: create_fragment$1X.name
		});
	}
}

var RefreshCcw$1 = RefreshCcw;

/* ../../components/ui/src/icons/feather/RefreshCw.svelte generated by Svelte v3.59.2 */

const file$1S = "../../components/ui/src/icons/feather/RefreshCw.svelte";

function create_fragment$1W(ctx) {
	let polyline0;
	let polyline1;
	let path;

	const block = {
		c: function create() {
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			polyline0 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline0).forEach(detach_dev);
			polyline1 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline1).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline0, "points", "23 4 23 10 17 10");
			add_location(polyline0, file$1S, 1, 0, 34);
			attr_dev(polyline1, "points", "1 20 1 14 7 14");
			add_location(polyline1, file$1S, 1, 47, 81);
			attr_dev(path, "d", "M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15");
			add_location(path, file$1S, 1, 92, 126);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline0, anchor);
			insert_hydration_dev(target, polyline1, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline0);
			if (detaching) detach_dev(polyline1);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1W.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1V($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('RefreshCw', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RefreshCw> was created with unknown prop '${key}'`);
	});

	return [];
}

class RefreshCw extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1V, create_fragment$1W, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "RefreshCw",
			options,
			id: create_fragment$1W.name
		});
	}
}

var RefreshCw$1 = RefreshCw;

/* ../../components/ui/src/icons/feather/Repeat.svelte generated by Svelte v3.59.2 */

const file$1R = "../../components/ui/src/icons/feather/Repeat.svelte";

function create_fragment$1V(ctx) {
	let polyline0;
	let path0;
	let polyline1;
	let path1;

	const block = {
		c: function create() {
			polyline0 = svg_element("polyline");
			path0 = svg_element("path");
			polyline1 = svg_element("polyline");
			path1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			polyline0 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline0).forEach(detach_dev);
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			polyline1 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline1).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline0, "points", "17 1 21 5 17 9");
			add_location(polyline0, file$1R, 1, 0, 34);
			attr_dev(path0, "d", "M3 11V9a4 4 0 0 1 4-4h14");
			add_location(path0, file$1R, 1, 45, 79);
			attr_dev(polyline1, "points", "7 23 3 19 7 15");
			add_location(polyline1, file$1R, 1, 87, 121);
			attr_dev(path1, "d", "M21 13v2a4 4 0 0 1-4 4H3");
			add_location(path1, file$1R, 1, 132, 166);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline0, anchor);
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, polyline1, anchor);
			insert_hydration_dev(target, path1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline0);
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(polyline1);
			if (detaching) detach_dev(path1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1V.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1U($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Repeat', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Repeat> was created with unknown prop '${key}'`);
	});

	return [];
}

class Repeat extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1U, create_fragment$1V, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Repeat",
			options,
			id: create_fragment$1V.name
		});
	}
}

var Repeat$1 = Repeat;

/* ../../components/ui/src/icons/feather/Rewind.svelte generated by Svelte v3.59.2 */

const file$1Q = "../../components/ui/src/icons/feather/Rewind.svelte";

function create_fragment$1U(ctx) {
	let polygon0;
	let polygon1;

	const block = {
		c: function create() {
			polygon0 = svg_element("polygon");
			polygon1 = svg_element("polygon");
			this.h();
		},
		l: function claim(nodes) {
			polygon0 = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon0).forEach(detach_dev);
			polygon1 = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polygon0, "points", "11 19 2 12 11 5 11 19");
			add_location(polygon0, file$1Q, 1, 0, 34);
			attr_dev(polygon1, "points", "22 19 13 12 22 5 22 19");
			add_location(polygon1, file$1Q, 1, 50, 84);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polygon0, anchor);
			insert_hydration_dev(target, polygon1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polygon0);
			if (detaching) detach_dev(polygon1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1U.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1T($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Rewind', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Rewind> was created with unknown prop '${key}'`);
	});

	return [];
}

class Rewind extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1T, create_fragment$1U, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Rewind",
			options,
			id: create_fragment$1U.name
		});
	}
}

var Rewind$1 = Rewind;

/* ../../components/ui/src/icons/feather/RotateCcw.svelte generated by Svelte v3.59.2 */

const file$1P = "../../components/ui/src/icons/feather/RotateCcw.svelte";

function create_fragment$1T(ctx) {
	let polyline;
	let path;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "1 4 1 10 7 10");
			add_location(polyline, file$1P, 1, 0, 34);
			attr_dev(path, "d", "M3.51 15a9 9 0 1 0 2.13-9.36L1 10");
			add_location(path, file$1P, 1, 44, 78);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1T.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1S($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('RotateCcw', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RotateCcw> was created with unknown prop '${key}'`);
	});

	return [];
}

class RotateCcw extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1S, create_fragment$1T, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "RotateCcw",
			options,
			id: create_fragment$1T.name
		});
	}
}

var RotateCcw$1 = RotateCcw;

/* ../../components/ui/src/icons/feather/RotateCw.svelte generated by Svelte v3.59.2 */

const file$1O = "../../components/ui/src/icons/feather/RotateCw.svelte";

function create_fragment$1S(ctx) {
	let polyline;
	let path;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "23 4 23 10 17 10");
			add_location(polyline, file$1O, 1, 0, 34);
			attr_dev(path, "d", "M20.49 15a9 9 0 1 1-2.12-9.36L23 10");
			add_location(path, file$1O, 1, 47, 81);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1S.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1R($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('RotateCw', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RotateCw> was created with unknown prop '${key}'`);
	});

	return [];
}

class RotateCw extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1R, create_fragment$1S, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "RotateCw",
			options,
			id: create_fragment$1S.name
		});
	}
}

var RotateCw$1 = RotateCw;

/* ../../components/ui/src/icons/feather/Rss.svelte generated by Svelte v3.59.2 */

const file$1N = "../../components/ui/src/icons/feather/Rss.svelte";

function create_fragment$1R(ctx) {
	let path0;
	let path1;
	let circle;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			circle = svg_element("circle");
			this.h();
		},
		l: function claim(nodes) {
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M4 11a9 9 0 0 1 9 9");
			add_location(path0, file$1N, 1, 0, 34);
			attr_dev(path1, "d", "M4 4a16 16 0 0 1 16 16");
			add_location(path1, file$1N, 1, 37, 71);
			attr_dev(circle, "cx", "5");
			attr_dev(circle, "cy", "19");
			attr_dev(circle, "r", "1");
			add_location(circle, file$1N, 1, 77, 111);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
			insert_hydration_dev(target, circle, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
			if (detaching) detach_dev(circle);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1R.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1Q($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Rss', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Rss> was created with unknown prop '${key}'`);
	});

	return [];
}

class Rss extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1Q, create_fragment$1R, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Rss",
			options,
			id: create_fragment$1R.name
		});
	}
}

var Rss$1 = Rss;

/* ../../components/ui/src/icons/feather/Save.svelte generated by Svelte v3.59.2 */

const file$1M = "../../components/ui/src/icons/feather/Save.svelte";

function create_fragment$1Q(ctx) {
	let path;
	let polyline0;
	let polyline1;

	const block = {
		c: function create() {
			path = svg_element("path");
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			polyline0 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline0).forEach(detach_dev);
			polyline1 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z");
			add_location(path, file$1M, 1, 0, 34);
			attr_dev(polyline0, "points", "17 21 17 13 7 13 7 21");
			add_location(polyline0, file$1M, 1, 81, 115);
			attr_dev(polyline1, "points", "7 3 7 8 15 8");
			add_location(polyline1, file$1M, 1, 133, 167);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, polyline0, anchor);
			insert_hydration_dev(target, polyline1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(polyline0);
			if (detaching) detach_dev(polyline1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1Q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1P($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Save', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Save> was created with unknown prop '${key}'`);
	});

	return [];
}

class Save extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1P, create_fragment$1Q, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Save",
			options,
			id: create_fragment$1Q.name
		});
	}
}

var Save$1 = Save;

/* ../../components/ui/src/icons/feather/Scissors.svelte generated by Svelte v3.59.2 */

const file$1L = "../../components/ui/src/icons/feather/Scissors.svelte";

function create_fragment$1P(ctx) {
	let circle0;
	let circle1;
	let line0;
	let line1;
	let line2;

	const block = {
		c: function create() {
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			circle0 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle0).forEach(detach_dev);
			circle1 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle1).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle0, "cx", "6");
			attr_dev(circle0, "cy", "6");
			attr_dev(circle0, "r", "3");
			add_location(circle0, file$1L, 1, 0, 34);
			attr_dev(circle1, "cx", "6");
			attr_dev(circle1, "cy", "18");
			attr_dev(circle1, "r", "3");
			add_location(circle1, file$1L, 1, 37, 71);
			attr_dev(line0, "x1", "20");
			attr_dev(line0, "y1", "4");
			attr_dev(line0, "x2", "8.12");
			attr_dev(line0, "y2", "15.88");
			add_location(line0, file$1L, 1, 75, 109);
			attr_dev(line1, "x1", "14.47");
			attr_dev(line1, "y1", "14.48");
			attr_dev(line1, "x2", "20");
			attr_dev(line1, "y2", "20");
			add_location(line1, file$1L, 1, 124, 158);
			attr_dev(line2, "x1", "8.12");
			attr_dev(line2, "y1", "8.12");
			attr_dev(line2, "x2", "12");
			attr_dev(line2, "y2", "12");
			add_location(line2, file$1L, 1, 175, 209);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle0, anchor);
			insert_hydration_dev(target, circle1, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle0);
			if (detaching) detach_dev(circle1);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1P.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1O($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Scissors', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Scissors> was created with unknown prop '${key}'`);
	});

	return [];
}

class Scissors extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1O, create_fragment$1P, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Scissors",
			options,
			id: create_fragment$1P.name
		});
	}
}

var Scissors$1 = Scissors;

/* ../../components/ui/src/icons/feather/Search.svelte generated by Svelte v3.59.2 */

const file$1K = "../../components/ui/src/icons/feather/Search.svelte";

function create_fragment$1O(ctx) {
	let circle;
	let line;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "11");
			attr_dev(circle, "cy", "11");
			attr_dev(circle, "r", "8");
			add_location(circle, file$1K, 1, 0, 34);
			attr_dev(line, "x1", "21");
			attr_dev(line, "y1", "21");
			attr_dev(line, "x2", "16.65");
			attr_dev(line, "y2", "16.65");
			add_location(line, file$1K, 1, 39, 73);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1O.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1N($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Search', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Search> was created with unknown prop '${key}'`);
	});

	return [];
}

class Search extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1N, create_fragment$1O, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Search",
			options,
			id: create_fragment$1O.name
		});
	}
}

var Search$1 = Search;

/* ../../components/ui/src/icons/feather/Send.svelte generated by Svelte v3.59.2 */

const file$1J = "../../components/ui/src/icons/feather/Send.svelte";

function create_fragment$1N(ctx) {
	let line;
	let polygon;

	const block = {
		c: function create() {
			line = svg_element("line");
			polygon = svg_element("polygon");
			this.h();
		},
		l: function claim(nodes) {
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line, "x1", "22");
			attr_dev(line, "y1", "2");
			attr_dev(line, "x2", "11");
			attr_dev(line, "y2", "13");
			add_location(line, file$1J, 1, 0, 34);
			attr_dev(polygon, "points", "22 2 15 22 11 13 2 9 22 2");
			add_location(polygon, file$1J, 1, 44, 78);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line, anchor);
			insert_hydration_dev(target, polygon, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line);
			if (detaching) detach_dev(polygon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1N.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1M($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Send', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Send> was created with unknown prop '${key}'`);
	});

	return [];
}

class Send extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1M, create_fragment$1N, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Send",
			options,
			id: create_fragment$1N.name
		});
	}
}

var Send$1 = Send;

/* ../../components/ui/src/icons/feather/Server.svelte generated by Svelte v3.59.2 */

const file$1I = "../../components/ui/src/icons/feather/Server.svelte";

function create_fragment$1M(ctx) {
	let rect0;
	let rect1;
	let line0;
	let line1;

	const block = {
		c: function create() {
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			rect0 = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect0).forEach(detach_dev);

			rect1 = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect1).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect0, "x", "2");
			attr_dev(rect0, "y", "2");
			attr_dev(rect0, "width", "20");
			attr_dev(rect0, "height", "8");
			attr_dev(rect0, "rx", "2");
			attr_dev(rect0, "ry", "2");
			add_location(rect0, file$1I, 1, 0, 34);
			attr_dev(rect1, "x", "2");
			attr_dev(rect1, "y", "14");
			attr_dev(rect1, "width", "20");
			attr_dev(rect1, "height", "8");
			attr_dev(rect1, "rx", "2");
			attr_dev(rect1, "ry", "2");
			add_location(rect1, file$1I, 1, 61, 95);
			attr_dev(line0, "x1", "6");
			attr_dev(line0, "y1", "6");
			attr_dev(line0, "x2", "6.01");
			attr_dev(line0, "y2", "6");
			add_location(line0, file$1I, 1, 123, 157);
			attr_dev(line1, "x1", "6");
			attr_dev(line1, "y1", "18");
			attr_dev(line1, "x2", "6.01");
			attr_dev(line1, "y2", "18");
			add_location(line1, file$1I, 1, 167, 201);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect0, anchor);
			insert_hydration_dev(target, rect1, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect0);
			if (detaching) detach_dev(rect1);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1M.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1L($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Server', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Server> was created with unknown prop '${key}'`);
	});

	return [];
}

class Server extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1L, create_fragment$1M, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Server",
			options,
			id: create_fragment$1M.name
		});
	}
}

var Server$1 = Server;

/* ../../components/ui/src/icons/feather/Share2.svelte generated by Svelte v3.59.2 */

const file$1H = "../../components/ui/src/icons/feather/Share2.svelte";

function create_fragment$1L(ctx) {
	let circle0;
	let circle1;
	let circle2;
	let line0;
	let line1;

	const block = {
		c: function create() {
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			circle0 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle0).forEach(detach_dev);
			circle1 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle1).forEach(detach_dev);
			circle2 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle2).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle0, "cx", "18");
			attr_dev(circle0, "cy", "5");
			attr_dev(circle0, "r", "3");
			add_location(circle0, file$1H, 1, 0, 34);
			attr_dev(circle1, "cx", "6");
			attr_dev(circle1, "cy", "12");
			attr_dev(circle1, "r", "3");
			add_location(circle1, file$1H, 1, 38, 72);
			attr_dev(circle2, "cx", "18");
			attr_dev(circle2, "cy", "19");
			attr_dev(circle2, "r", "3");
			add_location(circle2, file$1H, 1, 76, 110);
			attr_dev(line0, "x1", "8.59");
			attr_dev(line0, "y1", "13.51");
			attr_dev(line0, "x2", "15.42");
			attr_dev(line0, "y2", "17.49");
			add_location(line0, file$1H, 1, 115, 149);
			attr_dev(line1, "x1", "15.41");
			attr_dev(line1, "y1", "6.51");
			attr_dev(line1, "x2", "8.59");
			attr_dev(line1, "y2", "10.49");
			add_location(line1, file$1H, 1, 171, 205);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle0, anchor);
			insert_hydration_dev(target, circle1, anchor);
			insert_hydration_dev(target, circle2, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle0);
			if (detaching) detach_dev(circle1);
			if (detaching) detach_dev(circle2);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1L.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1K($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Share2', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Share2> was created with unknown prop '${key}'`);
	});

	return [];
}

class Share2 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1K, create_fragment$1L, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Share2",
			options,
			id: create_fragment$1L.name
		});
	}
}

var Share2$1 = Share2;

/* ../../components/ui/src/icons/feather/Share.svelte generated by Svelte v3.59.2 */

const file$1G = "../../components/ui/src/icons/feather/Share.svelte";

function create_fragment$1K(ctx) {
	let path;
	let polyline;
	let line;

	const block = {
		c: function create() {
			path = svg_element("path");
			polyline = svg_element("polyline");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8");
			add_location(path, file$1G, 1, 0, 34);
			attr_dev(polyline, "points", "16 6 12 2 8 6");
			add_location(polyline, file$1G, 1, 59, 93);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "2");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "15");
			add_location(line, file$1G, 1, 103, 137);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1K.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1J($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Share', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Share> was created with unknown prop '${key}'`);
	});

	return [];
}

class Share extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1J, create_fragment$1K, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Share",
			options,
			id: create_fragment$1K.name
		});
	}
}

var Share$1 = Share;

/* ../../components/ui/src/icons/feather/ShieldOff.svelte generated by Svelte v3.59.2 */

const file$1F = "../../components/ui/src/icons/feather/ShieldOff.svelte";

function create_fragment$1J(ctx) {
	let path0;
	let path1;
	let line;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M19.69 14a6.9 6.9 0 0 0 .31-2V5l-8-3-3.16 1.18");
			add_location(path0, file$1F, 1, 0, 34);
			attr_dev(path1, "d", "M4.73 4.73L4 5v7c0 6 8 10 8 10a20.29 20.29 0 0 0 5.62-4.38");
			add_location(path1, file$1F, 1, 64, 98);
			attr_dev(line, "x1", "1");
			attr_dev(line, "y1", "1");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "23");
			add_location(line, file$1F, 1, 140, 174);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1J.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1I($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ShieldOff', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ShieldOff> was created with unknown prop '${key}'`);
	});

	return [];
}

class ShieldOff extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1I, create_fragment$1J, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ShieldOff",
			options,
			id: create_fragment$1J.name
		});
	}
}

var ShieldOff$1 = ShieldOff;

/* ../../components/ui/src/icons/feather/Shield.svelte generated by Svelte v3.59.2 */

const file$1E = "../../components/ui/src/icons/feather/Shield.svelte";

function create_fragment$1I(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z");
			add_location(path, file$1E, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1I.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1H($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Shield', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Shield> was created with unknown prop '${key}'`);
	});

	return [];
}

class Shield extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1H, create_fragment$1I, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Shield",
			options,
			id: create_fragment$1I.name
		});
	}
}

var Shield$1 = Shield;

/* ../../components/ui/src/icons/feather/ShoppingBag.svelte generated by Svelte v3.59.2 */

const file$1D = "../../components/ui/src/icons/feather/ShoppingBag.svelte";

function create_fragment$1H(ctx) {
	let path0;
	let line;
	let path1;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			line = svg_element("line");
			path1 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z");
			add_location(path0, file$1D, 1, 0, 34);
			attr_dev(line, "x1", "3");
			attr_dev(line, "y1", "6");
			attr_dev(line, "x2", "21");
			attr_dev(line, "y2", "6");
			add_location(line, file$1D, 1, 68, 102);
			attr_dev(path1, "d", "M16 10a4 4 0 0 1-8 0");
			add_location(path1, file$1D, 1, 110, 144);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, line, anchor);
			insert_hydration_dev(target, path1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(line);
			if (detaching) detach_dev(path1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1H.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1G($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ShoppingBag', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ShoppingBag> was created with unknown prop '${key}'`);
	});

	return [];
}

class ShoppingBag extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1G, create_fragment$1H, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ShoppingBag",
			options,
			id: create_fragment$1H.name
		});
	}
}

var ShoppingBag$1 = ShoppingBag;

/* ../../components/ui/src/icons/feather/ShoppingCart.svelte generated by Svelte v3.59.2 */

const file$1C = "../../components/ui/src/icons/feather/ShoppingCart.svelte";

function create_fragment$1G(ctx) {
	let circle0;
	let circle1;
	let path;

	const block = {
		c: function create() {
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			circle0 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle0).forEach(detach_dev);
			circle1 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle1).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle0, "cx", "9");
			attr_dev(circle0, "cy", "21");
			attr_dev(circle0, "r", "1");
			add_location(circle0, file$1C, 1, 0, 34);
			attr_dev(circle1, "cx", "20");
			attr_dev(circle1, "cy", "21");
			attr_dev(circle1, "r", "1");
			add_location(circle1, file$1C, 1, 38, 72);
			attr_dev(path, "d", "M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6");
			add_location(path, file$1C, 1, 77, 111);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle0, anchor);
			insert_hydration_dev(target, circle1, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle0);
			if (detaching) detach_dev(circle1);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1G.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1F($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ShoppingCart', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ShoppingCart> was created with unknown prop '${key}'`);
	});

	return [];
}

class ShoppingCart extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1F, create_fragment$1G, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ShoppingCart",
			options,
			id: create_fragment$1G.name
		});
	}
}

var ShoppingCart$1 = ShoppingCart;

/* ../../components/ui/src/icons/feather/Shuffle.svelte generated by Svelte v3.59.2 */

const file$1B = "../../components/ui/src/icons/feather/Shuffle.svelte";

function create_fragment$1F(ctx) {
	let polyline0;
	let line0;
	let polyline1;
	let line1;
	let line2;

	const block = {
		c: function create() {
			polyline0 = svg_element("polyline");
			line0 = svg_element("line");
			polyline1 = svg_element("polyline");
			line1 = svg_element("line");
			line2 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			polyline0 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline0).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			polyline1 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline1).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline0, "points", "16 3 21 3 21 8");
			add_location(polyline0, file$1B, 1, 0, 34);
			attr_dev(line0, "x1", "4");
			attr_dev(line0, "y1", "20");
			attr_dev(line0, "x2", "21");
			attr_dev(line0, "y2", "3");
			add_location(line0, file$1B, 1, 45, 79);
			attr_dev(polyline1, "points", "21 16 21 21 16 21");
			add_location(polyline1, file$1B, 1, 88, 122);
			attr_dev(line1, "x1", "15");
			attr_dev(line1, "y1", "15");
			attr_dev(line1, "x2", "21");
			attr_dev(line1, "y2", "21");
			add_location(line1, file$1B, 1, 136, 170);
			attr_dev(line2, "x1", "4");
			attr_dev(line2, "y1", "4");
			attr_dev(line2, "x2", "9");
			attr_dev(line2, "y2", "9");
			add_location(line2, file$1B, 1, 181, 215);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline0, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, polyline1, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline0);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(polyline1);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1F.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1E($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Shuffle', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Shuffle> was created with unknown prop '${key}'`);
	});

	return [];
}

class Shuffle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1E, create_fragment$1F, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Shuffle",
			options,
			id: create_fragment$1F.name
		});
	}
}

var Shuffle$1 = Shuffle;

/* ../../components/ui/src/icons/feather/Sidebar.svelte generated by Svelte v3.59.2 */

const file$1A = "../../components/ui/src/icons/feather/Sidebar.svelte";

function create_fragment$1E(ctx) {
	let rect;
	let line;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "3");
			attr_dev(rect, "y", "3");
			attr_dev(rect, "width", "18");
			attr_dev(rect, "height", "18");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$1A, 1, 0, 34);
			attr_dev(line, "x1", "9");
			attr_dev(line, "y1", "3");
			attr_dev(line, "x2", "9");
			attr_dev(line, "y2", "21");
			add_location(line, file$1A, 1, 62, 96);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1E.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1D($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Sidebar', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Sidebar> was created with unknown prop '${key}'`);
	});

	return [];
}

class Sidebar extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1D, create_fragment$1E, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Sidebar",
			options,
			id: create_fragment$1E.name
		});
	}
}

var Sidebar$1 = Sidebar;

/* ../../components/ui/src/icons/feather/SkipBack.svelte generated by Svelte v3.59.2 */

const file$1z = "../../components/ui/src/icons/feather/SkipBack.svelte";

function create_fragment$1D(ctx) {
	let polygon;
	let line;

	const block = {
		c: function create() {
			polygon = svg_element("polygon");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polygon, "points", "19 20 9 12 19 4 19 20");
			add_location(polygon, file$1z, 1, 0, 34);
			attr_dev(line, "x1", "5");
			attr_dev(line, "y1", "19");
			attr_dev(line, "x2", "5");
			attr_dev(line, "y2", "5");
			add_location(line, file$1z, 1, 50, 84);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polygon, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polygon);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1D.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1C($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('SkipBack', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SkipBack> was created with unknown prop '${key}'`);
	});

	return [];
}

class SkipBack extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1C, create_fragment$1D, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SkipBack",
			options,
			id: create_fragment$1D.name
		});
	}
}

var SkipBack$1 = SkipBack;

/* ../../components/ui/src/icons/feather/SkipForward.svelte generated by Svelte v3.59.2 */

const file$1y = "../../components/ui/src/icons/feather/SkipForward.svelte";

function create_fragment$1C(ctx) {
	let polygon;
	let line;

	const block = {
		c: function create() {
			polygon = svg_element("polygon");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polygon, "points", "5 4 15 12 5 20 5 4");
			add_location(polygon, file$1y, 1, 0, 34);
			attr_dev(line, "x1", "19");
			attr_dev(line, "y1", "5");
			attr_dev(line, "x2", "19");
			attr_dev(line, "y2", "19");
			add_location(line, file$1y, 1, 47, 81);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polygon, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polygon);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1C.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1B($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('SkipForward', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SkipForward> was created with unknown prop '${key}'`);
	});

	return [];
}

class SkipForward extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1B, create_fragment$1C, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "SkipForward",
			options,
			id: create_fragment$1C.name
		});
	}
}

var SkipForward$1 = SkipForward;

/* ../../components/ui/src/icons/feather/Slack.svelte generated by Svelte v3.59.2 */

const file$1x = "../../components/ui/src/icons/feather/Slack.svelte";

function create_fragment$1B(ctx) {
	let path0;
	let path1;
	let path2;
	let path3;
	let path4;
	let path5;
	let path6;
	let path7;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			path4 = svg_element("path");
			path5 = svg_element("path");
			path6 = svg_element("path");
			path7 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			path2 = claim_svg_element(nodes, "path", { d: true });
			children(path2).forEach(detach_dev);
			path3 = claim_svg_element(nodes, "path", { d: true });
			children(path3).forEach(detach_dev);
			path4 = claim_svg_element(nodes, "path", { d: true });
			children(path4).forEach(detach_dev);
			path5 = claim_svg_element(nodes, "path", { d: true });
			children(path5).forEach(detach_dev);
			path6 = claim_svg_element(nodes, "path", { d: true });
			children(path6).forEach(detach_dev);
			path7 = claim_svg_element(nodes, "path", { d: true });
			children(path7).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M14.5 10c-.83 0-1.5-.67-1.5-1.5v-5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5z");
			add_location(path0, file$1x, 1, 0, 34);
			attr_dev(path1, "d", "M20.5 10H19V8.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z");
			add_location(path1, file$1x, 1, 113, 147);
			attr_dev(path2, "d", "M9.5 14c.83 0 1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5S8 21.33 8 20.5v-5c0-.83.67-1.5 1.5-1.5z");
			add_location(path2, file$1x, 1, 199, 233);
			attr_dev(path3, "d", "M3.5 14H5v1.5c0 .83-.67 1.5-1.5 1.5S2 16.33 2 15.5 2.67 14 3.5 14z");
			add_location(path3, file$1x, 1, 309, 343);
			attr_dev(path4, "d", "M14 14.5c0-.83.67-1.5 1.5-1.5h5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z");
			add_location(path4, file$1x, 1, 393, 427);
			attr_dev(path5, "d", "M15.5 19H14v1.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z");
			add_location(path5, file$1x, 1, 507, 541);
			attr_dev(path6, "d", "M10 9.5C10 8.67 9.33 8 8.5 8h-5C2.67 8 2 8.67 2 9.5S2.67 11 3.5 11h5c.83 0 1.5-.67 1.5-1.5z");
			add_location(path6, file$1x, 1, 594, 628);
			attr_dev(path7, "d", "M8.5 5H10V3.5C10 2.67 9.33 2 8.5 2S7 2.67 7 3.5 7.67 5 8.5 5z");
			add_location(path7, file$1x, 1, 703, 737);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
			insert_hydration_dev(target, path2, anchor);
			insert_hydration_dev(target, path3, anchor);
			insert_hydration_dev(target, path4, anchor);
			insert_hydration_dev(target, path5, anchor);
			insert_hydration_dev(target, path6, anchor);
			insert_hydration_dev(target, path7, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
			if (detaching) detach_dev(path2);
			if (detaching) detach_dev(path3);
			if (detaching) detach_dev(path4);
			if (detaching) detach_dev(path5);
			if (detaching) detach_dev(path6);
			if (detaching) detach_dev(path7);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1B.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1A($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Slack', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Slack> was created with unknown prop '${key}'`);
	});

	return [];
}

class Slack extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1A, create_fragment$1B, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Slack",
			options,
			id: create_fragment$1B.name
		});
	}
}

var Slack$1 = Slack;

/* ../../components/ui/src/icons/feather/Slash.svelte generated by Svelte v3.59.2 */

const file$1w = "../../components/ui/src/icons/feather/Slash.svelte";

function create_fragment$1A(ctx) {
	let circle;
	let line;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$1w, 1, 0, 34);
			attr_dev(line, "x1", "4.93");
			attr_dev(line, "y1", "4.93");
			attr_dev(line, "x2", "19.07");
			attr_dev(line, "y2", "19.07");
			add_location(line, file$1w, 1, 40, 74);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1A.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1z($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Slash', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Slash> was created with unknown prop '${key}'`);
	});

	return [];
}

class Slash extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1z, create_fragment$1A, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Slash",
			options,
			id: create_fragment$1A.name
		});
	}
}

var Slash$1 = Slash;

/* ../../components/ui/src/icons/feather/Sliders.svelte generated by Svelte v3.59.2 */

const file$1v = "../../components/ui/src/icons/feather/Sliders.svelte";

function create_fragment$1z(ctx) {
	let line0;
	let line1;
	let line2;
	let line3;
	let line4;
	let line5;
	let line6;
	let line7;
	let line8;

	const block = {
		c: function create() {
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			line4 = svg_element("line");
			line5 = svg_element("line");
			line6 = svg_element("line");
			line7 = svg_element("line");
			line8 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			line3 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line3).forEach(detach_dev);
			line4 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line4).forEach(detach_dev);
			line5 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line5).forEach(detach_dev);
			line6 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line6).forEach(detach_dev);
			line7 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line7).forEach(detach_dev);
			line8 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line8).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line0, "x1", "4");
			attr_dev(line0, "y1", "21");
			attr_dev(line0, "x2", "4");
			attr_dev(line0, "y2", "14");
			add_location(line0, file$1v, 1, 0, 34);
			attr_dev(line1, "x1", "4");
			attr_dev(line1, "y1", "10");
			attr_dev(line1, "x2", "4");
			attr_dev(line1, "y2", "3");
			add_location(line1, file$1v, 1, 43, 77);
			attr_dev(line2, "x1", "12");
			attr_dev(line2, "y1", "21");
			attr_dev(line2, "x2", "12");
			attr_dev(line2, "y2", "12");
			add_location(line2, file$1v, 1, 85, 119);
			attr_dev(line3, "x1", "12");
			attr_dev(line3, "y1", "8");
			attr_dev(line3, "x2", "12");
			attr_dev(line3, "y2", "3");
			add_location(line3, file$1v, 1, 130, 164);
			attr_dev(line4, "x1", "20");
			attr_dev(line4, "y1", "21");
			attr_dev(line4, "x2", "20");
			attr_dev(line4, "y2", "16");
			add_location(line4, file$1v, 1, 173, 207);
			attr_dev(line5, "x1", "20");
			attr_dev(line5, "y1", "12");
			attr_dev(line5, "x2", "20");
			attr_dev(line5, "y2", "3");
			add_location(line5, file$1v, 1, 218, 252);
			attr_dev(line6, "x1", "1");
			attr_dev(line6, "y1", "14");
			attr_dev(line6, "x2", "7");
			attr_dev(line6, "y2", "14");
			add_location(line6, file$1v, 1, 262, 296);
			attr_dev(line7, "x1", "9");
			attr_dev(line7, "y1", "8");
			attr_dev(line7, "x2", "15");
			attr_dev(line7, "y2", "8");
			add_location(line7, file$1v, 1, 305, 339);
			attr_dev(line8, "x1", "17");
			attr_dev(line8, "y1", "16");
			attr_dev(line8, "x2", "23");
			attr_dev(line8, "y2", "16");
			add_location(line8, file$1v, 1, 347, 381);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
			insert_hydration_dev(target, line3, anchor);
			insert_hydration_dev(target, line4, anchor);
			insert_hydration_dev(target, line5, anchor);
			insert_hydration_dev(target, line6, anchor);
			insert_hydration_dev(target, line7, anchor);
			insert_hydration_dev(target, line8, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
			if (detaching) detach_dev(line3);
			if (detaching) detach_dev(line4);
			if (detaching) detach_dev(line5);
			if (detaching) detach_dev(line6);
			if (detaching) detach_dev(line7);
			if (detaching) detach_dev(line8);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1y($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Sliders', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Sliders> was created with unknown prop '${key}'`);
	});

	return [];
}

class Sliders extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1y, create_fragment$1z, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Sliders",
			options,
			id: create_fragment$1z.name
		});
	}
}

var Sliders$1 = Sliders;

/* ../../components/ui/src/icons/feather/Smartphone.svelte generated by Svelte v3.59.2 */

const file$1u = "../../components/ui/src/icons/feather/Smartphone.svelte";

function create_fragment$1y(ctx) {
	let rect;
	let line;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "5");
			attr_dev(rect, "y", "2");
			attr_dev(rect, "width", "14");
			attr_dev(rect, "height", "20");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$1u, 1, 0, 34);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "18");
			attr_dev(line, "x2", "12.01");
			attr_dev(line, "y2", "18");
			add_location(line, file$1u, 1, 62, 96);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1x($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Smartphone', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Smartphone> was created with unknown prop '${key}'`);
	});

	return [];
}

class Smartphone extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1x, create_fragment$1y, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Smartphone",
			options,
			id: create_fragment$1y.name
		});
	}
}

var Smartphone$1 = Smartphone;

/* ../../components/ui/src/icons/feather/Smile.svelte generated by Svelte v3.59.2 */

const file$1t = "../../components/ui/src/icons/feather/Smile.svelte";

function create_fragment$1x(ctx) {
	let circle;
	let path;
	let line0;
	let line1;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$1t, 1, 0, 34);
			attr_dev(path, "d", "M8 14s1.5 2 4 2 4-2 4-2");
			add_location(path, file$1t, 1, 40, 74);
			attr_dev(line0, "x1", "9");
			attr_dev(line0, "y1", "9");
			attr_dev(line0, "x2", "9.01");
			attr_dev(line0, "y2", "9");
			add_location(line0, file$1t, 1, 81, 115);
			attr_dev(line1, "x1", "15");
			attr_dev(line1, "y1", "9");
			attr_dev(line1, "x2", "15.01");
			attr_dev(line1, "y2", "9");
			add_location(line1, file$1t, 1, 125, 159);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1x.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1w($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Smile', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Smile> was created with unknown prop '${key}'`);
	});

	return [];
}

class Smile extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1w, create_fragment$1x, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Smile",
			options,
			id: create_fragment$1x.name
		});
	}
}

var Smile$1 = Smile;

/* ../../components/ui/src/icons/feather/Speaker.svelte generated by Svelte v3.59.2 */

const file$1s = "../../components/ui/src/icons/feather/Speaker.svelte";

function create_fragment$1w(ctx) {
	let rect;
	let circle;
	let line;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			circle = svg_element("circle");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect).forEach(detach_dev);
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "4");
			attr_dev(rect, "y", "2");
			attr_dev(rect, "width", "16");
			attr_dev(rect, "height", "20");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$1s, 1, 0, 34);
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "14");
			attr_dev(circle, "r", "4");
			add_location(circle, file$1s, 1, 62, 96);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "6");
			attr_dev(line, "x2", "12.01");
			attr_dev(line, "y2", "6");
			add_location(line, file$1s, 1, 101, 135);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1w.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1v($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Speaker', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Speaker> was created with unknown prop '${key}'`);
	});

	return [];
}

class Speaker extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1v, create_fragment$1w, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Speaker",
			options,
			id: create_fragment$1w.name
		});
	}
}

var Speaker$1 = Speaker;

/* ../../components/ui/src/icons/feather/Star.svelte generated by Svelte v3.59.2 */

const file$1r = "../../components/ui/src/icons/feather/Star.svelte";

function create_fragment$1v(ctx) {
	let polygon;

	const block = {
		c: function create() {
			polygon = svg_element("polygon");
			this.h();
		},
		l: function claim(nodes) {
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polygon, "points", "12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2");
			add_location(polygon, file$1r, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polygon, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polygon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1v.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1u($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Star', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Star> was created with unknown prop '${key}'`);
	});

	return [];
}

class Star extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1u, create_fragment$1v, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Star",
			options,
			id: create_fragment$1v.name
		});
	}
}

var Star$1 = Star;

/* ../../components/ui/src/icons/feather/StopCircle.svelte generated by Svelte v3.59.2 */

const file$1q = "../../components/ui/src/icons/feather/StopCircle.svelte";

function create_fragment$1u(ctx) {
	let circle;
	let rect;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			rect = svg_element("rect");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);

			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true
			});

			children(rect).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$1q, 1, 0, 34);
			attr_dev(rect, "x", "9");
			attr_dev(rect, "y", "9");
			attr_dev(rect, "width", "6");
			attr_dev(rect, "height", "6");
			add_location(rect, file$1q, 1, 40, 74);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, rect, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(rect);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1u.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1t($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('StopCircle', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<StopCircle> was created with unknown prop '${key}'`);
	});

	return [];
}

class StopCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1t, create_fragment$1u, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "StopCircle",
			options,
			id: create_fragment$1u.name
		});
	}
}

var StopCircle$1 = StopCircle;

/* ../../components/ui/src/icons/feather/Sunrise.svelte generated by Svelte v3.59.2 */

const file$1p = "../../components/ui/src/icons/feather/Sunrise.svelte";

function create_fragment$1t(ctx) {
	let path;
	let line0;
	let line1;
	let line2;
	let line3;
	let line4;
	let line5;
	let polyline;

	const block = {
		c: function create() {
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			line4 = svg_element("line");
			line5 = svg_element("line");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			line3 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line3).forEach(detach_dev);
			line4 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line4).forEach(detach_dev);
			line5 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line5).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M17 18a5 5 0 0 0-10 0");
			add_location(path, file$1p, 1, 0, 34);
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "2");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "9");
			add_location(line0, file$1p, 1, 39, 73);
			attr_dev(line1, "x1", "4.22");
			attr_dev(line1, "y1", "10.22");
			attr_dev(line1, "x2", "5.64");
			attr_dev(line1, "y2", "11.64");
			add_location(line1, file$1p, 1, 82, 116);
			attr_dev(line2, "x1", "1");
			attr_dev(line2, "y1", "18");
			attr_dev(line2, "x2", "3");
			attr_dev(line2, "y2", "18");
			add_location(line2, file$1p, 1, 137, 171);
			attr_dev(line3, "x1", "21");
			attr_dev(line3, "y1", "18");
			attr_dev(line3, "x2", "23");
			attr_dev(line3, "y2", "18");
			add_location(line3, file$1p, 1, 180, 214);
			attr_dev(line4, "x1", "18.36");
			attr_dev(line4, "y1", "11.64");
			attr_dev(line4, "x2", "19.78");
			attr_dev(line4, "y2", "10.22");
			add_location(line4, file$1p, 1, 225, 259);
			attr_dev(line5, "x1", "23");
			attr_dev(line5, "y1", "22");
			attr_dev(line5, "x2", "1");
			attr_dev(line5, "y2", "22");
			add_location(line5, file$1p, 1, 282, 316);
			attr_dev(polyline, "points", "8 6 12 2 16 6");
			add_location(polyline, file$1p, 1, 326, 360);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
			insert_hydration_dev(target, line3, anchor);
			insert_hydration_dev(target, line4, anchor);
			insert_hydration_dev(target, line5, anchor);
			insert_hydration_dev(target, polyline, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
			if (detaching) detach_dev(line3);
			if (detaching) detach_dev(line4);
			if (detaching) detach_dev(line5);
			if (detaching) detach_dev(polyline);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1t.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1s($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Sunrise', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Sunrise> was created with unknown prop '${key}'`);
	});

	return [];
}

class Sunrise extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1s, create_fragment$1t, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Sunrise",
			options,
			id: create_fragment$1t.name
		});
	}
}

var Sunrise$1 = Sunrise;

/* ../../components/ui/src/icons/feather/Sunset.svelte generated by Svelte v3.59.2 */

const file$1o = "../../components/ui/src/icons/feather/Sunset.svelte";

function create_fragment$1s(ctx) {
	let path;
	let line0;
	let line1;
	let line2;
	let line3;
	let line4;
	let line5;
	let polyline;

	const block = {
		c: function create() {
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			line3 = svg_element("line");
			line4 = svg_element("line");
			line5 = svg_element("line");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			line3 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line3).forEach(detach_dev);
			line4 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line4).forEach(detach_dev);
			line5 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line5).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M17 18a5 5 0 0 0-10 0");
			add_location(path, file$1o, 1, 0, 34);
			attr_dev(line0, "x1", "12");
			attr_dev(line0, "y1", "9");
			attr_dev(line0, "x2", "12");
			attr_dev(line0, "y2", "2");
			add_location(line0, file$1o, 1, 39, 73);
			attr_dev(line1, "x1", "4.22");
			attr_dev(line1, "y1", "10.22");
			attr_dev(line1, "x2", "5.64");
			attr_dev(line1, "y2", "11.64");
			add_location(line1, file$1o, 1, 82, 116);
			attr_dev(line2, "x1", "1");
			attr_dev(line2, "y1", "18");
			attr_dev(line2, "x2", "3");
			attr_dev(line2, "y2", "18");
			add_location(line2, file$1o, 1, 137, 171);
			attr_dev(line3, "x1", "21");
			attr_dev(line3, "y1", "18");
			attr_dev(line3, "x2", "23");
			attr_dev(line3, "y2", "18");
			add_location(line3, file$1o, 1, 180, 214);
			attr_dev(line4, "x1", "18.36");
			attr_dev(line4, "y1", "11.64");
			attr_dev(line4, "x2", "19.78");
			attr_dev(line4, "y2", "10.22");
			add_location(line4, file$1o, 1, 225, 259);
			attr_dev(line5, "x1", "23");
			attr_dev(line5, "y1", "22");
			attr_dev(line5, "x2", "1");
			attr_dev(line5, "y2", "22");
			add_location(line5, file$1o, 1, 282, 316);
			attr_dev(polyline, "points", "16 5 12 9 8 5");
			add_location(polyline, file$1o, 1, 326, 360);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
			insert_hydration_dev(target, line3, anchor);
			insert_hydration_dev(target, line4, anchor);
			insert_hydration_dev(target, line5, anchor);
			insert_hydration_dev(target, polyline, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
			if (detaching) detach_dev(line3);
			if (detaching) detach_dev(line4);
			if (detaching) detach_dev(line5);
			if (detaching) detach_dev(polyline);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1s.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1r($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Sunset', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Sunset> was created with unknown prop '${key}'`);
	});

	return [];
}

class Sunset extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1r, create_fragment$1s, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Sunset",
			options,
			id: create_fragment$1s.name
		});
	}
}

var Sunset$1 = Sunset;

/* ../../components/ui/src/icons/feather/Table.svelte generated by Svelte v3.59.2 */

const file$1n = "../../components/ui/src/icons/feather/Table.svelte";

function create_fragment$1r(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18");
			add_location(path, file$1n, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1r.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1q($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Table', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Table> was created with unknown prop '${key}'`);
	});

	return [];
}

class Table extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1q, create_fragment$1r, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Table",
			options,
			id: create_fragment$1r.name
		});
	}
}

var Table$1 = Table;

/* ../../components/ui/src/icons/feather/Tablet.svelte generated by Svelte v3.59.2 */

const file$1m = "../../components/ui/src/icons/feather/Tablet.svelte";

function create_fragment$1q(ctx) {
	let rect;
	let line;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "4");
			attr_dev(rect, "y", "2");
			attr_dev(rect, "width", "16");
			attr_dev(rect, "height", "20");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$1m, 1, 0, 34);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "18");
			attr_dev(line, "x2", "12.01");
			attr_dev(line, "y2", "18");
			add_location(line, file$1m, 1, 62, 96);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1p($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Tablet', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tablet> was created with unknown prop '${key}'`);
	});

	return [];
}

class Tablet extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1p, create_fragment$1q, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Tablet",
			options,
			id: create_fragment$1q.name
		});
	}
}

var Tablet$1 = Tablet;

/* ../../components/ui/src/icons/feather/Tag.svelte generated by Svelte v3.59.2 */

const file$1l = "../../components/ui/src/icons/feather/Tag.svelte";

function create_fragment$1p(ctx) {
	let path;
	let line;

	const block = {
		c: function create() {
			path = svg_element("path");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z");
			add_location(path, file$1l, 1, 0, 34);
			attr_dev(line, "x1", "7");
			attr_dev(line, "y1", "7");
			attr_dev(line, "x2", "7.01");
			attr_dev(line, "y2", "7");
			add_location(line, file$1l, 1, 96, 130);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1p.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1o($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Tag', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tag> was created with unknown prop '${key}'`);
	});

	return [];
}

class Tag extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1o, create_fragment$1p, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Tag",
			options,
			id: create_fragment$1p.name
		});
	}
}

var Tag$1 = Tag;

/* ../../components/ui/src/icons/feather/Target.svelte generated by Svelte v3.59.2 */

const file$1k = "../../components/ui/src/icons/feather/Target.svelte";

function create_fragment$1o(ctx) {
	let circle0;
	let circle1;
	let circle2;

	const block = {
		c: function create() {
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			circle2 = svg_element("circle");
			this.h();
		},
		l: function claim(nodes) {
			circle0 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle0).forEach(detach_dev);
			circle1 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle1).forEach(detach_dev);
			circle2 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle2).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle0, "cx", "12");
			attr_dev(circle0, "cy", "12");
			attr_dev(circle0, "r", "10");
			add_location(circle0, file$1k, 1, 0, 34);
			attr_dev(circle1, "cx", "12");
			attr_dev(circle1, "cy", "12");
			attr_dev(circle1, "r", "6");
			add_location(circle1, file$1k, 1, 40, 74);
			attr_dev(circle2, "cx", "12");
			attr_dev(circle2, "cy", "12");
			attr_dev(circle2, "r", "2");
			add_location(circle2, file$1k, 1, 79, 113);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle0, anchor);
			insert_hydration_dev(target, circle1, anchor);
			insert_hydration_dev(target, circle2, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle0);
			if (detaching) detach_dev(circle1);
			if (detaching) detach_dev(circle2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1o.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1n($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Target', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Target> was created with unknown prop '${key}'`);
	});

	return [];
}

class Target extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1n, create_fragment$1o, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Target",
			options,
			id: create_fragment$1o.name
		});
	}
}

var Target$1 = Target;

/* ../../components/ui/src/icons/feather/Terminal.svelte generated by Svelte v3.59.2 */

const file$1j = "../../components/ui/src/icons/feather/Terminal.svelte";

function create_fragment$1n(ctx) {
	let polyline;
	let line;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "4 17 10 11 4 5");
			add_location(polyline, file$1j, 1, 0, 34);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "19");
			attr_dev(line, "x2", "20");
			attr_dev(line, "y2", "19");
			add_location(line, file$1j, 1, 45, 79);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1n.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1m($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Terminal', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Terminal> was created with unknown prop '${key}'`);
	});

	return [];
}

class Terminal extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1m, create_fragment$1n, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Terminal",
			options,
			id: create_fragment$1n.name
		});
	}
}

var Terminal$1 = Terminal;

/* ../../components/ui/src/icons/feather/Thermometer.svelte generated by Svelte v3.59.2 */

const file$1i = "../../components/ui/src/icons/feather/Thermometer.svelte";

function create_fragment$1m(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z");
			add_location(path, file$1i, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1m.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1l($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Thermometer', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Thermometer> was created with unknown prop '${key}'`);
	});

	return [];
}

class Thermometer extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1l, create_fragment$1m, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Thermometer",
			options,
			id: create_fragment$1m.name
		});
	}
}

var Thermometer$1 = Thermometer;

/* ../../components/ui/src/icons/feather/ThumbsDown.svelte generated by Svelte v3.59.2 */

const file$1h = "../../components/ui/src/icons/feather/ThumbsDown.svelte";

function create_fragment$1l(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17");
			add_location(path, file$1h, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1l.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1k($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ThumbsDown', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ThumbsDown> was created with unknown prop '${key}'`);
	});

	return [];
}

class ThumbsDown extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1k, create_fragment$1l, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ThumbsDown",
			options,
			id: create_fragment$1l.name
		});
	}
}

var ThumbsDown$1 = ThumbsDown;

/* ../../components/ui/src/icons/feather/ThumbsUp.svelte generated by Svelte v3.59.2 */

const file$1g = "../../components/ui/src/icons/feather/ThumbsUp.svelte";

function create_fragment$1k(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3");
			add_location(path, file$1g, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1j($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ThumbsUp', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ThumbsUp> was created with unknown prop '${key}'`);
	});

	return [];
}

class ThumbsUp extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1j, create_fragment$1k, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ThumbsUp",
			options,
			id: create_fragment$1k.name
		});
	}
}

var ThumbsUp$1 = ThumbsUp;

/* ../../components/ui/src/icons/feather/ToggleLeft.svelte generated by Svelte v3.59.2 */

const file$1f = "../../components/ui/src/icons/feather/ToggleLeft.svelte";

function create_fragment$1j(ctx) {
	let rect;
	let circle;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			circle = svg_element("circle");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect).forEach(detach_dev);
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "1");
			attr_dev(rect, "y", "5");
			attr_dev(rect, "width", "22");
			attr_dev(rect, "height", "14");
			attr_dev(rect, "rx", "7");
			attr_dev(rect, "ry", "7");
			add_location(rect, file$1f, 1, 0, 34);
			attr_dev(circle, "cx", "8");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "3");
			add_location(circle, file$1f, 1, 62, 96);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, circle, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(circle);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1i($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ToggleLeft', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ToggleLeft> was created with unknown prop '${key}'`);
	});

	return [];
}

class ToggleLeft extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1i, create_fragment$1j, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ToggleLeft",
			options,
			id: create_fragment$1j.name
		});
	}
}

var ToggleLeft$1 = ToggleLeft;

/* ../../components/ui/src/icons/feather/ToggleRight.svelte generated by Svelte v3.59.2 */

const file$1e = "../../components/ui/src/icons/feather/ToggleRight.svelte";

function create_fragment$1i(ctx) {
	let rect;
	let circle;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			circle = svg_element("circle");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect).forEach(detach_dev);
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "1");
			attr_dev(rect, "y", "5");
			attr_dev(rect, "width", "22");
			attr_dev(rect, "height", "14");
			attr_dev(rect, "rx", "7");
			attr_dev(rect, "ry", "7");
			add_location(rect, file$1e, 1, 0, 34);
			attr_dev(circle, "cx", "16");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "3");
			add_location(circle, file$1e, 1, 62, 96);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, circle, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(circle);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1h($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ToggleRight', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ToggleRight> was created with unknown prop '${key}'`);
	});

	return [];
}

class ToggleRight extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1h, create_fragment$1i, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ToggleRight",
			options,
			id: create_fragment$1i.name
		});
	}
}

var ToggleRight$1 = ToggleRight;

/* ../../components/ui/src/icons/feather/Tool.svelte generated by Svelte v3.59.2 */

const file$1d = "../../components/ui/src/icons/feather/Tool.svelte";

function create_fragment$1h(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z");
			add_location(path, file$1d, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1g($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Tool', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tool> was created with unknown prop '${key}'`);
	});

	return [];
}

class Tool extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1g, create_fragment$1h, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Tool",
			options,
			id: create_fragment$1h.name
		});
	}
}

var Tool$1 = Tool;

/* ../../components/ui/src/icons/feather/Trash2.svelte generated by Svelte v3.59.2 */

const file$1c = "../../components/ui/src/icons/feather/Trash2.svelte";

function create_fragment$1g(ctx) {
	let polyline;
	let path;
	let line0;
	let line1;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			path = svg_element("path");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "3 6 5 6 21 6");
			add_location(polyline, file$1c, 1, 0, 34);
			attr_dev(path, "d", "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2");
			add_location(path, file$1c, 1, 43, 77);
			attr_dev(line0, "x1", "10");
			attr_dev(line0, "y1", "11");
			attr_dev(line0, "x2", "10");
			attr_dev(line0, "y2", "17");
			add_location(line0, file$1c, 1, 139, 173);
			attr_dev(line1, "x1", "14");
			attr_dev(line1, "y1", "11");
			attr_dev(line1, "x2", "14");
			attr_dev(line1, "y2", "17");
			add_location(line1, file$1c, 1, 184, 218);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1f($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Trash2', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Trash2> was created with unknown prop '${key}'`);
	});

	return [];
}

class Trash2 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1f, create_fragment$1g, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Trash2",
			options,
			id: create_fragment$1g.name
		});
	}
}

var Trash2$1 = Trash2;

/* ../../components/ui/src/icons/feather/Trash.svelte generated by Svelte v3.59.2 */

const file$1b = "../../components/ui/src/icons/feather/Trash.svelte";

function create_fragment$1f(ctx) {
	let polyline;
	let path;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "3 6 5 6 21 6");
			add_location(polyline, file$1b, 1, 0, 34);
			attr_dev(path, "d", "M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2");
			add_location(path, file$1b, 1, 43, 77);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1e($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Trash', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Trash> was created with unknown prop '${key}'`);
	});

	return [];
}

class Trash extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1e, create_fragment$1f, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Trash",
			options,
			id: create_fragment$1f.name
		});
	}
}

var Trash$1 = Trash;

/* ../../components/ui/src/icons/feather/Trello.svelte generated by Svelte v3.59.2 */

const file$1a = "../../components/ui/src/icons/feather/Trello.svelte";

function create_fragment$1e(ctx) {
	let rect0;
	let rect1;
	let rect2;

	const block = {
		c: function create() {
			rect0 = svg_element("rect");
			rect1 = svg_element("rect");
			rect2 = svg_element("rect");
			this.h();
		},
		l: function claim(nodes) {
			rect0 = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect0).forEach(detach_dev);

			rect1 = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true
			});

			children(rect1).forEach(detach_dev);

			rect2 = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true
			});

			children(rect2).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect0, "x", "3");
			attr_dev(rect0, "y", "3");
			attr_dev(rect0, "width", "18");
			attr_dev(rect0, "height", "18");
			attr_dev(rect0, "rx", "2");
			attr_dev(rect0, "ry", "2");
			add_location(rect0, file$1a, 1, 0, 34);
			attr_dev(rect1, "x", "7");
			attr_dev(rect1, "y", "7");
			attr_dev(rect1, "width", "3");
			attr_dev(rect1, "height", "9");
			add_location(rect1, file$1a, 1, 62, 96);
			attr_dev(rect2, "x", "14");
			attr_dev(rect2, "y", "7");
			attr_dev(rect2, "width", "3");
			attr_dev(rect2, "height", "5");
			add_location(rect2, file$1a, 1, 108, 142);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect0, anchor);
			insert_hydration_dev(target, rect1, anchor);
			insert_hydration_dev(target, rect2, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect0);
			if (detaching) detach_dev(rect1);
			if (detaching) detach_dev(rect2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1d($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Trello', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Trello> was created with unknown prop '${key}'`);
	});

	return [];
}

class Trello extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1d, create_fragment$1e, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Trello",
			options,
			id: create_fragment$1e.name
		});
	}
}

var Trello$1 = Trello;

/* ../../components/ui/src/icons/feather/TrendingDown.svelte generated by Svelte v3.59.2 */

const file$19 = "../../components/ui/src/icons/feather/TrendingDown.svelte";

function create_fragment$1d(ctx) {
	let polyline0;
	let polyline1;

	const block = {
		c: function create() {
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			polyline0 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline0).forEach(detach_dev);
			polyline1 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline0, "points", "23 18 13.5 8.5 8.5 13.5 1 6");
			add_location(polyline0, file$19, 1, 0, 34);
			attr_dev(polyline1, "points", "17 18 23 18 23 12");
			add_location(polyline1, file$19, 1, 58, 92);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline0, anchor);
			insert_hydration_dev(target, polyline1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline0);
			if (detaching) detach_dev(polyline1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1c($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('TrendingDown', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TrendingDown> was created with unknown prop '${key}'`);
	});

	return [];
}

class TrendingDown extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1c, create_fragment$1d, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TrendingDown",
			options,
			id: create_fragment$1d.name
		});
	}
}

var TrendingDown$1 = TrendingDown;

/* ../../components/ui/src/icons/feather/TrendingUp.svelte generated by Svelte v3.59.2 */

const file$18 = "../../components/ui/src/icons/feather/TrendingUp.svelte";

function create_fragment$1c(ctx) {
	let polyline0;
	let polyline1;

	const block = {
		c: function create() {
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			polyline0 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline0).forEach(detach_dev);
			polyline1 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline0, "points", "23 6 13.5 15.5 8.5 10.5 1 18");
			add_location(polyline0, file$18, 1, 0, 34);
			attr_dev(polyline1, "points", "17 6 23 6 23 12");
			add_location(polyline1, file$18, 1, 59, 93);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline0, anchor);
			insert_hydration_dev(target, polyline1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline0);
			if (detaching) detach_dev(polyline1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1b($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('TrendingUp', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TrendingUp> was created with unknown prop '${key}'`);
	});

	return [];
}

class TrendingUp extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1b, create_fragment$1c, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TrendingUp",
			options,
			id: create_fragment$1c.name
		});
	}
}

var TrendingUp$1 = TrendingUp;

/* ../../components/ui/src/icons/feather/Triangle.svelte generated by Svelte v3.59.2 */

const file$17 = "../../components/ui/src/icons/feather/Triangle.svelte";

function create_fragment$1b(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z");
			add_location(path, file$17, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1a($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Triangle', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Triangle> was created with unknown prop '${key}'`);
	});

	return [];
}

class Triangle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1a, create_fragment$1b, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Triangle",
			options,
			id: create_fragment$1b.name
		});
	}
}

var Triangle$1 = Triangle;

/* ../../components/ui/src/icons/feather/Truck.svelte generated by Svelte v3.59.2 */

const file$16 = "../../components/ui/src/icons/feather/Truck.svelte";

function create_fragment$1a(ctx) {
	let rect;
	let polygon;
	let circle0;
	let circle1;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			polygon = svg_element("polygon");
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true
			});

			children(rect).forEach(detach_dev);
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			circle0 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle0).forEach(detach_dev);
			circle1 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "1");
			attr_dev(rect, "y", "3");
			attr_dev(rect, "width", "15");
			attr_dev(rect, "height", "13");
			add_location(rect, file$16, 1, 0, 34);
			attr_dev(polygon, "points", "16 8 20 8 23 11 23 16 16 16 16 8");
			add_location(polygon, file$16, 1, 48, 82);
			attr_dev(circle0, "cx", "5.5");
			attr_dev(circle0, "cy", "18.5");
			attr_dev(circle0, "r", "2.5");
			add_location(circle0, file$16, 1, 109, 143);
			attr_dev(circle1, "cx", "18.5");
			attr_dev(circle1, "cy", "18.5");
			attr_dev(circle1, "r", "2.5");
			add_location(circle1, file$16, 1, 153, 187);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, polygon, anchor);
			insert_hydration_dev(target, circle0, anchor);
			insert_hydration_dev(target, circle1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(polygon);
			if (detaching) detach_dev(circle0);
			if (detaching) detach_dev(circle1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$19($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Truck', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Truck> was created with unknown prop '${key}'`);
	});

	return [];
}

class Truck extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$19, create_fragment$1a, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Truck",
			options,
			id: create_fragment$1a.name
		});
	}
}

var Truck$1 = Truck;

/* ../../components/ui/src/icons/feather/Tv.svelte generated by Svelte v3.59.2 */

const file$15 = "../../components/ui/src/icons/feather/Tv.svelte";

function create_fragment$19(ctx) {
	let rect;
	let polyline;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "2");
			attr_dev(rect, "y", "7");
			attr_dev(rect, "width", "20");
			attr_dev(rect, "height", "15");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$15, 1, 0, 34);
			attr_dev(polyline, "points", "17 2 12 7 7 2");
			add_location(polyline, file$15, 1, 62, 96);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, polyline, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(polyline);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$19.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$18($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Tv', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Tv> was created with unknown prop '${key}'`);
	});

	return [];
}

class Tv extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$18, create_fragment$19, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Tv",
			options,
			id: create_fragment$19.name
		});
	}
}

var Tv$1 = Tv;

/* ../../components/ui/src/icons/feather/Twitch.svelte generated by Svelte v3.59.2 */

const file$14 = "../../components/ui/src/icons/feather/Twitch.svelte";

function create_fragment$18(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M21 2H3v16h5v4l4-4h5l4-4V2zm-10 9V7m5 4V7");
			add_location(path, file$14, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$18.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$17($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Twitch', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Twitch> was created with unknown prop '${key}'`);
	});

	return [];
}

class Twitch extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$17, create_fragment$18, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Twitch",
			options,
			id: create_fragment$18.name
		});
	}
}

var Twitch$1 = Twitch;

/* ../../components/ui/src/icons/feather/Twitter.svelte generated by Svelte v3.59.2 */

const file$13 = "../../components/ui/src/icons/feather/Twitter.svelte";

function create_fragment$17(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z");
			add_location(path, file$13, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$17.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$16($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Twitter', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Twitter> was created with unknown prop '${key}'`);
	});

	return [];
}

class Twitter extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$16, create_fragment$17, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Twitter",
			options,
			id: create_fragment$17.name
		});
	}
}

var Twitter$1 = Twitter;

/* ../../components/ui/src/icons/feather/Type.svelte generated by Svelte v3.59.2 */

const file$12 = "../../components/ui/src/icons/feather/Type.svelte";

function create_fragment$16(ctx) {
	let polyline;
	let line0;
	let line1;

	const block = {
		c: function create() {
			polyline = svg_element("polyline");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline, "points", "4 7 4 4 20 4 20 7");
			add_location(polyline, file$12, 1, 0, 34);
			attr_dev(line0, "x1", "9");
			attr_dev(line0, "y1", "20");
			attr_dev(line0, "x2", "15");
			attr_dev(line0, "y2", "20");
			add_location(line0, file$12, 1, 48, 82);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "4");
			attr_dev(line1, "x2", "12");
			attr_dev(line1, "y2", "20");
			add_location(line1, file$12, 1, 92, 126);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$16.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$15($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Type', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Type> was created with unknown prop '${key}'`);
	});

	return [];
}

class Type extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$15, create_fragment$16, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Type",
			options,
			id: create_fragment$16.name
		});
	}
}

var Type$1 = Type;

/* ../../components/ui/src/icons/feather/Umbrella.svelte generated by Svelte v3.59.2 */

const file$11 = "../../components/ui/src/icons/feather/Umbrella.svelte";

function create_fragment$15(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M23 12a11.05 11.05 0 0 0-22 0zm-5 7a3 3 0 0 1-6 0v-7");
			add_location(path, file$11, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$15.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$14($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Umbrella', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Umbrella> was created with unknown prop '${key}'`);
	});

	return [];
}

class Umbrella extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$14, create_fragment$15, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Umbrella",
			options,
			id: create_fragment$15.name
		});
	}
}

var Umbrella$1 = Umbrella;

/* ../../components/ui/src/icons/feather/Underline.svelte generated by Svelte v3.59.2 */

const file$10 = "../../components/ui/src/icons/feather/Underline.svelte";

function create_fragment$14(ctx) {
	let path;
	let line;

	const block = {
		c: function create() {
			path = svg_element("path");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3");
			add_location(path, file$10, 1, 0, 34);
			attr_dev(line, "x1", "4");
			attr_dev(line, "y1", "21");
			attr_dev(line, "x2", "20");
			attr_dev(line, "y2", "21");
			add_location(line, file$10, 1, 54, 88);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$14.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$13($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Underline', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Underline> was created with unknown prop '${key}'`);
	});

	return [];
}

class Underline extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$13, create_fragment$14, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Underline",
			options,
			id: create_fragment$14.name
		});
	}
}

var Underline$1 = Underline;

/* ../../components/ui/src/icons/feather/Unlock.svelte generated by Svelte v3.59.2 */

const file$$ = "../../components/ui/src/icons/feather/Unlock.svelte";

function create_fragment$13(ctx) {
	let rect;
	let path;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "3");
			attr_dev(rect, "y", "11");
			attr_dev(rect, "width", "18");
			attr_dev(rect, "height", "11");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$$, 1, 0, 34);
			attr_dev(path, "d", "M7 11V7a5 5 0 0 1 9.9-1");
			add_location(path, file$$, 1, 63, 97);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$13.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$12($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Unlock', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Unlock> was created with unknown prop '${key}'`);
	});

	return [];
}

class Unlock extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$12, create_fragment$13, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Unlock",
			options,
			id: create_fragment$13.name
		});
	}
}

var Unlock$1 = Unlock;

/* ../../components/ui/src/icons/feather/UploadCloud.svelte generated by Svelte v3.59.2 */

const file$_ = "../../components/ui/src/icons/feather/UploadCloud.svelte";

function create_fragment$12(ctx) {
	let polyline0;
	let line;
	let path;
	let polyline1;

	const block = {
		c: function create() {
			polyline0 = svg_element("polyline");
			line = svg_element("line");
			path = svg_element("path");
			polyline1 = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			polyline0 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline0).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			polyline1 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline0, "points", "16 16 12 12 8 16");
			add_location(polyline0, file$_, 1, 0, 34);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "12");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "21");
			add_location(line, file$_, 1, 47, 81);
			attr_dev(path, "d", "M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3");
			add_location(path, file$_, 1, 92, 126);
			attr_dev(polyline1, "points", "16 16 12 12 8 16");
			add_location(polyline1, file$_, 1, 160, 194);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline0, anchor);
			insert_hydration_dev(target, line, anchor);
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, polyline1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline0);
			if (detaching) detach_dev(line);
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(polyline1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$12.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$11($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('UploadCloud', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UploadCloud> was created with unknown prop '${key}'`);
	});

	return [];
}

class UploadCloud extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$11, create_fragment$12, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UploadCloud",
			options,
			id: create_fragment$12.name
		});
	}
}

var UploadCloud$1 = UploadCloud;

/* ../../components/ui/src/icons/feather/Upload.svelte generated by Svelte v3.59.2 */

const file$Z = "../../components/ui/src/icons/feather/Upload.svelte";

function create_fragment$11(ctx) {
	let path;
	let polyline;
	let line;

	const block = {
		c: function create() {
			path = svg_element("path");
			polyline = svg_element("polyline");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4");
			add_location(path, file$Z, 1, 0, 34);
			attr_dev(polyline, "points", "17 8 12 3 7 8");
			add_location(polyline, file$Z, 1, 59, 93);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "3");
			attr_dev(line, "x2", "12");
			attr_dev(line, "y2", "15");
			add_location(line, file$Z, 1, 103, 137);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$11.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$10($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Upload', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Upload> was created with unknown prop '${key}'`);
	});

	return [];
}

class Upload extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$10, create_fragment$11, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Upload",
			options,
			id: create_fragment$11.name
		});
	}
}

var Upload$1 = Upload;

/* ../../components/ui/src/icons/feather/UserCheck.svelte generated by Svelte v3.59.2 */

const file$Y = "../../components/ui/src/icons/feather/UserCheck.svelte";

function create_fragment$10(ctx) {
	let path;
	let circle;
	let polyline;

	const block = {
		c: function create() {
			path = svg_element("path");
			circle = svg_element("circle");
			polyline = svg_element("polyline");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
			add_location(path, file$Y, 1, 0, 34);
			attr_dev(circle, "cx", "8.5");
			attr_dev(circle, "cy", "7");
			attr_dev(circle, "r", "4");
			add_location(circle, file$Y, 1, 59, 93);
			attr_dev(polyline, "points", "17 11 19 13 23 9");
			add_location(polyline, file$Y, 1, 98, 132);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, polyline, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(polyline);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$10.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$$($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('UserCheck', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UserCheck> was created with unknown prop '${key}'`);
	});

	return [];
}

class UserCheck extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$$, create_fragment$10, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UserCheck",
			options,
			id: create_fragment$10.name
		});
	}
}

var UserCheck$1 = UserCheck;

/* ../../components/ui/src/icons/feather/UserMinus.svelte generated by Svelte v3.59.2 */

const file$X = "../../components/ui/src/icons/feather/UserMinus.svelte";

function create_fragment$$(ctx) {
	let path;
	let circle;
	let line;

	const block = {
		c: function create() {
			path = svg_element("path");
			circle = svg_element("circle");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
			add_location(path, file$X, 1, 0, 34);
			attr_dev(circle, "cx", "8.5");
			attr_dev(circle, "cy", "7");
			attr_dev(circle, "r", "4");
			add_location(circle, file$X, 1, 59, 93);
			attr_dev(line, "x1", "23");
			attr_dev(line, "y1", "11");
			attr_dev(line, "x2", "17");
			attr_dev(line, "y2", "11");
			add_location(line, file$X, 1, 98, 132);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$$.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$_($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('UserMinus', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UserMinus> was created with unknown prop '${key}'`);
	});

	return [];
}

class UserMinus extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$_, create_fragment$$, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UserMinus",
			options,
			id: create_fragment$$.name
		});
	}
}

var UserMinus$1 = UserMinus;

/* ../../components/ui/src/icons/feather/UserPlus.svelte generated by Svelte v3.59.2 */

const file$W = "../../components/ui/src/icons/feather/UserPlus.svelte";

function create_fragment$_(ctx) {
	let path;
	let circle;
	let line0;
	let line1;

	const block = {
		c: function create() {
			path = svg_element("path");
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
			add_location(path, file$W, 1, 0, 34);
			attr_dev(circle, "cx", "8.5");
			attr_dev(circle, "cy", "7");
			attr_dev(circle, "r", "4");
			add_location(circle, file$W, 1, 59, 93);
			attr_dev(line0, "x1", "20");
			attr_dev(line0, "y1", "8");
			attr_dev(line0, "x2", "20");
			attr_dev(line0, "y2", "14");
			add_location(line0, file$W, 1, 98, 132);
			attr_dev(line1, "x1", "23");
			attr_dev(line1, "y1", "11");
			attr_dev(line1, "x2", "17");
			attr_dev(line1, "y2", "11");
			add_location(line1, file$W, 1, 142, 176);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$_.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$Z($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('UserPlus', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UserPlus> was created with unknown prop '${key}'`);
	});

	return [];
}

class UserPlus extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$Z, create_fragment$_, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UserPlus",
			options,
			id: create_fragment$_.name
		});
	}
}

var UserPlus$1 = UserPlus;

/* ../../components/ui/src/icons/feather/UserX.svelte generated by Svelte v3.59.2 */

const file$V = "../../components/ui/src/icons/feather/UserX.svelte";

function create_fragment$Z(ctx) {
	let path;
	let circle;
	let line0;
	let line1;

	const block = {
		c: function create() {
			path = svg_element("path");
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
			add_location(path, file$V, 1, 0, 34);
			attr_dev(circle, "cx", "8.5");
			attr_dev(circle, "cy", "7");
			attr_dev(circle, "r", "4");
			add_location(circle, file$V, 1, 59, 93);
			attr_dev(line0, "x1", "18");
			attr_dev(line0, "y1", "8");
			attr_dev(line0, "x2", "23");
			attr_dev(line0, "y2", "13");
			add_location(line0, file$V, 1, 98, 132);
			attr_dev(line1, "x1", "23");
			attr_dev(line1, "y1", "8");
			attr_dev(line1, "x2", "18");
			attr_dev(line1, "y2", "13");
			add_location(line1, file$V, 1, 142, 176);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$Z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$Y($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('UserX', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<UserX> was created with unknown prop '${key}'`);
	});

	return [];
}

class UserX extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$Y, create_fragment$Z, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "UserX",
			options,
			id: create_fragment$Z.name
		});
	}
}

var UserX$1 = UserX;

/* ../../components/ui/src/icons/feather/User.svelte generated by Svelte v3.59.2 */

const file$U = "../../components/ui/src/icons/feather/User.svelte";

function create_fragment$Y(ctx) {
	let path;
	let circle;

	const block = {
		c: function create() {
			path = svg_element("path");
			circle = svg_element("circle");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2");
			add_location(path, file$U, 1, 0, 34);
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "7");
			attr_dev(circle, "r", "4");
			add_location(circle, file$U, 1, 59, 93);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, circle, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(circle);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$Y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$X($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('User', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<User> was created with unknown prop '${key}'`);
	});

	return [];
}

class User extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$X, create_fragment$Y, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "User",
			options,
			id: create_fragment$Y.name
		});
	}
}

var User$1 = User;

/* ../../components/ui/src/icons/feather/Users.svelte generated by Svelte v3.59.2 */

const file$T = "../../components/ui/src/icons/feather/Users.svelte";

function create_fragment$X(ctx) {
	let path0;
	let circle;
	let path1;
	let path2;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			circle = svg_element("circle");
			path1 = svg_element("path");
			path2 = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			path2 = claim_svg_element(nodes, "path", { d: true });
			children(path2).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2");
			add_location(path0, file$T, 1, 0, 34);
			attr_dev(circle, "cx", "9");
			attr_dev(circle, "cy", "7");
			attr_dev(circle, "r", "4");
			add_location(circle, file$T, 1, 59, 93);
			attr_dev(path1, "d", "M23 21v-2a4 4 0 0 0-3-3.87");
			add_location(path1, file$T, 1, 96, 130);
			attr_dev(path2, "d", "M16 3.13a4 4 0 0 1 0 7.75");
			add_location(path2, file$T, 1, 140, 174);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, path1, anchor);
			insert_hydration_dev(target, path2, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(path1);
			if (detaching) detach_dev(path2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$X.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$W($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Users', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Users> was created with unknown prop '${key}'`);
	});

	return [];
}

class Users extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$W, create_fragment$X, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Users",
			options,
			id: create_fragment$X.name
		});
	}
}

var Users$1 = Users;

/* ../../components/ui/src/icons/feather/VideoOff.svelte generated by Svelte v3.59.2 */

const file$S = "../../components/ui/src/icons/feather/VideoOff.svelte";

function create_fragment$W(ctx) {
	let path;
	let line;

	const block = {
		c: function create() {
			path = svg_element("path");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10");
			add_location(path, file$S, 1, 0, 34);
			attr_dev(line, "x1", "1");
			attr_dev(line, "y1", "1");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "23");
			add_location(line, file$S, 1, 115, 149);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$W.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$V($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('VideoOff', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<VideoOff> was created with unknown prop '${key}'`);
	});

	return [];
}

class VideoOff extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$V, create_fragment$W, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "VideoOff",
			options,
			id: create_fragment$W.name
		});
	}
}

var VideoOff$1 = VideoOff;

/* ../../components/ui/src/icons/feather/Video.svelte generated by Svelte v3.59.2 */

const file$R = "../../components/ui/src/icons/feather/Video.svelte";

function create_fragment$V(ctx) {
	let polygon;
	let rect;

	const block = {
		c: function create() {
			polygon = svg_element("polygon");
			rect = svg_element("rect");
			this.h();
		},
		l: function claim(nodes) {
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);

			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polygon, "points", "23 7 16 12 23 17 23 7");
			add_location(polygon, file$R, 1, 0, 34);
			attr_dev(rect, "x", "1");
			attr_dev(rect, "y", "5");
			attr_dev(rect, "width", "15");
			attr_dev(rect, "height", "14");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$R, 1, 50, 84);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polygon, anchor);
			insert_hydration_dev(target, rect, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polygon);
			if (detaching) detach_dev(rect);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$V.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$U($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Video', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Video> was created with unknown prop '${key}'`);
	});

	return [];
}

class Video extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$U, create_fragment$V, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Video",
			options,
			id: create_fragment$V.name
		});
	}
}

var Video$1 = Video;

/* ../../components/ui/src/icons/feather/Voicemail.svelte generated by Svelte v3.59.2 */

const file$Q = "../../components/ui/src/icons/feather/Voicemail.svelte";

function create_fragment$U(ctx) {
	let circle0;
	let circle1;
	let line;

	const block = {
		c: function create() {
			circle0 = svg_element("circle");
			circle1 = svg_element("circle");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			circle0 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle0).forEach(detach_dev);
			circle1 = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle1).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle0, "cx", "5.5");
			attr_dev(circle0, "cy", "11.5");
			attr_dev(circle0, "r", "4.5");
			add_location(circle0, file$Q, 1, 0, 34);
			attr_dev(circle1, "cx", "18.5");
			attr_dev(circle1, "cy", "11.5");
			attr_dev(circle1, "r", "4.5");
			add_location(circle1, file$Q, 1, 44, 78);
			attr_dev(line, "x1", "5.5");
			attr_dev(line, "y1", "16");
			attr_dev(line, "x2", "18.5");
			attr_dev(line, "y2", "16");
			add_location(line, file$Q, 1, 89, 123);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle0, anchor);
			insert_hydration_dev(target, circle1, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle0);
			if (detaching) detach_dev(circle1);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$U.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$T($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Voicemail', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Voicemail> was created with unknown prop '${key}'`);
	});

	return [];
}

class Voicemail extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$T, create_fragment$U, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Voicemail",
			options,
			id: create_fragment$U.name
		});
	}
}

var Voicemail$1 = Voicemail;

/* ../../components/ui/src/icons/feather/Volume1.svelte generated by Svelte v3.59.2 */

const file$P = "../../components/ui/src/icons/feather/Volume1.svelte";

function create_fragment$T(ctx) {
	let polygon;
	let path;

	const block = {
		c: function create() {
			polygon = svg_element("polygon");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polygon, "points", "11 5 6 9 2 9 2 15 6 15 11 19 11 5");
			add_location(polygon, file$P, 1, 0, 34);
			attr_dev(path, "d", "M15.54 8.46a5 5 0 0 1 0 7.07");
			add_location(path, file$P, 1, 62, 96);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polygon, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polygon);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$T.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$S($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Volume1', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Volume1> was created with unknown prop '${key}'`);
	});

	return [];
}

class Volume1 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$S, create_fragment$T, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Volume1",
			options,
			id: create_fragment$T.name
		});
	}
}

var Volume1$1 = Volume1;

/* ../../components/ui/src/icons/feather/Volume2.svelte generated by Svelte v3.59.2 */

const file$O = "../../components/ui/src/icons/feather/Volume2.svelte";

function create_fragment$S(ctx) {
	let polygon;
	let path;

	const block = {
		c: function create() {
			polygon = svg_element("polygon");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polygon, "points", "11 5 6 9 2 9 2 15 6 15 11 19 11 5");
			add_location(polygon, file$O, 1, 0, 34);
			attr_dev(path, "d", "M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07");
			add_location(path, file$O, 1, 62, 96);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polygon, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polygon);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$S.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$R($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Volume2', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Volume2> was created with unknown prop '${key}'`);
	});

	return [];
}

class Volume2 extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$R, create_fragment$S, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Volume2",
			options,
			id: create_fragment$S.name
		});
	}
}

var Volume2$1 = Volume2;

/* ../../components/ui/src/icons/feather/VolumeX.svelte generated by Svelte v3.59.2 */

const file$N = "../../components/ui/src/icons/feather/VolumeX.svelte";

function create_fragment$R(ctx) {
	let polygon;
	let line0;
	let line1;

	const block = {
		c: function create() {
			polygon = svg_element("polygon");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polygon, "points", "11 5 6 9 2 9 2 15 6 15 11 19 11 5");
			add_location(polygon, file$N, 1, 0, 34);
			attr_dev(line0, "x1", "23");
			attr_dev(line0, "y1", "9");
			attr_dev(line0, "x2", "17");
			attr_dev(line0, "y2", "15");
			add_location(line0, file$N, 1, 62, 96);
			attr_dev(line1, "x1", "17");
			attr_dev(line1, "y1", "9");
			attr_dev(line1, "x2", "23");
			attr_dev(line1, "y2", "15");
			add_location(line1, file$N, 1, 106, 140);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polygon, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polygon);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$R.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$Q($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('VolumeX', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<VolumeX> was created with unknown prop '${key}'`);
	});

	return [];
}

class VolumeX extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$Q, create_fragment$R, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "VolumeX",
			options,
			id: create_fragment$R.name
		});
	}
}

var VolumeX$1 = VolumeX;

/* ../../components/ui/src/icons/feather/Volume.svelte generated by Svelte v3.59.2 */

const file$M = "../../components/ui/src/icons/feather/Volume.svelte";

function create_fragment$Q(ctx) {
	let polygon;

	const block = {
		c: function create() {
			polygon = svg_element("polygon");
			this.h();
		},
		l: function claim(nodes) {
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polygon, "points", "11 5 6 9 2 9 2 15 6 15 11 19 11 5");
			add_location(polygon, file$M, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polygon, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polygon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$Q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$P($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Volume', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Volume> was created with unknown prop '${key}'`);
	});

	return [];
}

class Volume extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$P, create_fragment$Q, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Volume",
			options,
			id: create_fragment$Q.name
		});
	}
}

var Volume$1 = Volume;

/* ../../components/ui/src/icons/feather/Watch.svelte generated by Svelte v3.59.2 */

const file$L = "../../components/ui/src/icons/feather/Watch.svelte";

function create_fragment$P(ctx) {
	let circle;
	let polyline;
	let path;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			polyline = svg_element("polyline");
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			polyline = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline).forEach(detach_dev);
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "7");
			add_location(circle, file$L, 1, 0, 34);
			attr_dev(polyline, "points", "12 9 12 12 13.5 13.5");
			add_location(polyline, file$L, 1, 39, 73);
			attr_dev(path, "d", "M16.51 17.35l-.35 3.83a2 2 0 0 1-2 1.82H9.83a2 2 0 0 1-2-1.82l-.35-3.83m.01-10.7l.35-3.83A2 2 0 0 1 9.83 1h4.35a2 2 0 0 1 2 1.82l.35 3.83");
			add_location(path, file$L, 1, 90, 124);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, polyline, anchor);
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(polyline);
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$P.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$O($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Watch', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Watch> was created with unknown prop '${key}'`);
	});

	return [];
}

class Watch extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$O, create_fragment$P, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Watch",
			options,
			id: create_fragment$P.name
		});
	}
}

var Watch$1 = Watch;

/* ../../components/ui/src/icons/feather/WifiOff.svelte generated by Svelte v3.59.2 */

const file$K = "../../components/ui/src/icons/feather/WifiOff.svelte";

function create_fragment$O(ctx) {
	let line0;
	let path0;
	let path1;
	let path2;
	let path3;
	let path4;
	let line1;

	const block = {
		c: function create() {
			line0 = svg_element("line");
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			path3 = svg_element("path");
			path4 = svg_element("path");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			path2 = claim_svg_element(nodes, "path", { d: true });
			children(path2).forEach(detach_dev);
			path3 = claim_svg_element(nodes, "path", { d: true });
			children(path3).forEach(detach_dev);
			path4 = claim_svg_element(nodes, "path", { d: true });
			children(path4).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line0, "x1", "1");
			attr_dev(line0, "y1", "1");
			attr_dev(line0, "x2", "23");
			attr_dev(line0, "y2", "23");
			add_location(line0, file$K, 1, 0, 34);
			attr_dev(path0, "d", "M16.72 11.06A10.94 10.94 0 0 1 19 12.55");
			add_location(path0, file$K, 1, 43, 77);
			attr_dev(path1, "d", "M5 12.55a10.94 10.94 0 0 1 5.17-2.39");
			add_location(path1, file$K, 1, 100, 134);
			attr_dev(path2, "d", "M10.71 5.05A16 16 0 0 1 22.58 9");
			add_location(path2, file$K, 1, 154, 188);
			attr_dev(path3, "d", "M1.42 9a15.91 15.91 0 0 1 4.7-2.88");
			add_location(path3, file$K, 1, 203, 237);
			attr_dev(path4, "d", "M8.53 16.11a6 6 0 0 1 6.95 0");
			add_location(path4, file$K, 1, 255, 289);
			attr_dev(line1, "x1", "12");
			attr_dev(line1, "y1", "20");
			attr_dev(line1, "x2", "12.01");
			attr_dev(line1, "y2", "20");
			add_location(line1, file$K, 1, 301, 335);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
			insert_hydration_dev(target, path2, anchor);
			insert_hydration_dev(target, path3, anchor);
			insert_hydration_dev(target, path4, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
			if (detaching) detach_dev(path2);
			if (detaching) detach_dev(path3);
			if (detaching) detach_dev(path4);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$O.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$N($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('WifiOff', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<WifiOff> was created with unknown prop '${key}'`);
	});

	return [];
}

class WifiOff extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$N, create_fragment$O, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "WifiOff",
			options,
			id: create_fragment$O.name
		});
	}
}

var WifiOff$1 = WifiOff;

/* ../../components/ui/src/icons/feather/Wifi.svelte generated by Svelte v3.59.2 */

const file$J = "../../components/ui/src/icons/feather/Wifi.svelte";

function create_fragment$N(ctx) {
	let path0;
	let path1;
	let path2;
	let line;

	const block = {
		c: function create() {
			path0 = svg_element("path");
			path1 = svg_element("path");
			path2 = svg_element("path");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			path0 = claim_svg_element(nodes, "path", { d: true });
			children(path0).forEach(detach_dev);
			path1 = claim_svg_element(nodes, "path", { d: true });
			children(path1).forEach(detach_dev);
			path2 = claim_svg_element(nodes, "path", { d: true });
			children(path2).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path0, "d", "M5 12.55a11 11 0 0 1 14.08 0");
			add_location(path0, file$J, 1, 0, 34);
			attr_dev(path1, "d", "M1.42 9a16 16 0 0 1 21.16 0");
			add_location(path1, file$J, 1, 46, 80);
			attr_dev(path2, "d", "M8.53 16.11a6 6 0 0 1 6.95 0");
			add_location(path2, file$J, 1, 91, 125);
			attr_dev(line, "x1", "12");
			attr_dev(line, "y1", "20");
			attr_dev(line, "x2", "12.01");
			attr_dev(line, "y2", "20");
			add_location(line, file$J, 1, 137, 171);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path0, anchor);
			insert_hydration_dev(target, path1, anchor);
			insert_hydration_dev(target, path2, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path0);
			if (detaching) detach_dev(path1);
			if (detaching) detach_dev(path2);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$N.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$M($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Wifi', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Wifi> was created with unknown prop '${key}'`);
	});

	return [];
}

class Wifi extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$M, create_fragment$N, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Wifi",
			options,
			id: create_fragment$N.name
		});
	}
}

var Wifi$1 = Wifi;

/* ../../components/ui/src/icons/feather/Wind.svelte generated by Svelte v3.59.2 */

const file$I = "../../components/ui/src/icons/feather/Wind.svelte";

function create_fragment$M(ctx) {
	let path;

	const block = {
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2");
			add_location(path, file$I, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$M.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$L($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Wind', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Wind> was created with unknown prop '${key}'`);
	});

	return [];
}

class Wind extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$L, create_fragment$M, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Wind",
			options,
			id: create_fragment$M.name
		});
	}
}

var Wind$1 = Wind;

/* ../../components/ui/src/icons/feather/XCircle.svelte generated by Svelte v3.59.2 */

const file$H = "../../components/ui/src/icons/feather/XCircle.svelte";

function create_fragment$L(ctx) {
	let circle;
	let line0;
	let line1;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "12");
			attr_dev(circle, "cy", "12");
			attr_dev(circle, "r", "10");
			add_location(circle, file$H, 1, 0, 34);
			attr_dev(line0, "x1", "15");
			attr_dev(line0, "y1", "9");
			attr_dev(line0, "x2", "9");
			attr_dev(line0, "y2", "15");
			add_location(line0, file$H, 1, 40, 74);
			attr_dev(line1, "x1", "9");
			attr_dev(line1, "y1", "9");
			attr_dev(line1, "x2", "15");
			attr_dev(line1, "y2", "15");
			add_location(line1, file$H, 1, 83, 117);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$L.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$K($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('XCircle', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<XCircle> was created with unknown prop '${key}'`);
	});

	return [];
}

class XCircle extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$K, create_fragment$L, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "XCircle",
			options,
			id: create_fragment$L.name
		});
	}
}

var XCircle$1 = XCircle;

/* ../../components/ui/src/icons/feather/XOctagon.svelte generated by Svelte v3.59.2 */

const file$G = "../../components/ui/src/icons/feather/XOctagon.svelte";

function create_fragment$K(ctx) {
	let polygon;
	let line0;
	let line1;

	const block = {
		c: function create() {
			polygon = svg_element("polygon");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polygon, "points", "7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2");
			add_location(polygon, file$G, 1, 0, 34);
			attr_dev(line0, "x1", "15");
			attr_dev(line0, "y1", "9");
			attr_dev(line0, "x2", "9");
			attr_dev(line0, "y2", "15");
			add_location(line0, file$G, 1, 99, 133);
			attr_dev(line1, "x1", "9");
			attr_dev(line1, "y1", "9");
			attr_dev(line1, "x2", "15");
			attr_dev(line1, "y2", "15");
			add_location(line1, file$G, 1, 142, 176);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polygon, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polygon);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$K.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$J($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('XOctagon', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<XOctagon> was created with unknown prop '${key}'`);
	});

	return [];
}

class XOctagon extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$J, create_fragment$K, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "XOctagon",
			options,
			id: create_fragment$K.name
		});
	}
}

var XOctagon$1 = XOctagon;

/* ../../components/ui/src/icons/feather/XSquare.svelte generated by Svelte v3.59.2 */

const file$F = "../../components/ui/src/icons/feather/XSquare.svelte";

function create_fragment$J(ctx) {
	let rect;
	let line0;
	let line1;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				rx: true,
				ry: true
			});

			children(rect).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "x", "3");
			attr_dev(rect, "y", "3");
			attr_dev(rect, "width", "18");
			attr_dev(rect, "height", "18");
			attr_dev(rect, "rx", "2");
			attr_dev(rect, "ry", "2");
			add_location(rect, file$F, 1, 0, 34);
			attr_dev(line0, "x1", "9");
			attr_dev(line0, "y1", "9");
			attr_dev(line0, "x2", "15");
			attr_dev(line0, "y2", "15");
			add_location(line0, file$F, 1, 62, 96);
			attr_dev(line1, "x1", "15");
			attr_dev(line1, "y1", "9");
			attr_dev(line1, "x2", "9");
			attr_dev(line1, "y2", "15");
			add_location(line1, file$F, 1, 105, 139);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$J.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$I($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('XSquare', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<XSquare> was created with unknown prop '${key}'`);
	});

	return [];
}

class XSquare extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$I, create_fragment$J, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "XSquare",
			options,
			id: create_fragment$J.name
		});
	}
}

var XSquare$1 = XSquare;

/* ../../components/ui/src/icons/feather/X.svelte generated by Svelte v3.59.2 */

const file$E = "../../components/ui/src/icons/feather/X.svelte";

function create_fragment$I(ctx) {
	let line0;
	let line1;

	const block = {
		c: function create() {
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line0, "x1", "18");
			attr_dev(line0, "y1", "6");
			attr_dev(line0, "x2", "6");
			attr_dev(line0, "y2", "18");
			add_location(line0, file$E, 1, 0, 34);
			attr_dev(line1, "x1", "6");
			attr_dev(line1, "y1", "6");
			attr_dev(line1, "x2", "18");
			attr_dev(line1, "y2", "18");
			add_location(line1, file$E, 1, 43, 77);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$I.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$H($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('X', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<X> was created with unknown prop '${key}'`);
	});

	return [];
}

class X extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$H, create_fragment$I, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "X",
			options,
			id: create_fragment$I.name
		});
	}
}

var X$1 = X;

/* ../../components/ui/src/icons/feather/Youtube.svelte generated by Svelte v3.59.2 */

const file$D = "../../components/ui/src/icons/feather/Youtube.svelte";

function create_fragment$H(ctx) {
	let path;
	let polygon;

	const block = {
		c: function create() {
			path = svg_element("path");
			polygon = svg_element("polygon");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true });
			children(path).forEach(detach_dev);
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", "M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z");
			add_location(path, file$D, 1, 0, 34);
			attr_dev(polygon, "points", "9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02");
			add_location(polygon, file$D, 1, 275, 309);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
			insert_hydration_dev(target, polygon, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			if (detaching) detach_dev(polygon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$H.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$G($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Youtube', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Youtube> was created with unknown prop '${key}'`);
	});

	return [];
}

class Youtube extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$G, create_fragment$H, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Youtube",
			options,
			id: create_fragment$H.name
		});
	}
}

var Youtube$1 = Youtube;

/* ../../components/ui/src/icons/feather/ZapOff.svelte generated by Svelte v3.59.2 */

const file$C = "../../components/ui/src/icons/feather/ZapOff.svelte";

function create_fragment$G(ctx) {
	let polyline0;
	let polyline1;
	let polyline2;
	let line;

	const block = {
		c: function create() {
			polyline0 = svg_element("polyline");
			polyline1 = svg_element("polyline");
			polyline2 = svg_element("polyline");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			polyline0 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline0).forEach(detach_dev);
			polyline1 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline1).forEach(detach_dev);
			polyline2 = claim_svg_element(nodes, "polyline", { points: true });
			children(polyline2).forEach(detach_dev);
			line = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polyline0, "points", "12.41 6.75 13 2 10.57 4.92");
			add_location(polyline0, file$C, 1, 0, 34);
			attr_dev(polyline1, "points", "18.57 12.91 21 10 15.66 10");
			add_location(polyline1, file$C, 1, 57, 91);
			attr_dev(polyline2, "points", "8 8 3 14 12 14 11 22 16 16");
			add_location(polyline2, file$C, 1, 114, 148);
			attr_dev(line, "x1", "1");
			attr_dev(line, "y1", "1");
			attr_dev(line, "x2", "23");
			attr_dev(line, "y2", "23");
			add_location(line, file$C, 1, 171, 205);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polyline0, anchor);
			insert_hydration_dev(target, polyline1, anchor);
			insert_hydration_dev(target, polyline2, anchor);
			insert_hydration_dev(target, line, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polyline0);
			if (detaching) detach_dev(polyline1);
			if (detaching) detach_dev(polyline2);
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$G.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$F($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ZapOff', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ZapOff> was created with unknown prop '${key}'`);
	});

	return [];
}

class ZapOff extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$F, create_fragment$G, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ZapOff",
			options,
			id: create_fragment$G.name
		});
	}
}

var ZapOff$1 = ZapOff;

/* ../../components/ui/src/icons/feather/Zap.svelte generated by Svelte v3.59.2 */

const file$B = "../../components/ui/src/icons/feather/Zap.svelte";

function create_fragment$F(ctx) {
	let polygon;

	const block = {
		c: function create() {
			polygon = svg_element("polygon");
			this.h();
		},
		l: function claim(nodes) {
			polygon = claim_svg_element(nodes, "polygon", { points: true });
			children(polygon).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(polygon, "points", "13 2 3 14 12 14 11 22 21 10 12 10 13 2");
			add_location(polygon, file$B, 1, 0, 34);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, polygon, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(polygon);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$F.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$E($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Zap', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Zap> was created with unknown prop '${key}'`);
	});

	return [];
}

class Zap extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$E, create_fragment$F, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Zap",
			options,
			id: create_fragment$F.name
		});
	}
}

var Zap$1 = Zap;

/* ../../components/ui/src/icons/feather/ZoomIn.svelte generated by Svelte v3.59.2 */

const file$A = "../../components/ui/src/icons/feather/ZoomIn.svelte";

function create_fragment$E(ctx) {
	let circle;
	let line0;
	let line1;
	let line2;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			line2 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			line2 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line2).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "11");
			attr_dev(circle, "cy", "11");
			attr_dev(circle, "r", "8");
			add_location(circle, file$A, 1, 0, 34);
			attr_dev(line0, "x1", "21");
			attr_dev(line0, "y1", "21");
			attr_dev(line0, "x2", "16.65");
			attr_dev(line0, "y2", "16.65");
			add_location(line0, file$A, 1, 39, 73);
			attr_dev(line1, "x1", "11");
			attr_dev(line1, "y1", "8");
			attr_dev(line1, "x2", "11");
			attr_dev(line1, "y2", "14");
			add_location(line1, file$A, 1, 90, 124);
			attr_dev(line2, "x1", "8");
			attr_dev(line2, "y1", "11");
			attr_dev(line2, "x2", "14");
			attr_dev(line2, "y2", "11");
			add_location(line2, file$A, 1, 134, 168);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
			insert_hydration_dev(target, line2, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
			if (detaching) detach_dev(line2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$E.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$D($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ZoomIn', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ZoomIn> was created with unknown prop '${key}'`);
	});

	return [];
}

class ZoomIn extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$D, create_fragment$E, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ZoomIn",
			options,
			id: create_fragment$E.name
		});
	}
}

var ZoomIn$1 = ZoomIn;

/* ../../components/ui/src/icons/feather/ZoomOut.svelte generated by Svelte v3.59.2 */

const file$z = "../../components/ui/src/icons/feather/ZoomOut.svelte";

function create_fragment$D(ctx) {
	let circle;
	let line0;
	let line1;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			line0 = svg_element("line");
			line1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { cx: true, cy: true, r: true });
			children(circle).forEach(detach_dev);
			line0 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line0).forEach(detach_dev);
			line1 = claim_svg_element(nodes, "line", { x1: true, y1: true, x2: true, y2: true });
			children(line1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", "11");
			attr_dev(circle, "cy", "11");
			attr_dev(circle, "r", "8");
			add_location(circle, file$z, 1, 0, 34);
			attr_dev(line0, "x1", "21");
			attr_dev(line0, "y1", "21");
			attr_dev(line0, "x2", "16.65");
			attr_dev(line0, "y2", "16.65");
			add_location(line0, file$z, 1, 39, 73);
			attr_dev(line1, "x1", "8");
			attr_dev(line1, "y1", "11");
			attr_dev(line1, "x2", "14");
			attr_dev(line1, "y2", "11");
			add_location(line1, file$z, 1, 90, 124);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
			insert_hydration_dev(target, line0, anchor);
			insert_hydration_dev(target, line1, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
			if (detaching) detach_dev(line0);
			if (detaching) detach_dev(line1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$D.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$C($$self, $$props) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ZoomOut', slots, []);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ZoomOut> was created with unknown prop '${key}'`);
	});

	return [];
}

class ZoomOut extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$C, create_fragment$D, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ZoomOut",
			options,
			id: create_fragment$D.name
		});
	}
}

var ZoomOut$1 = ZoomOut;

/* ../../components/ui/src/sensors/style/StyleSensor.svelte generated by Svelte v3.59.2 */

function create_fragment$C(ctx) {
	const block = {
		c: noop,
		l: noop,
		m: noop,
		p: noop,
		i: noop,
		o: noop,
		d: noop
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$C.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$B($$self, $$props, $$invalidate) {
	let hrefURL;
	let allStyleRules;
	let getStyleRulesObj;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('StyleSensor', slots, []);
	let { href } = $$props;
	let { selectorRegex } = $$props;
	let { styleRules } = $$props;

	$$self.$$.on_mount.push(function () {
		if (href === undefined && !('href' in $$props || $$self.$$.bound[$$self.$$.props['href']])) {
			console.warn("<StyleSensor> was created without expected prop 'href'");
		}

		if (selectorRegex === undefined && !('selectorRegex' in $$props || $$self.$$.bound[$$self.$$.props['selectorRegex']])) {
			console.warn("<StyleSensor> was created without expected prop 'selectorRegex'");
		}

		if (styleRules === undefined && !('styleRules' in $$props || $$self.$$.bound[$$self.$$.props['styleRules']])) {
			console.warn("<StyleSensor> was created without expected prop 'styleRules'");
		}
	});

	const writable_props = ['href', 'selectorRegex', 'styleRules'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<StyleSensor> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('href' in $$props) $$invalidate(1, href = $$props.href);
		if ('selectorRegex' in $$props) $$invalidate(2, selectorRegex = $$props.selectorRegex);
		if ('styleRules' in $$props) $$invalidate(0, styleRules = $$props.styleRules);
	};

	$$self.$capture_state = () => ({
		isClientSide,
		getStylesheet,
		makeGetStyleRulesObj,
		getURL,
		href,
		selectorRegex,
		styleRules,
		allStyleRules,
		getStyleRulesObj,
		hrefURL
	});

	$$self.$inject_state = $$props => {
		if ('href' in $$props) $$invalidate(1, href = $$props.href);
		if ('selectorRegex' in $$props) $$invalidate(2, selectorRegex = $$props.selectorRegex);
		if ('styleRules' in $$props) $$invalidate(0, styleRules = $$props.styleRules);
		if ('allStyleRules' in $$props) $$invalidate(3, allStyleRules = $$props.allStyleRules);
		if ('getStyleRulesObj' in $$props) $$invalidate(4, getStyleRulesObj = $$props.getStyleRulesObj);
		if ('hrefURL' in $$props) $$invalidate(5, hrefURL = $$props.hrefURL);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*href*/ 2) {
			$$invalidate(5, hrefURL = isClientSide && href && getURL(href).toString());
		}

		if ($$self.$$.dirty & /*hrefURL*/ 32) {
			$$invalidate(3, allStyleRules = hrefURL ? [...getStylesheet(hrefURL).cssRules] : []); // convert collection to array
		}

		if ($$self.$$.dirty & /*selectorRegex*/ 4) {
			$$invalidate(4, getStyleRulesObj = makeGetStyleRulesObj(selectorRegex));
		}

		if ($$self.$$.dirty & /*getStyleRulesObj, allStyleRules*/ 24) {
			$$invalidate(0, styleRules = getStyleRulesObj(allStyleRules));
		}
	};

	return [styleRules, href, selectorRegex, allStyleRules, getStyleRulesObj, hrefURL];
}

class StyleSensor extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$B, create_fragment$C, safe_not_equal, { href: 1, selectorRegex: 2, styleRules: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "StyleSensor",
			options,
			id: create_fragment$C.name
		});
	}

	get href() {
		throw new Error("<StyleSensor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set href(value) {
		throw new Error("<StyleSensor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selectorRegex() {
		throw new Error("<StyleSensor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selectorRegex(value) {
		throw new Error("<StyleSensor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get styleRules() {
		throw new Error("<StyleSensor>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set styleRules(value) {
		throw new Error("<StyleSensor>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var StyleSensor$1 = StyleSensor;

/* ../../components/ui/src/Banner.svelte generated by Svelte v3.59.2 */
const file$y = "../../components/ui/src/Banner.svelte";

function create_fragment$B(ctx) {
	let div1;
	let div0;
	let div1_class_value;
	let current;
	let mounted;
	let dispose;
	const default_slot_template = /*#slots*/ ctx[10].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", {
				style: true,
				"aria-label": true,
				class: true,
				role: true
			});

			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true, role: true });
			var div0_nodes = children(div0);
			if (default_slot) default_slot.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "inner svelte-13u9ek9");
			attr_dev(div0, "role", "button");
			toggle_class(div0, "narrow", /*isNarrow*/ ctx[2]);
			add_location(div0, file$y, 51, 1, 1124);
			attr_dev(div1, "style", /*style*/ ctx[3]);
			attr_dev(div1, "aria-label", "Banner");
			attr_dev(div1, "class", div1_class_value = "Banner " + /*$_screen*/ ctx[4]?.classes + " svelte-13u9ek9");
			attr_dev(div1, "role", "alert");
			toggle_class(div1, "backdrop", /*hasBackdrop*/ ctx[1]);
			add_location(div1, file$y, 41, 0, 908);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div1, anchor);
			append_hydration_dev(div1, div0);

			if (default_slot) {
				default_slot.m(div0, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(window, "keydown", /*onKeyDown*/ ctx[6], false, false, false, false),
					listen_dev(div0, "click", stop_propagation(/*click_handler*/ ctx[11]), false, false, true, false),
					listen_dev(div0, "keydown", stop_propagation(/*keydown_handler*/ ctx[12]), false, false, true, false),
					listen_dev(div1, "click", /*close*/ ctx[5], false, false, false, false),
					listen_dev(div1, "keydown", /*onKeyDown*/ ctx[6], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 512)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[9],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[9])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[9], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*isNarrow*/ 4) {
				toggle_class(div0, "narrow", /*isNarrow*/ ctx[2]);
			}

			if (!current || dirty & /*style*/ 8) {
				attr_dev(div1, "style", /*style*/ ctx[3]);
			}

			if (!current || dirty & /*$_screen*/ 16 && div1_class_value !== (div1_class_value = "Banner " + /*$_screen*/ ctx[4]?.classes + " svelte-13u9ek9")) {
				attr_dev(div1, "class", div1_class_value);
			}

			if (!current || dirty & /*$_screen, hasBackdrop*/ 18) {
				toggle_class(div1, "backdrop", /*hasBackdrop*/ ctx[1]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (default_slot) default_slot.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$B.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$A($$self, $$props, $$invalidate) {
	let style;

	let $_screen,
		$$unsubscribe__screen = noop,
		$$subscribe__screen = () => ($$unsubscribe__screen(), $$unsubscribe__screen = subscribe(_screen, $$value => $$invalidate(4, $_screen = $$value)), _screen);

	$$self.$$.on_destroy.push(() => $$unsubscribe__screen());
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Banner', slots, ['default']);

	const defaultTheme = {
		border: 'thin solid rgb(70, 70, 70)',
		borderRadius: '1rem',
		colorBackdropSensor: 'rgba(0, 0, 0, 0.25)',
		colorBackground: 'white',
		colorBoxShadow: 'lightgrey',
		colorText: 'black',
		padding: '0.5rem',
		shadowGeometry: '2px 8px 9px -4px',
		zIndex: 2000
	};

	let { _screen } = $$props;
	validate_store(_screen, '_screen');
	$$subscribe__screen();
	let { hasBackdrop = true } = $$props;
	let { isNarrow = true } = $$props;
	let { theme } = $$props;
	let { width } = $$props;
	const dispatch = createEventDispatcher();
	const close = () => dispatch('close');

	const onKeyDown = event => {
		if (event.key === 'Escape') {
			event.preventDefault();
			close();
		}
	};

	$$self.$$.on_mount.push(function () {
		if (_screen === undefined && !('_screen' in $$props || $$self.$$.bound[$$self.$$.props['_screen']])) {
			console.warn("<Banner> was created without expected prop '_screen'");
		}

		if (theme === undefined && !('theme' in $$props || $$self.$$.bound[$$self.$$.props['theme']])) {
			console.warn("<Banner> was created without expected prop 'theme'");
		}

		if (width === undefined && !('width' in $$props || $$self.$$.bound[$$self.$$.props['width']])) {
			console.warn("<Banner> was created without expected prop 'width'");
		}
	});

	const writable_props = ['_screen', 'hasBackdrop', 'isNarrow', 'theme', 'width'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Banner> was created with unknown prop '${key}'`);
	});

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	function keydown_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('_screen' in $$props) $$subscribe__screen($$invalidate(0, _screen = $$props._screen));
		if ('hasBackdrop' in $$props) $$invalidate(1, hasBackdrop = $$props.hasBackdrop);
		if ('isNarrow' in $$props) $$invalidate(2, isNarrow = $$props.isNarrow);
		if ('theme' in $$props) $$invalidate(7, theme = $$props.theme);
		if ('width' in $$props) $$invalidate(8, width = $$props.width);
		if ('$$scope' in $$props) $$invalidate(9, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		makeStyleVars,
		createEventDispatcher,
		defaultTheme,
		_screen,
		hasBackdrop,
		isNarrow,
		theme,
		width,
		dispatch,
		close,
		onKeyDown,
		style,
		$_screen
	});

	$$self.$inject_state = $$props => {
		if ('_screen' in $$props) $$subscribe__screen($$invalidate(0, _screen = $$props._screen));
		if ('hasBackdrop' in $$props) $$invalidate(1, hasBackdrop = $$props.hasBackdrop);
		if ('isNarrow' in $$props) $$invalidate(2, isNarrow = $$props.isNarrow);
		if ('theme' in $$props) $$invalidate(7, theme = $$props.theme);
		if ('width' in $$props) $$invalidate(8, width = $$props.width);
		if ('style' in $$props) $$invalidate(3, style = $$props.style);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*width*/ 256) {
			$$invalidate(8, width = width || '90%');
		}

		if ($$self.$$.dirty & /*theme*/ 128) {
			$$invalidate(7, theme = theme ? { ...defaultTheme, ...theme } : defaultTheme);
		}

		if ($$self.$$.dirty & /*theme, width*/ 384) {
			$$invalidate(3, style = makeStyleVars({ ...theme, width }));
		}
	};

	return [
		_screen,
		hasBackdrop,
		isNarrow,
		style,
		$_screen,
		close,
		onKeyDown,
		theme,
		width,
		$$scope,
		slots,
		click_handler,
		keydown_handler
	];
}

class Banner extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$A, create_fragment$B, safe_not_equal, {
			_screen: 0,
			hasBackdrop: 1,
			isNarrow: 2,
			theme: 7,
			width: 8
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Banner",
			options,
			id: create_fragment$B.name
		});
	}

	get _screen() {
		throw new Error("<Banner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set _screen(value) {
		throw new Error("<Banner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hasBackdrop() {
		throw new Error("<Banner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hasBackdrop(value) {
		throw new Error("<Banner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isNarrow() {
		throw new Error("<Banner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isNarrow(value) {
		throw new Error("<Banner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get theme() {
		throw new Error("<Banner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set theme(value) {
		throw new Error("<Banner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<Banner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<Banner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var Banner$1 = Banner;

/* ../../components/ui/src/HighlightedText.svelte generated by Svelte v3.59.2 */
const file$x = "../../components/ui/src/HighlightedText.svelte";

function get_each_context$a(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i][0];
	child_ctx[10] = list[i][1];
	child_ctx[12] = i;
	return child_ctx;
}

// (53:44) {#if styled}
function create_if_block$l(ctx) {
	let span;
	let t_value = /*styled*/ ctx[10] + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { style: true, id: true, class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "style", /*style*/ ctx[0]);
			attr_dev(span, "id", "highlighted-" + /*i*/ ctx[12]);
			attr_dev(span, "class", "highlighted svelte-9csl53");
			add_location(span, file$x, 52, 56, 1301);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*parts*/ 2 && t_value !== (t_value = /*styled*/ ctx[10] + "")) set_data_dev(t, t_value);

			if (dirty & /*style*/ 1) {
				attr_dev(span, "style", /*style*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$l.name,
		type: "if",
		source: "(53:44) {#if styled}",
		ctx
	});

	return block;
}

// (53:0) {#each parts as [normal, styled], i}
function create_each_block$a(ctx) {
	let t_value = /*normal*/ ctx[9] + "";
	let t;
	let if_block_anchor;
	let if_block = /*styled*/ ctx[10] && create_if_block$l(ctx);

	const block = {
		c: function create() {
			t = text(t_value);
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_hydration_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*parts*/ 2 && t_value !== (t_value = /*normal*/ ctx[9] + "")) set_data_dev(t, t_value);

			if (/*styled*/ ctx[10]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$l(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$a.name,
		type: "each",
		source: "(53:0) {#each parts as [normal, styled], i}",
		ctx
	});

	return block;
}

function create_fragment$A(ctx) {
	let each_1_anchor;
	let each_value = /*parts*/ ctx[1];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert_hydration_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*style, parts*/ 3) {
				each_value = /*parts*/ ctx[1];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$a(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$a(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$A.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const defaultString = '';

function instance$z($$self, $$props, $$invalidate) {
	let parts;
	let style;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('HighlightedText', slots, []);

	const defaultTheme = {
		colorHighlightedBackground: 'yellow',
		colorHighlightedText: 'black'
	};

	let { regex } = $$props;
	let { shouldScroll = false } = $$props;
	let { string = defaultString } = $$props;
	let { theme } = $$props;

	const splitText = (text, regExp) => {
		let pairs = [[text, '']];

		if (regExp && isRegexpNotEmpty(regExp)) {
			const remains = text.split(regExp);

			if (remains.length > 1) {
				const matches = text.match(regExp)?.concat('');
				pairs = zip(remains, matches);
			}
		}

		return pairs;
	};

	const scrollIntoView = async () => {
		await tick();
		const targetElement = document.getElementById('highlighted-0');

		if (targetElement) {
			if (targetElement.scrollIntoViewIfNeeded) {
				targetElement.scrollIntoViewIfNeeded(); // Chrome/Safari/Edge
			} else {
				targetElement.scrollIntoView(); // FF
			}
		}
	};

	$$self.$$.on_mount.push(function () {
		if (regex === undefined && !('regex' in $$props || $$self.$$.bound[$$self.$$.props['regex']])) {
			console.warn("<HighlightedText> was created without expected prop 'regex'");
		}

		if (theme === undefined && !('theme' in $$props || $$self.$$.bound[$$self.$$.props['theme']])) {
			console.warn("<HighlightedText> was created without expected prop 'theme'");
		}
	});

	const writable_props = ['regex', 'shouldScroll', 'string', 'theme'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<HighlightedText> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('regex' in $$props) $$invalidate(4, regex = $$props.regex);
		if ('shouldScroll' in $$props) $$invalidate(5, shouldScroll = $$props.shouldScroll);
		if ('string' in $$props) $$invalidate(2, string = $$props.string);
		if ('theme' in $$props) $$invalidate(3, theme = $$props.theme);
	};

	$$self.$capture_state = () => ({
		makeStyleVars,
		isRegexpNotEmpty,
		_,
		tick,
		defaultString,
		defaultTheme,
		regex,
		shouldScroll,
		string,
		theme,
		splitText,
		scrollIntoView,
		style,
		parts
	});

	$$self.$inject_state = $$props => {
		if ('regex' in $$props) $$invalidate(4, regex = $$props.regex);
		if ('shouldScroll' in $$props) $$invalidate(5, shouldScroll = $$props.shouldScroll);
		if ('string' in $$props) $$invalidate(2, string = $$props.string);
		if ('theme' in $$props) $$invalidate(3, theme = $$props.theme);
		if ('style' in $$props) $$invalidate(0, style = $$props.style);
		if ('parts' in $$props) $$invalidate(1, parts = $$props.parts);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*string*/ 4) {
			$$invalidate(2, string = string || defaultString);
		}

		if ($$self.$$.dirty & /*string, regex*/ 20) {
			$$invalidate(1, parts = splitText(string, regex));
		}

		if ($$self.$$.dirty & /*theme*/ 8) {
			$$invalidate(3, theme = { ...defaultTheme, ...theme });
		}

		if ($$self.$$.dirty & /*theme*/ 8) {
			$$invalidate(0, style = makeStyleVars(theme));
		}

		if ($$self.$$.dirty & /*string, regex, shouldScroll*/ 52) {
			string && regex && shouldScroll && scrollIntoView();
		}
	};

	return [style, parts, string, theme, regex, shouldScroll];
}

class HighlightedText extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$z, create_fragment$A, safe_not_equal, {
			regex: 4,
			shouldScroll: 5,
			string: 2,
			theme: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "HighlightedText",
			options,
			id: create_fragment$A.name
		});
	}

	get regex() {
		throw new Error("<HighlightedText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set regex(value) {
		throw new Error("<HighlightedText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get shouldScroll() {
		throw new Error("<HighlightedText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set shouldScroll(value) {
		throw new Error("<HighlightedText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get string() {
		throw new Error("<HighlightedText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set string(value) {
		throw new Error("<HighlightedText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get theme() {
		throw new Error("<HighlightedText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set theme(value) {
		throw new Error("<HighlightedText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var HighlightedText$1 = HighlightedText;

/* ../../components/ui/src/Input.svelte generated by Svelte v3.59.2 */
const file$w = "../../components/ui/src/Input.svelte";

// (81:1) {#if value !== ''}
function create_if_block$k(ctx) {
	let button;
	let icon;
	let current;
	let mounted;
	let dispose;

	icon = new Icon({
			props: {
				glyph: X$1,
				size: 16,
				strokeWidth: 1,
				stroke: /*theme*/ ctx[1].colorIcon
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			button = element("button");
			create_component(icon.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { "aria-label": true, class: true });
			var button_nodes = children(button);
			claim_component(icon.$$.fragment, button_nodes);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(button, "aria-label", /*ariaLabel*/ ctx[2]);
			attr_dev(button, "class", "clickable svelte-116moha");
			add_location(button, file$w, 81, 2, 1539);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, button, anchor);
			mount_component(icon, button, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(button, "click", /*resetValue*/ ctx[10], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const icon_changes = {};
			if (dirty & /*theme*/ 2) icon_changes.stroke = /*theme*/ ctx[1].colorIcon;
			icon.$set(icon_changes);

			if (!current || dirty & /*ariaLabel*/ 4) {
				attr_dev(button, "aria-label", /*ariaLabel*/ ctx[2]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			destroy_component(icon);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$k.name,
		type: "if",
		source: "(81:1) {#if value !== ''}",
		ctx
	});

	return block;
}

function create_fragment$z(ctx) {
	let div;
	let input_1;
	let t;
	let current;
	let mounted;
	let dispose;
	let if_block = /*value*/ ctx[0] !== '' && create_if_block$k(ctx);

	const block = {
		c: function create() {
			div = element("div");
			input_1 = element("input");
			t = space();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { style: true, class: true });
			var div_nodes = children(div);

			input_1 = claim_element(div_nodes, "INPUT", {
				"aria-label": true,
				placeholder: true,
				type: true,
				class: true
			});

			t = claim_space(div_nodes);
			if (if_block) if_block.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(input_1, "aria-label", /*placeholder*/ ctx[4]);
			input_1.autofocus = /*autofocus*/ ctx[3];
			attr_dev(input_1, "placeholder", /*placeholder*/ ctx[4]);
			attr_dev(input_1, "type", /*type*/ ctx[5]);
			attr_dev(input_1, "class", "svelte-116moha");
			add_location(input_1, file$w, 71, 1, 1372);
			attr_dev(div, "style", /*style*/ ctx[7]);
			attr_dev(div, "class", "Input svelte-116moha");
			add_location(div, file$w, 66, 0, 1301);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, input_1);
			/*input_1_binding*/ ctx[11](input_1);
			append_hydration_dev(div, t);
			if (if_block) if_block.m(div, null);
			current = true;
			if (/*autofocus*/ ctx[3]) input_1.focus();

			if (!mounted) {
				dispose = [
					listen_dev(input_1, "input", /*onInput*/ ctx[8], false, false, false, false),
					listen_dev(input_1, "keypress", /*onKeyPress*/ ctx[9], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (!current || dirty & /*placeholder*/ 16) {
				attr_dev(input_1, "aria-label", /*placeholder*/ ctx[4]);
			}

			if (!current || dirty & /*autofocus*/ 8) {
				prop_dev(input_1, "autofocus", /*autofocus*/ ctx[3]);
			}

			if (!current || dirty & /*placeholder*/ 16) {
				attr_dev(input_1, "placeholder", /*placeholder*/ ctx[4]);
			}

			if (!current || dirty & /*type*/ 32) {
				attr_dev(input_1, "type", /*type*/ ctx[5]);
			}

			if (/*value*/ ctx[0] !== '') {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*value*/ 1) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$k(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div, null);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty & /*style*/ 128) {
				attr_dev(div, "style", /*style*/ ctx[7]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			/*input_1_binding*/ ctx[11](null);
			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$z.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$y($$self, $$props, $$invalidate) {
	let style;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Input', slots, []);
	let { ariaLabel = 'Clear text' } = $$props;
	let { autofocus = false } = $$props;
	let { placeholder } = $$props;
	let { type = 'text' } = $$props;
	let { value } = $$props;
	let { theme } = $$props;

	const defaultTheme = {
		backgroundColor: 'transparent',
		borderColor: 'rgb(70, 70, 70)',
		colorIcon: 'lightgrey',
		colorText: 'black',
		outline: '1px solid'
	};

	let input;
	const dispatch = createEventDispatcher();

	const onInput = event => {
		const tValue = event.target.value;

		if (value !== tValue) {
			$$invalidate(0, value = tValue);
			dispatch('changed', value);

			if (value === '') {
				dispatch('reset');
			}
		}
	};

	const onKeyPress = event => {
		if (event.keyCode === 13) {
			event.preventDefault();
			dispatch('submitted');
		}
	};

	const resetValue = () => {
		$$invalidate(6, input.value = '', input);
		$$invalidate(0, value = '');
		dispatch('reset');
	};

	onMount(() => {
		// https://github.com/sveltejs/sapper/issues/619#issuecomment-480616597
		// FIXME check with screen readers
		if (autofocus) {
			setTimeout(
				() => {
					input.focus();
				},
				100
			);
		}
	});

	$$self.$$.on_mount.push(function () {
		if (placeholder === undefined && !('placeholder' in $$props || $$self.$$.bound[$$self.$$.props['placeholder']])) {
			console.warn("<Input> was created without expected prop 'placeholder'");
		}

		if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
			console.warn("<Input> was created without expected prop 'value'");
		}

		if (theme === undefined && !('theme' in $$props || $$self.$$.bound[$$self.$$.props['theme']])) {
			console.warn("<Input> was created without expected prop 'theme'");
		}
	});

	const writable_props = ['ariaLabel', 'autofocus', 'placeholder', 'type', 'value', 'theme'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Input> was created with unknown prop '${key}'`);
	});

	function input_1_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			input = $$value;
			($$invalidate(6, input), $$invalidate(0, value));
		});
	}

	$$self.$$set = $$props => {
		if ('ariaLabel' in $$props) $$invalidate(2, ariaLabel = $$props.ariaLabel);
		if ('autofocus' in $$props) $$invalidate(3, autofocus = $$props.autofocus);
		if ('placeholder' in $$props) $$invalidate(4, placeholder = $$props.placeholder);
		if ('type' in $$props) $$invalidate(5, type = $$props.type);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('theme' in $$props) $$invalidate(1, theme = $$props.theme);
	};

	$$self.$capture_state = () => ({
		makeStyleVars,
		createEventDispatcher,
		onMount,
		Icon,
		X: X$1,
		ariaLabel,
		autofocus,
		placeholder,
		type,
		value,
		theme,
		defaultTheme,
		input,
		dispatch,
		onInput,
		onKeyPress,
		resetValue,
		style
	});

	$$self.$inject_state = $$props => {
		if ('ariaLabel' in $$props) $$invalidate(2, ariaLabel = $$props.ariaLabel);
		if ('autofocus' in $$props) $$invalidate(3, autofocus = $$props.autofocus);
		if ('placeholder' in $$props) $$invalidate(4, placeholder = $$props.placeholder);
		if ('type' in $$props) $$invalidate(5, type = $$props.type);
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('theme' in $$props) $$invalidate(1, theme = $$props.theme);
		if ('input' in $$props) $$invalidate(6, input = $$props.input);
		if ('style' in $$props) $$invalidate(7, style = $$props.style);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*theme*/ 2) {
			$$invalidate(1, theme = theme ? { ...defaultTheme, ...theme } : defaultTheme);
		}

		if ($$self.$$.dirty & /*theme*/ 2) {
			$$invalidate(7, style = makeStyleVars(theme));
		}

		if ($$self.$$.dirty & /*input, value*/ 65) {
			input && $$invalidate(6, input.value = value, input);
		}
	};

	return [
		value,
		theme,
		ariaLabel,
		autofocus,
		placeholder,
		type,
		input,
		style,
		onInput,
		onKeyPress,
		resetValue,
		input_1_binding
	];
}

class Input extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$y, create_fragment$z, safe_not_equal, {
			ariaLabel: 2,
			autofocus: 3,
			placeholder: 4,
			type: 5,
			value: 0,
			theme: 1
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Input",
			options,
			id: create_fragment$z.name
		});
	}

	get ariaLabel() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ariaLabel(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get autofocus() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set autofocus(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get placeholder() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set placeholder(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get type() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set type(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get value() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get theme() {
		throw new Error("<Input>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set theme(value) {
		throw new Error("<Input>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var Input$1 = Input;

/* ../../components/ui/src/LayoutHMF.svelte generated by Svelte v3.59.2 */

const file$v = "../../components/ui/src/LayoutHMF.svelte";
const get_footer_slot_changes = dirty => ({});
const get_footer_slot_context = ctx => ({});
const get_main_slot_changes = dirty => ({});
const get_main_slot_context = ctx => ({});
const get_header_slot_changes = dirty => ({});
const get_header_slot_context = ctx => ({});

function create_fragment$y(ctx) {
	let div;
	let header;
	let t0;
	let main;
	let t1;
	let footer;
	let current;
	const header_slot_template = /*#slots*/ ctx[3].header;
	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[2], get_header_slot_context);
	const main_slot_template = /*#slots*/ ctx[3].main;
	const main_slot = create_slot(main_slot_template, ctx, /*$$scope*/ ctx[2], get_main_slot_context);
	const footer_slot_template = /*#slots*/ ctx[3].footer;
	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[2], get_footer_slot_context);

	const block = {
		c: function create() {
			div = element("div");
			header = element("header");
			if (header_slot) header_slot.c();
			t0 = space();
			main = element("main");
			if (main_slot) main_slot.c();
			t1 = space();
			footer = element("footer");
			if (footer_slot) footer_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true, style: true });
			var div_nodes = children(div);
			header = claim_element(div_nodes, "HEADER", { class: true });
			var header_nodes = children(header);
			if (header_slot) header_slot.l(header_nodes);
			header_nodes.forEach(detach_dev);
			t0 = claim_space(div_nodes);
			main = claim_element(div_nodes, "MAIN", { class: true });
			var main_nodes = children(main);
			if (main_slot) main_slot.l(main_nodes);
			main_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			footer = claim_element(div_nodes, "FOOTER", { class: true });
			var footer_nodes = children(footer);
			if (footer_slot) footer_slot.l(footer_nodes);
			footer_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(header, "class", "svelte-1al1j4k");
			add_location(header, file$v, 6, 1, 160);
			attr_dev(main, "class", "svelte-1al1j4k");
			add_location(main, file$v, 9, 1, 206);
			attr_dev(footer, "class", "svelte-1al1j4k");
			add_location(footer, file$v, 12, 1, 246);
			attr_dev(div, "class", "LayoutHMF svelte-1al1j4k");
			attr_dev(div, "style", /*style*/ ctx[0]);
			add_location(div, file$v, 5, 0, 127);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, header);

			if (header_slot) {
				header_slot.m(header, null);
			}

			append_hydration_dev(div, t0);
			append_hydration_dev(div, main);

			if (main_slot) {
				main_slot.m(main, null);
			}

			append_hydration_dev(div, t1);
			append_hydration_dev(div, footer);

			if (footer_slot) {
				footer_slot.m(footer, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (header_slot) {
				if (header_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						header_slot,
						header_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(header_slot_template, /*$$scope*/ ctx[2], dirty, get_header_slot_changes),
						get_header_slot_context
					);
				}
			}

			if (main_slot) {
				if (main_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						main_slot,
						main_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(main_slot_template, /*$$scope*/ ctx[2], dirty, get_main_slot_changes),
						get_main_slot_context
					);
				}
			}

			if (footer_slot) {
				if (footer_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						footer_slot,
						footer_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(footer_slot_template, /*$$scope*/ ctx[2], dirty, get_footer_slot_changes),
						get_footer_slot_context
					);
				}
			}

			if (!current || dirty & /*style*/ 1) {
				attr_dev(div, "style", /*style*/ ctx[0]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(header_slot, local);
			transition_in(main_slot, local);
			transition_in(footer_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(header_slot, local);
			transition_out(main_slot, local);
			transition_out(footer_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (header_slot) header_slot.d(detaching);
			if (main_slot) main_slot.d(detaching);
			if (footer_slot) footer_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$y.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$x($$self, $$props, $$invalidate) {
	let headerPaddingTop;
	let style;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('LayoutHMF', slots, ['header','main','footer']);
	const $$slots = compute_slots(slots);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<LayoutHMF> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ headerPaddingTop, style });

	$$self.$inject_state = $$props => {
		if ('headerPaddingTop' in $$props) $$invalidate(1, headerPaddingTop = $$props.headerPaddingTop);
		if ('style' in $$props) $$invalidate(0, style = $$props.style);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*headerPaddingTop*/ 2) {
			$$invalidate(0, style = `--headerPaddingTop: ${headerPaddingTop};`);
		}
	};

	$$invalidate(1, headerPaddingTop = $$slots.header ? '1em' : 0);
	return [style, headerPaddingTop, $$scope, slots];
}

class LayoutHMF extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$x, create_fragment$y, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "LayoutHMF",
			options,
			id: create_fragment$y.name
		});
	}
}

var LayoutHMF$1 = LayoutHMF;

/* ../../components/ui/src/MultiBanner.svelte generated by Svelte v3.59.2 */
const file$u = "../../components/ui/src/MultiBanner.svelte";

// (35:0) {#if isActive}
function create_if_block$j(ctx) {
	let banner;
	let current;

	banner = new Banner$1({
			props: {
				_screen: /*_screen*/ ctx[1],
				theme: /*theme*/ ctx[3],
				$$slots: { default: [create_default_slot$3] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	banner.$on("close", /*next*/ ctx[6]);

	const block = {
		c: function create() {
			create_component(banner.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(banner.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(banner, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const banner_changes = {};
			if (dirty & /*_screen*/ 2) banner_changes._screen = /*_screen*/ ctx[1];
			if (dirty & /*theme*/ 8) banner_changes.theme = /*theme*/ ctx[3];

			if (dirty & /*$$scope, footerText, components, currentIndex*/ 277) {
				banner_changes.$$scope = { dirty, ctx };
			}

			banner.$set(banner_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(banner.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(banner.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(banner, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$j.name,
		type: "if",
		source: "(35:0) {#if isActive}",
		ctx
	});

	return block;
}

// (43:4) <Scroller>
function create_default_slot_1$2(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	var switch_value = /*components*/ ctx[2]?.[/*currentIndex*/ ctx[4]];

	function switch_props(ctx) {
		return { $$inline: true };
	}

	if (switch_value) {
		switch_instance = construct_svelte_component_dev(switch_value, switch_props());
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l: function claim(nodes) {
			if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) mount_component(switch_instance, target, anchor);
			insert_hydration_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*components, currentIndex*/ 20 && switch_value !== (switch_value = /*components*/ ctx[2]?.[/*currentIndex*/ ctx[4]])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component_dev(switch_value, switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$2.name,
		type: "slot",
		source: "(43:4) <Scroller>",
		ctx
	});

	return block;
}

// (42:3) 
function create_main_slot(ctx) {
	let div;
	let scroller;
	let current;

	scroller = new Scroller({
			props: {
				$$slots: { default: [create_default_slot_1$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			div = element("div");
			create_component(scroller.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { slot: true, class: true });
			var div_nodes = children(div);
			claim_component(scroller.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "slot", "main");
			attr_dev(div, "class", "svelte-16lglc9");
			add_location(div, file$u, 41, 3, 808);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			mount_component(scroller, div, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const scroller_changes = {};

			if (dirty & /*$$scope, components, currentIndex*/ 276) {
				scroller_changes.$$scope = { dirty, ctx };
			}

			scroller.$set(scroller_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(scroller.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(scroller.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_component(scroller);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_main_slot.name,
		type: "slot",
		source: "(42:3) ",
		ctx
	});

	return block;
}

// (47:3) 
function create_footer_slot(ctx) {
	let p;
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(/*footerText*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", { slot: true });
			var p_nodes = children(p);
			t = claim_text(p_nodes, /*footerText*/ ctx[0]);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(p, "slot", "footer");
			add_location(p, file$u, 46, 3, 930);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, p, anchor);
			append_hydration_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*footerText*/ 1) set_data_dev(t, /*footerText*/ ctx[0]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_footer_slot.name,
		type: "slot",
		source: "(47:3) ",
		ctx
	});

	return block;
}

// (36:1) <Banner   {_screen}   {theme}   on:close={next}  >
function create_default_slot$3(ctx) {
	let layouthmf;
	let current;

	layouthmf = new LayoutHMF$1({
			props: {
				$$slots: {
					footer: [create_footer_slot],
					main: [create_main_slot]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(layouthmf.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(layouthmf.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(layouthmf, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const layouthmf_changes = {};

			if (dirty & /*$$scope, footerText, components, currentIndex*/ 277) {
				layouthmf_changes.$$scope = { dirty, ctx };
			}

			layouthmf.$set(layouthmf_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(layouthmf.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(layouthmf.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(layouthmf, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$3.name,
		type: "slot",
		source: "(36:1) <Banner   {_screen}   {theme}   on:close={next}  >",
		ctx
	});

	return block;
}

function create_fragment$x(ctx) {
	let if_block_anchor;
	let current;
	let if_block = /*isActive*/ ctx[5] && create_if_block$j(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_hydration_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*isActive*/ ctx[5]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*isActive*/ 32) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$j(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$x.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const defaultFooterText = 'Click on background to dismiss';

function instance$w($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('MultiBanner', slots, []);
	let { _screen } = $$props;
	let { components } = $$props;
	let { footerText = defaultFooterText } = $$props;
	let { theme } = $$props;
	let currentIndex = 0;
	let isActive = false;

	function init() {
		$$invalidate(4, currentIndex = 0);
		$$invalidate(5, isActive = true);
	}

	function next() {
		$$invalidate(4, currentIndex++, currentIndex);

		if (currentIndex >= components.length) {
			$$invalidate(5, isActive = false);
		}
	}

	$$self.$$.on_mount.push(function () {
		if (_screen === undefined && !('_screen' in $$props || $$self.$$.bound[$$self.$$.props['_screen']])) {
			console.warn("<MultiBanner> was created without expected prop '_screen'");
		}

		if (components === undefined && !('components' in $$props || $$self.$$.bound[$$self.$$.props['components']])) {
			console.warn("<MultiBanner> was created without expected prop 'components'");
		}

		if (theme === undefined && !('theme' in $$props || $$self.$$.bound[$$self.$$.props['theme']])) {
			console.warn("<MultiBanner> was created without expected prop 'theme'");
		}
	});

	const writable_props = ['_screen', 'components', 'footerText', 'theme'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MultiBanner> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('_screen' in $$props) $$invalidate(1, _screen = $$props._screen);
		if ('components' in $$props) $$invalidate(2, components = $$props.components);
		if ('footerText' in $$props) $$invalidate(0, footerText = $$props.footerText);
		if ('theme' in $$props) $$invalidate(3, theme = $$props.theme);
	};

	$$self.$capture_state = () => ({
		Banner: Banner$1,
		LayoutHMF: LayoutHMF$1,
		Scroller,
		defaultFooterText,
		_screen,
		components,
		footerText,
		theme,
		currentIndex,
		isActive,
		init,
		next
	});

	$$self.$inject_state = $$props => {
		if ('_screen' in $$props) $$invalidate(1, _screen = $$props._screen);
		if ('components' in $$props) $$invalidate(2, components = $$props.components);
		if ('footerText' in $$props) $$invalidate(0, footerText = $$props.footerText);
		if ('theme' in $$props) $$invalidate(3, theme = $$props.theme);
		if ('currentIndex' in $$props) $$invalidate(4, currentIndex = $$props.currentIndex);
		if ('isActive' in $$props) $$invalidate(5, isActive = $$props.isActive);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*footerText*/ 1) {
			$$invalidate(0, footerText = footerText || defaultFooterText);
		}

		if ($$self.$$.dirty & /*components*/ 4) {
			components?.length > 0 && init();
		}

		if ($$self.$$.dirty & /*components*/ 4) {
			if (!components || components?.length === 0) {
				$$invalidate(5, isActive = false);
			}
		}
	};

	return [footerText, _screen, components, theme, currentIndex, isActive, next];
}

class MultiBanner extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$w, create_fragment$x, safe_not_equal, {
			_screen: 1,
			components: 2,
			footerText: 0,
			theme: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "MultiBanner",
			options,
			id: create_fragment$x.name
		});
	}

	get _screen() {
		throw new Error("<MultiBanner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set _screen(value) {
		throw new Error("<MultiBanner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get components() {
		throw new Error("<MultiBanner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set components(value) {
		throw new Error("<MultiBanner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get footerText() {
		throw new Error("<MultiBanner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set footerText(value) {
		throw new Error("<MultiBanner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get theme() {
		throw new Error("<MultiBanner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set theme(value) {
		throw new Error("<MultiBanner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var MultiBanner$1 = MultiBanner;

/* ../../components/ui/src/Pill.svelte generated by Svelte v3.59.2 */
const file$t = "../../components/ui/src/Pill.svelte";

function create_fragment$w(ctx) {
	let div;
	let span;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			t = text(/*label*/ ctx[2]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true, style: true });
			var div_nodes = children(div);
			span = claim_element(div_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, /*label*/ ctx[2]);
			span_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "label svelte-18qvzzt");
			toggle_class(span, "bold", /*isBold*/ ctx[1]);
			toggle_class(span, "nowrap", /*nowrap*/ ctx[0]);
			add_location(span, file$t, 24, 1, 437);
			attr_dev(div, "class", "Pill svelte-18qvzzt");
			attr_dev(div, "style", /*style*/ ctx[3]);
			add_location(div, file$t, 20, 0, 406);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, span);
			append_hydration_dev(span, t);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*label*/ 4) set_data_dev(t, /*label*/ ctx[2]);

			if (dirty & /*isBold*/ 2) {
				toggle_class(span, "bold", /*isBold*/ ctx[1]);
			}

			if (dirty & /*nowrap*/ 1) {
				toggle_class(span, "nowrap", /*nowrap*/ ctx[0]);
			}

			if (dirty & /*style*/ 8) {
				attr_dev(div, "style", /*style*/ ctx[3]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$w.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$v($$self, $$props, $$invalidate) {
	let style;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Pill', slots, []);
	let { isBold } = $$props;
	let { label = null } = $$props;
	let { nowrap } = $$props;
	let { theme } = $$props;

	const defaultTheme = {
		backgroundColor: 'white',
		border: 'thin solid black',
		fontSize: '1em',
		textColor: 'black'
	};

	$$self.$$.on_mount.push(function () {
		if (isBold === undefined && !('isBold' in $$props || $$self.$$.bound[$$self.$$.props['isBold']])) {
			console.warn("<Pill> was created without expected prop 'isBold'");
		}

		if (nowrap === undefined && !('nowrap' in $$props || $$self.$$.bound[$$self.$$.props['nowrap']])) {
			console.warn("<Pill> was created without expected prop 'nowrap'");
		}

		if (theme === undefined && !('theme' in $$props || $$self.$$.bound[$$self.$$.props['theme']])) {
			console.warn("<Pill> was created without expected prop 'theme'");
		}
	});

	const writable_props = ['isBold', 'label', 'nowrap', 'theme'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Pill> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('isBold' in $$props) $$invalidate(1, isBold = $$props.isBold);
		if ('label' in $$props) $$invalidate(2, label = $$props.label);
		if ('nowrap' in $$props) $$invalidate(0, nowrap = $$props.nowrap);
		if ('theme' in $$props) $$invalidate(4, theme = $$props.theme);
	};

	$$self.$capture_state = () => ({
		makeStyleVars,
		isBold,
		label,
		nowrap,
		theme,
		defaultTheme,
		style
	});

	$$self.$inject_state = $$props => {
		if ('isBold' in $$props) $$invalidate(1, isBold = $$props.isBold);
		if ('label' in $$props) $$invalidate(2, label = $$props.label);
		if ('nowrap' in $$props) $$invalidate(0, nowrap = $$props.nowrap);
		if ('theme' in $$props) $$invalidate(4, theme = $$props.theme);
		if ('style' in $$props) $$invalidate(3, style = $$props.style);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*nowrap*/ 1) {
			$$invalidate(0, nowrap = nowrap ?? true);
		}

		if ($$self.$$.dirty & /*theme*/ 16) {
			$$invalidate(4, theme = theme ? { ...defaultTheme, ...theme } : defaultTheme);
		}

		if ($$self.$$.dirty & /*theme*/ 16) {
			$$invalidate(3, style = makeStyleVars(theme));
		}
	};

	return [nowrap, isBold, label, style, theme];
}

class Pill extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$v, create_fragment$w, safe_not_equal, { isBold: 1, label: 2, nowrap: 0, theme: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Pill",
			options,
			id: create_fragment$w.name
		});
	}

	get isBold() {
		throw new Error("<Pill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isBold(value) {
		throw new Error("<Pill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<Pill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<Pill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nowrap() {
		throw new Error("<Pill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nowrap(value) {
		throw new Error("<Pill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get theme() {
		throw new Error("<Pill>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set theme(value) {
		throw new Error("<Pill>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var Pill$1 = Pill;

/* ../../components/ui/src/ResponsiveButton.svelte generated by Svelte v3.59.2 */
const file$s = "../../components/ui/src/ResponsiveButton.svelte";
const get_always_slot_changes_1 = dirty => ({});
const get_always_slot_context_1 = ctx => ({});
const get_optional_slot_changes_1 = dirty => ({});
const get_optional_slot_context_1 = ctx => ({});
const get_always_slot_changes = dirty => ({});
const get_always_slot_context = ctx => ({});
const get_optional_slot_changes = dirty => ({});
const get_optional_slot_context = ctx => ({});

// (52:2) {#if !doesOverflow && !isOptionalHidden}
function create_if_block$i(ctx) {
	let current;
	const optional_slot_template = /*#slots*/ ctx[13].optional;
	const optional_slot = create_slot(optional_slot_template, ctx, /*$$scope*/ ctx[12], get_optional_slot_context);

	const block = {
		c: function create() {
			if (optional_slot) optional_slot.c();
		},
		l: function claim(nodes) {
			if (optional_slot) optional_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (optional_slot) {
				optional_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (optional_slot) {
				if (optional_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot_base(
						optional_slot,
						optional_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(optional_slot_template, /*$$scope*/ ctx[12], dirty, get_optional_slot_changes),
						get_optional_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(optional_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(optional_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (optional_slot) optional_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$i.name,
		type: "if",
		source: "(52:2) {#if !doesOverflow && !isOptionalHidden}",
		ctx
	});

	return block;
}

function create_fragment$v(ctx) {
	let button;
	let div0;
	let t0;
	let t1;
	let div1;
	let t2;
	let current;
	let mounted;
	let dispose;
	let if_block = !/*doesOverflow*/ ctx[0] && !/*isOptionalHidden*/ ctx[2] && create_if_block$i(ctx);
	const always_slot_template = /*#slots*/ ctx[13].always;
	const always_slot = create_slot(always_slot_template, ctx, /*$$scope*/ ctx[12], get_always_slot_context);
	const optional_slot_template = /*#slots*/ ctx[13].optional;
	const optional_slot = create_slot(optional_slot_template, ctx, /*$$scope*/ ctx[12], get_optional_slot_context_1);
	const always_slot_template_1 = /*#slots*/ ctx[13].always;
	const always_slot_1 = create_slot(always_slot_template_1, ctx, /*$$scope*/ ctx[12], get_always_slot_context_1);

	const block = {
		c: function create() {
			button = element("button");
			div0 = element("div");
			if (if_block) if_block.c();
			t0 = space();
			if (always_slot) always_slot.c();
			t1 = space();
			div1 = element("div");
			if (optional_slot) optional_slot.c();
			t2 = space();
			if (always_slot_1) always_slot_1.c();
			this.h();
		},
		l: function claim(nodes) {
			button = claim_element(nodes, "BUTTON", { style: true, title: true, class: true });
			var button_nodes = children(button);
			div0 = claim_element(button_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (if_block) if_block.l(div0_nodes);
			t0 = claim_space(div0_nodes);
			if (always_slot) always_slot.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			button_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			div1 = claim_element(nodes, "DIV", { class: true, role: true });
			var div1_nodes = children(div1);
			if (optional_slot) optional_slot.l(div1_nodes);
			t2 = claim_space(div1_nodes);
			if (always_slot_1) always_slot_1.l(div1_nodes);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "content svelte-sacwwa");
			add_location(div0, file$s, 47, 1, 1006);
			attr_dev(button, "style", /*style*/ ctx[4]);
			attr_dev(button, "title", /*title*/ ctx[3]);
			attr_dev(button, "class", "ResponsiveButton nowrap svelte-sacwwa");
			toggle_class(button, "active", /*isActive*/ ctx[1]);
			add_location(button, file$s, 40, 0, 909);
			attr_dev(div1, "class", "ResponsiveButtonSensor nowrap svelte-sacwwa");
			attr_dev(div1, "role", "none");
			add_location(div1, file$s, 58, 0, 1181);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, button, anchor);
			append_hydration_dev(button, div0);
			if (if_block) if_block.m(div0, null);
			append_hydration_dev(div0, t0);

			if (always_slot) {
				always_slot.m(div0, null);
			}

			insert_hydration_dev(target, t1, anchor);
			insert_hydration_dev(target, div1, anchor);

			if (optional_slot) {
				optional_slot.m(div1, null);
			}

			append_hydration_dev(div1, t2);

			if (always_slot_1) {
				always_slot_1.m(div1, null);
			}

			current = true;

			if (!mounted) {
				dispose = [
					action_destroyer(/*contentSizeObserver*/ ctx[6].call(null, div0)),
					listen_dev(button, "click", /*click_handler*/ ctx[14], false, false, false, false),
					action_destroyer(/*sensorSizeObserver*/ ctx[8].call(null, div1))
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (!/*doesOverflow*/ ctx[0] && !/*isOptionalHidden*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty & /*doesOverflow, isOptionalHidden*/ 5) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block$i(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(div0, t0);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (always_slot) {
				if (always_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot_base(
						always_slot,
						always_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(always_slot_template, /*$$scope*/ ctx[12], dirty, get_always_slot_changes),
						get_always_slot_context
					);
				}
			}

			if (!current || dirty & /*style*/ 16) {
				attr_dev(button, "style", /*style*/ ctx[4]);
			}

			if (!current || dirty & /*title*/ 8) {
				attr_dev(button, "title", /*title*/ ctx[3]);
			}

			if (!current || dirty & /*isActive*/ 2) {
				toggle_class(button, "active", /*isActive*/ ctx[1]);
			}

			if (optional_slot) {
				if (optional_slot.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot_base(
						optional_slot,
						optional_slot_template,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(optional_slot_template, /*$$scope*/ ctx[12], dirty, get_optional_slot_changes_1),
						get_optional_slot_context_1
					);
				}
			}

			if (always_slot_1) {
				if (always_slot_1.p && (!current || dirty & /*$$scope*/ 4096)) {
					update_slot_base(
						always_slot_1,
						always_slot_template_1,
						ctx,
						/*$$scope*/ ctx[12],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[12])
						: get_slot_changes(always_slot_template_1, /*$$scope*/ ctx[12], dirty, get_always_slot_changes_1),
						get_always_slot_context_1
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			transition_in(always_slot, local);
			transition_in(optional_slot, local);
			transition_in(always_slot_1, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			transition_out(always_slot, local);
			transition_out(optional_slot, local);
			transition_out(always_slot_1, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(button);
			if (if_block) if_block.d();
			if (always_slot) always_slot.d(detaching);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div1);
			if (optional_slot) optional_slot.d(detaching);
			if (always_slot_1) always_slot_1.d(detaching);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$v.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$u($$self, $$props, $$invalidate) {
	let style;
	let $_sensorSize;
	let $_contentSize;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ResponsiveButton', slots, ['optional','always']);
	const { _writable: _contentSize, resizeObserver: contentSizeObserver } = setupResizeObserver();
	validate_store(_contentSize, '_contentSize');
	component_subscribe($$self, _contentSize, value => $$invalidate(11, $_contentSize = value));
	const { _writable: _sensorSize, resizeObserver: sensorSizeObserver } = setupResizeObserver();
	validate_store(_sensorSize, '_sensorSize');
	component_subscribe($$self, _sensorSize, value => $$invalidate(10, $_sensorSize = value));
	let { doesOverflow } = $$props;
	let { isActive } = $$props;
	let { isOptionalHidden } = $$props;
	let { title = '' } = $$props;
	let { theme } = $$props;

	const defaultTheme = {
		borderBottom: 'none',
		borderLeft: 'none',
		borderRight: 'none',
		borderTop: 'none',
		colorBackground: 'initial',
		colorBackgroundActive: '#333',
		colorText: 'initial',
		colorTextActive: 'white',
		outlineColor: 'black',
		outlineStyle: 'auto',
		outlineWidth: '2px'
	};

	$$self.$$.on_mount.push(function () {
		if (doesOverflow === undefined && !('doesOverflow' in $$props || $$self.$$.bound[$$self.$$.props['doesOverflow']])) {
			console.warn("<ResponsiveButton> was created without expected prop 'doesOverflow'");
		}

		if (isActive === undefined && !('isActive' in $$props || $$self.$$.bound[$$self.$$.props['isActive']])) {
			console.warn("<ResponsiveButton> was created without expected prop 'isActive'");
		}

		if (isOptionalHidden === undefined && !('isOptionalHidden' in $$props || $$self.$$.bound[$$self.$$.props['isOptionalHidden']])) {
			console.warn("<ResponsiveButton> was created without expected prop 'isOptionalHidden'");
		}

		if (theme === undefined && !('theme' in $$props || $$self.$$.bound[$$self.$$.props['theme']])) {
			console.warn("<ResponsiveButton> was created without expected prop 'theme'");
		}
	});

	const writable_props = ['doesOverflow', 'isActive', 'isOptionalHidden', 'title', 'theme'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ResponsiveButton> was created with unknown prop '${key}'`);
	});

	function click_handler(event) {
		bubble.call(this, $$self, event);
	}

	$$self.$$set = $$props => {
		if ('doesOverflow' in $$props) $$invalidate(0, doesOverflow = $$props.doesOverflow);
		if ('isActive' in $$props) $$invalidate(1, isActive = $$props.isActive);
		if ('isOptionalHidden' in $$props) $$invalidate(2, isOptionalHidden = $$props.isOptionalHidden);
		if ('title' in $$props) $$invalidate(3, title = $$props.title);
		if ('theme' in $$props) $$invalidate(9, theme = $$props.theme);
		if ('$$scope' in $$props) $$invalidate(12, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		makeStyleVars,
		setupResizeObserver,
		_contentSize,
		contentSizeObserver,
		_sensorSize,
		sensorSizeObserver,
		doesOverflow,
		isActive,
		isOptionalHidden,
		title,
		theme,
		defaultTheme,
		style,
		$_sensorSize,
		$_contentSize
	});

	$$self.$inject_state = $$props => {
		if ('doesOverflow' in $$props) $$invalidate(0, doesOverflow = $$props.doesOverflow);
		if ('isActive' in $$props) $$invalidate(1, isActive = $$props.isActive);
		if ('isOptionalHidden' in $$props) $$invalidate(2, isOptionalHidden = $$props.isOptionalHidden);
		if ('title' in $$props) $$invalidate(3, title = $$props.title);
		if ('theme' in $$props) $$invalidate(9, theme = $$props.theme);
		if ('style' in $$props) $$invalidate(4, style = $$props.style);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*$_contentSize, $_sensorSize*/ 3072) {
			$$invalidate(0, doesOverflow = $_contentSize.inlineSize < $_sensorSize.inlineSize);
		}

		if ($$self.$$.dirty & /*theme*/ 512) {
			$$invalidate(9, theme = { ...defaultTheme, ...theme });
		}

		if ($$self.$$.dirty & /*theme*/ 512) {
			$$invalidate(4, style = makeStyleVars(theme));
		}
	};

	return [
		doesOverflow,
		isActive,
		isOptionalHidden,
		title,
		style,
		_contentSize,
		contentSizeObserver,
		_sensorSize,
		sensorSizeObserver,
		theme,
		$_sensorSize,
		$_contentSize,
		$$scope,
		slots,
		click_handler
	];
}

class ResponsiveButton extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$u, create_fragment$v, safe_not_equal, {
			doesOverflow: 0,
			isActive: 1,
			isOptionalHidden: 2,
			title: 3,
			theme: 9
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ResponsiveButton",
			options,
			id: create_fragment$v.name
		});
	}

	get doesOverflow() {
		throw new Error("<ResponsiveButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set doesOverflow(value) {
		throw new Error("<ResponsiveButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isActive() {
		throw new Error("<ResponsiveButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isActive(value) {
		throw new Error("<ResponsiveButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isOptionalHidden() {
		throw new Error("<ResponsiveButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isOptionalHidden(value) {
		throw new Error("<ResponsiveButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<ResponsiveButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<ResponsiveButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get theme() {
		throw new Error("<ResponsiveButton>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set theme(value) {
		throw new Error("<ResponsiveButton>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var ResponsiveButton$1 = ResponsiveButton;

/* ../../components/ui/src/ResponsiveFlex.svelte generated by Svelte v3.59.2 */
const file$r = "../../components/ui/src/ResponsiveFlex.svelte";

function create_fragment$u(ctx) {
	let div;
	let div_class_value;
	let current;
	const default_slot_template = /*#slots*/ ctx[2].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

	const block = {
		c: function create() {
			div = element("div");
			if (default_slot) default_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			if (default_slot) default_slot.l(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", div_class_value = "ResponsiveFlex " + /*$_screen*/ ctx[0]?.classes + " svelte-1tya6p1");
			add_location(div, file$r, 4, 0, 83);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);

			if (default_slot) {
				default_slot.m(div, null);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 2)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[1],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[1])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[1], dirty, null),
						null
					);
				}
			}

			if (!current || dirty & /*$_screen*/ 1 && div_class_value !== (div_class_value = "ResponsiveFlex " + /*$_screen*/ ctx[0]?.classes + " svelte-1tya6p1")) {
				attr_dev(div, "class", div_class_value);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$u.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$t($$self, $$props, $$invalidate) {
	let $_screen;
	validate_store(_screen, '_screen');
	component_subscribe($$self, _screen, $$value => $$invalidate(0, $_screen = $$value));
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ResponsiveFlex', slots, ['default']);
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ResponsiveFlex> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(1, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ _screen, $_screen });
	return [$_screen, $$scope, slots];
}

class ResponsiveFlex extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$t, create_fragment$u, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ResponsiveFlex",
			options,
			id: create_fragment$u.name
		});
	}
}

var ResponsiveFlex$1 = ResponsiveFlex;

/* ../../components/ui/src/ScrollbarStyler.svelte generated by Svelte v3.59.2 */
const file$q = "../../components/ui/src/ScrollbarStyler.svelte";

function create_fragment$t(ctx) {
	let div;

	const block = {
		c: function create() {
			div = element("div");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			children(div).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", "svelte-t9pxmr");
			add_location(div, file$q, 36, 0, 964);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
		},
		p: noop,
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$t.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$s($$self, $$props, $$invalidate) {
	let rootElement;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ScrollbarStyler', slots, []);
	let { isEnabled = true } = $$props;
	let { theme } = $$props;

	let { defaultTheme = {
		thumbColor: 'grey',
		thumbRadius: '50px',
		trackBorderColor: 'lightgrey',
		trackColor: 'rgb(250,250,250)',
		trackWidth: '9px'
	} } = $$props;

	// eslint-disable-next-line no-undef
	const getRootElement = () => globalThis.document?.documentElement;

	const getClassList = () => getRootElement()?.classList;
	const enableStyle = () => getClassList()?.add('styledScrollbar');
	const disableStyle = () => getClassList()?.remove('styledScrollbar');
	onDestroy(disableStyle);

	$$self.$$.on_mount.push(function () {
		if (theme === undefined && !('theme' in $$props || $$self.$$.bound[$$self.$$.props['theme']])) {
			console.warn("<ScrollbarStyler> was created without expected prop 'theme'");
		}
	});

	const writable_props = ['isEnabled', 'theme', 'defaultTheme'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ScrollbarStyler> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('isEnabled' in $$props) $$invalidate(0, isEnabled = $$props.isEnabled);
		if ('theme' in $$props) $$invalidate(1, theme = $$props.theme);
		if ('defaultTheme' in $$props) $$invalidate(2, defaultTheme = $$props.defaultTheme);
	};

	$$self.$capture_state = () => ({
		makeStyleVars,
		onDestroy,
		isClientSide,
		isEnabled,
		theme,
		defaultTheme,
		getRootElement,
		getClassList,
		enableStyle,
		disableStyle,
		rootElement
	});

	$$self.$inject_state = $$props => {
		if ('isEnabled' in $$props) $$invalidate(0, isEnabled = $$props.isEnabled);
		if ('theme' in $$props) $$invalidate(1, theme = $$props.theme);
		if ('defaultTheme' in $$props) $$invalidate(2, defaultTheme = $$props.defaultTheme);
		if ('rootElement' in $$props) $$invalidate(3, rootElement = $$props.rootElement);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*isEnabled*/ 1) {
			$$invalidate(0, isEnabled = isEnabled ?? true);
		}

		if ($$self.$$.dirty & /*isEnabled*/ 1) {
			isClientSide && isEnabled
			? enableStyle()
			: disableStyle();
		}

		if ($$self.$$.dirty & /*theme, defaultTheme*/ 6) {
			$$invalidate(1, theme = theme ? { ...defaultTheme, ...theme } : defaultTheme);
		}

		if ($$self.$$.dirty & /*rootElement, theme*/ 10) {
			if (rootElement) {
				$$invalidate(3, rootElement.style = makeStyleVars(theme), rootElement);
			}
		}
	};

	$$invalidate(3, rootElement = getRootElement());
	return [isEnabled, theme, defaultTheme, rootElement];
}

class ScrollbarStyler extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$s, create_fragment$t, safe_not_equal, { isEnabled: 0, theme: 1, defaultTheme: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ScrollbarStyler",
			options,
			id: create_fragment$t.name
		});
	}

	get isEnabled() {
		throw new Error("<ScrollbarStyler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isEnabled(value) {
		throw new Error("<ScrollbarStyler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get theme() {
		throw new Error("<ScrollbarStyler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set theme(value) {
		throw new Error("<ScrollbarStyler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get defaultTheme() {
		throw new Error("<ScrollbarStyler>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set defaultTheme(value) {
		throw new Error("<ScrollbarStyler>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var ScrollbarStyler$1 = ScrollbarStyler;

/* ../../components/ui/src/XorNavigator.svelte generated by Svelte v3.59.2 */
const file$p = "../../components/ui/src/XorNavigator.svelte";

// (59:1) {#if label}
function create_if_block$h(ctx) {
	let div;
	let t;

	const block = {
		c: function create() {
			div = element("div");
			t = text(/*label*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", {});
			var div_nodes = children(div);
			t = claim_text(div_nodes, /*label*/ ctx[0]);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(div, file$p, 59, 2, 1732);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*label*/ 1) set_data_dev(t, /*label*/ ctx[0]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$h.name,
		type: "if",
		source: "(59:1) {#if label}",
		ctx
	});

	return block;
}

function create_fragment$s(ctx) {
	let div2;
	let t0;
	let div1;
	let div0;
	let t1;
	let t2;
	let button0;
	let icon0;
	let button0_disabled_value;
	let t3;
	let button1;
	let icon1;
	let button1_disabled_value;
	let div1_resize_listener;
	let current;
	let mounted;
	let dispose;
	let if_block = /*label*/ ctx[0] && create_if_block$h(ctx);

	icon0 = new Icon({
			props: { glyph: ChevronLeft },
			$$inline: true
		});

	icon1 = new Icon({
			props: { glyph: ChevronRight },
			$$inline: true
		});

	const block = {
		c: function create() {
			div2 = element("div");
			if (if_block) if_block.c();
			t0 = space();
			div1 = element("div");
			div0 = element("div");
			t1 = text(/*currentLabel*/ ctx[8]);
			t2 = space();
			button0 = element("button");
			create_component(icon0.$$.fragment);
			t3 = space();
			button1 = element("button");
			create_component(icon1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div2 = claim_element(nodes, "DIV", { style: true, class: true });
			var div2_nodes = children(div2);
			if (if_block) if_block.l(div2_nodes);
			t0 = claim_space(div2_nodes);
			div1 = claim_element(div2_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t1 = claim_text(div0_nodes, /*currentLabel*/ ctx[8]);
			div0_nodes.forEach(detach_dev);
			t2 = claim_space(div1_nodes);
			button0 = claim_element(div1_nodes, "BUTTON", { "aria-label": true, class: true });
			var button0_nodes = children(button0);
			claim_component(icon0.$$.fragment, button0_nodes);
			button0_nodes.forEach(detach_dev);
			t3 = claim_space(div1_nodes);
			button1 = claim_element(div1_nodes, "BUTTON", { "aria-label": true, class: true });
			var button1_nodes = children(button1);
			claim_component(icon1.$$.fragment, button1_nodes);
			button1_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			div2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "currentLabel svelte-1e6j4ud");
			add_location(div0, file$p, 65, 2, 1818);
			attr_dev(button0, "aria-label", "Previous value");
			attr_dev(button0, "class", "prev svelte-1e6j4ud");
			button0.disabled = button0_disabled_value = !/*hasPrevValue*/ ctx[3];
			toggle_class(button0, "clickable", /*hasPrevValue*/ ctx[3]);
			add_location(button0, file$p, 66, 2, 1867);
			attr_dev(button1, "aria-label", "Next value");
			attr_dev(button1, "class", "next svelte-1e6j4ud");
			button1.disabled = button1_disabled_value = !/*hasNextValue*/ ctx[2];
			toggle_class(button1, "clickable", /*hasNextValue*/ ctx[2]);
			add_location(button1, file$p, 76, 2, 2090);
			attr_dev(div1, "class", "navigator svelte-1e6j4ud");
			add_render_callback(() => /*div1_elementresize_handler*/ ctx[17].call(div1));
			add_location(div1, file$p, 61, 1, 1759);
			attr_dev(div2, "style", /*style*/ ctx[9]);
			attr_dev(div2, "class", "XorNavigator svelte-1e6j4ud");
			add_location(div2, file$p, 54, 0, 1679);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div2, anchor);
			if (if_block) if_block.m(div2, null);
			append_hydration_dev(div2, t0);
			append_hydration_dev(div2, div1);
			append_hydration_dev(div1, div0);
			append_hydration_dev(div0, t1);
			append_hydration_dev(div1, t2);
			append_hydration_dev(div1, button0);
			mount_component(icon0, button0, null);
			append_hydration_dev(div1, t3);
			append_hydration_dev(div1, button1);
			mount_component(icon1, button1, null);
			div1_resize_listener = add_iframe_resize_listener(div1, /*div1_elementresize_handler*/ ctx[17].bind(div1));
			current = true;

			if (!mounted) {
				dispose = [
					listen_dev(
						button0,
						"click",
						function () {
							if (is_function(/*clickedPrev*/ ctx[7])) /*clickedPrev*/ ctx[7].apply(this, arguments);
						},
						false,
						false,
						false,
						false
					),
					listen_dev(
						button0,
						"keydown",
						function () {
							if (is_function(/*onKeyDownPrev*/ ctx[5])) /*onKeyDownPrev*/ ctx[5].apply(this, arguments);
						},
						false,
						false,
						false,
						false
					),
					listen_dev(
						button1,
						"click",
						function () {
							if (is_function(/*clickedNext*/ ctx[6])) /*clickedNext*/ ctx[6].apply(this, arguments);
						},
						false,
						false,
						false,
						false
					),
					listen_dev(
						button1,
						"keydown",
						function () {
							if (is_function(/*onKeyDownNext*/ ctx[4])) /*onKeyDownNext*/ ctx[4].apply(this, arguments);
						},
						false,
						false,
						false,
						false
					)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, [dirty]) {
			ctx = new_ctx;

			if (/*label*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$h(ctx);
					if_block.c();
					if_block.m(div2, t0);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (!current || dirty & /*currentLabel*/ 256) set_data_dev(t1, /*currentLabel*/ ctx[8]);

			if (!current || dirty & /*hasPrevValue*/ 8 && button0_disabled_value !== (button0_disabled_value = !/*hasPrevValue*/ ctx[3])) {
				prop_dev(button0, "disabled", button0_disabled_value);
			}

			if (!current || dirty & /*hasPrevValue*/ 8) {
				toggle_class(button0, "clickable", /*hasPrevValue*/ ctx[3]);
			}

			if (!current || dirty & /*hasNextValue*/ 4 && button1_disabled_value !== (button1_disabled_value = !/*hasNextValue*/ ctx[2])) {
				prop_dev(button1, "disabled", button1_disabled_value);
			}

			if (!current || dirty & /*hasNextValue*/ 4) {
				toggle_class(button1, "clickable", /*hasNextValue*/ ctx[2]);
			}

			if (!current || dirty & /*style*/ 512) {
				attr_dev(div2, "style", /*style*/ ctx[9]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(icon0.$$.fragment, local);
			transition_in(icon1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(icon0.$$.fragment, local);
			transition_out(icon1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div2);
			if (if_block) if_block.d();
			destroy_component(icon0);
			destroy_component(icon1);
			div1_resize_listener();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$s.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$r($$self, $$props, $$invalidate) {
	let style;
	let values;
	let currentLabel;
	let currentValueIndex;
	let prevValue;
	let nextValue;
	let hasPrevValue;
	let hasNextValue;
	let clickedPrev;
	let clickedNext;
	let onKeyDownPrev;
	let onKeyDownNext;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('XorNavigator', slots, []);
	let { currentValue } = $$props;
	let { label = null } = $$props;
	let { theme } = $$props;
	let { valuesToLabels } = $$props;

	const defaultTheme = {
		border: 'solid 1px black',
		colorBackground: 'white',
		colorIcon: 'black',
		colorIconDisabled: 'grey',
		textColor: 'black',
		outlineColor: 'black',
		outlineStyle: 'solid',
		outlineWidth: '1px'
	};

	const dispatch = createEventDispatcher();

	const updateValue = val => {
		$$invalidate(10, currentValue = val);
		dispatch('changed', val);
	};

	const onKeyDown = (event, val) => {
		if (event.key === 'Enter') {
			event.preventDefault();
			updateValue(val);
		}
	};

	let height;

	$$self.$$.on_mount.push(function () {
		if (currentValue === undefined && !('currentValue' in $$props || $$self.$$.bound[$$self.$$.props['currentValue']])) {
			console.warn("<XorNavigator> was created without expected prop 'currentValue'");
		}

		if (theme === undefined && !('theme' in $$props || $$self.$$.bound[$$self.$$.props['theme']])) {
			console.warn("<XorNavigator> was created without expected prop 'theme'");
		}

		if (valuesToLabels === undefined && !('valuesToLabels' in $$props || $$self.$$.bound[$$self.$$.props['valuesToLabels']])) {
			console.warn("<XorNavigator> was created without expected prop 'valuesToLabels'");
		}
	});

	const writable_props = ['currentValue', 'label', 'theme', 'valuesToLabels'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<XorNavigator> was created with unknown prop '${key}'`);
	});

	function div1_elementresize_handler() {
		height = this.offsetHeight;
		$$invalidate(1, height);
	}

	$$self.$$set = $$props => {
		if ('currentValue' in $$props) $$invalidate(10, currentValue = $$props.currentValue);
		if ('label' in $$props) $$invalidate(0, label = $$props.label);
		if ('theme' in $$props) $$invalidate(11, theme = $$props.theme);
		if ('valuesToLabels' in $$props) $$invalidate(12, valuesToLabels = $$props.valuesToLabels);
	};

	$$self.$capture_state = () => ({
		makeStyleVars,
		toPx,
		isNotNil,
		_,
		createEventDispatcher,
		ChevronLeft,
		ChevronRight,
		Icon,
		currentValue,
		label,
		theme,
		valuesToLabels,
		defaultTheme,
		dispatch,
		updateValue,
		onKeyDown,
		height,
		nextValue,
		hasNextValue,
		onKeyDownNext,
		prevValue,
		hasPrevValue,
		onKeyDownPrev,
		clickedNext,
		clickedPrev,
		currentValueIndex,
		values,
		currentLabel,
		style
	});

	$$self.$inject_state = $$props => {
		if ('currentValue' in $$props) $$invalidate(10, currentValue = $$props.currentValue);
		if ('label' in $$props) $$invalidate(0, label = $$props.label);
		if ('theme' in $$props) $$invalidate(11, theme = $$props.theme);
		if ('valuesToLabels' in $$props) $$invalidate(12, valuesToLabels = $$props.valuesToLabels);
		if ('height' in $$props) $$invalidate(1, height = $$props.height);
		if ('nextValue' in $$props) $$invalidate(13, nextValue = $$props.nextValue);
		if ('hasNextValue' in $$props) $$invalidate(2, hasNextValue = $$props.hasNextValue);
		if ('onKeyDownNext' in $$props) $$invalidate(4, onKeyDownNext = $$props.onKeyDownNext);
		if ('prevValue' in $$props) $$invalidate(14, prevValue = $$props.prevValue);
		if ('hasPrevValue' in $$props) $$invalidate(3, hasPrevValue = $$props.hasPrevValue);
		if ('onKeyDownPrev' in $$props) $$invalidate(5, onKeyDownPrev = $$props.onKeyDownPrev);
		if ('clickedNext' in $$props) $$invalidate(6, clickedNext = $$props.clickedNext);
		if ('clickedPrev' in $$props) $$invalidate(7, clickedPrev = $$props.clickedPrev);
		if ('currentValueIndex' in $$props) $$invalidate(15, currentValueIndex = $$props.currentValueIndex);
		if ('values' in $$props) $$invalidate(16, values = $$props.values);
		if ('currentLabel' in $$props) $$invalidate(8, currentLabel = $$props.currentLabel);
		if ('style' in $$props) $$invalidate(9, style = $$props.style);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*theme*/ 2048) {
			$$invalidate(11, theme = theme ? { ...defaultTheme, ...theme } : defaultTheme);
		}

		if ($$self.$$.dirty & /*theme, height*/ 2050) {
			$$invalidate(9, style = makeStyleVars({ ...theme, height: toPx(height) }));
		}

		if ($$self.$$.dirty & /*valuesToLabels*/ 4096) {
			$$invalidate(16, values = keys(valuesToLabels));
		}

		if ($$self.$$.dirty & /*valuesToLabels, currentValue*/ 5120) {
			$$invalidate(8, currentLabel = valuesToLabels[currentValue]);
		}

		if ($$self.$$.dirty & /*values, currentValue*/ 66560) {
			$$invalidate(15, currentValueIndex = findIndex(values, is(currentValue)));
		}

		if ($$self.$$.dirty & /*values, currentValueIndex*/ 98304) {
			$$invalidate(14, prevValue = values[currentValueIndex - 1]);
		}

		if ($$self.$$.dirty & /*values, currentValueIndex*/ 98304) {
			$$invalidate(13, nextValue = values[currentValueIndex + 1]);
		}

		if ($$self.$$.dirty & /*prevValue*/ 16384) {
			$$invalidate(3, hasPrevValue = isNotNil(prevValue));
		}

		if ($$self.$$.dirty & /*nextValue*/ 8192) {
			$$invalidate(2, hasNextValue = isNotNil(nextValue));
		}

		if ($$self.$$.dirty & /*hasPrevValue, prevValue*/ 16392) {
			$$invalidate(7, clickedPrev = () => hasPrevValue && updateValue(prevValue));
		}

		if ($$self.$$.dirty & /*hasNextValue, nextValue*/ 8196) {
			$$invalidate(6, clickedNext = () => hasNextValue && updateValue(nextValue));
		}

		if ($$self.$$.dirty & /*hasPrevValue, prevValue*/ 16392) {
			$$invalidate(5, onKeyDownPrev = event => hasPrevValue && onKeyDown(event, prevValue));
		}

		if ($$self.$$.dirty & /*hasNextValue, nextValue*/ 8196) {
			$$invalidate(4, onKeyDownNext = event => hasNextValue && onKeyDown(event, nextValue));
		}
	};

	return [
		label,
		height,
		hasNextValue,
		hasPrevValue,
		onKeyDownNext,
		onKeyDownPrev,
		clickedNext,
		clickedPrev,
		currentLabel,
		style,
		currentValue,
		theme,
		valuesToLabels,
		nextValue,
		prevValue,
		currentValueIndex,
		values,
		div1_elementresize_handler
	];
}

class XorNavigator extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$r, create_fragment$s, safe_not_equal, {
			currentValue: 10,
			label: 0,
			theme: 11,
			valuesToLabels: 12
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "XorNavigator",
			options,
			id: create_fragment$s.name
		});
	}

	get currentValue() {
		throw new Error("<XorNavigator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set currentValue(value) {
		throw new Error("<XorNavigator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<XorNavigator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<XorNavigator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get theme() {
		throw new Error("<XorNavigator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set theme(value) {
		throw new Error("<XorNavigator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get valuesToLabels() {
		throw new Error("<XorNavigator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set valuesToLabels(value) {
		throw new Error("<XorNavigator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var XorNavigator$1 = XorNavigator;

var ui = /*#__PURE__*/Object.freeze({
	__proto__: null,
	StyleDriver: StyleDriver$1,
	StorageIO: StorageIO,
	AlphabetPicker: AlphabetPicker,
	Banner: Banner$1,
	CenteredView: CenteredView,
	CopyToClipboard: CopyToClipboard,
	HighlightedText: HighlightedText$1,
	HyperLink: HyperLink,
	Input: Input$1,
	LayoutHMF: LayoutHMF$1,
	LinkButton: LinkButton,
	LoadingView: LoadingView,
	MessageView: MessageView,
	MultiBanner: MultiBanner$1,
	NoScript: NoScript,
	Pill: Pill$1,
	ResponsiveButton: ResponsiveButton$1,
	ResponsiveFlex: ResponsiveFlex$1,
	ScrollbarStyler: ScrollbarStyler$1,
	Scroller: Scroller,
	Switch: Switch,
	View: View,
	ViewsSlider: ViewsSlider,
	ViewsXor: ViewsXor,
	XorNavigator: XorNavigator$1,
	XorSelector: XorSelector,
	A11yMenu: A11yMenu,
	A11yMenuDriver: A11yMenuDriver,
	ColorCorrection: ColorCorrection,
	_a11ySettings: _a11ySettings,
	_currentId: _currentId,
	_currentSetting: _currentSetting,
	_formatValue: _formatValue,
	setNextId: setNextId,
	setPrevId: setPrevId,
	_hasPrev: _hasPrev,
	_hasNext: _hasNext,
	updateCurrentValue: updateCurrentValue,
	mergeDefaultSettings: mergeDefaultSettings,
	_groupsResetStatus: _groupsResetStatus,
	_isA11yDirty: _isA11yDirty,
	resetGroup: resetGroup,
	_a11yColorStyles: _a11yColorStyles,
	_a11yTextStyles: _a11yTextStyles,
	applyStyles: applyStyles,
	resizeHandler: resizeHandler,
	setupResizeObserver: setupResizeObserver,
	FontsLoader: FontsLoader,
	getFamily: getFamily,
	getFamilies: getFamilies,
	isFamilyEqualTo: isFamilyEqualTo,
	createFontFaces: createFontFaces,
	loadFontFaces: loadFontFaces,
	Icon: Icon,
	Activity: Activity,
	Airplay: Airplay$1,
	AlertCircle: AlertCircle$1,
	AlertOctagon: AlertOctagon$1,
	AlertTriangle: AlertTriangle,
	AlignCenter: AlignCenter$1,
	AlignJustify: AlignJustify$1,
	AlignLeft: AlignLeft$1,
	AlignRight: AlignRight$1,
	Anchor: Anchor$1,
	Aperture: Aperture$1,
	Archive: Archive$1,
	ArrowDownCircle: ArrowDownCircle$1,
	ArrowDownLeft: ArrowDownLeft$1,
	ArrowDownRight: ArrowDownRight$1,
	ArrowDown: ArrowDown$1,
	ArrowLeftCircle: ArrowLeftCircle,
	ArrowLeft: ArrowLeft$1,
	ArrowRightCircle: ArrowRightCircle,
	ArrowRight: ArrowRight$1,
	ArrowUpCircle: ArrowUpCircle$1,
	ArrowUpLeft: ArrowUpLeft$1,
	ArrowUpRight: ArrowUpRight$1,
	ArrowUp: ArrowUp$1,
	AtSign: AtSign$1,
	Award: Award$1,
	BarChart2: BarChart2$1,
	BarChart: BarChart,
	BatteryCharging: BatteryCharging$1,
	Battery: Battery$1,
	BellOff: BellOff$1,
	Bell: Bell$1,
	Bluetooth: Bluetooth$1,
	Bold: Bold$1,
	BookOpen: BookOpen$1,
	Book: Book$1,
	Bookmark: Bookmark$1,
	Box: Box$1,
	Briefcase: Briefcase$1,
	Calendar: Calendar$1,
	CameraOff: CameraOff$1,
	Camera: Camera$1,
	Cast: Cast$1,
	CheckCircle: CheckCircle$1,
	CheckSquare: CheckSquare,
	Check: Check$1,
	ChevronDown: ChevronDown,
	ChevronLeft: ChevronLeft,
	ChevronRight: ChevronRight,
	ChevronUp: ChevronUp,
	ChevronsDown: ChevronsDown$1,
	ChevronsLeft: ChevronsLeft$1,
	ChevronsRight: ChevronsRight$1,
	ChevronsUp: ChevronsUp$1,
	Chrome: Chrome$1,
	Circle: Circle$1,
	Clipboard: Clipboard,
	Clock: Clock,
	CloudDrizzle: CloudDrizzle$1,
	CloudLightning: CloudLightning$1,
	CloudOff: CloudOff$1,
	CloudRain: CloudRain$1,
	CloudSnow: CloudSnow$1,
	Cloud: Cloud$1,
	Code: Code$1,
	Codepen: Codepen$1,
	Codesandbox: Codesandbox$1,
	Coffee: Coffee$1,
	Columns: Columns$1,
	Command: Command$1,
	Compass: Compass$1,
	Copy: Copy,
	CornerDownLeft: CornerDownLeft$1,
	CornerDownRight: CornerDownRight$1,
	CornerLeftDown: CornerLeftDown$1,
	CornerLeftUp: CornerLeftUp$1,
	CornerRightDown: CornerRightDown$1,
	CornerRightUp: CornerRightUp$1,
	CornerUpLeft: CornerUpLeft$1,
	CornerUpRight: CornerUpRight$1,
	Cpu: Cpu$1,
	CreditCard: CreditCard$1,
	Crop: Crop$1,
	Crosshair: Crosshair$1,
	Database: Database$1,
	Delete: Delete$1,
	Disc: Disc$1,
	DivideCircle: DivideCircle$1,
	DivideSquare: DivideSquare$1,
	Divide: Divide$1,
	DollarSign: DollarSign$1,
	DownloadCloud: DownloadCloud$1,
	Download: Download,
	Dribbble: Dribbble$1,
	Droplet: Droplet$1,
	Edit2: Edit2$1,
	Edit3: Edit3$1,
	Edit: Edit$1,
	ExternalLink: ExternalLink,
	EyeOff: EyeOff$1,
	Eye: Eye$1,
	Facebook: Facebook$1,
	FastForward: FastForward$1,
	Feather: Feather$1,
	Figma: Figma$1,
	FileMinus: FileMinus$1,
	FilePlus: FilePlus$1,
	FileText: FileText$1,
	File: File$1,
	Film: Film$1,
	Filter: Filter$1,
	Flag: Flag$1,
	FolderMinus: FolderMinus$1,
	FolderPlus: FolderPlus$1,
	Folder: Folder$1,
	Framer: Framer$1,
	Frown: Frown$1,
	Gift: Gift$1,
	GitBranch: GitBranch$1,
	GitCommit: GitCommit$1,
	GitMerge: GitMerge$1,
	GitPullRequest: GitPullRequest$1,
	Github: Github$1,
	Gitlab: Gitlab$1,
	Globe: Globe,
	Grid: Grid$1,
	HardDrive: HardDrive$1,
	Hash: Hash$1,
	Headphones: Headphones$1,
	Heart: Heart$1,
	HelpCircle: HelpCircle$1,
	Hexagon: Hexagon$1,
	Home: Home$1,
	Image: Image$1,
	Inbox: Inbox$1,
	Info: Info,
	Instagram: Instagram$1,
	Italic: Italic$1,
	Key: Key$1,
	Layers: Layers$1,
	Layout: Layout$1,
	LifeBuoy: LifeBuoy$1,
	Link2: Link2$1,
	Link: Link$1,
	Linkedin: Linkedin$1,
	List: List,
	Loader: Loader,
	Lock: Lock$1,
	LogIn: LogIn$1,
	LogOut: LogOut$1,
	Mail: Mail$1,
	MapPin: MapPin,
	Map: Map$2,
	Maximize2: Maximize2$1,
	Maximize: Maximize$1,
	Meh: Meh$1,
	Menu: Menu$1,
	MessageCircle: MessageCircle$1,
	MessageSquare: MessageSquare$1,
	MicOff: MicOff$1,
	Mic: Mic$1,
	Minimize2: Minimize2$1,
	Minimize: Minimize$1,
	MinusCircle: MinusCircle,
	MinusSquare: MinusSquare,
	Minus: Minus$1,
	Monitor: Monitor$1,
	Moon: Moon$1,
	MoreHorizontal: MoreHorizontal$1,
	MoreVertical: MoreVertical$1,
	MousePointer: MousePointer$1,
	Move: Move$1,
	Music: Music$1,
	Navigation2: Navigation2$1,
	Navigation: Navigation$1,
	Octagon: Octagon$1,
	Package: Package$1,
	Paperclip: Paperclip$1,
	PauseCircle: PauseCircle$1,
	Pause: Pause$1,
	PenTool: PenTool$1,
	Percent: Percent$1,
	PhoneCall: PhoneCall$1,
	PhoneForwarded: PhoneForwarded$1,
	PhoneIncoming: PhoneIncoming$1,
	PhoneMissed: PhoneMissed$1,
	PhoneOff: PhoneOff$1,
	PhoneOutgoing: PhoneOutgoing$1,
	Phone: Phone$1,
	PieChart: PieChart$1,
	PlayCircle: PlayCircle$1,
	Play: Play$1,
	PlusCircle: PlusCircle,
	PlusSquare: PlusSquare$1,
	Plus: Plus$1,
	Pocket: Pocket$1,
	Power: Power$1,
	Printer: Printer$1,
	Radio: Radio$1,
	RefreshCcw: RefreshCcw$1,
	RefreshCw: RefreshCw$1,
	Repeat: Repeat$1,
	Rewind: Rewind$1,
	RotateCcw: RotateCcw$1,
	RotateCw: RotateCw$1,
	Rss: Rss$1,
	Save: Save$1,
	Scissors: Scissors$1,
	Search: Search$1,
	Send: Send$1,
	Server: Server$1,
	Settings: Settings,
	Share2: Share2$1,
	Share: Share$1,
	ShieldOff: ShieldOff$1,
	Shield: Shield$1,
	ShoppingBag: ShoppingBag$1,
	ShoppingCart: ShoppingCart$1,
	Shuffle: Shuffle$1,
	Sidebar: Sidebar$1,
	SkipBack: SkipBack$1,
	SkipForward: SkipForward$1,
	Slack: Slack$1,
	Slash: Slash$1,
	Sliders: Sliders$1,
	Smartphone: Smartphone$1,
	Smile: Smile$1,
	Speaker: Speaker$1,
	Square: Square,
	Star: Star$1,
	StopCircle: StopCircle$1,
	Sun: Sun,
	Sunrise: Sunrise$1,
	Sunset: Sunset$1,
	Table: Table$1,
	Tablet: Tablet$1,
	Tag: Tag$1,
	Target: Target$1,
	Terminal: Terminal$1,
	Thermometer: Thermometer$1,
	ThumbsDown: ThumbsDown$1,
	ThumbsUp: ThumbsUp$1,
	ToggleLeft: ToggleLeft$1,
	ToggleRight: ToggleRight$1,
	Tool: Tool$1,
	Trash2: Trash2$1,
	Trash: Trash$1,
	Trello: Trello$1,
	TrendingDown: TrendingDown$1,
	TrendingUp: TrendingUp$1,
	Triangle: Triangle$1,
	Truck: Truck$1,
	Tv: Tv$1,
	Twitch: Twitch$1,
	Twitter: Twitter$1,
	Type: Type$1,
	Umbrella: Umbrella$1,
	Underline: Underline$1,
	Unlock: Unlock$1,
	UploadCloud: UploadCloud$1,
	Upload: Upload$1,
	UserCheck: UserCheck$1,
	UserMinus: UserMinus$1,
	UserPlus: UserPlus$1,
	UserX: UserX$1,
	User: User$1,
	Users: Users$1,
	VideoOff: VideoOff$1,
	Video: Video$1,
	Voicemail: Voicemail$1,
	Volume1: Volume1$1,
	Volume2: Volume2$1,
	VolumeX: VolumeX$1,
	Volume: Volume$1,
	Watch: Watch$1,
	WifiOff: WifiOff$1,
	Wifi: Wifi$1,
	Wind: Wind$1,
	XCircle: XCircle$1,
	XOctagon: XOctagon$1,
	XSquare: XSquare$1,
	X: X$1,
	Youtube: Youtube$1,
	ZapOff: ZapOff$1,
	Zap: Zap$1,
	ZoomIn: ZoomIn$1,
	ZoomOut: ZoomOut$1,
	A11yPerson: A11yPerson,
	_screen: _screen,
	ScreenSensor: ScreenSensor,
	StyleSensor: StyleSensor$1,
	isServerSide: isServerSide,
	isClientSide: isClientSide,
	PLATFORM: PLATFORM,
	isPlatformIn: isPlatformIn,
	rxStreamToSvReadable: rxStreamToSvReadable,
	rxStreamToSvWritable: rxStreamToSvWritable,
	defaultRel: defaultRel
});

function range(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;

  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}

function band() {
  var scale = ordinal().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      r0 = 0,
      r1 = 1,
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;

  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = r1 < r0,
        start = reverse ? r1 : r0,
        stop = reverse ? r0 : r1;
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = range(n).map(function(i) { return start + step * i; });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };

  scale.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round = true, rescale();
  };

  scale.bandwidth = function() {
    return bandwidth;
  };

  scale.step = function() {
    return step;
  };

  scale.round = function(_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };

  scale.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };

  scale.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };

  scale.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function() {
    return band(domain(), [r0, r1])
        .round(round)
        .paddingInner(paddingInner)
        .paddingOuter(paddingOuter)
        .align(align);
  };

  return initRange.apply(rescale(), arguments);
}

function pointish(scale) {
  var copy = scale.copy;

  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function() {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}

function nice(domain, interval) {
  domain = domain.slice();

  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}

function transformLog(x) {
  return Math.log(x);
}

function transformExp(x) {
  return Math.exp(x);
}

function transformLogn(x) {
  return -Math.log(-x);
}

function transformExpn(x) {
  return -Math.exp(-x);
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10
      : base === Math.E ? Math.exp
      : x => Math.pow(base, x);
}

function logp(base) {
  return base === Math.E ? Math.log
      : base === 10 && Math.log10
      || base === 2 && Math.log2
      || (base = Math.log(base), x => Math.log(x) / base);
}

function reflect(f) {
  return (x, k) => -f(-x, k);
}

function loggish(transform) {
  const scale = transform(transformLog, transformExp);
  const domain = scale.domain;
  let base = 10;
  let logs;
  let pows;

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale;
  }

  scale.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = count => {
    const d = domain();
    let u = d[0];
    let v = d[d.length - 1];
    const r = v < u;

    if (r) ([u, v] = [v, u]);

    let i = logs(u);
    let j = logs(v);
    let k;
    let t;
    const n = count == null ? 10 : +count;
    let z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0) for (; i <= j; ++i) {
        for (k = 1; k < base; ++k) {
          t = i < 0 ? k / pows(-i) : k * pows(i);
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i <= j; ++i) {
        for (k = base - 1; k >= 1; --k) {
          t = i > 0 ? k / pows(-i) : k * pows(i);
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
      if (z.length * 2 < n) z = ticks(u, v, n);
    } else {
      z = ticks(i, j, Math.min(j - i, n)).map(pows);
    }
    return r ? z.reverse() : z;
  };

  scale.tickFormat = (count, specifier) => {
    if (count == null) count = 10;
    if (specifier == null) specifier = base === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null) specifier.trim = true;
      specifier = format(specifier);
    }
    if (count === Infinity) return specifier;
    const k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?
    return d => {
      let i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = () => {
    return domain(nice(domain(), {
      floor: x => pows(Math.floor(logs(x))),
      ceil: x => pows(Math.ceil(logs(x)))
    }));
  };

  return scale;
}

function log() {
  const scale = loggish(transformer()).domain([1, 10]);
  scale.copy = () => copy(scale, log()).base(scale.base());
  initRange.apply(scale, arguments);
  return scale;
}

const t0 = new Date, t1 = new Date;

function timeInterval(floori, offseti, count, field) {

  function interval(date) {
    return floori(date = arguments.length === 0 ? new Date : new Date(+date)), date;
  }

  interval.floor = (date) => {
    return floori(date = new Date(+date)), date;
  };

  interval.ceil = (date) => {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = (date) => {
    const d0 = interval(date), d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = (date, step) => {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = (start, stop, step) => {
    const range = [];
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date
    let previous;
    do range.push(previous = new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range;
  };

  interval.filter = (test) => {
    return timeInterval((date) => {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, (date, step) => {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty
        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty
        }
      }
    });
  };

  if (count) {
    interval.count = (start, end) => {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null
          : !(step > 1) ? interval
          : interval.filter(field
              ? (d) => field(d) % step === 0
              : (d) => interval.count(0, d) % step === 0);
    };
  }

  return interval;
}

const millisecond = timeInterval(() => {
  // noop
}, (date, step) => {
  date.setTime(+date + step);
}, (start, end) => {
  return end - start;
});

// An optimized implementation for this simple case.
millisecond.every = (k) => {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return timeInterval((date) => {
    date.setTime(Math.floor(date / k) * k);
  }, (date, step) => {
    date.setTime(+date + step * k);
  }, (start, end) => {
    return (end - start) / k;
  });
};

millisecond.range;

const durationSecond = 1000;
const durationMinute = durationSecond * 60;
const durationHour = durationMinute * 60;
const durationDay = durationHour * 24;
const durationWeek = durationDay * 7;
const durationMonth = durationDay * 30;
const durationYear = durationDay * 365;

const second = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds());
}, (date, step) => {
  date.setTime(+date + step * durationSecond);
}, (start, end) => {
  return (end - start) / durationSecond;
}, (date) => {
  return date.getUTCSeconds();
});

second.range;

const timeMinute = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond);
}, (date, step) => {
  date.setTime(+date + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date) => {
  return date.getMinutes();
});

timeMinute.range;

const utcMinute = timeInterval((date) => {
  date.setUTCSeconds(0, 0);
}, (date, step) => {
  date.setTime(+date + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date) => {
  return date.getUTCMinutes();
});

utcMinute.range;

const timeHour = timeInterval((date) => {
  date.setTime(date - date.getMilliseconds() - date.getSeconds() * durationSecond - date.getMinutes() * durationMinute);
}, (date, step) => {
  date.setTime(+date + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date) => {
  return date.getHours();
});

timeHour.range;

const utcHour = timeInterval((date) => {
  date.setUTCMinutes(0, 0, 0);
}, (date, step) => {
  date.setTime(+date + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date) => {
  return date.getUTCHours();
});

utcHour.range;

const timeDay = timeInterval(
  date => date.setHours(0, 0, 0, 0),
  (date, step) => date.setDate(date.getDate() + step),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
  date => date.getDate() - 1
);

timeDay.range;

const utcDay = timeInterval((date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCDate(date.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date) => {
  return date.getUTCDate() - 1;
});

utcDay.range;

const unixDay = timeInterval((date) => {
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCDate(date.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date) => {
  return Math.floor(date / durationDay);
});

unixDay.range;

function timeWeekday(i) {
  return timeInterval((date) => {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setDate(date.getDate() + step * 7);
  }, (start, end) => {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}

const timeSunday = timeWeekday(0);
const timeMonday = timeWeekday(1);
const timeTuesday = timeWeekday(2);
const timeWednesday = timeWeekday(3);
const timeThursday = timeWeekday(4);
const timeFriday = timeWeekday(5);
const timeSaturday = timeWeekday(6);

timeSunday.range;
timeMonday.range;
timeTuesday.range;
timeWednesday.range;
timeThursday.range;
timeFriday.range;
timeSaturday.range;

function utcWeekday(i) {
  return timeInterval((date) => {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, (start, end) => {
    return (end - start) / durationWeek;
  });
}

const utcSunday = utcWeekday(0);
const utcMonday = utcWeekday(1);
const utcTuesday = utcWeekday(2);
const utcWednesday = utcWeekday(3);
const utcThursday = utcWeekday(4);
const utcFriday = utcWeekday(5);
const utcSaturday = utcWeekday(6);

utcSunday.range;
utcMonday.range;
utcTuesday.range;
utcWednesday.range;
utcThursday.range;
utcFriday.range;
utcSaturday.range;

const timeMonth = timeInterval((date) => {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, (date, step) => {
  date.setMonth(date.getMonth() + step);
}, (start, end) => {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, (date) => {
  return date.getMonth();
});

timeMonth.range;

const utcMonth = timeInterval((date) => {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCMonth(date.getUTCMonth() + step);
}, (start, end) => {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, (date) => {
  return date.getUTCMonth();
});

utcMonth.range;

const timeYear = timeInterval((date) => {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, (date, step) => {
  date.setFullYear(date.getFullYear() + step);
}, (start, end) => {
  return end.getFullYear() - start.getFullYear();
}, (date) => {
  return date.getFullYear();
});

// An optimized implementation for this simple case.
timeYear.every = (k) => {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date) => {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

timeYear.range;

const utcYear = timeInterval((date) => {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, (date, step) => {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, (start, end) => {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, (date) => {
  return date.getUTCFullYear();
});

// An optimized implementation for this simple case.
utcYear.every = (k) => {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : timeInterval((date) => {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, (date, step) => {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

utcYear.range;

function ticker(year, month, week, day, hour, minute) {

  const tickIntervals = [
    [second,  1,      durationSecond],
    [second,  5,  5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute,  1,      durationMinute],
    [minute,  5,  5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [  hour,  1,      durationHour  ],
    [  hour,  3,  3 * durationHour  ],
    [  hour,  6,  6 * durationHour  ],
    [  hour, 12, 12 * durationHour  ],
    [   day,  1,      durationDay   ],
    [   day,  2,  2 * durationDay   ],
    [  week,  1,      durationWeek  ],
    [ month,  1,      durationMonth ],
    [ month,  3,  3 * durationMonth ],
    [  year,  1,      durationYear  ]
  ];

  function ticks(start, stop, count) {
    const reverse = stop < start;
    if (reverse) [start, stop] = [stop, start];
    const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
    const ticks = interval ? interval.range(start, +stop + 1) : []; // inclusive stop
    return reverse ? ticks.reverse() : ticks;
  }

  function tickInterval(start, stop, count) {
    const target = Math.abs(stop - start) / count;
    const i = bisector(([,, step]) => step).right(tickIntervals, target);
    if (i === tickIntervals.length) return year.every(tickStep(start / durationYear, stop / durationYear, count));
    if (i === 0) return millisecond.every(Math.max(tickStep(start, stop, count), 1));
    const [t, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t.every(step);
  }

  return [ticks, tickInterval];
}

ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
const [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newDate(y, m, d) {
  return {y: y, m: m, d: d, H: 0, M: 0, S: 0, L: 0};
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;

  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);

  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };

  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };

  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };

  // These recursive directive definitions must be deferred.
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function(date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;

      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);
          else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, undefined, 1),
          i = parseSpecifier(d, specifier, string += "", 0),
          week, day;
      if (i != string.length) return null;

      // If a UNIX timestamp is specified, return it.
      if ("Q" in d) return new Date(d.Q);
      if ("s" in d) return new Date(d.s * 1000 + ("L" in d ? d.L : 0));

      // If this is utcParse, never use the local timezone.
      if (Z && !("Z" in d)) d.Z = 0;

      // The am-pm flag is 0 for AM, and 1 for PM.
      if ("p" in d) d.H = d.H % 12 + d.p * 12;

      // If the month was not specified, inherit from the quarter.
      if (d.m === undefined) d.m = "q" in d ? d.q : 0;

      // Convert day-of-week and week-of-year to day-of-year.
      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
          week = timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      }

      // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }

      // Otherwise, all fields are in local time.
      return localDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);
      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || ((j = parse(d, string, j)) < 0)) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }

  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() { return specifier; };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() { return specifier; };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() { return specifier; };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() { return specifier; };
      return p;
    }
  };
}

var pads = {"-": "", "_": " ", "0": "0"},
    numberRe = /^\s*\d+/, // note: ignores next directive
    percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + timeDay.count(timeYear(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(timeSunday.count(timeYear(d) - 1, d), p, 2);
}

function dISO(d) {
  var day = d.getDay();
  return (day >= 4 || day === 0) ? timeThursday(d) : timeThursday.ceil(d);
}

function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(timeThursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(timeMonday.count(timeYear(d) - 1, d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatFullYearISO(d, p) {
  var day = d.getDay();
  d = (day >= 4 || day === 0) ? timeThursday(d) : timeThursday.ceil(d);
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+"))
      + pad(z / 60 | 0, "0", 2)
      + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay.count(utcYear(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear(d) - 1, d), p, 2);
}

function UTCdISO(d) {
  var day = d.getUTCDay();
  return (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
}

function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(utcThursday.count(utcYear(d), d) + (utcYear(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear(d) - 1, d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCFullYearISO(d, p) {
  var day = d.getUTCDay();
  d = (day >= 4 || day === 0) ? utcThursday(d) : utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}

var locale;
var timeFormat;

defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale = formatLocale(definition);
  timeFormat = locale.format;
  locale.parse;
  locale.utcFormat;
  locale.utcParse;
  return locale;
}

function date(t) {
  return new Date(t);
}

function number(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format) {
  var scale = continuous(),
      invert = scale.invert,
      domain = scale.domain;

  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond
        : minute(date) < date ? formatSecond
        : hour(date) < date ? formatMinute
        : day(date) < date ? formatHour
        : month(date) < date ? (week(date) < date ? formatDay : formatWeek)
        : year(date) < date ? formatMonth
        : formatYear)(date);
  }

  scale.invert = function(y) {
    return new Date(invert(y));
  };

  scale.domain = function(_) {
    return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
  };

  scale.ticks = function(interval) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], interval == null ? 10 : interval);
  };

  scale.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function(interval) {
    var d = domain();
    if (!interval || typeof interval.range !== "function") interval = tickInterval(d[0], d[d.length - 1], interval == null ? 10 : interval);
    return interval ? domain(nice(d, interval)) : scale;
  };

  scale.copy = function() {
    return copy(scale, calendar(ticks, tickInterval, year, month, week, day, hour, minute, second, format));
  };

  return scale;
}

function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]), arguments);
}

const STATE = {};
function useState(newState, opts) {
    const currentState = getContext(STATE);
    const _newState = typeof newState === 'function' ? newState(currentState) : newState;
    const nextState = { ...currentState, ..._newState };
    if (opts?.expandable)
        nextState.isParentExpanded = nextState.expanded;
    setContext(STATE, nextState);
    return currentState;
}

/* ../../../node_modules/svelte-json-tree/_/JSONArrow.svelte generated by Svelte v3.59.2 */
const file$o = "../../../node_modules/svelte-json-tree/_/JSONArrow.svelte";

// (6:0) {#if $expandable}
function create_if_block$g(ctx) {
	let span1;
	let span0;
	let t_value = '\u25B6' + "";
	let t;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			span1 = element("span");
			span0 = element("span");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			span1 = claim_element(nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			span0 = claim_element(span1_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			t = claim_text(span0_nodes, t_value);
			span0_nodes.forEach(detach_dev);
			span1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span0, "class", "arrow svelte-1qd6nto");
			toggle_class(span0, "expanded", /*$expanded*/ ctx[2]);
			add_location(span0, file$o, 13, 4, 304);
			attr_dev(span1, "class", "container svelte-1qd6nto");
			add_location(span1, file$o, 6, 2, 173);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span1, anchor);
			append_hydration_dev(span1, span0);
			append_hydration_dev(span0, t);

			if (!mounted) {
				dispose = listen_dev(span1, "click", /*click_handler*/ ctx[4], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$expanded*/ 4) {
				toggle_class(span0, "expanded", /*$expanded*/ ctx[2]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span1);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$g.name,
		type: "if",
		source: "(6:0) {#if $expandable}",
		ctx
	});

	return block;
}

function create_fragment$r(ctx) {
	let if_block_anchor;
	let if_block = /*$expandable*/ ctx[1] && create_if_block$g(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_hydration_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (/*$expandable*/ ctx[1]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$g(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$r.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$q($$self, $$props, $$invalidate) {
	let $expandable;

	let $expanded,
		$$unsubscribe_expanded = noop,
		$$subscribe_expanded = () => ($$unsubscribe_expanded(), $$unsubscribe_expanded = subscribe(expanded, $$value => $$invalidate(2, $expanded = $$value)), expanded);

	$$self.$$.on_destroy.push(() => $$unsubscribe_expanded());
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('JSONArrow', slots, []);
	const { expanded: _expanded, expandable } = useState();
	validate_store(expandable, 'expandable');
	component_subscribe($$self, expandable, value => $$invalidate(1, $expandable = value));
	let { expanded = _expanded } = $$props;
	validate_store(expanded, 'expanded');
	$$subscribe_expanded();
	const writable_props = ['expanded'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<JSONArrow> was created with unknown prop '${key}'`);
	});

	const click_handler = event => {
		event.stopPropagation();
		set_store_value(expanded, $expanded = !$expanded, $expanded);
	};

	$$self.$$set = $$props => {
		if ('expanded' in $$props) $$subscribe_expanded($$invalidate(0, expanded = $$props.expanded));
	};

	$$self.$capture_state = () => ({
		useState,
		_expanded,
		expandable,
		expanded,
		$expandable,
		$expanded
	});

	$$self.$inject_state = $$props => {
		if ('expanded' in $$props) $$subscribe_expanded($$invalidate(0, expanded = $$props.expanded));
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [expanded, $expandable, $expanded, expandable, click_handler];
}

class JSONArrow extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$q, create_fragment$r, safe_not_equal, { expanded: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "JSONArrow",
			options,
			id: create_fragment$r.name
		});
	}

	get expanded() {
		throw new Error("<JSONArrow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set expanded(value) {
		throw new Error("<JSONArrow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* ../../../node_modules/svelte-json-tree/_/Summary.svelte generated by Svelte v3.59.2 */

function create_fragment$q(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[1].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 1)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[0],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[0])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[0], dirty, null),
						null
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$q.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$p($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Summary', slots, ['default']);
	useState({ displayMode: 'summary' });
	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Summary> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('$$scope' in $$props) $$invalidate(0, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ useState });
	return [$$scope, slots];
}

class Summary extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$p, create_fragment$q, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Summary",
			options,
			id: create_fragment$q.name
		});
	}
}

/* ../../../node_modules/svelte-json-tree/_/Expandable.svelte generated by Svelte v3.59.2 */

function create_fragment$p(ctx) {
	let current;
	const default_slot_template = /*#slots*/ ctx[3].default;
	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

	const block = {
		c: function create() {
			if (default_slot) default_slot.c();
		},
		l: function claim(nodes) {
			if (default_slot) default_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (default_slot) {
				default_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (default_slot) {
				if (default_slot.p && (!current || dirty & /*$$scope*/ 4)) {
					update_slot_base(
						default_slot,
						default_slot_template,
						ctx,
						/*$$scope*/ ctx[2],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[2])
						: get_slot_changes(default_slot_template, /*$$scope*/ ctx[2], dirty, null),
						null
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(default_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(default_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (default_slot) default_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$p.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$o($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Expandable', slots, ['default']);
	let { expanded } = $$props;
	let { key } = $$props;
	const expandable = writable(false);

	useState(({ keyPath, level }) => {
		if (key !== '[[Entries]]') {
			keyPath = [...keyPath, key];
			level = level + 1;
		}

		return { keyPath, level, expanded, expandable };
	});

	$$self.$$.on_mount.push(function () {
		if (expanded === undefined && !('expanded' in $$props || $$self.$$.bound[$$self.$$.props['expanded']])) {
			console.warn("<Expandable> was created without expected prop 'expanded'");
		}

		if (key === undefined && !('key' in $$props || $$self.$$.bound[$$self.$$.props['key']])) {
			console.warn("<Expandable> was created without expected prop 'key'");
		}
	});

	const writable_props = ['expanded', 'key'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Expandable> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('expanded' in $$props) $$invalidate(0, expanded = $$props.expanded);
		if ('key' in $$props) $$invalidate(1, key = $$props.key);
		if ('$$scope' in $$props) $$invalidate(2, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		writable,
		useState,
		expanded,
		key,
		expandable
	});

	$$self.$inject_state = $$props => {
		if ('expanded' in $$props) $$invalidate(0, expanded = $$props.expanded);
		if ('key' in $$props) $$invalidate(1, key = $$props.key);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [expanded, key, $$scope, slots];
}

class Expandable extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$o, create_fragment$p, safe_not_equal, { expanded: 0, key: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Expandable",
			options,
			id: create_fragment$p.name
		});
	}

	get expanded() {
		throw new Error("<Expandable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set expanded(value) {
		throw new Error("<Expandable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get key() {
		throw new Error("<Expandable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set key(value) {
		throw new Error("<Expandable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* ../../../node_modules/svelte-json-tree/_/JSONNested.svelte generated by Svelte v3.59.2 */
const file$n = "../../../node_modules/svelte-json-tree/_/JSONNested.svelte";

function get_each_context$9(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[19] = list[i];
	child_ctx[21] = i;
	return child_ctx;
}

const get_item_value_slot_changes = dirty => ({ key: dirty & /*keys*/ 1 });

const get_item_value_slot_context = ctx => ({
	key: /*key*/ ctx[19],
	index: /*index*/ ctx[21]
});

const get_item_key_slot_changes = dirty => ({ key: dirty & /*keys*/ 1 });

const get_item_key_slot_context = ctx => ({
	key: /*key*/ ctx[19],
	index: /*index*/ ctx[21]
});

const get_preview_slot_changes = dirty => ({});
const get_preview_slot_context = ctx => ({});
const get_summary_slot_changes = dirty => ({});
const get_summary_slot_context = ctx => ({});

// (39:0) {:else}
function create_else_block$8(ctx) {
	let span;
	let t0;
	let summary;
	let t1;
	let if_block1_anchor;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*root*/ ctx[6] && create_if_block_3$4(ctx);

	summary = new Summary({
			props: {
				$$slots: { default: [create_default_slot_1$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	let if_block1 = /*$expanded*/ ctx[4] && create_if_block_1$7(ctx);

	const block = {
		c: function create() {
			span = element("span");
			if (if_block0) if_block0.c();
			t0 = space();
			create_component(summary.$$.fragment);
			t1 = space();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			if (if_block0) if_block0.l(span_nodes);
			t0 = claim_space(span_nodes);
			claim_component(summary.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			if_block1_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "root svelte-19drypg");
			add_location(span, file$n, 39, 2, 1294);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			if (if_block0) if_block0.m(span, null);
			append_hydration_dev(span, t0);
			mount_component(summary, span, null);
			insert_hydration_dev(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_hydration_dev(target, if_block1_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = listen_dev(span, "click", /*toggleExpand*/ ctx[9], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*root*/ ctx[6]) if_block0.p(ctx, dirty);
			const summary_changes = {};

			if (dirty & /*$$scope*/ 8192) {
				summary_changes.$$scope = { dirty, ctx };
			}

			summary.$set(summary_changes);

			if (/*$expanded*/ ctx[4]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*$expanded*/ 16) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_1$7(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block0);
			transition_in(summary.$$.fragment, local);
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block0);
			transition_out(summary.$$.fragment, local);
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if (if_block0) if_block0.d();
			destroy_component(summary);
			if (detaching) detach_dev(t1);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$8.name,
		type: "else",
		source: "(39:0) {:else}",
		ctx
	});

	return block;
}

// (37:0) {#if displayMode === 'summary'}
function create_if_block$f(ctx) {
	let current;
	const summary_slot_template = /*#slots*/ ctx[11].summary;
	const summary_slot = create_slot(summary_slot_template, ctx, /*$$scope*/ ctx[13], get_summary_slot_context);

	const block = {
		c: function create() {
			if (summary_slot) summary_slot.c();
		},
		l: function claim(nodes) {
			if (summary_slot) summary_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (summary_slot) {
				summary_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (summary_slot) {
				if (summary_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
					update_slot_base(
						summary_slot,
						summary_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: get_slot_changes(summary_slot_template, /*$$scope*/ ctx[13], dirty, get_summary_slot_changes),
						get_summary_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(summary_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(summary_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (summary_slot) summary_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$f.name,
		type: "if",
		source: "(37:0) {#if displayMode === 'summary'}",
		ctx
	});

	return block;
}

// (41:4) {#if root}
function create_if_block_3$4(ctx) {
	let jsonarrow;
	let current;

	jsonarrow = new JSONArrow({
			props: { expanded: /*expanded*/ ctx[7] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonarrow.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonarrow.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonarrow, target, anchor);
			current = true;
		},
		p: noop,
		i: function intro(local) {
			if (current) return;
			transition_in(jsonarrow.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonarrow.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonarrow, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$4.name,
		type: "if",
		source: "(41:4) {#if root}",
		ctx
	});

	return block;
}

// (44:4) <Summary>
function create_default_slot_1$1(ctx) {
	let current;
	const preview_slot_template = /*#slots*/ ctx[11].preview;
	const preview_slot = create_slot(preview_slot_template, ctx, /*$$scope*/ ctx[13], get_preview_slot_context);

	const block = {
		c: function create() {
			if (preview_slot) preview_slot.c();
		},
		l: function claim(nodes) {
			if (preview_slot) preview_slot.l(nodes);
		},
		m: function mount(target, anchor) {
			if (preview_slot) {
				preview_slot.m(target, anchor);
			}

			current = true;
		},
		p: function update(ctx, dirty) {
			if (preview_slot) {
				if (preview_slot.p && (!current || dirty & /*$$scope*/ 8192)) {
					update_slot_base(
						preview_slot,
						preview_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: get_slot_changes(preview_slot_template, /*$$scope*/ ctx[13], dirty, get_preview_slot_changes),
						get_preview_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(preview_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(preview_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (preview_slot) preview_slot.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1$1.name,
		type: "slot",
		source: "(44:4) <Summary>",
		ctx
	});

	return block;
}

// (49:2) {#if $expanded}
function create_if_block_1$7(ctx) {
	let ul;
	let current;
	let mounted;
	let dispose;
	let each_value = /*keys*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", {});
			var ul_nodes = children(ul);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(ul_nodes);
			}

			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(ul, file$n, 49, 4, 1486);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(ul, null);
				}
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(ul, "click", stop_propagation(/*toggleExpand*/ ctx[9]), false, false, true, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*$expanded, expandKey, keys, child_expanded, $$scope, shouldShowColon*/ 8223) {
				each_value = /*keys*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$9(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$9(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(ul, null);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$7.name,
		type: "if",
		source: "(49:2) {#if $expanded}",
		ctx
	});

	return block;
}

// (55:65) {#if !shouldShowColon || shouldShowColon(key)}
function create_if_block_2$5(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(":");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, ":");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "operator");
			add_location(span, file$n, 54, 111, 1924);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$5.name,
		type: "if",
		source: "(55:65) {#if !shouldShowColon || shouldShowColon(key)}",
		ctx
	});

	return block;
}

// (53:10) <Expandable key={expandKey(key)} expanded={child_expanded[index]}>
function create_default_slot$2(ctx) {
	let span;
	let jsonarrow;
	let show_if = !/*shouldShowColon*/ ctx[1] || /*shouldShowColon*/ ctx[1](/*key*/ ctx[19]);
	let t;
	let current;
	let mounted;
	let dispose;
	jsonarrow = new JSONArrow({ $$inline: true });
	const item_key_slot_template = /*#slots*/ ctx[11].item_key;
	const item_key_slot = create_slot(item_key_slot_template, ctx, /*$$scope*/ ctx[13], get_item_key_slot_context);
	let if_block = show_if && create_if_block_2$5(ctx);

	function click_handler() {
		return /*click_handler*/ ctx[12](/*index*/ ctx[21]);
	}

	const item_value_slot_template = /*#slots*/ ctx[11].item_value;
	const item_value_slot = create_slot(item_value_slot_template, ctx, /*$$scope*/ ctx[13], get_item_value_slot_context);

	const block = {
		c: function create() {
			span = element("span");
			create_component(jsonarrow.$$.fragment);
			if (item_key_slot) item_key_slot.c();
			if (if_block) if_block.c();
			t = space();
			if (item_value_slot) item_value_slot.c();
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			claim_component(jsonarrow.$$.fragment, span_nodes);
			if (item_key_slot) item_key_slot.l(span_nodes);
			if (if_block) if_block.l(span_nodes);
			t = claim_space(span_nodes);
			span_nodes.forEach(detach_dev);
			if (item_value_slot) item_value_slot.l(nodes);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "label svelte-19drypg");
			add_location(span, file$n, 53, 12, 1727);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			mount_component(jsonarrow, span, null);

			if (item_key_slot) {
				item_key_slot.m(span, null);
			}

			if (if_block) if_block.m(span, null);
			append_hydration_dev(span, t);

			if (item_value_slot) {
				item_value_slot.m(target, anchor);
			}

			current = true;

			if (!mounted) {
				dispose = listen_dev(span, "click", click_handler, false, false, false, false);
				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (item_key_slot) {
				if (item_key_slot.p && (!current || dirty & /*$$scope, keys*/ 8193)) {
					update_slot_base(
						item_key_slot,
						item_key_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: get_slot_changes(item_key_slot_template, /*$$scope*/ ctx[13], dirty, get_item_key_slot_changes),
						get_item_key_slot_context
					);
				}
			}

			if (dirty & /*shouldShowColon, keys*/ 3) show_if = !/*shouldShowColon*/ ctx[1] || /*shouldShowColon*/ ctx[1](/*key*/ ctx[19]);

			if (show_if) {
				if (if_block) ; else {
					if_block = create_if_block_2$5(ctx);
					if_block.c();
					if_block.m(span, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (item_value_slot) {
				if (item_value_slot.p && (!current || dirty & /*$$scope, keys*/ 8193)) {
					update_slot_base(
						item_value_slot,
						item_value_slot_template,
						ctx,
						/*$$scope*/ ctx[13],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[13])
						: get_slot_changes(item_value_slot_template, /*$$scope*/ ctx[13], dirty, get_item_value_slot_changes),
						get_item_value_slot_context
					);
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonarrow.$$.fragment, local);
			transition_in(item_key_slot, local);
			transition_in(item_value_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonarrow.$$.fragment, local);
			transition_out(item_key_slot, local);
			transition_out(item_value_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(jsonarrow);
			if (item_key_slot) item_key_slot.d(detaching);
			if (if_block) if_block.d();
			if (item_value_slot) item_value_slot.d(detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$2.name,
		type: "slot",
		source: "(53:10) <Expandable key={expandKey(key)} expanded={child_expanded[index]}>",
		ctx
	});

	return block;
}

// (51:6) {#each keys as key, index}
function create_each_block$9(ctx) {
	let li;
	let expandable_1;
	let t;
	let current;
	let mounted;
	let dispose;

	expandable_1 = new Expandable({
			props: {
				key: /*expandKey*/ ctx[2](/*key*/ ctx[19]),
				expanded: /*child_expanded*/ ctx[3][/*index*/ ctx[21]],
				$$slots: { default: [create_default_slot$2] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			li = element("li");
			create_component(expandable_1.$$.fragment);
			t = space();
			this.h();
		},
		l: function claim(nodes) {
			li = claim_element(nodes, "LI", { class: true });
			var li_nodes = children(li);
			claim_component(expandable_1.$$.fragment, li_nodes);
			t = claim_space(li_nodes);
			li_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(li, "class", "svelte-19drypg");
			toggle_class(li, "indent", /*$expanded*/ ctx[4]);
			add_location(li, file$n, 51, 8, 1572);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, li, anchor);
			mount_component(expandable_1, li, null);
			append_hydration_dev(li, t);
			current = true;

			if (!mounted) {
				dispose = listen_dev(li, "click", stop_propagation(click_handler_1), false, false, true, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			const expandable_1_changes = {};
			if (dirty & /*expandKey, keys*/ 5) expandable_1_changes.key = /*expandKey*/ ctx[2](/*key*/ ctx[19]);
			if (dirty & /*child_expanded*/ 8) expandable_1_changes.expanded = /*child_expanded*/ ctx[3][/*index*/ ctx[21]];

			if (dirty & /*$$scope, keys, child_expanded, shouldShowColon*/ 8203) {
				expandable_1_changes.$$scope = { dirty, ctx };
			}

			expandable_1.$set(expandable_1_changes);

			if (!current || dirty & /*$expanded*/ 16) {
				toggle_class(li, "indent", /*$expanded*/ ctx[4]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(expandable_1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(expandable_1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(li);
			destroy_component(expandable_1);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$9.name,
		type: "each",
		source: "(51:6) {#each keys as key, index}",
		ctx
	});

	return block;
}

function create_fragment$o(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$f, create_else_block$8];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*displayMode*/ ctx[5] === 'summary') return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if_block.p(ctx, dirty);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$o.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const click_handler_1 = () => {
	
};

function instance$n($$self, $$props, $$invalidate) {
	let child_expanded;
	let $expanded;
	let $expandable;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('JSONNested', slots, ['summary','preview','item_key','item_value']);
	let { keys } = $$props;
	let { shouldShowColon = undefined } = $$props;
	let { expandKey = key => key } = $$props;
	let { defaultExpanded = false } = $$props;
	const { isParentExpanded, displayMode, root, expanded, expandable, keyPath, level, shouldExpandNode } = useState({ root: false }, { expandable: true });
	validate_store(expanded, 'expanded');
	component_subscribe($$self, expanded, value => $$invalidate(4, $expanded = value));
	validate_store(expandable, 'expandable');
	component_subscribe($$self, expandable, value => $$invalidate(14, $expandable = value));
	set_store_value(expandable, $expandable = true, $expandable);

	if (displayMode !== 'summary') {
		// if not internally control to open
		if (!defaultExpanded) {
			const controlled = shouldExpandNode({ keyPath, level });

			if (controlled !== undefined) {
				defaultExpanded = controlled;
			}
		}

		onMount(() => {
			return isParentExpanded.subscribe(value => {
				if (!value) expanded.set(false); else expanded.set(defaultExpanded);
			});
		});
	}

	function toggleExpand() {
		set_store_value(expanded, $expanded = !$expanded, $expanded);
	}

	$$self.$$.on_mount.push(function () {
		if (keys === undefined && !('keys' in $$props || $$self.$$.bound[$$self.$$.props['keys']])) {
			console.warn("<JSONNested> was created without expected prop 'keys'");
		}
	});

	const writable_props = ['keys', 'shouldShowColon', 'expandKey', 'defaultExpanded'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<JSONNested> was created with unknown prop '${key}'`);
	});

	const click_handler = index => child_expanded[index].update(value => !value);

	$$self.$$set = $$props => {
		if ('keys' in $$props) $$invalidate(0, keys = $$props.keys);
		if ('shouldShowColon' in $$props) $$invalidate(1, shouldShowColon = $$props.shouldShowColon);
		if ('expandKey' in $$props) $$invalidate(2, expandKey = $$props.expandKey);
		if ('defaultExpanded' in $$props) $$invalidate(10, defaultExpanded = $$props.defaultExpanded);
		if ('$$scope' in $$props) $$invalidate(13, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({
		onMount,
		JSONArrow,
		useState,
		writable,
		Summary,
		Expandable,
		keys,
		shouldShowColon,
		expandKey,
		defaultExpanded,
		isParentExpanded,
		displayMode,
		root,
		expanded,
		expandable,
		keyPath,
		level,
		shouldExpandNode,
		toggleExpand,
		child_expanded,
		$expanded,
		$expandable
	});

	$$self.$inject_state = $$props => {
		if ('keys' in $$props) $$invalidate(0, keys = $$props.keys);
		if ('shouldShowColon' in $$props) $$invalidate(1, shouldShowColon = $$props.shouldShowColon);
		if ('expandKey' in $$props) $$invalidate(2, expandKey = $$props.expandKey);
		if ('defaultExpanded' in $$props) $$invalidate(10, defaultExpanded = $$props.defaultExpanded);
		if ('child_expanded' in $$props) $$invalidate(3, child_expanded = $$props.child_expanded);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*keys*/ 1) {
			$$invalidate(3, child_expanded = keys.map(() => writable(false)));
		}
	};

	return [
		keys,
		shouldShowColon,
		expandKey,
		child_expanded,
		$expanded,
		displayMode,
		root,
		expanded,
		expandable,
		toggleExpand,
		defaultExpanded,
		slots,
		click_handler,
		$$scope
	];
}

class JSONNested extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$n, create_fragment$o, safe_not_equal, {
			keys: 0,
			shouldShowColon: 1,
			expandKey: 2,
			defaultExpanded: 10
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "JSONNested",
			options,
			id: create_fragment$o.name
		});
	}

	get keys() {
		throw new Error("<JSONNested>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set keys(value) {
		throw new Error("<JSONNested>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get shouldShowColon() {
		throw new Error("<JSONNested>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set shouldShowColon(value) {
		throw new Error("<JSONNested>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get expandKey() {
		throw new Error("<JSONNested>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set expandKey(value) {
		throw new Error("<JSONNested>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get defaultExpanded() {
		throw new Error("<JSONNested>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set defaultExpanded(value) {
		throw new Error("<JSONNested>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* ../../../node_modules/svelte-json-tree/_/PreviewList.svelte generated by Svelte v3.59.2 */

const file$m = "../../../node_modules/svelte-json-tree/_/PreviewList.svelte";

function get_each_context$8(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[7] = list[i];
	child_ctx[9] = i;
	return child_ctx;
}

const get_item_slot_changes = dirty => ({ item: dirty & /*list*/ 1 });

const get_item_slot_context = ctx => ({
	item: /*item*/ ctx[7],
	index: /*index*/ ctx[9]
});

// (8:0) {#if prefix}
function create_if_block_3$3(ctx) {
	let span;
	let t;
	let if_block = /*label*/ ctx[2] && create_if_block_4$2(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			span = element("span");
			t = text(/*prefix*/ ctx[3]);
			this.h();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, /*prefix*/ ctx[3]);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "operator");
			add_location(span, file$m, 7, 62, 212);
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (/*label*/ ctx[2]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_4$2(ctx);
					if_block.c();
					if_block.m(span.parentNode, span);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty & /*prefix*/ 8) set_data_dev(t, /*prefix*/ ctx[3]);
		},
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$3.name,
		type: "if",
		source: "(8:0) {#if prefix}",
		ctx
	});

	return block;
}

// (8:12) {#if label}
function create_if_block_4$2(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*label*/ ctx[2]);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, /*label*/ ctx[2]);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "label");
			add_location(span, file$m, 7, 23, 173);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*label*/ 4) set_data_dev(t, /*label*/ ctx[2]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$2.name,
		type: "if",
		source: "(8:12) {#if label}",
		ctx
	});

	return block;
}

// (11:2) {#if index < list.length - 1}
function create_if_block_2$4(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(",");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, ",");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "comma operator svelte-150ffaa");
			add_location(span, file$m, 11, 4, 358);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$4.name,
		type: "if",
		source: "(11:2) {#if index < list.length - 1}",
		ctx
	});

	return block;
}

// (9:0) {#each list as item, index}
function create_each_block$8(ctx) {
	let t;
	let if_block_anchor;
	let current;
	const item_slot_template = /*#slots*/ ctx[6].item;
	const item_slot = create_slot(item_slot_template, ctx, /*$$scope*/ ctx[5], get_item_slot_context);
	let if_block = /*index*/ ctx[9] < /*list*/ ctx[0].length - 1 && create_if_block_2$4(ctx);

	const block = {
		c: function create() {
			if (item_slot) item_slot.c();
			t = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (item_slot) item_slot.l(nodes);
			t = claim_space(nodes);
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (item_slot) {
				item_slot.m(target, anchor);
			}

			insert_hydration_dev(target, t, anchor);
			if (if_block) if_block.m(target, anchor);
			insert_hydration_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (item_slot) {
				if (item_slot.p && (!current || dirty & /*$$scope, list*/ 33)) {
					update_slot_base(
						item_slot,
						item_slot_template,
						ctx,
						/*$$scope*/ ctx[5],
						!current
						? get_all_dirty_from_scope(/*$$scope*/ ctx[5])
						: get_slot_changes(item_slot_template, /*$$scope*/ ctx[5], dirty, get_item_slot_changes),
						get_item_slot_context
					);
				}
			}

			if (/*index*/ ctx[9] < /*list*/ ctx[0].length - 1) {
				if (if_block) ; else {
					if_block = create_if_block_2$4(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(item_slot, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(item_slot, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (item_slot) item_slot.d(detaching);
			if (detaching) detach_dev(t);
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$8.name,
		type: "each",
		source: "(9:0) {#each list as item, index}",
		ctx
	});

	return block;
}

// (15:0) {#if hasMore}
function create_if_block_1$6(ctx) {
	let span0;
	let t0;
	let t1;
	let span1;
	let t2;

	const block = {
		c: function create() {
			span0 = element("span");
			t0 = text(",");
			t1 = space();
			span1 = element("span");
			t2 = text("…");
			this.h();
		},
		l: function claim(nodes) {
			span0 = claim_element(nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			t0 = claim_text(span0_nodes, ",");
			span0_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			span1 = claim_element(nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			t2 = claim_text(span1_nodes, "…");
			span1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span0, "class", "comma operator svelte-150ffaa");
			add_location(span0, file$m, 15, 2, 428);
			attr_dev(span1, "class", "operator");
			add_location(span1, file$m, 16, 2, 468);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span0, anchor);
			append_hydration_dev(span0, t0);
			insert_hydration_dev(target, t1, anchor);
			insert_hydration_dev(target, span1, anchor);
			append_hydration_dev(span1, t2);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span0);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(span1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$6.name,
		type: "if",
		source: "(15:0) {#if hasMore}",
		ctx
	});

	return block;
}

// (19:0) {#if postfix}
function create_if_block$e(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*postfix*/ ctx[4]);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, /*postfix*/ ctx[4]);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "operator");
			add_location(span, file$m, 18, 13, 519);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*postfix*/ 16) set_data_dev(t, /*postfix*/ ctx[4]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$e.name,
		type: "if",
		source: "(19:0) {#if postfix}",
		ctx
	});

	return block;
}

function create_fragment$n(ctx) {
	let t0;
	let t1;
	let t2;
	let if_block2_anchor;
	let current;
	let if_block0 = /*prefix*/ ctx[3] && create_if_block_3$3(ctx);
	let each_value = /*list*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	let if_block1 = /*hasMore*/ ctx[1] && create_if_block_1$6(ctx);
	let if_block2 = /*postfix*/ ctx[4] && create_if_block$e(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			t0 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t1 = space();
			if (if_block1) if_block1.c();
			t2 = space();
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block0) if_block0.l(nodes);
			t0 = claim_space(nodes);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			t1 = claim_space(nodes);
			if (if_block1) if_block1.l(nodes);
			t2 = claim_space(nodes);
			if (if_block2) if_block2.l(nodes);
			if_block2_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration_dev(target, t0, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert_hydration_dev(target, t1, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_hydration_dev(target, t2, anchor);
			if (if_block2) if_block2.m(target, anchor);
			insert_hydration_dev(target, if_block2_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*prefix*/ ctx[3]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3$3(ctx);
					if_block0.c();
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty & /*list, $$scope*/ 33) {
				each_value = /*list*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$8(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$8(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(t1.parentNode, t1);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			if (/*hasMore*/ ctx[1]) {
				if (if_block1) ; else {
					if_block1 = create_if_block_1$6(ctx);
					if_block1.c();
					if_block1.m(t2.parentNode, t2);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (/*postfix*/ ctx[4]) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block$e(ctx);
					if_block2.c();
					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(t0);
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(t1);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(t2);
			if (if_block2) if_block2.d(detaching);
			if (detaching) detach_dev(if_block2_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$n.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$m($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('PreviewList', slots, ['item']);
	let { list } = $$props;
	let { hasMore } = $$props;
	let { label = undefined } = $$props;
	let { prefix = undefined } = $$props;
	let { postfix = undefined } = $$props;

	$$self.$$.on_mount.push(function () {
		if (list === undefined && !('list' in $$props || $$self.$$.bound[$$self.$$.props['list']])) {
			console.warn("<PreviewList> was created without expected prop 'list'");
		}

		if (hasMore === undefined && !('hasMore' in $$props || $$self.$$.bound[$$self.$$.props['hasMore']])) {
			console.warn("<PreviewList> was created without expected prop 'hasMore'");
		}
	});

	const writable_props = ['list', 'hasMore', 'label', 'prefix', 'postfix'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PreviewList> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('list' in $$props) $$invalidate(0, list = $$props.list);
		if ('hasMore' in $$props) $$invalidate(1, hasMore = $$props.hasMore);
		if ('label' in $$props) $$invalidate(2, label = $$props.label);
		if ('prefix' in $$props) $$invalidate(3, prefix = $$props.prefix);
		if ('postfix' in $$props) $$invalidate(4, postfix = $$props.postfix);
		if ('$$scope' in $$props) $$invalidate(5, $$scope = $$props.$$scope);
	};

	$$self.$capture_state = () => ({ list, hasMore, label, prefix, postfix });

	$$self.$inject_state = $$props => {
		if ('list' in $$props) $$invalidate(0, list = $$props.list);
		if ('hasMore' in $$props) $$invalidate(1, hasMore = $$props.hasMore);
		if ('label' in $$props) $$invalidate(2, label = $$props.label);
		if ('prefix' in $$props) $$invalidate(3, prefix = $$props.prefix);
		if ('postfix' in $$props) $$invalidate(4, postfix = $$props.postfix);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [list, hasMore, label, prefix, postfix, $$scope, slots];
}

class PreviewList extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$m, create_fragment$n, safe_not_equal, {
			list: 0,
			hasMore: 1,
			label: 2,
			prefix: 3,
			postfix: 4
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PreviewList",
			options,
			id: create_fragment$n.name
		});
	}

	get list() {
		throw new Error("<PreviewList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set list(value) {
		throw new Error("<PreviewList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hasMore() {
		throw new Error("<PreviewList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hasMore(value) {
		throw new Error("<PreviewList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get label() {
		throw new Error("<PreviewList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set label(value) {
		throw new Error("<PreviewList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get prefix() {
		throw new Error("<PreviewList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set prefix(value) {
		throw new Error("<PreviewList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get postfix() {
		throw new Error("<PreviewList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set postfix(value) {
		throw new Error("<PreviewList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* ../../../node_modules/svelte-json-tree/_/JSONObjectNode.svelte generated by Svelte v3.59.2 */

const { Object: Object_1$3 } = globals;
const file$l = "../../../node_modules/svelte-json-tree/_/JSONObjectNode.svelte";

// (10:2) <svelte:fragment slot="summary">
function create_summary_slot$8(ctx) {
	let span;
	let t_value = '{…}' + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "label");
			add_location(span, file$l, 9, 34, 308);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_summary_slot$8.name,
		type: "slot",
		source: "(10:2) <svelte:fragment slot=\\\"summary\\\">",
		ctx
	});

	return block;
}

// (13:6) <svelte:fragment slot="item" let:item         >
function create_item_slot$5(ctx) {
	let span0;
	let t0_value = /*item*/ ctx[4] + "";
	let t0;
	let span1;
	let t1_value = ': ' + "";
	let t1;
	let jsonnode;
	let current;

	jsonnode = new JSONNode({
			props: { value: /*value*/ ctx[0][/*item*/ ctx[4]] },
			$$inline: true
		});

	const block = {
		c: function create() {
			span0 = element("span");
			t0 = text(t0_value);
			span1 = element("span");
			t1 = text(t1_value);
			create_component(jsonnode.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span0 = claim_element(nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			t0 = claim_text(span0_nodes, t0_value);
			span0_nodes.forEach(detach_dev);
			span1 = claim_element(nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			t1 = claim_text(span1_nodes, t1_value);
			span1_nodes.forEach(detach_dev);
			claim_component(jsonnode.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span0, "class", "property");
			add_location(span0, file$l, 13, 9, 556);
			attr_dev(span1, "class", "operator");
			add_location(span1, file$l, 13, 45, 592);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span0, anchor);
			append_hydration_dev(span0, t0);
			insert_hydration_dev(target, span1, anchor);
			append_hydration_dev(span1, t1);
			mount_component(jsonnode, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*item*/ 16) && t0_value !== (t0_value = /*item*/ ctx[4] + "")) set_data_dev(t0, t0_value);
			const jsonnode_changes = {};
			if (dirty & /*value, item*/ 17) jsonnode_changes.value = /*value*/ ctx[0][/*item*/ ctx[4]];
			jsonnode.$set(jsonnode_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span0);
			if (detaching) detach_dev(span1);
			destroy_component(jsonnode, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_slot$5.name,
		type: "slot",
		source: "(13:6) <svelte:fragment slot=\\\"item\\\" let:item         >",
		ctx
	});

	return block;
}

// (11:2) <svelte:fragment slot="preview">
function create_preview_slot$8(ctx) {
	let previewlist;
	let current;

	previewlist = new PreviewList({
			props: {
				list: /*previewKeys*/ ctx[2],
				hasMore: /*previewKeys*/ ctx[2].length < /*keys*/ ctx[1].length,
				prefix: '{',
				postfix: '}',
				$$slots: {
					item: [
						create_item_slot$5,
						({ item }) => ({ 4: item }),
						({ item }) => item ? 16 : 0
					]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(previewlist.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(previewlist.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(previewlist, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const previewlist_changes = {};
			if (dirty & /*previewKeys*/ 4) previewlist_changes.list = /*previewKeys*/ ctx[2];
			if (dirty & /*previewKeys, keys*/ 6) previewlist_changes.hasMore = /*previewKeys*/ ctx[2].length < /*keys*/ ctx[1].length;

			if (dirty & /*$$scope, value, item*/ 49) {
				previewlist_changes.$$scope = { dirty, ctx };
			}

			previewlist.$set(previewlist_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(previewlist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(previewlist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(previewlist, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_preview_slot$8.name,
		type: "slot",
		source: "(11:2) <svelte:fragment slot=\\\"preview\\\">",
		ctx
	});

	return block;
}

// (18:2) <svelte:fragment slot="item_key" let:key>
function create_item_key_slot$8(ctx) {
	let span;
	let t_value = /*key*/ ctx[3] + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "property");
			add_location(span, file$l, 17, 43, 769);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*key*/ 8 && t_value !== (t_value = /*key*/ ctx[3] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_key_slot$8.name,
		type: "slot",
		source: "(18:2) <svelte:fragment slot=\\\"item_key\\\" let:key>",
		ctx
	});

	return block;
}

// (19:2) <svelte:fragment slot="item_value" let:key>
function create_item_value_slot$8(ctx) {
	let jsonnode;
	let current;

	jsonnode = new JSONNode({
			props: { value: /*value*/ ctx[0][/*key*/ ctx[3]] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnode.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnode.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnode, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const jsonnode_changes = {};
			if (dirty & /*value, key*/ 9) jsonnode_changes.value = /*value*/ ctx[0][/*key*/ ctx[3]];
			jsonnode.$set(jsonnode_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnode, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_value_slot$8.name,
		type: "slot",
		source: "(19:2) <svelte:fragment slot=\\\"item_value\\\" let:key>",
		ctx
	});

	return block;
}

function create_fragment$m(ctx) {
	let jsonnested;
	let current;

	jsonnested = new JSONNested({
			props: {
				keys: /*keys*/ ctx[1],
				$$slots: {
					item_value: [
						create_item_value_slot$8,
						({ key }) => ({ 3: key }),
						({ key }) => key ? 8 : 0
					],
					item_key: [
						create_item_key_slot$8,
						({ key }) => ({ 3: key }),
						({ key }) => key ? 8 : 0
					],
					preview: [create_preview_slot$8],
					summary: [create_summary_slot$8]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnested.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnested.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnested, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const jsonnested_changes = {};
			if (dirty & /*keys*/ 2) jsonnested_changes.keys = /*keys*/ ctx[1];

			if (dirty & /*$$scope, value, key, previewKeys, keys*/ 47) {
				jsonnested_changes.$$scope = { dirty, ctx };
			}

			jsonnested.$set(jsonnested_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnested.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnested.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnested, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$m.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$l($$self, $$props, $$invalidate) {
	let keys;
	let previewKeys;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('JSONObjectNode', slots, []);
	let { value } = $$props;

	$$self.$$.on_mount.push(function () {
		if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
			console.warn("<JSONObjectNode> was created without expected prop 'value'");
		}
	});

	const writable_props = ['value'];

	Object_1$3.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<JSONObjectNode> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
	};

	$$self.$capture_state = () => ({
		JSONNested,
		JSONNode,
		PreviewList,
		value,
		keys,
		previewKeys
	});

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('keys' in $$props) $$invalidate(1, keys = $$props.keys);
		if ('previewKeys' in $$props) $$invalidate(2, previewKeys = $$props.previewKeys);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			$$invalidate(1, keys = Object.getOwnPropertyNames(value));
		}

		if ($$self.$$.dirty & /*keys*/ 2) {
			$$invalidate(2, previewKeys = keys.slice(0, 5));
		}
	};

	return [value, keys, previewKeys];
}

class JSONObjectNode extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$l, create_fragment$m, safe_not_equal, { value: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "JSONObjectNode",
			options,
			id: create_fragment$m.name
		});
	}

	get value() {
		throw new Error("<JSONObjectNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<JSONObjectNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* ../../../node_modules/svelte-json-tree/_/JSONArrayNode.svelte generated by Svelte v3.59.2 */

const { Object: Object_1$2 } = globals;
const file$k = "../../../node_modules/svelte-json-tree/_/JSONArrayNode.svelte";

// (10:2) <svelte:fragment slot="summary">
function create_summary_slot$7(ctx) {
	let span;
	let t0;
	let t1_value = /*value*/ ctx[0].length + "";
	let t1;
	let t2;

	const block = {
		c: function create() {
			span = element("span");
			t0 = text("Array(");
			t1 = text(t1_value);
			t2 = text(")");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, "Array(");
			t1 = claim_text(span_nodes, t1_value);
			t2 = claim_text(span_nodes, ")");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "label");
			add_location(span, file$k, 9, 34, 305);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t0);
			append_hydration_dev(span, t1);
			append_hydration_dev(span, t2);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*value*/ 1 && t1_value !== (t1_value = /*value*/ ctx[0].length + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_summary_slot$7.name,
		type: "slot",
		source: "(10:2) <svelte:fragment slot=\\\"summary\\\">",
		ctx
	});

	return block;
}

// (13:6) <svelte:fragment slot="item" let:item>
function create_item_slot$4(ctx) {
	let jsonnode;
	let current;

	jsonnode = new JSONNode({
			props: { value: /*item*/ ctx[4] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnode.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnode.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnode, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const jsonnode_changes = {};
			if (dirty & /*item*/ 16) jsonnode_changes.value = /*item*/ ctx[4];
			jsonnode.$set(jsonnode_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnode, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_slot$4.name,
		type: "slot",
		source: "(13:6) <svelte:fragment slot=\\\"item\\\" let:item>",
		ctx
	});

	return block;
}

// (11:2) <svelte:fragment slot="preview">
function create_preview_slot$7(ctx) {
	let previewlist;
	let current;

	previewlist = new PreviewList({
			props: {
				list: /*preview*/ ctx[1],
				hasMore: /*preview*/ ctx[1].length < /*value*/ ctx[0].length,
				label: "(" + /*value*/ ctx[0].length + ") ",
				prefix: "[",
				postfix: "]",
				$$slots: {
					item: [
						create_item_slot$4,
						({ item }) => ({ 4: item }),
						({ item }) => item ? 16 : 0
					]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(previewlist.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(previewlist.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(previewlist, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const previewlist_changes = {};
			if (dirty & /*preview*/ 2) previewlist_changes.list = /*preview*/ ctx[1];
			if (dirty & /*preview, value*/ 3) previewlist_changes.hasMore = /*preview*/ ctx[1].length < /*value*/ ctx[0].length;
			if (dirty & /*value*/ 1) previewlist_changes.label = "(" + /*value*/ ctx[0].length + ") ";

			if (dirty & /*$$scope, item*/ 48) {
				previewlist_changes.$$scope = { dirty, ctx };
			}

			previewlist.$set(previewlist_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(previewlist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(previewlist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(previewlist, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_preview_slot$7.name,
		type: "slot",
		source: "(11:2) <svelte:fragment slot=\\\"preview\\\">",
		ctx
	});

	return block;
}

// (18:2) <svelte:fragment slot="item_key" let:key>
function create_item_key_slot$7(ctx) {
	let span;
	let t_value = String(/*key*/ ctx[3]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "property");
			add_location(span, file$k, 17, 43, 716);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*key*/ 8 && t_value !== (t_value = String(/*key*/ ctx[3]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_key_slot$7.name,
		type: "slot",
		source: "(18:2) <svelte:fragment slot=\\\"item_key\\\" let:key>",
		ctx
	});

	return block;
}

// (19:2) <svelte:fragment slot="item_value" let:key>
function create_item_value_slot$7(ctx) {
	let jsonnode;
	let current;

	jsonnode = new JSONNode({
			props: { value: /*value*/ ctx[0][/*key*/ ctx[3]] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnode.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnode.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnode, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const jsonnode_changes = {};
			if (dirty & /*value, key*/ 9) jsonnode_changes.value = /*value*/ ctx[0][/*key*/ ctx[3]];
			jsonnode.$set(jsonnode_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnode, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_value_slot$7.name,
		type: "slot",
		source: "(19:2) <svelte:fragment slot=\\\"item_value\\\" let:key>",
		ctx
	});

	return block;
}

function create_fragment$l(ctx) {
	let jsonnested;
	let current;

	jsonnested = new JSONNested({
			props: {
				keys: /*keys*/ ctx[2],
				$$slots: {
					item_value: [
						create_item_value_slot$7,
						({ key }) => ({ 3: key }),
						({ key }) => key ? 8 : 0
					],
					item_key: [
						create_item_key_slot$7,
						({ key }) => ({ 3: key }),
						({ key }) => key ? 8 : 0
					],
					preview: [create_preview_slot$7],
					summary: [create_summary_slot$7]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnested.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnested.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnested, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const jsonnested_changes = {};
			if (dirty & /*keys*/ 4) jsonnested_changes.keys = /*keys*/ ctx[2];

			if (dirty & /*$$scope, value, key, preview*/ 43) {
				jsonnested_changes.$$scope = { dirty, ctx };
			}

			jsonnested.$set(jsonnested_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnested.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnested.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnested, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$l.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$k($$self, $$props, $$invalidate) {
	let keys;
	let preview;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('JSONArrayNode', slots, []);
	let { value } = $$props;

	$$self.$$.on_mount.push(function () {
		if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
			console.warn("<JSONArrayNode> was created without expected prop 'value'");
		}
	});

	const writable_props = ['value'];

	Object_1$2.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<JSONArrayNode> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
	};

	$$self.$capture_state = () => ({
		JSONNested,
		JSONNode,
		PreviewList,
		value,
		preview,
		keys
	});

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('preview' in $$props) $$invalidate(1, preview = $$props.preview);
		if ('keys' in $$props) $$invalidate(2, keys = $$props.keys);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			$$invalidate(2, keys = Object.getOwnPropertyNames(value));
		}

		if ($$self.$$.dirty & /*value*/ 1) {
			$$invalidate(1, preview = value.slice(0, 5));
		}
	};

	return [value, preview, keys];
}

class JSONArrayNode extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$k, create_fragment$l, safe_not_equal, { value: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "JSONArrayNode",
			options,
			id: create_fragment$l.name
		});
	}

	get value() {
		throw new Error("<JSONArrayNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<JSONArrayNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* ../../../node_modules/svelte-json-tree/_/JSONIterableArrayNode.svelte generated by Svelte v3.59.2 */
const file$j = "../../../node_modules/svelte-json-tree/_/JSONIterableArrayNode.svelte";

// (24:2) <svelte:fragment slot="summary">
function create_summary_slot$6(ctx) {
	let span;
	let t0;
	let t1;
	let t2_value = /*indexes*/ ctx[3].length + "";
	let t2;
	let t3;

	const block = {
		c: function create() {
			span = element("span");
			t0 = text(/*nodeType*/ ctx[1]);
			t1 = text("(");
			t2 = text(t2_value);
			t3 = text(")");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, /*nodeType*/ ctx[1]);
			t1 = claim_text(span_nodes, "(");
			t2 = claim_text(span_nodes, t2_value);
			t3 = claim_text(span_nodes, ")");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "label");
			add_location(span, file$j, 23, 34, 617);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t0);
			append_hydration_dev(span, t1);
			append_hydration_dev(span, t2);
			append_hydration_dev(span, t3);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*nodeType*/ 2) set_data_dev(t0, /*nodeType*/ ctx[1]);
			if (dirty & /*indexes*/ 8 && t2_value !== (t2_value = /*indexes*/ ctx[3].length + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_summary_slot$6.name,
		type: "slot",
		source: "(24:2) <svelte:fragment slot=\\\"summary\\\">",
		ctx
	});

	return block;
}

// (27:6) <svelte:fragment slot="item" let:item>
function create_item_slot$3(ctx) {
	let jsonnode;
	let current;

	jsonnode = new JSONNode({
			props: { value: /*item*/ ctx[8] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnode.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnode.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnode, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const jsonnode_changes = {};
			if (dirty & /*item*/ 256) jsonnode_changes.value = /*item*/ ctx[8];
			jsonnode.$set(jsonnode_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnode, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_slot$3.name,
		type: "slot",
		source: "(27:6) <svelte:fragment slot=\\\"item\\\" let:item>",
		ctx
	});

	return block;
}

// (25:2) <svelte:fragment slot="preview">
function create_preview_slot$6(ctx) {
	let previewlist;
	let current;

	previewlist = new PreviewList({
			props: {
				list: /*previewItems*/ ctx[4],
				hasMore: /*previewItems*/ ctx[4].length < /*items*/ ctx[2].length,
				label: `${/*nodeType*/ ctx[1]}(${/*indexes*/ ctx[3].length}) `,
				prefix: '{',
				postfix: "}",
				$$slots: {
					item: [
						create_item_slot$3,
						({ item }) => ({ 8: item }),
						({ item }) => item ? 256 : 0
					]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(previewlist.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(previewlist.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(previewlist, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const previewlist_changes = {};
			if (dirty & /*previewItems*/ 16) previewlist_changes.list = /*previewItems*/ ctx[4];
			if (dirty & /*previewItems, items*/ 20) previewlist_changes.hasMore = /*previewItems*/ ctx[4].length < /*items*/ ctx[2].length;
			if (dirty & /*nodeType, indexes*/ 10) previewlist_changes.label = `${/*nodeType*/ ctx[1]}(${/*indexes*/ ctx[3].length}) `;

			if (dirty & /*$$scope, item*/ 768) {
				previewlist_changes.$$scope = { dirty, ctx };
			}

			previewlist.$set(previewlist_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(previewlist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(previewlist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(previewlist, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_preview_slot$6.name,
		type: "slot",
		source: "(25:2) <svelte:fragment slot=\\\"preview\\\">",
		ctx
	});

	return block;
}

// (33:2) <svelte:fragment slot="item_key" let:key>
function create_item_key_slot_1$1(ctx) {
	let span;
	let t_value = /*key*/ ctx[6] + "";
	let t;
	let span_class_value;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", span_class_value = /*key*/ ctx[6] === ENTRIES$1 ? 'internal' : 'property');
			add_location(span, file$j, 32, 43, 1064);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*key*/ 64 && t_value !== (t_value = /*key*/ ctx[6] + "")) set_data_dev(t, t_value);

			if (dirty & /*key*/ 64 && span_class_value !== (span_class_value = /*key*/ ctx[6] === ENTRIES$1 ? 'internal' : 'property')) {
				attr_dev(span, "class", span_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_key_slot_1$1.name,
		type: "slot",
		source: "(33:2) <svelte:fragment slot=\\\"item_key\\\" let:key>",
		ctx
	});

	return block;
}

// (40:4) {:else}
function create_else_block$7(ctx) {
	let jsonnode;
	let current;

	jsonnode = new JSONNode({
			props: { value: /*value*/ ctx[0][/*key*/ ctx[6]] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnode.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnode.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnode, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const jsonnode_changes = {};
			if (dirty & /*value, key*/ 65) jsonnode_changes.value = /*value*/ ctx[0][/*key*/ ctx[6]];
			jsonnode.$set(jsonnode_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnode, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$7.name,
		type: "else",
		source: "(40:4) {:else}",
		ctx
	});

	return block;
}

// (35:4) {#if key === ENTRIES}
function create_if_block$d(ctx) {
	let jsonnested;
	let current;

	jsonnested = new JSONNested({
			props: {
				keys: /*indexes*/ ctx[3],
				defaultExpanded: true,
				$$slots: {
					item_value: [
						create_item_value_slot_1$1,
						({ key: index }) => ({ 7: index }),
						({ key: index }) => index ? 128 : 0
					],
					item_key: [
						create_item_key_slot$6,
						({ key: index }) => ({ 7: index }),
						({ key: index }) => index ? 128 : 0
					]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnested.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnested.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnested, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const jsonnested_changes = {};
			if (dirty & /*indexes*/ 8) jsonnested_changes.keys = /*indexes*/ ctx[3];

			if (dirty & /*$$scope, items, index*/ 644) {
				jsonnested_changes.$$scope = { dirty, ctx };
			}

			jsonnested.$set(jsonnested_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnested.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnested.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnested, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$d.name,
		type: "if",
		source: "(35:4) {#if key === ENTRIES}",
		ctx
	});

	return block;
}

// (37:8) <svelte:fragment slot="item_key" let:key={index}>
function create_item_key_slot$6(ctx) {
	let span;
	let t_value = /*index*/ ctx[7] + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "property");
			add_location(span, file$j, 36, 57, 1330);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*index*/ 128 && t_value !== (t_value = /*index*/ ctx[7] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_key_slot$6.name,
		type: "slot",
		source: "(37:8) <svelte:fragment slot=\\\"item_key\\\" let:key={index}>",
		ctx
	});

	return block;
}

// (38:8) <svelte:fragment slot="item_value" let:key={index}>
function create_item_value_slot_1$1(ctx) {
	let jsonnode;
	let current;

	jsonnode = new JSONNode({
			props: {
				value: /*items*/ ctx[2][/*index*/ ctx[7]]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnode.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnode.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnode, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const jsonnode_changes = {};
			if (dirty & /*items, index*/ 132) jsonnode_changes.value = /*items*/ ctx[2][/*index*/ ctx[7]];
			jsonnode.$set(jsonnode_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnode, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_value_slot_1$1.name,
		type: "slot",
		source: "(38:8) <svelte:fragment slot=\\\"item_value\\\" let:key={index}>",
		ctx
	});

	return block;
}

// (34:2) <svelte:fragment slot="item_value" let:key>
function create_item_value_slot$6(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$d, create_else_block$7];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*key*/ ctx[6] === ENTRIES$1) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_value_slot$6.name,
		type: "slot",
		source: "(34:2) <svelte:fragment slot=\\\"item_value\\\" let:key>",
		ctx
	});

	return block;
}

function create_fragment$k(ctx) {
	let jsonnested;
	let current;

	jsonnested = new JSONNested({
			props: {
				keys: [ENTRIES$1, 'size'],
				shouldShowColon: /*func*/ ctx[5],
				$$slots: {
					item_value: [
						create_item_value_slot$6,
						({ key }) => ({ 6: key }),
						({ key }) => key ? 64 : 0
					],
					item_key: [
						create_item_key_slot_1$1,
						({ key }) => ({ 6: key }),
						({ key }) => key ? 64 : 0
					],
					preview: [create_preview_slot$6],
					summary: [create_summary_slot$6]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnested.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnested.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnested, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const jsonnested_changes = {};

			if (dirty & /*$$scope, indexes, items, key, value, previewItems, nodeType*/ 607) {
				jsonnested_changes.$$scope = { dirty, ctx };
			}

			jsonnested.$set(jsonnested_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnested.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnested.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnested, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$k.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const ENTRIES$1 = '[[Entries]]';

function instance$j($$self, $$props, $$invalidate) {
	let previewItems;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('JSONIterableArrayNode', slots, []);
	let { value } = $$props;
	let { nodeType } = $$props;
	let indexes = [];
	let items = [];

	$$self.$$.on_mount.push(function () {
		if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
			console.warn("<JSONIterableArrayNode> was created without expected prop 'value'");
		}

		if (nodeType === undefined && !('nodeType' in $$props || $$self.$$.bound[$$self.$$.props['nodeType']])) {
			console.warn("<JSONIterableArrayNode> was created without expected prop 'nodeType'");
		}
	});

	const writable_props = ['value', 'nodeType'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<JSONIterableArrayNode> was created with unknown prop '${key}'`);
	});

	const func = key => key !== ENTRIES$1;

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('nodeType' in $$props) $$invalidate(1, nodeType = $$props.nodeType);
	};

	$$self.$capture_state = () => ({
		JSONNested,
		JSONNode,
		PreviewList,
		value,
		nodeType,
		indexes,
		items,
		ENTRIES: ENTRIES$1,
		previewItems
	});

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('nodeType' in $$props) $$invalidate(1, nodeType = $$props.nodeType);
		if ('indexes' in $$props) $$invalidate(3, indexes = $$props.indexes);
		if ('items' in $$props) $$invalidate(2, items = $$props.items);
		if ('previewItems' in $$props) $$invalidate(4, previewItems = $$props.previewItems);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			{
				let _indexes = [];
				let _items = [];
				let i = 0;

				for (const entry of value) {
					_indexes.push(i++);
					_items.push(entry);
				}

				$$invalidate(3, indexes = _indexes);
				$$invalidate(2, items = _items);
			}
		}

		if ($$self.$$.dirty & /*items*/ 4) {
			$$invalidate(4, previewItems = items.slice(0, 5));
		}
	};

	return [value, nodeType, items, indexes, previewItems, func];
}

class JSONIterableArrayNode extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$j, create_fragment$k, safe_not_equal, { value: 0, nodeType: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "JSONIterableArrayNode",
			options,
			id: create_fragment$k.name
		});
	}

	get value() {
		throw new Error("<JSONIterableArrayNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<JSONIterableArrayNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nodeType() {
		throw new Error("<JSONIterableArrayNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodeType(value) {
		throw new Error("<JSONIterableArrayNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* ../../../node_modules/svelte-json-tree/_/JSONIterableMapNode.svelte generated by Svelte v3.59.2 */
const file$i = "../../../node_modules/svelte-json-tree/_/JSONIterableMapNode.svelte";

// (29:2) <svelte:fragment slot="summary">
function create_summary_slot$5(ctx) {
	let span;
	let t0;
	let t1_value = /*keys*/ ctx[2].length + "";
	let t1;
	let t2;

	const block = {
		c: function create() {
			span = element("span");
			t0 = text("Map(");
			t1 = text(t1_value);
			t2 = text(")");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { color: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, "Map(");
			t1 = claim_text(span_nodes, t1_value);
			t2 = claim_text(span_nodes, ")");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "color", "label");
			add_location(span, file$i, 28, 34, 761);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t0);
			append_hydration_dev(span, t1);
			append_hydration_dev(span, t2);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*keys*/ 4 && t1_value !== (t1_value = /*keys*/ ctx[2].length + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_summary_slot$5.name,
		type: "slot",
		source: "(29:2) <svelte:fragment slot=\\\"summary\\\">",
		ctx
	});

	return block;
}

// (32:6) <svelte:fragment slot="item" let:item>
function create_item_slot$2(ctx) {
	let jsonnode0;
	let span;
	let t_value = ' => ' + "";
	let t;
	let jsonnode1;
	let current;

	jsonnode0 = new JSONNode({
			props: { value: /*item*/ ctx[10] },
			$$inline: true
		});

	jsonnode1 = new JSONNode({
			props: {
				value: /*value*/ ctx[0].get(/*item*/ ctx[10])
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnode0.$$.fragment);
			span = element("span");
			t = text(t_value);
			create_component(jsonnode1.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			claim_component(jsonnode0.$$.fragment, nodes);
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			claim_component(jsonnode1.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "operator");
			add_location(span, file$i, 32, 33, 1073);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnode0, target, anchor);
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
			mount_component(jsonnode1, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const jsonnode0_changes = {};
			if (dirty & /*item*/ 1024) jsonnode0_changes.value = /*item*/ ctx[10];
			jsonnode0.$set(jsonnode0_changes);
			const jsonnode1_changes = {};
			if (dirty & /*value, item*/ 1025) jsonnode1_changes.value = /*value*/ ctx[0].get(/*item*/ ctx[10]);
			jsonnode1.$set(jsonnode1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode0.$$.fragment, local);
			transition_in(jsonnode1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnode0.$$.fragment, local);
			transition_out(jsonnode1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnode0, detaching);
			if (detaching) detach_dev(span);
			destroy_component(jsonnode1, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_slot$2.name,
		type: "slot",
		source: "(32:6) <svelte:fragment slot=\\\"item\\\" let:item>",
		ctx
	});

	return block;
}

// (30:2) <svelte:fragment slot="preview">
function create_preview_slot_1(ctx) {
	let previewlist;
	let current;

	previewlist = new PreviewList({
			props: {
				list: /*previewKeys*/ ctx[4],
				hasMore: /*previewKeys*/ ctx[4].length < /*value*/ ctx[0].size,
				label: `Map(${/*keys*/ ctx[2].length}) `,
				prefix: `{`,
				postfix: "}",
				$$slots: {
					item: [
						create_item_slot$2,
						({ item }) => ({ 10: item }),
						({ item }) => item ? 1024 : 0
					]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(previewlist.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(previewlist.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(previewlist, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const previewlist_changes = {};
			if (dirty & /*previewKeys*/ 16) previewlist_changes.list = /*previewKeys*/ ctx[4];
			if (dirty & /*previewKeys, value*/ 17) previewlist_changes.hasMore = /*previewKeys*/ ctx[4].length < /*value*/ ctx[0].size;
			if (dirty & /*keys*/ 4) previewlist_changes.label = `Map(${/*keys*/ ctx[2].length}) `;

			if (dirty & /*$$scope, value, item*/ 3073) {
				previewlist_changes.$$scope = { dirty, ctx };
			}

			previewlist.$set(previewlist_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(previewlist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(previewlist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(previewlist, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_preview_slot_1.name,
		type: "slot",
		source: "(30:2) <svelte:fragment slot=\\\"preview\\\">",
		ctx
	});

	return block;
}

// (38:2) <svelte:fragment slot="item_key" let:key>
function create_item_key_slot_2(ctx) {
	let span;
	let t_value = /*key*/ ctx[7] + "";
	let t;
	let span_class_value;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", span_class_value = /*key*/ ctx[7] === ENTRIES ? 'internal' : 'property');
			add_location(span, file$i, 37, 43, 1257);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*key*/ 128 && t_value !== (t_value = /*key*/ ctx[7] + "")) set_data_dev(t, t_value);

			if (dirty & /*key*/ 128 && span_class_value !== (span_class_value = /*key*/ ctx[7] === ENTRIES ? 'internal' : 'property')) {
				attr_dev(span, "class", span_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_key_slot_2.name,
		type: "slot",
		source: "(38:2) <svelte:fragment slot=\\\"item_key\\\" let:key>",
		ctx
	});

	return block;
}

// (56:4) {:else}
function create_else_block$6(ctx) {
	let jsonnode;
	let current;

	jsonnode = new JSONNode({
			props: { value: /*value*/ ctx[0][/*key*/ ctx[7]] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnode.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnode.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnode, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const jsonnode_changes = {};
			if (dirty & /*value, key*/ 129) jsonnode_changes.value = /*value*/ ctx[0][/*key*/ ctx[7]];
			jsonnode.$set(jsonnode_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnode, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$6.name,
		type: "else",
		source: "(56:4) {:else}",
		ctx
	});

	return block;
}

// (40:4) {#if key === ENTRIES}
function create_if_block$c(ctx) {
	let jsonnested;
	let current;

	jsonnested = new JSONNested({
			props: {
				keys: /*indexes*/ ctx[1],
				expandKey: /*func*/ ctx[5],
				defaultExpanded: true,
				$$slots: {
					item_value: [
						create_item_value_slot_1,
						({ key: index }) => ({ 8: index }),
						({ key: index }) => index ? 256 : 0
					],
					item_key: [
						create_item_key_slot_1,
						({ key: index }) => ({ 8: index }),
						({ key: index }) => index ? 256 : 0
					]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnested.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnested.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnested, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const jsonnested_changes = {};
			if (dirty & /*indexes*/ 2) jsonnested_changes.keys = /*indexes*/ ctx[1];
			if (dirty & /*keys*/ 4) jsonnested_changes.expandKey = /*func*/ ctx[5];

			if (dirty & /*$$scope, keys, index, values*/ 2316) {
				jsonnested_changes.$$scope = { dirty, ctx };
			}

			jsonnested.$set(jsonnested_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnested.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnested.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnested, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$c.name,
		type: "if",
		source: "(40:4) {#if key === ENTRIES}",
		ctx
	});

	return block;
}

// (41:8) <svelte:fragment slot="item_key" let:key={index}>
function create_item_key_slot_1(ctx) {
	let span;
	let t_value = /*index*/ ctx[8] + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "property");
			add_location(span, file$i, 40, 57, 1551);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*index*/ 256 && t_value !== (t_value = /*index*/ ctx[8] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_key_slot_1.name,
		type: "slot",
		source: "(41:8) <svelte:fragment slot=\\\"item_key\\\" let:key={index}>",
		ctx
	});

	return block;
}

// (44:12) <svelte:fragment slot="preview"               >
function create_preview_slot$5(ctx) {
	let span0;
	let t0_value = '{ ' + "";
	let t0;
	let jsonnode0;
	let span1;
	let t1_value = ' => ' + "";
	let t1;
	let jsonnode1;
	let span2;
	let t2_value = ' }' + "";
	let t2;
	let current;

	jsonnode0 = new JSONNode({
			props: { value: /*keys*/ ctx[2][/*index*/ ctx[8]] },
			$$inline: true
		});

	jsonnode1 = new JSONNode({
			props: {
				value: /*values*/ ctx[3][/*index*/ ctx[8]]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			span0 = element("span");
			t0 = text(t0_value);
			create_component(jsonnode0.$$.fragment);
			span1 = element("span");
			t1 = text(t1_value);
			create_component(jsonnode1.$$.fragment);
			span2 = element("span");
			t2 = text(t2_value);
			this.h();
		},
		l: function claim(nodes) {
			span0 = claim_element(nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			t0 = claim_text(span0_nodes, t0_value);
			span0_nodes.forEach(detach_dev);
			claim_component(jsonnode0.$$.fragment, nodes);
			span1 = claim_element(nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			t1 = claim_text(span1_nodes, t1_value);
			span1_nodes.forEach(detach_dev);
			claim_component(jsonnode1.$$.fragment, nodes);
			span2 = claim_element(nodes, "SPAN", { class: true });
			var span2_nodes = children(span2);
			t2 = claim_text(span2_nodes, t2_value);
			span2_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span0, "class", "operator");
			add_location(span0, file$i, 44, 15, 1773);
			attr_dev(span1, "class", "operator");
			add_location(span1, file$i, 44, 83, 1841);
			attr_dev(span2, "class", "operator");
			add_location(span2, file$i, 46, 16, 1943);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span0, anchor);
			append_hydration_dev(span0, t0);
			mount_component(jsonnode0, target, anchor);
			insert_hydration_dev(target, span1, anchor);
			append_hydration_dev(span1, t1);
			mount_component(jsonnode1, target, anchor);
			insert_hydration_dev(target, span2, anchor);
			append_hydration_dev(span2, t2);
			current = true;
		},
		p: function update(ctx, dirty) {
			const jsonnode0_changes = {};
			if (dirty & /*keys, index*/ 260) jsonnode0_changes.value = /*keys*/ ctx[2][/*index*/ ctx[8]];
			jsonnode0.$set(jsonnode0_changes);
			const jsonnode1_changes = {};
			if (dirty & /*values, index*/ 264) jsonnode1_changes.value = /*values*/ ctx[3][/*index*/ ctx[8]];
			jsonnode1.$set(jsonnode1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode0.$$.fragment, local);
			transition_in(jsonnode1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnode0.$$.fragment, local);
			transition_out(jsonnode1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span0);
			destroy_component(jsonnode0, detaching);
			if (detaching) detach_dev(span1);
			destroy_component(jsonnode1, detaching);
			if (detaching) detach_dev(span2);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_preview_slot$5.name,
		type: "slot",
		source: "(44:12) <svelte:fragment slot=\\\"preview\\\"               >",
		ctx
	});

	return block;
}

// (49:12) <svelte:fragment slot="item_key" let:key={name}>
function create_item_key_slot$5(ctx) {
	let span;
	let t_value = /*name*/ ctx[9] + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "property");
			add_location(span, file$i, 48, 60, 2071);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*name*/ 512 && t_value !== (t_value = /*name*/ ctx[9] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_key_slot$5.name,
		type: "slot",
		source: "(49:12) <svelte:fragment slot=\\\"item_key\\\" let:key={name}>",
		ctx
	});

	return block;
}

// (50:12) <svelte:fragment slot="item_value" let:key={name}               >
function create_item_value_slot_2(ctx) {
	let jsonnode;
	let current;

	jsonnode = new JSONNode({
			props: {
				value: /*name*/ ctx[9] === 'key'
				? /*keys*/ ctx[2][/*index*/ ctx[8]]
				: /*values*/ ctx[3][/*index*/ ctx[8]]
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnode.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnode.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnode, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const jsonnode_changes = {};

			if (dirty & /*name, keys, index, values*/ 780) jsonnode_changes.value = /*name*/ ctx[9] === 'key'
			? /*keys*/ ctx[2][/*index*/ ctx[8]]
			: /*values*/ ctx[3][/*index*/ ctx[8]];

			jsonnode.$set(jsonnode_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnode, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_value_slot_2.name,
		type: "slot",
		source: "(50:12) <svelte:fragment slot=\\\"item_value\\\" let:key={name}               >",
		ctx
	});

	return block;
}

// (42:8) <svelte:fragment slot="item_value" let:key={index}>
function create_item_value_slot_1(ctx) {
	let jsonnested;
	let current;

	jsonnested = new JSONNested({
			props: {
				keys: ['key', 'value'],
				$$slots: {
					item_value: [
						create_item_value_slot_2,
						({ key: name }) => ({ 9: name }),
						({ key: name }) => name ? 512 : 0
					],
					item_key: [
						create_item_key_slot$5,
						({ key: name }) => ({ 9: name }),
						({ key: name }) => name ? 512 : 0
					],
					preview: [create_preview_slot$5]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnested.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnested.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnested, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const jsonnested_changes = {};

			if (dirty & /*$$scope, name, keys, index, values*/ 2828) {
				jsonnested_changes.$$scope = { dirty, ctx };
			}

			jsonnested.$set(jsonnested_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnested.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnested.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnested, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_value_slot_1.name,
		type: "slot",
		source: "(42:8) <svelte:fragment slot=\\\"item_value\\\" let:key={index}>",
		ctx
	});

	return block;
}

// (39:2) <svelte:fragment slot="item_value" let:key>
function create_item_value_slot$5(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$c, create_else_block$6];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*key*/ ctx[7] === ENTRIES) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_value_slot$5.name,
		type: "slot",
		source: "(39:2) <svelte:fragment slot=\\\"item_value\\\" let:key>",
		ctx
	});

	return block;
}

function create_fragment$j(ctx) {
	let jsonnested;
	let current;

	jsonnested = new JSONNested({
			props: {
				keys: [ENTRIES, 'size'],
				shouldShowColon: /*func_1*/ ctx[6],
				$$slots: {
					item_value: [
						create_item_value_slot$5,
						({ key }) => ({ 7: key }),
						({ key }) => key ? 128 : 0
					],
					item_key: [
						create_item_key_slot_2,
						({ key }) => ({ 7: key }),
						({ key }) => key ? 128 : 0
					],
					preview: [create_preview_slot_1],
					summary: [create_summary_slot$5]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnested.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnested.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnested, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const jsonnested_changes = {};

			if (dirty & /*$$scope, indexes, keys, values, key, value, previewKeys*/ 2207) {
				jsonnested_changes.$$scope = { dirty, ctx };
			}

			jsonnested.$set(jsonnested_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnested.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnested.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnested, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$j.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const ENTRIES = '[[Entries]]';

function instance$i($$self, $$props, $$invalidate) {
	let previewKeys;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('JSONIterableMapNode', slots, []);
	let { value } = $$props;
	useState();
	let indexes = [];
	let keys = [];
	let values = [];

	$$self.$$.on_mount.push(function () {
		if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
			console.warn("<JSONIterableMapNode> was created without expected prop 'value'");
		}
	});

	const writable_props = ['value'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<JSONIterableMapNode> was created with unknown prop '${key}'`);
	});

	const func = index => keys[index];
	const func_1 = key => key !== ENTRIES;

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
	};

	$$self.$capture_state = () => ({
		useState,
		JSONNested,
		JSONNode,
		PreviewList,
		value,
		indexes,
		keys,
		values,
		ENTRIES,
		previewKeys
	});

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('indexes' in $$props) $$invalidate(1, indexes = $$props.indexes);
		if ('keys' in $$props) $$invalidate(2, keys = $$props.keys);
		if ('values' in $$props) $$invalidate(3, values = $$props.values);
		if ('previewKeys' in $$props) $$invalidate(4, previewKeys = $$props.previewKeys);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			{
				let _indexes = [];
				let _keys = [];
				let _values = [];
				let i = 0;

				for (const entry of value) {
					_indexes.push(i++);
					_keys.push(entry[0]);
					_values.push(entry[1]);
				}

				$$invalidate(1, indexes = _indexes);
				$$invalidate(2, keys = _keys);
				$$invalidate(3, values = _values);
			}
		}

		if ($$self.$$.dirty & /*value*/ 1) {
			$$invalidate(4, previewKeys = Array.from(value.keys()).slice(0, 5));
		}
	};

	return [value, indexes, keys, values, previewKeys, func, func_1];
}

class JSONIterableMapNode extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$i, create_fragment$j, safe_not_equal, { value: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "JSONIterableMapNode",
			options,
			id: create_fragment$j.name
		});
	}

	get value() {
		throw new Error("<JSONIterableMapNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<JSONIterableMapNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* ../../../node_modules/svelte-json-tree/_/JSONValueNode.svelte generated by Svelte v3.59.2 */

const file$h = "../../../node_modules/svelte-json-tree/_/JSONValueNode.svelte";

function create_fragment$i(ctx) {
	let span;
	let t;
	let span_class_value;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*value*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, /*value*/ ctx[0]);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", span_class_value = "" + (null_to_empty(/*nodeType*/ ctx[1]) + " svelte-l95iub"));
			add_location(span, file$h, 3, 0, 48);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*value*/ 1) set_data_dev(t, /*value*/ ctx[0]);

			if (dirty & /*nodeType*/ 2 && span_class_value !== (span_class_value = "" + (null_to_empty(/*nodeType*/ ctx[1]) + " svelte-l95iub"))) {
				attr_dev(span, "class", span_class_value);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$i.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$h($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('JSONValueNode', slots, []);
	let { value, nodeType } = $$props;

	$$self.$$.on_mount.push(function () {
		if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
			console.warn("<JSONValueNode> was created without expected prop 'value'");
		}

		if (nodeType === undefined && !('nodeType' in $$props || $$self.$$.bound[$$self.$$.props['nodeType']])) {
			console.warn("<JSONValueNode> was created without expected prop 'nodeType'");
		}
	});

	const writable_props = ['value', 'nodeType'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<JSONValueNode> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('nodeType' in $$props) $$invalidate(1, nodeType = $$props.nodeType);
	};

	$$self.$capture_state = () => ({ value, nodeType });

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('nodeType' in $$props) $$invalidate(1, nodeType = $$props.nodeType);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [value, nodeType];
}

class JSONValueNode extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$h, create_fragment$i, safe_not_equal, { value: 0, nodeType: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "JSONValueNode",
			options,
			id: create_fragment$i.name
		});
	}

	get value() {
		throw new Error("<JSONValueNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<JSONValueNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nodeType() {
		throw new Error("<JSONValueNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodeType(value) {
		throw new Error("<JSONValueNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* ../../../node_modules/svelte-json-tree/_/ErrorStack.svelte generated by Svelte v3.59.2 */
const file$g = "../../../node_modules/svelte-json-tree/_/ErrorStack.svelte";

function get_each_context$7(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[6] = list[i];
	child_ctx[9] = i;
	const constants_0 = /*index*/ child_ctx[9] < /*stack*/ child_ctx[0].length - 1;
	child_ctx[7] = constants_0;
	return child_ctx;
}

// (14:2) {:else}
function create_else_block$5(ctx) {
	let span;
	let jsonnode;
	let current;

	jsonnode = new JSONNode({
			props: { value: /*stack*/ ctx[0][0] + '…' },
			$$inline: true
		});

	const block = {
		c: function create() {
			span = element("span");
			create_component(jsonnode.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			claim_component(jsonnode.$$.fragment, span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(span, file$g, 14, 4, 535);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			mount_component(jsonnode, span, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			const jsonnode_changes = {};
			if (dirty & /*stack*/ 1) jsonnode_changes.value = /*stack*/ ctx[0][0] + '…';
			jsonnode.$set(jsonnode_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(jsonnode);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$5.name,
		type: "else",
		source: "(14:2) {:else}",
		ctx
	});

	return block;
}

// (9:2) {#if $expanded}
function create_if_block$b(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*stack*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert_hydration_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty & /*stack*/ 1) {
				each_value = /*stack*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$7(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block$7(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$b.name,
		type: "if",
		source: "(9:2) {#if $expanded}",
		ctx
	});

	return block;
}

// (10:4) {#each stack as line, index}
function create_each_block$7(ctx) {
	let span1;
	let jsonnode;
	let span0;
	let t_value = (/*appendNewLine*/ ctx[7] ? ' +' : '') + "";
	let t;
	let br;
	let current;

	jsonnode = new JSONNode({
			props: {
				value: /*line*/ ctx[6] + (/*appendNewLine*/ ctx[7] ? '\\n' : '')
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			span1 = element("span");
			create_component(jsonnode.$$.fragment);
			span0 = element("span");
			t = text(t_value);
			br = element("br");
			this.h();
		},
		l: function claim(nodes) {
			span1 = claim_element(nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			claim_component(jsonnode.$$.fragment, span1_nodes);
			span0 = claim_element(span1_nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			t = claim_text(span0_nodes, t_value);
			span0_nodes.forEach(detach_dev);
			span1_nodes.forEach(detach_dev);
			br = claim_element(nodes, "BR", {});
			this.h();
		},
		h: function hydrate() {
			attr_dev(span0, "class", "operator");
			add_location(span0, file$g, 11, 93, 438);
			attr_dev(span1, "class", "svelte-1u08yw6");
			toggle_class(span1, "indent", /*index*/ ctx[9] > 0);
			add_location(span1, file$g, 11, 6, 351);
			add_location(br, file$g, 11, 157, 502);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span1, anchor);
			mount_component(jsonnode, span1, null);
			append_hydration_dev(span1, span0);
			append_hydration_dev(span0, t);
			insert_hydration_dev(target, br, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const jsonnode_changes = {};
			if (dirty & /*stack*/ 1) jsonnode_changes.value = /*line*/ ctx[6] + (/*appendNewLine*/ ctx[7] ? '\\n' : '');
			jsonnode.$set(jsonnode_changes);
			if ((!current || dirty & /*stack*/ 1) && t_value !== (t_value = (/*appendNewLine*/ ctx[7] ? ' +' : '') + "")) set_data_dev(t, t_value);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span1);
			destroy_component(jsonnode);
			if (detaching) detach_dev(br);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$7.name,
		type: "each",
		source: "(10:4) {#each stack as line, index}",
		ctx
	});

	return block;
}

function create_fragment$h(ctx) {
	let span;
	let current_block_type_index;
	let if_block;
	let current;
	let mounted;
	let dispose;
	const if_block_creators = [create_if_block$b, create_else_block$5];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*$expanded*/ ctx[1]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			span = element("span");
			if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", {});
			var span_nodes = children(span);
			if_block.l(span_nodes);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(span, file$g, 7, 0, 189);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			if_blocks[current_block_type_index].m(span, null);
			current = true;

			if (!mounted) {
				dispose = listen_dev(span, "click", /*click_handler*/ ctx[4], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(span, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			if_blocks[current_block_type_index].d();
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$h.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$g($$self, $$props, $$invalidate) {
	let $expandable;
	let $expanded;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ErrorStack', slots, []);
	let { stack } = $$props;
	const { expanded, expandable } = useState();
	validate_store(expanded, 'expanded');
	component_subscribe($$self, expanded, value => $$invalidate(1, $expanded = value));
	validate_store(expandable, 'expandable');
	component_subscribe($$self, expandable, value => $$invalidate(5, $expandable = value));
	set_store_value(expandable, $expandable = true, $expandable);

	$$self.$$.on_mount.push(function () {
		if (stack === undefined && !('stack' in $$props || $$self.$$.bound[$$self.$$.props['stack']])) {
			console.warn("<ErrorStack> was created without expected prop 'stack'");
		}
	});

	const writable_props = ['stack'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ErrorStack> was created with unknown prop '${key}'`);
	});

	const click_handler = () => set_store_value(expanded, $expanded = !$expanded, $expanded);

	$$self.$$set = $$props => {
		if ('stack' in $$props) $$invalidate(0, stack = $$props.stack);
	};

	$$self.$capture_state = () => ({
		JsonNode: JSONNode,
		useState,
		stack,
		expanded,
		expandable,
		$expandable,
		$expanded
	});

	$$self.$inject_state = $$props => {
		if ('stack' in $$props) $$invalidate(0, stack = $$props.stack);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [stack, $expanded, expanded, expandable, click_handler];
}

class ErrorStack extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$g, create_fragment$h, safe_not_equal, { stack: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ErrorStack",
			options,
			id: create_fragment$h.name
		});
	}

	get stack() {
		throw new Error("<ErrorStack>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set stack(value) {
		throw new Error("<ErrorStack>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* ../../../node_modules/svelte-json-tree/_/ErrorNode.svelte generated by Svelte v3.59.2 */
const file$f = "../../../node_modules/svelte-json-tree/_/ErrorNode.svelte";

// (9:2) <svelte:fragment slot="summary">
function create_summary_slot$4(ctx) {
	let span;
	let t0;
	let t1_value = String(/*value*/ ctx[0].message) + "";
	let t1;

	const block = {
		c: function create() {
			span = element("span");
			t0 = text("Error: ");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, "Error: ");
			t1 = claim_text(span_nodes, t1_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "label");
			add_location(span, file$f, 8, 34, 283);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t0);
			append_hydration_dev(span, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*value*/ 1 && t1_value !== (t1_value = String(/*value*/ ctx[0].message) + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_summary_slot$4.name,
		type: "slot",
		source: "(9:2) <svelte:fragment slot=\\\"summary\\\">",
		ctx
	});

	return block;
}

// (10:2) <svelte:fragment slot="preview">
function create_preview_slot$4(ctx) {
	let span;
	let t0;
	let t1_value = String(/*value*/ ctx[0].message) + "";
	let t1;

	const block = {
		c: function create() {
			span = element("span");
			t0 = text("Error: ");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, "Error: ");
			t1 = claim_text(span_nodes, t1_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "label");
			add_location(span, file$f, 9, 34, 393);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t0);
			append_hydration_dev(span, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*value*/ 1 && t1_value !== (t1_value = String(/*value*/ ctx[0].message) + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_preview_slot$4.name,
		type: "slot",
		source: "(10:2) <svelte:fragment slot=\\\"preview\\\">",
		ctx
	});

	return block;
}

// (11:2) <svelte:fragment slot="item_key" let:key>
function create_item_key_slot$4(ctx) {
	let span;
	let t_value = /*key*/ ctx[2] + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "property");
			add_location(span, file$f, 10, 43, 512);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*key*/ 4 && t_value !== (t_value = /*key*/ ctx[2] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_key_slot$4.name,
		type: "slot",
		source: "(11:2) <svelte:fragment slot=\\\"item_key\\\" let:key>",
		ctx
	});

	return block;
}

// (15:4) {:else}
function create_else_block$4(ctx) {
	let jsonnode;
	let current;

	jsonnode = new JSONNode({
			props: { value: /*value*/ ctx[0][/*key*/ ctx[2]] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnode.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnode.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnode, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const jsonnode_changes = {};
			if (dirty & /*value, key*/ 5) jsonnode_changes.value = /*value*/ ctx[0][/*key*/ ctx[2]];
			jsonnode.$set(jsonnode_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnode, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$4.name,
		type: "else",
		source: "(15:4) {:else}",
		ctx
	});

	return block;
}

// (13:4) {#if key === 'stack'}
function create_if_block$a(ctx) {
	let errorstack;
	let current;

	errorstack = new ErrorStack({
			props: { stack: /*stack*/ ctx[1] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(errorstack.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(errorstack.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(errorstack, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const errorstack_changes = {};
			if (dirty & /*stack*/ 2) errorstack_changes.stack = /*stack*/ ctx[1];
			errorstack.$set(errorstack_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(errorstack.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(errorstack.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(errorstack, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$a.name,
		type: "if",
		source: "(13:4) {#if key === 'stack'}",
		ctx
	});

	return block;
}

// (12:2) <svelte:fragment slot="item_value" let:key>
function create_item_value_slot$4(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$a, create_else_block$4];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*key*/ ctx[2] === 'stack') return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_value_slot$4.name,
		type: "slot",
		source: "(12:2) <svelte:fragment slot=\\\"item_value\\\" let:key>",
		ctx
	});

	return block;
}

function create_fragment$g(ctx) {
	let jsonnested;
	let current;

	jsonnested = new JSONNested({
			props: {
				keys: ['message', 'stack'],
				$$slots: {
					item_value: [
						create_item_value_slot$4,
						({ key }) => ({ 2: key }),
						({ key }) => key ? 4 : 0
					],
					item_key: [
						create_item_key_slot$4,
						({ key }) => ({ 2: key }),
						({ key }) => key ? 4 : 0
					],
					preview: [create_preview_slot$4],
					summary: [create_summary_slot$4]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnested.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnested.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnested, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const jsonnested_changes = {};

			if (dirty & /*$$scope, stack, key, value*/ 15) {
				jsonnested_changes.$$scope = { dirty, ctx };
			}

			jsonnested.$set(jsonnested_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnested.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnested.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnested, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$g.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$f($$self, $$props, $$invalidate) {
	let stack;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ErrorNode', slots, []);
	let { value } = $$props;

	$$self.$$.on_mount.push(function () {
		if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
			console.warn("<ErrorNode> was created without expected prop 'value'");
		}
	});

	const writable_props = ['value'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ErrorNode> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
	};

	$$self.$capture_state = () => ({
		ErrorStack,
		JsonNested: JSONNested,
		JSONNode,
		value,
		stack
	});

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('stack' in $$props) $$invalidate(1, stack = $$props.stack);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			$$invalidate(1, stack = value.stack.split('\n'));
		}
	};

	return [value, stack];
}

class ErrorNode extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$f, create_fragment$g, safe_not_equal, { value: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ErrorNode",
			options,
			id: create_fragment$g.name
		});
	}

	get value() {
		throw new Error("<ErrorNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<ErrorNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function objType(obj) {
    const type = Object.prototype.toString.call(obj).slice(8, -1);
    if (type === 'Object') {
        if (typeof obj[Symbol.iterator] === 'function') {
            return 'Iterable';
        }
        return obj.constructor.name;
    }
    return type;
}

/* ../../../node_modules/svelte-json-tree/_/JSONStringNode.svelte generated by Svelte v3.59.2 */
const file$e = "../../../node_modules/svelte-json-tree/_/JSONStringNode.svelte";

// (14:0) {:else}
function create_else_block$3(ctx) {
	let span;
	let t0;
	let t1;
	let t2;

	const block = {
		c: function create() {
			span = element("span");
			t0 = text("\"");
			t1 = text(/*serialised*/ ctx[0]);
			t2 = text("\"");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, "\"");
			t1 = claim_text(span_nodes, /*serialised*/ ctx[0]);
			t2 = claim_text(span_nodes, "\"");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "svelte-1fvwa9c");
			add_location(span, file$e, 14, 2, 368);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t0);
			append_hydration_dev(span, t1);
			append_hydration_dev(span, t2);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*serialised*/ 1) set_data_dev(t1, /*serialised*/ ctx[0]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$3.name,
		type: "else",
		source: "(14:0) {:else}",
		ctx
	});

	return block;
}

// (12:0) {#if displayMode === 'summary'}
function create_if_block$9(ctx) {
	let span;
	let t0;
	let t1_value = /*serialised*/ ctx[0].slice(0, 30) + (/*serialised*/ ctx[0].length > 30 ? '…' : '') + "";
	let t1;
	let t2;

	const block = {
		c: function create() {
			span = element("span");
			t0 = text("\"");
			t1 = text(t1_value);
			t2 = text("\"");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, "\"");
			t1 = claim_text(span_nodes, t1_value);
			t2 = claim_text(span_nodes, "\"");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "svelte-1fvwa9c");
			add_location(span, file$e, 12, 2, 279);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t0);
			append_hydration_dev(span, t1);
			append_hydration_dev(span, t2);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*serialised*/ 1 && t1_value !== (t1_value = /*serialised*/ ctx[0].slice(0, 30) + (/*serialised*/ ctx[0].length > 30 ? '…' : '') + "")) set_data_dev(t1, t1_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$9.name,
		type: "if",
		source: "(12:0) {#if displayMode === 'summary'}",
		ctx
	});

	return block;
}

function create_fragment$f(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*displayMode*/ ctx[1] === 'summary') return create_if_block$9;
		return create_else_block$3;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_block.m(target, anchor);
			insert_hydration_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if_block.p(ctx, dirty);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$f.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$e($$self, $$props, $$invalidate) {
	let serialised;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('JSONStringNode', slots, []);
	let { value } = $$props;
	const map = { '\n': '\\n', '\t': '\\t', '\r': '\\r' };
	const { displayMode } = useState();

	$$self.$$.on_mount.push(function () {
		if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
			console.warn("<JSONStringNode> was created without expected prop 'value'");
		}
	});

	const writable_props = ['value'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<JSONStringNode> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(2, value = $$props.value);
	};

	$$self.$capture_state = () => ({
		useState,
		value,
		map,
		displayMode,
		serialised
	});

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$invalidate(2, value = $$props.value);
		if ('serialised' in $$props) $$invalidate(0, serialised = $$props.serialised);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 4) {
			$$invalidate(0, serialised = value.replace(/[\n\t\r]/g, _ => map[_]));
		}
	};

	return [serialised, displayMode, value];
}

class JSONStringNode extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$e, create_fragment$f, safe_not_equal, { value: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "JSONStringNode",
			options,
			id: create_fragment$f.name
		});
	}

	get value() {
		throw new Error("<JSONStringNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<JSONStringNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* ../../../node_modules/svelte-json-tree/_/JSONFunctionNode.svelte generated by Svelte v3.59.2 */
const file$d = "../../../node_modules/svelte-json-tree/_/JSONFunctionNode.svelte";

// (66:2) <svelte:fragment slot="summary">
function create_summary_slot$3(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text("ƒ");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, "ƒ");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "i svelte-1eamqdt");
			add_location(span, file$d, 65, 34, 1956);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_summary_slot$3.name,
		type: "slot",
		source: "(66:2) <svelte:fragment slot=\\\"summary\\\">",
		ctx
	});

	return block;
}

// (68:5) {#if !ctx.isArrow}
function create_if_block_3$2(ctx) {
	let span;
	let t_value = getPreview1(/*ctx*/ ctx[2]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "fn i svelte-1eamqdt");
			add_location(span, file$d, 67, 23, 2056);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*ctx*/ 4 && t_value !== (t_value = getPreview1(/*ctx*/ ctx[2]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$2.name,
		type: "if",
		source: "(68:5) {#if !ctx.isArrow}",
		ctx
	});

	return block;
}

// (68:72) {#if !ctx.isClass}
function create_if_block_2$3(ctx) {
	let span;
	let t_value = getPreview2(/*ctx*/ ctx[2]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "i svelte-1eamqdt");
			add_location(span, file$d, 67, 90, 2123);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*ctx*/ 4 && t_value !== (t_value = getPreview2(/*ctx*/ ctx[2]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$3.name,
		type: "if",
		source: "(68:72) {#if !ctx.isClass}",
		ctx
	});

	return block;
}

// (67:2) <svelte:fragment slot="preview"     >
function create_preview_slot$3(ctx) {
	let if_block0_anchor;
	let if_block1_anchor;
	let if_block0 = !/*ctx*/ ctx[2].isArrow && create_if_block_3$2(ctx);
	let if_block1 = !/*ctx*/ ctx[2].isClass && create_if_block_2$3(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			if_block0_anchor = empty();
			if (if_block1) if_block1.c();
			if_block1_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block0) if_block0.l(nodes);
			if_block0_anchor = empty();
			if (if_block1) if_block1.l(nodes);
			if_block1_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration_dev(target, if_block0_anchor, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_hydration_dev(target, if_block1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (!/*ctx*/ ctx[2].isArrow) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_3$2(ctx);
					if_block0.c();
					if_block0.m(if_block0_anchor.parentNode, if_block0_anchor);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (!/*ctx*/ ctx[2].isClass) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_2$3(ctx);
					if_block1.c();
					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(if_block0_anchor);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(if_block1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_preview_slot$3.name,
		type: "slot",
		source: "(67:2) <svelte:fragment slot=\\\"preview\\\"     >",
		ctx
	});

	return block;
}

// (71:2) <svelte:fragment slot="item_key" let:key     >
function create_item_key_slot$3(ctx) {
	let span;
	let t_value = /*key*/ ctx[7] + "";
	let t;
	let span_class_value;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", span_class_value = /*key*/ ctx[7] === FUNCTION || /*key*/ ctx[7] === PROTO
			? 'internal'
			: 'property');

			add_location(span, file$d, 71, 5, 2246);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*key*/ 128 && t_value !== (t_value = /*key*/ ctx[7] + "")) set_data_dev(t, t_value);

			if (dirty & /*key*/ 128 && span_class_value !== (span_class_value = /*key*/ ctx[7] === FUNCTION || /*key*/ ctx[7] === PROTO
			? 'internal'
			: 'property')) {
				attr_dev(span, "class", span_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_key_slot$3.name,
		type: "slot",
		source: "(71:2) <svelte:fragment slot=\\\"item_key\\\" let:key     >",
		ctx
	});

	return block;
}

// (77:8) {:else}
function create_else_block$2(ctx) {
	let jsonnode;
	let current;

	jsonnode = new JSONNode({
			props: {
				value: /*getValue*/ ctx[3](/*key*/ ctx[7])
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnode.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnode.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnode, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const jsonnode_changes = {};
			if (dirty & /*key*/ 128) jsonnode_changes.value = /*getValue*/ ctx[3](/*key*/ ctx[7]);
			jsonnode.$set(jsonnode_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnode, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$2.name,
		type: "else",
		source: "(77:8) {:else}",
		ctx
	});

	return block;
}

// (75:85) 
function create_if_block_1$5(ctx) {
	let jsonobjectnode;
	let current;

	jsonobjectnode = new JSONObjectNode({
			props: {
				value: /*getValue*/ ctx[3](/*key*/ ctx[7])
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonobjectnode.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonobjectnode.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonobjectnode, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const jsonobjectnode_changes = {};
			if (dirty & /*key*/ 128) jsonobjectnode_changes.value = /*getValue*/ ctx[3](/*key*/ ctx[7]);
			jsonobjectnode.$set(jsonobjectnode_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonobjectnode.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonobjectnode.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonobjectnode, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$5.name,
		type: "if",
		source: "(75:85) ",
		ctx
	});

	return block;
}

// (75:5) {#if key === FUNCTION}
function create_if_block$8(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*str*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, /*str*/ ctx[0]);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "i svelte-1eamqdt");
			add_location(span, file$d, 74, 27, 2426);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*str*/ 1) set_data_dev(t, /*str*/ ctx[0]);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$8.name,
		type: "if",
		source: "(75:5) {#if key === FUNCTION}",
		ctx
	});

	return block;
}

// (74:2) <svelte:fragment slot="item_value" let:key     >
function create_item_value_slot$3(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block$8, create_if_block_1$5, create_else_block$2];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*key*/ ctx[7] === FUNCTION) return 0;
		if (/*key*/ ctx[7] === 'prototype') return 1;
		return 2;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert_hydration_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if_blocks[current_block_type_index].d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_value_slot$3.name,
		type: "slot",
		source: "(74:2) <svelte:fragment slot=\\\"item_value\\\" let:key     >",
		ctx
	});

	return block;
}

function create_fragment$e(ctx) {
	let jsonnested;
	let current;

	jsonnested = new JSONNested({
			props: {
				keys: /*keys*/ ctx[1],
				$$slots: {
					item_value: [
						create_item_value_slot$3,
						({ key }) => ({ 7: key }),
						({ key }) => key ? 128 : 0
					],
					item_key: [
						create_item_key_slot$3,
						({ key }) => ({ 7: key }),
						({ key }) => key ? 128 : 0
					],
					preview: [create_preview_slot$3],
					summary: [create_summary_slot$3]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnested.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnested.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnested, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const jsonnested_changes = {};
			if (dirty & /*keys*/ 2) jsonnested_changes.keys = /*keys*/ ctx[1];

			if (dirty & /*$$scope, str, key, ctx*/ 389) {
				jsonnested_changes.$$scope = { dirty, ctx };
			}

			jsonnested.$set(jsonnested_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnested.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnested.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnested, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$e.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const FUNCTION = '[[Function]]';
const PROTO = '[[Prototype]]';

function getPreview1({ isGenerator, isAsync, isClass }) {
	if (isClass) return `class ${isClass}`;
	return (isAsync ? 'async ' : '') + 'ƒ' + (isGenerator ? '*' : '');
}

function getPreview2({ isAsync, isArrow, fnName, args }) {
	return (isArrow && isAsync ? 'async' : '') + ' ' + (fnName ?? '') + args + (isArrow ? ' => …' : '');
}

function toString(value) {
	try {
		return value.toString();
	} catch {
		switch (value.constructor.name) {
			case 'AsyncFunction':
				return 'async function () {}';
			case 'AsyncGeneratorFunction':
				return 'async function * () {}';
			case 'GeneratorFunction:':
				return 'function * () {}';
			default:
				return 'function () {}';
		}
	}
}

function instance$d($$self, $$props, $$invalidate) {
	let str;
	let ctx;
	let keys;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('JSONFunctionNode', slots, []);
	let { value } = $$props;

	function parseFunction(str) {
		const match = str.match(/^(?:(async)\s+)?(?:function)?(\*)?\s*([^(]+)?(\([^)]*\))\s*(=>)?/);
		const isAsync = match?.[1];
		const isGenerator = match?.[2];
		const fnName = match?.[3];
		const args = match?.[4];
		const isArrow = match?.[5];
		const classMatch = str.match(/^class\s+([^\s]+)/);
		const isClass = classMatch?.[1];

		return {
			args,
			isAsync,
			isGenerator,
			fnName,
			isArrow,
			isClass
		};
	}

	function getValue(key) {
		if (key === PROTO) return value.__proto__;
		return value[key];
	}

	function filterKeys(key) {
		if (key === FUNCTION) return true;
		return getValue(key);
	}

	$$self.$$.on_mount.push(function () {
		if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
			console.warn("<JSONFunctionNode> was created without expected prop 'value'");
		}
	});

	const writable_props = ['value'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<JSONFunctionNode> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(4, value = $$props.value);
	};

	$$self.$capture_state = () => ({
		JSONNested,
		JSONNode,
		JsonObjectNode: JSONObjectNode,
		value,
		parseFunction,
		getPreview1,
		getPreview2,
		FUNCTION,
		PROTO,
		getValue,
		filterKeys,
		toString,
		keys,
		str,
		ctx
	});

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$invalidate(4, value = $$props.value);
		if ('keys' in $$props) $$invalidate(1, keys = $$props.keys);
		if ('str' in $$props) $$invalidate(0, str = $$props.str);
		if ('ctx' in $$props) $$invalidate(2, ctx = $$props.ctx);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 16) {
			$$invalidate(0, str = toString(value));
		}

		if ($$self.$$.dirty & /*str*/ 1) {
			$$invalidate(2, ctx = parseFunction(str));
		}
	};

	$$invalidate(1, keys = ['length', 'name', 'prototype', FUNCTION, PROTO].filter(filterKeys));
	return [str, keys, ctx, getValue, value];
}

class JSONFunctionNode extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$d, create_fragment$e, safe_not_equal, { value: 4 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "JSONFunctionNode",
			options,
			id: create_fragment$e.name
		});
	}

	get value() {
		throw new Error("<JSONFunctionNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<JSONFunctionNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* ../../../node_modules/svelte-json-tree/_/JSONSvelteStoreNode.svelte generated by Svelte v3.59.2 */

const { Object: Object_1$1 } = globals;
const file$c = "../../../node_modules/svelte-json-tree/_/JSONSvelteStoreNode.svelte";

// (19:2) <svelte:fragment slot="summary"     >
function create_summary_slot$2(ctx) {
	let span;
	let t0_value = (/*isWritableStore*/ ctx[3] ? 'writable(' : 'readable(') + "";
	let t0;
	let jsonnode;
	let t1_value = ')' + "";
	let t1;
	let current;

	jsonnode = new JSONNode({
			props: { value: /*storeValue*/ ctx[2] },
			$$inline: true
		});

	const block = {
		c: function create() {
			span = element("span");
			t0 = text(t0_value);
			create_component(jsonnode.$$.fragment);
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, t0_value);
			claim_component(jsonnode.$$.fragment, span_nodes);
			t1 = claim_text(span_nodes, t1_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "label");
			add_location(span, file$c, 19, 5, 579);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t0);
			mount_component(jsonnode, span, null);
			append_hydration_dev(span, t1);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*isWritableStore*/ 8) && t0_value !== (t0_value = (/*isWritableStore*/ ctx[3] ? 'writable(' : 'readable(') + "")) set_data_dev(t0, t0_value);
			const jsonnode_changes = {};
			if (dirty & /*storeValue*/ 4) jsonnode_changes.value = /*storeValue*/ ctx[2];
			jsonnode.$set(jsonnode_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
			destroy_component(jsonnode);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_summary_slot$2.name,
		type: "slot",
		source: "(19:2) <svelte:fragment slot=\\\"summary\\\"     >",
		ctx
	});

	return block;
}

// (24:6) <svelte:fragment slot="item" let:item         >
function create_item_slot$1(ctx) {
	let span0;
	let t0_value = /*item*/ ctx[9] + "";
	let t0;
	let span1;
	let t1_value = ': ' + "";
	let t1;
	let jsonnode;
	let current;

	jsonnode = new JSONNode({
			props: { value: /*value*/ ctx[0][/*item*/ ctx[9]] },
			$$inline: true
		});

	const block = {
		c: function create() {
			span0 = element("span");
			t0 = text(t0_value);
			span1 = element("span");
			t1 = text(t1_value);
			create_component(jsonnode.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			span0 = claim_element(nodes, "SPAN", { class: true });
			var span0_nodes = children(span0);
			t0 = claim_text(span0_nodes, t0_value);
			span0_nodes.forEach(detach_dev);
			span1 = claim_element(nodes, "SPAN", { class: true });
			var span1_nodes = children(span1);
			t1 = claim_text(span1_nodes, t1_value);
			span1_nodes.forEach(detach_dev);
			claim_component(jsonnode.$$.fragment, nodes);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span0, "class", "property");
			add_location(span0, file$c, 24, 9, 910);
			attr_dev(span1, "class", "operator");
			add_location(span1, file$c, 24, 45, 946);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span0, anchor);
			append_hydration_dev(span0, t0);
			insert_hydration_dev(target, span1, anchor);
			append_hydration_dev(span1, t1);
			mount_component(jsonnode, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty & /*item*/ 512) && t0_value !== (t0_value = /*item*/ ctx[9] + "")) set_data_dev(t0, t0_value);
			const jsonnode_changes = {};
			if (dirty & /*value, item*/ 513) jsonnode_changes.value = /*value*/ ctx[0][/*item*/ ctx[9]];
			jsonnode.$set(jsonnode_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span0);
			if (detaching) detach_dev(span1);
			destroy_component(jsonnode, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_slot$1.name,
		type: "slot",
		source: "(24:6) <svelte:fragment slot=\\\"item\\\" let:item         >",
		ctx
	});

	return block;
}

// (22:2) <svelte:fragment slot="preview">
function create_preview_slot$2(ctx) {
	let previewlist;
	let current;

	previewlist = new PreviewList({
			props: {
				list: /*previewKeys*/ ctx[4],
				hasMore: /*previewKeys*/ ctx[4].length < /*objectKeys*/ ctx[1].length,
				prefix: '{',
				postfix: '}',
				$$slots: {
					item: [
						create_item_slot$1,
						({ item }) => ({ 9: item }),
						({ item }) => item ? 512 : 0
					]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(previewlist.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(previewlist.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(previewlist, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const previewlist_changes = {};
			if (dirty & /*previewKeys*/ 16) previewlist_changes.list = /*previewKeys*/ ctx[4];
			if (dirty & /*previewKeys, objectKeys*/ 18) previewlist_changes.hasMore = /*previewKeys*/ ctx[4].length < /*objectKeys*/ ctx[1].length;

			if (dirty & /*$$scope, value, item*/ 1537) {
				previewlist_changes.$$scope = { dirty, ctx };
			}

			previewlist.$set(previewlist_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(previewlist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(previewlist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(previewlist, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_preview_slot$2.name,
		type: "slot",
		source: "(22:2) <svelte:fragment slot=\\\"preview\\\">",
		ctx
	});

	return block;
}

// (29:2) <svelte:fragment slot="item_key" let:key>
function create_item_key_slot$2(ctx) {
	let span;
	let t_value = /*key*/ ctx[8] + "";
	let t;
	let span_class_value;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", span_class_value = /*key*/ ctx[8] === STORE_VALUE ? 'internal' : 'property');
			add_location(span, file$c, 28, 43, 1123);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*key*/ 256 && t_value !== (t_value = /*key*/ ctx[8] + "")) set_data_dev(t, t_value);

			if (dirty & /*key*/ 256 && span_class_value !== (span_class_value = /*key*/ ctx[8] === STORE_VALUE ? 'internal' : 'property')) {
				attr_dev(span, "class", span_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_key_slot$2.name,
		type: "slot",
		source: "(29:2) <svelte:fragment slot=\\\"item_key\\\" let:key>",
		ctx
	});

	return block;
}

// (30:2) <svelte:fragment slot="item_value" let:key>
function create_item_value_slot$2(ctx) {
	let jsonnode;
	let current;

	jsonnode = new JSONNode({
			props: {
				value: /*getValue*/ ctx[6](/*key*/ ctx[8])
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnode.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnode.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnode, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const jsonnode_changes = {};
			if (dirty & /*key*/ 256) jsonnode_changes.value = /*getValue*/ ctx[6](/*key*/ ctx[8]);
			jsonnode.$set(jsonnode_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnode, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_value_slot$2.name,
		type: "slot",
		source: "(30:2) <svelte:fragment slot=\\\"item_value\\\" let:key>",
		ctx
	});

	return block;
}

function create_fragment$d(ctx) {
	let jsonnested;
	let current;

	jsonnested = new JSONNested({
			props: {
				keys: /*keys*/ ctx[5],
				$$slots: {
					item_value: [
						create_item_value_slot$2,
						({ key }) => ({ 8: key }),
						({ key }) => key ? 256 : 0
					],
					item_key: [
						create_item_key_slot$2,
						({ key }) => ({ 8: key }),
						({ key }) => key ? 256 : 0
					],
					preview: [create_preview_slot$2],
					summary: [create_summary_slot$2]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnested.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnested.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnested, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const jsonnested_changes = {};
			if (dirty & /*keys*/ 32) jsonnested_changes.keys = /*keys*/ ctx[5];

			if (dirty & /*$$scope, key, previewKeys, objectKeys, value, storeValue, isWritableStore*/ 1311) {
				jsonnested_changes.$$scope = { dirty, ctx };
			}

			jsonnested.$set(jsonnested_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnested.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnested.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnested, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$d.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const STORE_VALUE = '$value';

function instance$c($$self, $$props, $$invalidate) {
	let objectKeys;
	let keys;
	let previewKeys;
	let storeValue;
	let isWritableStore;

	let $value,
		$$unsubscribe_value = noop,
		$$subscribe_value = () => ($$unsubscribe_value(), $$unsubscribe_value = subscribe(value, $$value => $$invalidate(7, $value = $$value)), value);

	$$self.$$.on_destroy.push(() => $$unsubscribe_value());
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('JSONSvelteStoreNode', slots, []);
	let { value } = $$props;
	validate_store(value, 'value');
	$$subscribe_value();

	function getValue(key) {
		if (key === STORE_VALUE) return storeValue;
		return value[key];
	}

	$$self.$$.on_mount.push(function () {
		if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
			console.warn("<JSONSvelteStoreNode> was created without expected prop 'value'");
		}
	});

	const writable_props = ['value'];

	Object_1$1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<JSONSvelteStoreNode> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('value' in $$props) $$subscribe_value($$invalidate(0, value = $$props.value));
	};

	$$self.$capture_state = () => ({
		JSONNested,
		JSONNode,
		PreviewList,
		value,
		STORE_VALUE,
		getValue,
		storeValue,
		isWritableStore,
		objectKeys,
		previewKeys,
		keys,
		$value
	});

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$subscribe_value($$invalidate(0, value = $$props.value));
		if ('storeValue' in $$props) $$invalidate(2, storeValue = $$props.storeValue);
		if ('isWritableStore' in $$props) $$invalidate(3, isWritableStore = $$props.isWritableStore);
		if ('objectKeys' in $$props) $$invalidate(1, objectKeys = $$props.objectKeys);
		if ('previewKeys' in $$props) $$invalidate(4, previewKeys = $$props.previewKeys);
		if ('keys' in $$props) $$invalidate(5, keys = $$props.keys);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			$$invalidate(1, objectKeys = Object.getOwnPropertyNames(value));
		}

		if ($$self.$$.dirty & /*objectKeys*/ 2) {
			$$invalidate(5, keys = [STORE_VALUE, ...objectKeys]);
		}

		if ($$self.$$.dirty & /*objectKeys*/ 2) {
			$$invalidate(4, previewKeys = objectKeys.slice(0, 5));
		}

		if ($$self.$$.dirty & /*$value*/ 128) {
			$$invalidate(2, storeValue = $value);
		}

		if ($$self.$$.dirty & /*value*/ 1) {
			$$invalidate(3, isWritableStore = typeof value.set === 'function');
		}
	};

	return [
		value,
		objectKeys,
		storeValue,
		isWritableStore,
		previewKeys,
		keys,
		getValue,
		$value
	];
}

class JSONSvelteStoreNode extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$c, create_fragment$d, safe_not_equal, { value: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "JSONSvelteStoreNode",
			options,
			id: create_fragment$d.name
		});
	}

	get value() {
		throw new Error("<JSONSvelteStoreNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<JSONSvelteStoreNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* ../../../node_modules/svelte-json-tree/_/TypedArrayNode.svelte generated by Svelte v3.59.2 */

const { Object: Object_1 } = globals;
const file$b = "../../../node_modules/svelte-json-tree/_/TypedArrayNode.svelte";

// (19:2) <svelte:fragment slot="summary">
function create_summary_slot$1(ctx) {
	let span;
	let t0;
	let t1;
	let t2_value = /*value*/ ctx[0].length + "";
	let t2;
	let t3;

	const block = {
		c: function create() {
			span = element("span");
			t0 = text(/*nodeType*/ ctx[1]);
			t1 = text("(");
			t2 = text(t2_value);
			t3 = text(")");
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, /*nodeType*/ ctx[1]);
			t1 = claim_text(span_nodes, "(");
			t2 = claim_text(span_nodes, t2_value);
			t3 = claim_text(span_nodes, ")");
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "label");
			add_location(span, file$b, 18, 34, 617);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t0);
			append_hydration_dev(span, t1);
			append_hydration_dev(span, t2);
			append_hydration_dev(span, t3);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*nodeType*/ 2) set_data_dev(t0, /*nodeType*/ ctx[1]);
			if (dirty & /*value*/ 1 && t2_value !== (t2_value = /*value*/ ctx[0].length + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_summary_slot$1.name,
		type: "slot",
		source: "(19:2) <svelte:fragment slot=\\\"summary\\\">",
		ctx
	});

	return block;
}

// (22:6) <svelte:fragment slot="item" let:item>
function create_item_slot(ctx) {
	let jsonnode;
	let current;

	jsonnode = new JSONNode({
			props: { value: /*item*/ ctx[7] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnode.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnode.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnode, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const jsonnode_changes = {};
			if (dirty & /*item*/ 128) jsonnode_changes.value = /*item*/ ctx[7];
			jsonnode.$set(jsonnode_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnode, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_slot.name,
		type: "slot",
		source: "(22:6) <svelte:fragment slot=\\\"item\\\" let:item>",
		ctx
	});

	return block;
}

// (20:2) <svelte:fragment slot="preview">
function create_preview_slot$1(ctx) {
	let previewlist;
	let current;

	previewlist = new PreviewList({
			props: {
				list: /*preview*/ ctx[2],
				hasMore: /*preview*/ ctx[2].length < /*value*/ ctx[0].length,
				label: "" + (/*nodeType*/ ctx[1] + "(" + /*value*/ ctx[0].length + ") "),
				prefix: "[",
				postfix: "]",
				$$slots: {
					item: [
						create_item_slot,
						({ item }) => ({ 7: item }),
						({ item }) => item ? 128 : 0
					]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(previewlist.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(previewlist.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(previewlist, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const previewlist_changes = {};
			if (dirty & /*preview*/ 4) previewlist_changes.list = /*preview*/ ctx[2];
			if (dirty & /*preview, value*/ 5) previewlist_changes.hasMore = /*preview*/ ctx[2].length < /*value*/ ctx[0].length;
			if (dirty & /*nodeType, value*/ 3) previewlist_changes.label = "" + (/*nodeType*/ ctx[1] + "(" + /*value*/ ctx[0].length + ") ");

			if (dirty & /*$$scope, item*/ 384) {
				previewlist_changes.$$scope = { dirty, ctx };
			}

			previewlist.$set(previewlist_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(previewlist.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(previewlist.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(previewlist, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_preview_slot$1.name,
		type: "slot",
		source: "(20:2) <svelte:fragment slot=\\\"preview\\\">",
		ctx
	});

	return block;
}

// (27:2) <svelte:fragment slot="item_key" let:key     >
function create_item_key_slot$1(ctx) {
	let span;
	let t_value = String(/*key*/ ctx[6]) + "";
	let t;
	let span_class_value;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", span_class_value = /*internalKeys*/ ctx[4].includes(/*key*/ ctx[6])
			? 'internal'
			: 'property');

			add_location(span, file$b, 27, 5, 1048);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*key*/ 64 && t_value !== (t_value = String(/*key*/ ctx[6]) + "")) set_data_dev(t, t_value);

			if (dirty & /*key*/ 64 && span_class_value !== (span_class_value = /*internalKeys*/ ctx[4].includes(/*key*/ ctx[6])
			? 'internal'
			: 'property')) {
				attr_dev(span, "class", span_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_key_slot$1.name,
		type: "slot",
		source: "(27:2) <svelte:fragment slot=\\\"item_key\\\" let:key     >",
		ctx
	});

	return block;
}

// (30:2) <svelte:fragment slot="item_value" let:key>
function create_item_value_slot$1(ctx) {
	let jsonnode;
	let current;

	jsonnode = new JSONNode({
			props: {
				value: /*getValue*/ ctx[5](/*key*/ ctx[6])
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnode.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnode.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnode, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const jsonnode_changes = {};
			if (dirty & /*key*/ 64) jsonnode_changes.value = /*getValue*/ ctx[5](/*key*/ ctx[6]);
			jsonnode.$set(jsonnode_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnode, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_value_slot$1.name,
		type: "slot",
		source: "(30:2) <svelte:fragment slot=\\\"item_value\\\" let:key>",
		ctx
	});

	return block;
}

function create_fragment$c(ctx) {
	let jsonnested;
	let current;

	jsonnested = new JSONNested({
			props: {
				keys: /*keys*/ ctx[3],
				$$slots: {
					item_value: [
						create_item_value_slot$1,
						({ key }) => ({ 6: key }),
						({ key }) => key ? 64 : 0
					],
					item_key: [
						create_item_key_slot$1,
						({ key }) => ({ 6: key }),
						({ key }) => key ? 64 : 0
					],
					preview: [create_preview_slot$1],
					summary: [create_summary_slot$1]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnested.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnested.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnested, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const jsonnested_changes = {};
			if (dirty & /*keys*/ 8) jsonnested_changes.keys = /*keys*/ ctx[3];

			if (dirty & /*$$scope, key, preview, value, nodeType*/ 327) {
				jsonnested_changes.$$scope = { dirty, ctx };
			}

			jsonnested.$set(jsonnested_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnested.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnested.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnested, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$c.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const TO_STRING_TAG = 'Symbol(Symbol.toStringTag)';

function instance$b($$self, $$props, $$invalidate) {
	let keys;
	let preview;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('TypedArrayNode', slots, []);
	let { value } = $$props;
	let { nodeType } = $$props;
	const internalKeys = ['buffer', 'byteLength', 'byteOffset', 'length', TO_STRING_TAG];

	function getValue(key) {
		if (key === TO_STRING_TAG) {
			return value[Symbol.toStringTag];
		}

		return value[key];
	}

	$$self.$$.on_mount.push(function () {
		if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
			console.warn("<TypedArrayNode> was created without expected prop 'value'");
		}

		if (nodeType === undefined && !('nodeType' in $$props || $$self.$$.bound[$$self.$$.props['nodeType']])) {
			console.warn("<TypedArrayNode> was created without expected prop 'nodeType'");
		}
	});

	const writable_props = ['value', 'nodeType'];

	Object_1.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TypedArrayNode> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('nodeType' in $$props) $$invalidate(1, nodeType = $$props.nodeType);
	};

	$$self.$capture_state = () => ({
		JSONNested,
		JSONNode,
		PreviewList,
		value,
		nodeType,
		TO_STRING_TAG,
		internalKeys,
		getValue,
		preview,
		keys
	});

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('nodeType' in $$props) $$invalidate(1, nodeType = $$props.nodeType);
		if ('preview' in $$props) $$invalidate(2, preview = $$props.preview);
		if ('keys' in $$props) $$invalidate(3, keys = $$props.keys);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			$$invalidate(3, keys = [...Object.getOwnPropertyNames(value), ...internalKeys]);
		}

		if ($$self.$$.dirty & /*value*/ 1) {
			$$invalidate(2, preview = value.slice(0, 5));
		}
	};

	return [value, nodeType, preview, keys, internalKeys, getValue];
}

class TypedArrayNode extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$b, create_fragment$c, safe_not_equal, { value: 0, nodeType: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "TypedArrayNode",
			options,
			id: create_fragment$c.name
		});
	}

	get value() {
		throw new Error("<TypedArrayNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<TypedArrayNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get nodeType() {
		throw new Error("<TypedArrayNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set nodeType(value) {
		throw new Error("<TypedArrayNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* ../../../node_modules/svelte-json-tree/_/RegExpNode.svelte generated by Svelte v3.59.2 */
const file$a = "../../../node_modules/svelte-json-tree/_/RegExpNode.svelte";

// (9:2) <svelte:fragment slot="summary">
function create_summary_slot(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*str*/ ctx[1]);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, /*str*/ ctx[1]);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "regex svelte-17k1wqt");
			add_location(span, file$a, 8, 34, 336);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*str*/ 2) set_data_dev(t, /*str*/ ctx[1]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_summary_slot.name,
		type: "slot",
		source: "(9:2) <svelte:fragment slot=\\\"summary\\\">",
		ctx
	});

	return block;
}

// (10:2) <svelte:fragment slot="preview">
function create_preview_slot(ctx) {
	let span;
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(/*str*/ ctx[1]);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, /*str*/ ctx[1]);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "regex svelte-17k1wqt");
			add_location(span, file$a, 9, 34, 421);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*str*/ 2) set_data_dev(t, /*str*/ ctx[1]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_preview_slot.name,
		type: "slot",
		source: "(10:2) <svelte:fragment slot=\\\"preview\\\">",
		ctx
	});

	return block;
}

// (11:2) <svelte:fragment slot="item_key" let:key>
function create_item_key_slot(ctx) {
	let span;
	let t_value = String(/*key*/ ctx[3]) + "";
	let t;

	const block = {
		c: function create() {
			span = element("span");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			span = claim_element(nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t = claim_text(span_nodes, t_value);
			span_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "internal");
			add_location(span, file$a, 10, 43, 515);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, span, anchor);
			append_hydration_dev(span, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*key*/ 8 && t_value !== (t_value = String(/*key*/ ctx[3]) + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(span);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_key_slot.name,
		type: "slot",
		source: "(11:2) <svelte:fragment slot=\\\"item_key\\\" let:key>",
		ctx
	});

	return block;
}

// (12:2) <svelte:fragment slot="item_value" let:key>
function create_item_value_slot(ctx) {
	let jsonnode;
	let current;

	jsonnode = new JSONNode({
			props: { value: /*value*/ ctx[0][/*key*/ ctx[3]] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnode.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnode.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnode, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const jsonnode_changes = {};
			if (dirty & /*value, key*/ 9) jsonnode_changes.value = /*value*/ ctx[0][/*key*/ ctx[3]];
			jsonnode.$set(jsonnode_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnode, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_item_value_slot.name,
		type: "slot",
		source: "(12:2) <svelte:fragment slot=\\\"item_value\\\" let:key>",
		ctx
	});

	return block;
}

function create_fragment$b(ctx) {
	let jsonnested;
	let current;

	jsonnested = new JSONNested({
			props: {
				keys: /*keys*/ ctx[2],
				$$slots: {
					item_value: [
						create_item_value_slot,
						({ key }) => ({ 3: key }),
						({ key }) => key ? 8 : 0
					],
					item_key: [
						create_item_key_slot,
						({ key }) => ({ 3: key }),
						({ key }) => key ? 8 : 0
					],
					preview: [create_preview_slot],
					summary: [create_summary_slot]
				},
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnested.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnested.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnested, target, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const jsonnested_changes = {};

			if (dirty & /*$$scope, value, key, str*/ 27) {
				jsonnested_changes.$$scope = { dirty, ctx };
			}

			jsonnested.$set(jsonnested_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnested.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnested.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnested, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$b.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$a($$self, $$props, $$invalidate) {
	let str;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('RegExpNode', slots, []);
	let { value } = $$props;

	const keys = [
		'lastIndex',
		'dotAll',
		'flags',
		'global',
		'hasIndices',
		'ignoreCase',
		'multiline',
		'source',
		'sticky',
		'unicode'
	];

	$$self.$$.on_mount.push(function () {
		if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
			console.warn("<RegExpNode> was created without expected prop 'value'");
		}
	});

	const writable_props = ['value'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<RegExpNode> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
	};

	$$self.$capture_state = () => ({ JSONNested, JSONNode, value, keys, str });

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('str' in $$props) $$invalidate(1, str = $$props.str);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			$$invalidate(1, str = value.toString());
		}
	};

	return [value, str, keys];
}

class RegExpNode extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$a, create_fragment$b, safe_not_equal, { value: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "RegExpNode",
			options,
			id: create_fragment$b.name
		});
	}

	get value() {
		throw new Error("<RegExpNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<RegExpNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* ../../../node_modules/svelte-json-tree/_/JSONNode.svelte generated by Svelte v3.59.2 */

function create_fragment$a(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [{ value: /*value*/ ctx[0] }, /*props*/ ctx[1]];
	var switch_value = /*componentType*/ ctx[2];

	function switch_props(ctx) {
		let switch_instance_props = {};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = construct_svelte_component_dev(switch_value, switch_props());
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l: function claim(nodes) {
			if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) mount_component(switch_instance, target, anchor);
			insert_hydration_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const switch_instance_changes = (dirty & /*value, props*/ 3)
			? get_spread_update(switch_instance_spread_levels, [
					dirty & /*value*/ 1 && { value: /*value*/ ctx[0] },
					dirty & /*props*/ 2 && get_spread_object(/*props*/ ctx[1])
				])
			: {};

			if (dirty & /*componentType*/ 4 && switch_value !== (switch_value = /*componentType*/ ctx[2])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component_dev(switch_value, switch_props());
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$a.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$9($$self, $$props, $$invalidate) {
	let componentType;
	let props;
	let $nodeType;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('JSONNode', slots, []);
	let { value } = $$props;
	const nodeType = writable();
	validate_store(nodeType, 'nodeType');
	component_subscribe($$self, nodeType, value => $$invalidate(4, $nodeType = value));

	function getComponentAndProps(nodeType, value) {
		switch (nodeType) {
			case 'Object':
				if (typeof value.subscribe === 'function') return [JSONSvelteStoreNode];
				return [JSONObjectNode];
			case 'Error':
				return [ErrorNode];
			case 'Array':
				return [JSONArrayNode];
			case 'Map':
				return [JSONIterableMapNode];
			case 'Iterable':
			case 'Set':
				return [JSONIterableArrayNode, { nodeType }];
			case 'Number':
				return [JSONValueNode, { nodeType }];
			case 'String':
				return [JSONStringNode];
			case 'Boolean':
				return [
					JSONValueNode,
					{
						nodeType,
						value: value ? 'true' : 'false'
					}
				];
			case 'Date':
				return [JSONValueNode, { nodeType, value: value.toISOString() }];
			case 'Null':
				return [JSONValueNode, { nodeType, value: 'null' }];
			case 'Undefined':
				return [JSONValueNode, { nodeType, value: 'undefined' }];
			case 'Function':
			case 'AsyncFunction':
			case 'AsyncGeneratorFunction':
			case 'GeneratorFunction':
				return [JSONFunctionNode];
			case 'Symbol':
				return [JSONValueNode, { nodeType, value: value.toString() }];
			case 'BigInt':
				return [JSONValueNode, { nodeType, value: String(value) + 'n' }];
			case 'ArrayBuffer':
				return [
					JSONValueNode,
					{
						nodeType,
						value: `ArrayBuffer(${value.byteLength})`
					}
				];
			case 'BigInt64Array':
			case 'BigUint64Array':
			case 'Float32Array':
			case 'Float64Array':
			case 'Int8Array':
			case 'Int16Array':
			case 'Int32Array':
			case 'Uint8Array':
			case 'Uint8ClampedArray':
			case 'Uint16Array':
			case 'Uint32Array':
				return [TypedArrayNode, { nodeType }];
			case 'RegExp':
				return [RegExpNode];
			default:
				return [JSONValueNode, { nodeType, value: `<${nodeType}>` }];
		}
	}

	$$self.$$.on_mount.push(function () {
		if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
			console.warn("<JSONNode> was created without expected prop 'value'");
		}
	});

	const writable_props = ['value'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<JSONNode> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
	};

	$$self.$capture_state = () => ({
		JSONObjectNode,
		JSONArrayNode,
		JSONIterableArrayNode,
		JSONIterableMapNode,
		JSONValueNode,
		ErrorNode,
		objType,
		writable,
		JsonStringNode: JSONStringNode,
		JsonFunctionNode: JSONFunctionNode,
		JsonSvelteStoreNode: JSONSvelteStoreNode,
		TypedArrayNode,
		RegExpNode,
		value,
		nodeType,
		getComponentAndProps,
		props,
		componentType,
		$nodeType
	});

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('props' in $$props) $$invalidate(1, props = $$props.props);
		if ('componentType' in $$props) $$invalidate(2, componentType = $$props.componentType);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*value*/ 1) {
			set_store_value(nodeType, $nodeType = objType(value), $nodeType);
		}

		if ($$self.$$.dirty & /*$nodeType, value*/ 17) {
			$$invalidate(2, [componentType, props] = getComponentAndProps($nodeType, value), componentType, (($$invalidate(1, props), $$invalidate(4, $nodeType)), $$invalidate(0, value)));
		}
	};

	return [value, props, componentType, nodeType, $nodeType];
}

class JSONNode extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$9, create_fragment$a, safe_not_equal, { value: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "JSONNode",
			options,
			id: create_fragment$a.name
		});
	}

	get value() {
		throw new Error("<JSONNode>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<JSONNode>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

function getShouldExpandNode({ defaultExpandedPaths, defaultExpandedLevel, }) {
    const defaultExpandedPathsParts = defaultExpandedPaths.map(path => path.split('.'));
    function matchPath(keyPath) {
        outer: for (const parts of defaultExpandedPathsParts) {
            if (keyPath.length > parts.length)
                continue;
            const length = Math.min(keyPath.length, parts.length);
            for (let i = 0; i < length; i++) {
                if (parts[i] !== '*' && parts[i] !== String(keyPath[i]))
                    continue outer;
            }
            return true;
        }
        return false;
    }
    return function ({ keyPath, level }) {
        return level <= defaultExpandedLevel || matchPath(keyPath);
    };
}

/* ../../../node_modules/svelte-json-tree/_/Root.svelte generated by Svelte v3.59.2 */
const file$9 = "../../../node_modules/svelte-json-tree/_/Root.svelte";

// (22:2) <Expandable key="$" {expanded}>
function create_default_slot$1(ctx) {
	let jsonnode;
	let current;

	jsonnode = new JSONNode({
			props: { value: /*value*/ ctx[0] },
			$$inline: true
		});

	const block = {
		c: function create() {
			create_component(jsonnode.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(jsonnode.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(jsonnode, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const jsonnode_changes = {};
			if (dirty & /*value*/ 1) jsonnode_changes.value = /*value*/ ctx[0];
			jsonnode.$set(jsonnode_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsonnode.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsonnode.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(jsonnode, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot$1.name,
		type: "slot",
		source: "(22:2) <Expandable key=\\\"$\\\" {expanded}>",
		ctx
	});

	return block;
}

function create_fragment$9(ctx) {
	let ul;
	let expandable;
	let current;

	expandable = new Expandable({
			props: {
				key: "$",
				expanded: /*expanded*/ ctx[1],
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			ul = element("ul");
			create_component(expandable.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			ul = claim_element(nodes, "UL", { class: true });
			var ul_nodes = children(ul);
			claim_component(expandable.$$.fragment, ul_nodes);
			ul_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(ul, "class", "svelte-16cw61f");
			add_location(ul, file$9, 20, 0, 644);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, ul, anchor);
			mount_component(expandable, ul, null);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const expandable_changes = {};

			if (dirty & /*$$scope, value*/ 33) {
				expandable_changes.$$scope = { dirty, ctx };
			}

			expandable.$set(expandable_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(expandable.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(expandable.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(ul);
			destroy_component(expandable);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$9.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$8($$self, $$props, $$invalidate) {
	let shouldExpandNode;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Root', slots, []);
	let { value } = $$props;
	let { defaultExpandedPaths = [] } = $$props;
	let { defaultExpandedLevel = 0 } = $$props;
	const expanded = writable(true);

	useState({
		expanded,
		isParentExpanded: readable(true),
		root: true,
		shouldExpandNode: opts => shouldExpandNode(opts),
		level: 0,
		keyPath: []
	});

	$$self.$$.on_mount.push(function () {
		if (value === undefined && !('value' in $$props || $$self.$$.bound[$$self.$$.props['value']])) {
			console.warn("<Root> was created without expected prop 'value'");
		}
	});

	const writable_props = ['value', 'defaultExpandedPaths', 'defaultExpandedLevel'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Root> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('defaultExpandedPaths' in $$props) $$invalidate(2, defaultExpandedPaths = $$props.defaultExpandedPaths);
		if ('defaultExpandedLevel' in $$props) $$invalidate(3, defaultExpandedLevel = $$props.defaultExpandedLevel);
	};

	$$self.$capture_state = () => ({
		JSONNode,
		useState,
		readable,
		writable,
		Expandable,
		getShouldExpandNode,
		value,
		defaultExpandedPaths,
		defaultExpandedLevel,
		expanded,
		shouldExpandNode
	});

	$$self.$inject_state = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('defaultExpandedPaths' in $$props) $$invalidate(2, defaultExpandedPaths = $$props.defaultExpandedPaths);
		if ('defaultExpandedLevel' in $$props) $$invalidate(3, defaultExpandedLevel = $$props.defaultExpandedLevel);
		if ('shouldExpandNode' in $$props) shouldExpandNode = $$props.shouldExpandNode;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*defaultExpandedPaths, defaultExpandedLevel*/ 12) {
			shouldExpandNode = getShouldExpandNode({
				defaultExpandedPaths,
				defaultExpandedLevel
			});
		}
	};

	return [value, expanded, defaultExpandedPaths, defaultExpandedLevel];
}

class Root extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$8, create_fragment$9, safe_not_equal, {
			value: 0,
			defaultExpandedPaths: 2,
			defaultExpandedLevel: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Root",
			options,
			id: create_fragment$9.name
		});
	}

	get value() {
		throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set value(value) {
		throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get defaultExpandedPaths() {
		throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set defaultExpandedPaths(value) {
		throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get defaultExpandedLevel() {
		throw new Error("<Root>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set defaultExpandedLevel(value) {
		throw new Error("<Root>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/lib/components/Elements.svelte generated by Svelte v3.59.2 */

const file$8 = "src/lib/components/Elements.svelte";

function get_each_context$6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[1] = list[i].tag;
	child_ctx[2] = list[i].content;
	return child_ctx;
}

// (8:25) 
function create_if_block_1$4(ctx) {
	let pre;
	let t_value = /*content*/ ctx[2] + "";
	let t;

	const block = {
		c: function create() {
			pre = element("pre");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			pre = claim_element(nodes, "PRE", {});
			var pre_nodes = children(pre);
			t = claim_text(pre_nodes, t_value);
			pre_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(pre, file$8, 8, 2, 143);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, pre, anchor);
			append_hydration_dev(pre, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*elements*/ 1 && t_value !== (t_value = /*content*/ ctx[2] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(pre);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$4.name,
		type: "if",
		source: "(8:25) ",
		ctx
	});

	return block;
}

// (6:1) {#if tag === 'p'}
function create_if_block$7(ctx) {
	let p;
	let t_value = /*content*/ ctx[2] + "";
	let t;

	const block = {
		c: function create() {
			p = element("p");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t = claim_text(p_nodes, t_value);
			p_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file$8, 6, 2, 98);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, p, anchor);
			append_hydration_dev(p, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*elements*/ 1 && t_value !== (t_value = /*content*/ ctx[2] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$7.name,
		type: "if",
		source: "(6:1) {#if tag === 'p'}",
		ctx
	});

	return block;
}

// (5:0) {#each elements as {tag, content}}
function create_each_block$6(ctx) {
	let if_block_anchor;

	function select_block_type(ctx, dirty) {
		if (/*tag*/ ctx[1] === 'p') return create_if_block$7;
		if (/*tag*/ ctx[1] === 'pre') return create_if_block_1$4;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_hydration_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		d: function destroy(detaching) {
			if (if_block) {
				if_block.d(detaching);
			}

			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$6.name,
		type: "each",
		source: "(5:0) {#each elements as {tag, content}}",
		ctx
	});

	return block;
}

function create_fragment$8(ctx) {
	let each_1_anchor;
	let each_value = /*elements*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert_hydration_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*elements*/ 1) {
				each_value = /*elements*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$6(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$6(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$8.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$7($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Elements', slots, []);
	let { elements } = $$props;

	$$self.$$.on_mount.push(function () {
		if (elements === undefined && !('elements' in $$props || $$self.$$.bound[$$self.$$.props['elements']])) {
			console.warn("<Elements> was created without expected prop 'elements'");
		}
	});

	const writable_props = ['elements'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Elements> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('elements' in $$props) $$invalidate(0, elements = $$props.elements);
	};

	$$self.$capture_state = () => ({ elements });

	$$self.$inject_state = $$props => {
		if ('elements' in $$props) $$invalidate(0, elements = $$props.elements);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [elements];
}

class Elements extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$7, create_fragment$8, safe_not_equal, { elements: 0 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Elements",
			options,
			id: create_fragment$8.name
		});
	}

	get elements() {
		throw new Error("<Elements>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set elements(value) {
		throw new Error("<Elements>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var barchart = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BarchartVDiv: BarchartVDiv
});

/* ../../components/choropleth/src/ChoroplethDiv.svelte generated by Svelte v3.59.2 */
const file$7 = "../../components/choropleth/src/ChoroplethDiv.svelte";

// (45:1) {#if title}
function create_if_block$6(ctx) {
	let header;
	let h2;
	let t;

	const block = {
		c: function create() {
			header = element("header");
			h2 = element("h2");
			t = text(/*title*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			header = claim_element(nodes, "HEADER", { class: true });
			var header_nodes = children(header);
			h2 = claim_element(header_nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t = claim_text(h2_nodes, /*title*/ ctx[0]);
			h2_nodes.forEach(detach_dev);
			header_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h2, "class", "svelte-16q7f22");
			add_location(h2, file$7, 46, 3, 1007);
			attr_dev(header, "class", "svelte-16q7f22");
			add_location(header, file$7, 45, 2, 995);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, header, anchor);
			append_hydration_dev(header, h2);
			append_hydration_dev(h2, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title*/ 1) set_data_dev(t, /*title*/ ctx[0]);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(header);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$6.name,
		type: "if",
		source: "(45:1) {#if title}",
		ctx
	});

	return block;
}

function create_fragment$7(ctx) {
	let div;
	let t;
	let main;
	let svg;
	let choroplethg;
	let main_resize_listener;
	let current;
	let if_block = /*title*/ ctx[0] && create_if_block$6(ctx);

	choroplethg = new ChoroplethG({
			props: {
				focusedKey: /*focusedKey*/ ctx[5],
				geometry: /*geometry*/ ctx[6],
				height: /*height*/ ctx[16],
				isInteractive: /*isInteractive*/ ctx[7],
				key_alt: /*key_alt*/ ctx[4],
				key: /*key*/ ctx[3],
				keyToColor: /*keyToColor*/ ctx[8],
				keyToColorFn: /*keyToColorFn*/ ctx[9],
				message: /*message*/ ctx[10],
				projection: /*projection*/ ctx[11],
				projectionFn: /*projectionFn*/ ctx[12],
				projectionId: /*projectionId*/ ctx[13],
				selectedKeys: /*selectedKeys*/ ctx[14],
				theme: /*theme*/ ctx[15],
				topojson: /*topojson*/ ctx[1],
				topojsonId: /*topojsonId*/ ctx[2],
				width: /*width*/ ctx[17]
			},
			$$inline: true
		});

	choroplethg.$on("clicked", /*clicked_handler*/ ctx[21]);
	choroplethg.$on("entered", /*entered_handler*/ ctx[22]);
	choroplethg.$on("exited", /*exited_handler*/ ctx[23]);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block) if_block.c();
			t = space();
			main = element("main");
			svg = svg_element("svg");
			create_component(choroplethg.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true, style: true });
			var div_nodes = children(div);
			if (if_block) if_block.l(div_nodes);
			t = claim_space(div_nodes);
			main = claim_element(div_nodes, "MAIN", { class: true });
			var main_nodes = children(main);
			svg = claim_svg_element(main_nodes, "svg", { width: true, height: true, class: true });
			var svg_nodes = children(svg);
			claim_component(choroplethg.$$.fragment, svg_nodes);
			svg_nodes.forEach(detach_dev);
			main_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(svg, "width", /*width*/ ctx[17]);
			attr_dev(svg, "height", /*height*/ ctx[16]);
			attr_dev(svg, "class", "svelte-16q7f22");
			add_location(svg, file$7, 54, 2, 1150);
			attr_dev(main, "class", "svelte-16q7f22");
			add_render_callback(() => /*main_elementresize_handler*/ ctx[24].call(main));
			toggle_class(main, "titled", /*title*/ ctx[0] && /*title*/ ctx[0].length);
			add_location(main, file$7, 49, 1, 1044);
			attr_dev(div, "class", "ChoroplethDiv svelte-16q7f22");
			attr_dev(div, "style", /*style*/ ctx[18]);
			toggle_class(div, "interactive", /*isInteractive*/ ctx[7]);
			add_location(div, file$7, 39, 0, 906);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			if (if_block) if_block.m(div, null);
			append_hydration_dev(div, t);
			append_hydration_dev(div, main);
			append_hydration_dev(main, svg);
			mount_component(choroplethg, svg, null);
			main_resize_listener = add_iframe_resize_listener(main, /*main_elementresize_handler*/ ctx[24].bind(main));
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*title*/ ctx[0]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$6(ctx);
					if_block.c();
					if_block.m(div, t);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			const choroplethg_changes = {};
			if (dirty & /*focusedKey*/ 32) choroplethg_changes.focusedKey = /*focusedKey*/ ctx[5];
			if (dirty & /*geometry*/ 64) choroplethg_changes.geometry = /*geometry*/ ctx[6];
			if (dirty & /*height*/ 65536) choroplethg_changes.height = /*height*/ ctx[16];
			if (dirty & /*isInteractive*/ 128) choroplethg_changes.isInteractive = /*isInteractive*/ ctx[7];
			if (dirty & /*key_alt*/ 16) choroplethg_changes.key_alt = /*key_alt*/ ctx[4];
			if (dirty & /*key*/ 8) choroplethg_changes.key = /*key*/ ctx[3];
			if (dirty & /*keyToColor*/ 256) choroplethg_changes.keyToColor = /*keyToColor*/ ctx[8];
			if (dirty & /*keyToColorFn*/ 512) choroplethg_changes.keyToColorFn = /*keyToColorFn*/ ctx[9];
			if (dirty & /*message*/ 1024) choroplethg_changes.message = /*message*/ ctx[10];
			if (dirty & /*projection*/ 2048) choroplethg_changes.projection = /*projection*/ ctx[11];
			if (dirty & /*projectionFn*/ 4096) choroplethg_changes.projectionFn = /*projectionFn*/ ctx[12];
			if (dirty & /*projectionId*/ 8192) choroplethg_changes.projectionId = /*projectionId*/ ctx[13];
			if (dirty & /*selectedKeys*/ 16384) choroplethg_changes.selectedKeys = /*selectedKeys*/ ctx[14];
			if (dirty & /*theme*/ 32768) choroplethg_changes.theme = /*theme*/ ctx[15];
			if (dirty & /*topojson*/ 2) choroplethg_changes.topojson = /*topojson*/ ctx[1];
			if (dirty & /*topojsonId*/ 4) choroplethg_changes.topojsonId = /*topojsonId*/ ctx[2];
			if (dirty & /*width*/ 131072) choroplethg_changes.width = /*width*/ ctx[17];
			choroplethg.$set(choroplethg_changes);

			if (!current || dirty & /*width*/ 131072) {
				attr_dev(svg, "width", /*width*/ ctx[17]);
			}

			if (!current || dirty & /*height*/ 65536) {
				attr_dev(svg, "height", /*height*/ ctx[16]);
			}

			if (!current || dirty & /*title*/ 1) {
				toggle_class(main, "titled", /*title*/ ctx[0] && /*title*/ ctx[0].length);
			}

			if (!current || dirty & /*style*/ 262144) {
				attr_dev(div, "style", /*style*/ ctx[18]);
			}

			if (!current || dirty & /*isInteractive*/ 128) {
				toggle_class(div, "interactive", /*isInteractive*/ ctx[7]);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(choroplethg.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(choroplethg.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block) if_block.d();
			destroy_component(choroplethg);
			main_resize_listener();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$7.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$6($$self, $$props, $$invalidate) {
	let style;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ChoroplethDiv', slots, []);
	let { headerHeight } = $$props;
	let { padding } = $$props;
	let { title } = $$props;
	let { topojson = null } = $$props;
	let { topojsonId = null } = $$props;
	let { key = null } = $$props;
	let { key_alt = null } = $$props;
	let { focusedKey = null } = $$props;
	let { geometry = null } = $$props;
	let { isInteractive = false } = $$props;
	let { keyToColor = null } = $$props;
	let { keyToColorFn = null } = $$props;
	let { message = null } = $$props;
	let { projection = null } = $$props;
	let { projectionFn = null } = $$props;
	let { projectionId = null } = $$props;
	let { selectedKeys = [] } = $$props;
	let { theme = null } = $$props;
	let height = 0;
	let width = 0;

	$$self.$$.on_mount.push(function () {
		if (headerHeight === undefined && !('headerHeight' in $$props || $$self.$$.bound[$$self.$$.props['headerHeight']])) {
			console.warn("<ChoroplethDiv> was created without expected prop 'headerHeight'");
		}

		if (padding === undefined && !('padding' in $$props || $$self.$$.bound[$$self.$$.props['padding']])) {
			console.warn("<ChoroplethDiv> was created without expected prop 'padding'");
		}

		if (title === undefined && !('title' in $$props || $$self.$$.bound[$$self.$$.props['title']])) {
			console.warn("<ChoroplethDiv> was created without expected prop 'title'");
		}
	});

	const writable_props = [
		'headerHeight',
		'padding',
		'title',
		'topojson',
		'topojsonId',
		'key',
		'key_alt',
		'focusedKey',
		'geometry',
		'isInteractive',
		'keyToColor',
		'keyToColorFn',
		'message',
		'projection',
		'projectionFn',
		'projectionId',
		'selectedKeys',
		'theme'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ChoroplethDiv> was created with unknown prop '${key}'`);
	});

	function clicked_handler(event) {
		bubble.call(this, $$self, event);
	}

	function entered_handler(event) {
		bubble.call(this, $$self, event);
	}

	function exited_handler(event) {
		bubble.call(this, $$self, event);
	}

	function main_elementresize_handler() {
		width = this.clientWidth;
		height = this.clientHeight;
		$$invalidate(17, width);
		$$invalidate(16, height);
	}

	$$self.$$set = $$props => {
		if ('headerHeight' in $$props) $$invalidate(19, headerHeight = $$props.headerHeight);
		if ('padding' in $$props) $$invalidate(20, padding = $$props.padding);
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('topojson' in $$props) $$invalidate(1, topojson = $$props.topojson);
		if ('topojsonId' in $$props) $$invalidate(2, topojsonId = $$props.topojsonId);
		if ('key' in $$props) $$invalidate(3, key = $$props.key);
		if ('key_alt' in $$props) $$invalidate(4, key_alt = $$props.key_alt);
		if ('focusedKey' in $$props) $$invalidate(5, focusedKey = $$props.focusedKey);
		if ('geometry' in $$props) $$invalidate(6, geometry = $$props.geometry);
		if ('isInteractive' in $$props) $$invalidate(7, isInteractive = $$props.isInteractive);
		if ('keyToColor' in $$props) $$invalidate(8, keyToColor = $$props.keyToColor);
		if ('keyToColorFn' in $$props) $$invalidate(9, keyToColorFn = $$props.keyToColorFn);
		if ('message' in $$props) $$invalidate(10, message = $$props.message);
		if ('projection' in $$props) $$invalidate(11, projection = $$props.projection);
		if ('projectionFn' in $$props) $$invalidate(12, projectionFn = $$props.projectionFn);
		if ('projectionId' in $$props) $$invalidate(13, projectionId = $$props.projectionId);
		if ('selectedKeys' in $$props) $$invalidate(14, selectedKeys = $$props.selectedKeys);
		if ('theme' in $$props) $$invalidate(15, theme = $$props.theme);
	};

	$$self.$capture_state = () => ({
		makeStyleVars,
		ChoroplethG,
		headerHeight,
		padding,
		title,
		topojson,
		topojsonId,
		key,
		key_alt,
		focusedKey,
		geometry,
		isInteractive,
		keyToColor,
		keyToColorFn,
		message,
		projection,
		projectionFn,
		projectionId,
		selectedKeys,
		theme,
		height,
		width,
		style
	});

	$$self.$inject_state = $$props => {
		if ('headerHeight' in $$props) $$invalidate(19, headerHeight = $$props.headerHeight);
		if ('padding' in $$props) $$invalidate(20, padding = $$props.padding);
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('topojson' in $$props) $$invalidate(1, topojson = $$props.topojson);
		if ('topojsonId' in $$props) $$invalidate(2, topojsonId = $$props.topojsonId);
		if ('key' in $$props) $$invalidate(3, key = $$props.key);
		if ('key_alt' in $$props) $$invalidate(4, key_alt = $$props.key_alt);
		if ('focusedKey' in $$props) $$invalidate(5, focusedKey = $$props.focusedKey);
		if ('geometry' in $$props) $$invalidate(6, geometry = $$props.geometry);
		if ('isInteractive' in $$props) $$invalidate(7, isInteractive = $$props.isInteractive);
		if ('keyToColor' in $$props) $$invalidate(8, keyToColor = $$props.keyToColor);
		if ('keyToColorFn' in $$props) $$invalidate(9, keyToColorFn = $$props.keyToColorFn);
		if ('message' in $$props) $$invalidate(10, message = $$props.message);
		if ('projection' in $$props) $$invalidate(11, projection = $$props.projection);
		if ('projectionFn' in $$props) $$invalidate(12, projectionFn = $$props.projectionFn);
		if ('projectionId' in $$props) $$invalidate(13, projectionId = $$props.projectionId);
		if ('selectedKeys' in $$props) $$invalidate(14, selectedKeys = $$props.selectedKeys);
		if ('theme' in $$props) $$invalidate(15, theme = $$props.theme);
		if ('height' in $$props) $$invalidate(16, height = $$props.height);
		if ('width' in $$props) $$invalidate(17, width = $$props.width);
		if ('style' in $$props) $$invalidate(18, style = $$props.style);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*padding*/ 1048576) {
			$$invalidate(20, padding = padding || '10px');
		}

		if ($$self.$$.dirty & /*headerHeight*/ 524288) {
			$$invalidate(19, headerHeight = headerHeight || '2rem');
		}

		if ($$self.$$.dirty & /*headerHeight, padding*/ 1572864) {
			$$invalidate(18, style = makeStyleVars({ headerHeight, padding }));
		}
	};

	return [
		title,
		topojson,
		topojsonId,
		key,
		key_alt,
		focusedKey,
		geometry,
		isInteractive,
		keyToColor,
		keyToColorFn,
		message,
		projection,
		projectionFn,
		projectionId,
		selectedKeys,
		theme,
		height,
		width,
		style,
		headerHeight,
		padding,
		clicked_handler,
		entered_handler,
		exited_handler,
		main_elementresize_handler
	];
}

class ChoroplethDiv extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$6, create_fragment$7, safe_not_equal, {
			headerHeight: 19,
			padding: 20,
			title: 0,
			topojson: 1,
			topojsonId: 2,
			key: 3,
			key_alt: 4,
			focusedKey: 5,
			geometry: 6,
			isInteractive: 7,
			keyToColor: 8,
			keyToColorFn: 9,
			message: 10,
			projection: 11,
			projectionFn: 12,
			projectionId: 13,
			selectedKeys: 14,
			theme: 15
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ChoroplethDiv",
			options,
			id: create_fragment$7.name
		});
	}

	get headerHeight() {
		throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set headerHeight(value) {
		throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get padding() {
		throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set padding(value) {
		throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get topojson() {
		throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set topojson(value) {
		throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get topojsonId() {
		throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set topojsonId(value) {
		throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get key() {
		throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set key(value) {
		throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get key_alt() {
		throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set key_alt(value) {
		throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get focusedKey() {
		throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set focusedKey(value) {
		throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get geometry() {
		throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set geometry(value) {
		throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get isInteractive() {
		throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set isInteractive(value) {
		throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get keyToColor() {
		throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set keyToColor(value) {
		throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get keyToColorFn() {
		throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set keyToColorFn(value) {
		throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get message() {
		throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set message(value) {
		throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get projection() {
		throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set projection(value) {
		throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get projectionFn() {
		throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set projectionFn(value) {
		throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get projectionId() {
		throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set projectionId(value) {
		throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selectedKeys() {
		throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selectedKeys(value) {
		throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get theme() {
		throw new Error("<ChoroplethDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set theme(value) {
		throw new Error("<ChoroplethDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var ChoroplethDiv$1 = ChoroplethDiv;

var choropleth = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ChoroplethG: ChoroplethG,
	ChoroplethDiv: ChoroplethDiv$1,
	projections: projections,
	defaultGeometry: defaultGeometry
});

function count(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;
  else while (--i >= 0) sum += children[i].value;
  node.value = sum;
}

function node_count() {
  return this.eachAfter(count);
}

function node_each(callback, that) {
  let index = -1;
  for (const node of this) {
    callback.call(that, node, ++index, this);
  }
  return this;
}

function node_eachBefore(callback, that) {
  var node = this, nodes = [node], children, i, index = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index, this);
    if (children = node.children) {
      for (i = children.length - 1; i >= 0; --i) {
        nodes.push(children[i]);
      }
    }
  }
  return this;
}

function node_eachAfter(callback, that) {
  var node = this, nodes = [node], next = [], children, i, n, index = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children = node.children) {
      for (i = 0, n = children.length; i < n; ++i) {
        nodes.push(children[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index, this);
  }
  return this;
}

function node_find(callback, that) {
  let index = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index, this)) {
      return node;
    }
  }
}

function node_sum(value) {
  return this.eachAfter(function(node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;
    while (--i >= 0) sum += children[i].value;
    node.value = sum;
  });
}

function node_sort(compare) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}

function node_path(end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}

function node_ancestors() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}

function node_descendants() {
  return Array.from(this);
}

function node_leaves() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}

function node_links() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) { // Don’t include the root’s parent, if any.
      links.push({source: node.parent, target: node});
    }
  });
  return links;
}

function* node_iterator() {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children = node.children) {
        for (i = 0, n = children.length; i < n; ++i) {
          next.push(children[i]);
        }
      }
    }
  } while (next.length);
}

function hierarchy$1(data, children) {
  if (data instanceof Map) {
    data = [undefined, data];
    if (children === undefined) children = mapChildren;
  } else if (children === undefined) {
    children = objectChildren;
  }

  var root = new Node(data),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;

  while (node = nodes.pop()) {
    if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy$1(this).eachBefore(copyData);
}

function objectChildren(d) {
  return d.children;
}

function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}

function copyData(node) {
  if (node.data.value !== undefined) node.value = node.data.value;
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;
  do node.height = height;
  while ((node = node.parent) && (node.height < ++height));
}

function Node(data) {
  this.data = data;
  this.depth =
  this.height = 0;
  this.parent = null;
}

Node.prototype = hierarchy$1.prototype = {
  constructor: Node,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  find: node_find,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy,
  [Symbol.iterator]: node_iterator
};

function optional(f) {
  return f == null ? null : required(f);
}

function required(f) {
  if (typeof f !== "function") throw new Error;
  return f;
}

function constantZero() {
  return 0;
}

function constant(x) {
  return function() {
    return x;
  };
}

function roundNode(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}

function treemapDice(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (x1 - x0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}

var preroot = {depth: -1},
    ambiguous = {},
    imputed = {};

function defaultId(d) {
  return d.id;
}

function defaultParentId(d) {
  return d.parentId;
}

function stratify() {
  var id = defaultId,
      parentId = defaultParentId,
      path;

  function stratify(data) {
    var nodes = Array.from(data),
        currentId = id,
        currentParentId = parentId,
        n,
        d,
        i,
        root,
        parent,
        node,
        nodeId,
        nodeKey,
        nodeByKey = new Map;

    if (path != null) {
      const I = nodes.map((d, i) => normalize(path(d, i, data)));
      const P = I.map(parentof);
      const S = new Set(I).add("");
      for (const i of P) {
        if (!S.has(i)) {
          S.add(i);
          I.push(i);
          P.push(parentof(i));
          nodes.push(imputed);
        }
      }
      currentId = (_, i) => I[i];
      currentParentId = (_, i) => P[i];
    }

    for (i = 0, n = nodes.length; i < n; ++i) {
      d = nodes[i], node = nodes[i] = new Node(d);
      if ((nodeId = currentId(d, i, data)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = currentParentId(d, i, data)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }

    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);
        else parent.children = [node];
        node.parent = parent;
      } else {
        if (root) throw new Error("multiple roots");
        root = node;
      }
    }

    if (!root) throw new Error("no root");

    // When imputing internal nodes, only introduce roots if needed.
    // Then replace the imputed marker data with null.
    if (path != null) {
      while (root.data === imputed && root.children.length === 1) {
        root = root.children[0], --n;
      }
      for (let i = nodes.length - 1; i >= 0; --i) {
        node = nodes[i];
        if (node.data !== imputed) break;
        node.data = null;
      }
    }

    root.parent = preroot;
    root.eachBefore(function(node) { node.depth = node.parent.depth + 1; --n; }).eachBefore(computeHeight);
    root.parent = null;
    if (n > 0) throw new Error("cycle");

    return root;
  }

  stratify.id = function(x) {
    return arguments.length ? (id = optional(x), stratify) : id;
  };

  stratify.parentId = function(x) {
    return arguments.length ? (parentId = optional(x), stratify) : parentId;
  };

  stratify.path = function(x) {
    return arguments.length ? (path = optional(x), stratify) : path;
  };

  return stratify;
}

// To normalize a path, we coerce to a string, strip the trailing slash if any
// (as long as the trailing slash is not immediately preceded by another slash),
// and add leading slash if missing.
function normalize(path) {
  path = `${path}`;
  let i = path.length;
  if (slash(path, i - 1) && !slash(path, i - 2)) path = path.slice(0, -1);
  return path[0] === "/" ? path : `/${path}`;
}

// Walk backwards to find the first slash that is not the leading slash, e.g.:
// "/foo/bar" ⇥ "/foo", "/foo" ⇥ "/", "/" ↦ "". (The root is special-cased
// because the id of the root must be a truthy value.)
function parentof(path) {
  let i = path.length;
  if (i < 2) return "";
  while (--i > 1) if (slash(path, i)) break;
  return path.slice(0, i);
}

// Slashes can be escaped; to determine whether a slash is a path delimiter, we
// count the number of preceding backslashes escaping the forward slash: an odd
// number indicates an escaped forward slash.
function slash(path, i) {
  if (path[i] === "/") {
    let k = 0;
    while (i > 0 && path[--i] === "\\") ++k;
    if ((k & 1) === 0) return true;
  }
  return false;
}

function treemapSlice(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (y1 - y0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}

var phi = (1 + Math.sqrt(5)) / 2;

function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [],
      nodes = parent.children,
      row,
      nodeValue,
      i0 = 0,
      i1 = 0,
      n = nodes.length,
      dx, dy,
      value = parent.value,
      sumValue,
      minValue,
      maxValue,
      newRatio,
      minRatio,
      alpha,
      beta;

  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;

    // Find the next non-empty node.
    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);

    // Keep adding nodes while the aspect ratio maintains or improves.
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) { sumValue -= nodeValue; break; }
      minRatio = newRatio;
    }

    // Position and record the row orientation.
    rows.push(row = {value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1)});
    if (row.dice) treemapDice(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);
    else treemapSlice(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }

  return rows;
}

var squarify = (function custom(ratio) {

  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }

  squarify.ratio = function(x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return squarify;
})(phi);

function treemap() {
  var tile = squarify,
      round = false,
      dx = 1,
      dy = 1,
      paddingStack = [0],
      paddingInner = constantZero,
      paddingTop = constantZero,
      paddingRight = constantZero,
      paddingBottom = constantZero,
      paddingLeft = constantZero;

  function treemap(root) {
    root.x0 =
    root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root.eachBefore(roundNode);
    return root;
  }

  function positionNode(node) {
    var p = paddingStack[node.depth],
        x0 = node.x0 + p,
        y0 = node.y0 + p,
        x1 = node.x1 - p,
        y1 = node.y1 - p;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }

  treemap.round = function(x) {
    return arguments.length ? (round = !!x, treemap) : round;
  };

  treemap.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
  };

  treemap.tile = function(x) {
    return arguments.length ? (tile = required(x), treemap) : tile;
  };

  treemap.padding = function(x) {
    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
  };

  treemap.paddingInner = function(x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : constant(+x), treemap) : paddingInner;
  };

  treemap.paddingOuter = function(x) {
    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
  };

  treemap.paddingTop = function(x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : constant(+x), treemap) : paddingTop;
  };

  treemap.paddingRight = function(x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : constant(+x), treemap) : paddingRight;
  };

  treemap.paddingBottom = function(x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant(+x), treemap) : paddingBottom;
  };

  treemap.paddingLeft = function(x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant(+x), treemap) : paddingLeft;
  };

  return treemap;
}

/* ../../components/hierarchy/src/Treemap.svelte generated by Svelte v3.59.2 */
const file$6 = "../../components/hierarchy/src/Treemap.svelte";

function get_each_context$5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[27] = list[i].x0;
	child_ctx[28] = list[i].x1;
	child_ctx[29] = list[i].y0;
	child_ctx[30] = list[i].y1;
	child_ctx[31] = list[i].data.data;
	child_ctx[34] = list;
	child_ctx[35] = i;
	const constants_0 = Math.max(/*y1*/ child_ctx[30] - /*y0*/ child_ctx[29], 0);
	child_ctx[32] = constants_0;
	const constants_1 = Math.max(/*x1*/ child_ctx[28] - /*x0*/ child_ctx[27], 0);
	child_ctx[33] = constants_1;
	return child_ctx;
}

// (82:2) {#each treemapLeaves    as {x0, x1, y0, y1, data: {data}}
function create_each_block$5(ctx) {
	let g1;
	let rect;
	let rect_fill_value;
	let rect_height_value;
	let rect_width_value;
	let g0;
	let text0;
	let t0_value = /*keyAccessor*/ ctx[1](/*data*/ ctx[31]) + "";
	let t0;
	let text0_dx_value;
	let text0_dy_value;
	let text0_fill_value;
	let text0_maxheight_value;
	let text0_maxwidth_value;
	let text1;
	let t1_value = /*valueAccessor*/ ctx[4](/*data*/ ctx[31]) + "";
	let t1;
	let text1_dx_value;
	let text1_dy_value;
	let text1_fill_value;
	let g0_transform_value;
	let i = /*i*/ ctx[35];
	let g1_transform_value;
	let mounted;
	let dispose;
	const assign_g0 = () => /*g0_binding*/ ctx[20](g0, i);
	const unassign_g0 = () => /*g0_binding*/ ctx[20](null, i);

	function mousemove_handler(...args) {
		return /*mousemove_handler*/ ctx[21](/*data*/ ctx[31], ...args);
	}

	function mouseout_handler(...args) {
		return /*mouseout_handler*/ ctx[22](/*data*/ ctx[31], ...args);
	}

	function touchend_handler() {
		return /*touchend_handler*/ ctx[23](/*data*/ ctx[31]);
	}

	function touchstart_handler(...args) {
		return /*touchstart_handler*/ ctx[24](/*data*/ ctx[31], ...args);
	}

	const block = {
		c: function create() {
			g1 = svg_element("g");
			rect = svg_element("rect");
			g0 = svg_element("g");
			text0 = svg_element("text");
			t0 = text(t0_value);
			text1 = svg_element("text");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			g1 = claim_svg_element(nodes, "g", { role: true, transform: true });
			var g1_nodes = children(g1);

			rect = claim_svg_element(g1_nodes, "rect", {
				fill: true,
				height: true,
				"stroke-width": true,
				stroke: true,
				width: true
			});

			children(rect).forEach(detach_dev);
			g0 = claim_svg_element(g1_nodes, "g", { transform: true, class: true });
			var g0_nodes = children(g0);

			text0 = claim_svg_element(g0_nodes, "text", {
				dx: true,
				dy: true,
				fill: true,
				maxheight: true,
				maxwidth: true,
				class: true
			});

			var text0_nodes = children(text0);
			t0 = claim_text(text0_nodes, t0_value);
			text0_nodes.forEach(detach_dev);

			text1 = claim_svg_element(g0_nodes, "text", {
				dx: true,
				dy: true,
				fill: true,
				class: true
			});

			var text1_nodes = children(text1);
			t1 = claim_text(text1_nodes, t1_value);
			text1_nodes.forEach(detach_dev);
			g0_nodes.forEach(detach_dev);
			g1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "fill", rect_fill_value = /*keyToColorFn*/ ctx[2](/*keyAccessor*/ ctx[1](/*data*/ ctx[31])));
			attr_dev(rect, "height", rect_height_value = /*rectHeight*/ ctx[32]);
			attr_dev(rect, "stroke-width", 0.5);
			attr_dev(rect, "stroke", "var(--colorBorderAux)");
			attr_dev(rect, "width", rect_width_value = /*rectWidth*/ ctx[33]);
			add_location(rect, file$6, 99, 4, 2860);
			attr_dev(text0, "dx", text0_dx_value = /*geometry*/ ctx[0].textPadding);
			attr_dev(text0, "dy", text0_dy_value = /*geometry*/ ctx[0].textPadding);
			attr_dev(text0, "fill", text0_fill_value = /*keyToColorLabelFn*/ ctx[3](/*keyAccessor*/ ctx[1](/*data*/ ctx[31])));
			attr_dev(text0, "maxheight", text0_maxheight_value = /*rectHeight*/ ctx[32]);
			attr_dev(text0, "maxwidth", text0_maxwidth_value = /*rectWidth*/ ctx[33]);
			attr_dev(text0, "class", "svelte-bgsdbd");
			add_location(text0, file$6, 114, 5, 3264);
			attr_dev(text1, "dx", text1_dx_value = /*geometry*/ ctx[0].textPadding);
			attr_dev(text1, "dy", text1_dy_value = /*geometry*/ ctx[0].textPadding + /*geometry*/ ctx[0].lineHeight);
			attr_dev(text1, "fill", text1_fill_value = /*keyToColorLabelFn*/ ctx[3](/*keyAccessor*/ ctx[1](/*data*/ ctx[31])));
			attr_dev(text1, "class", "svelte-bgsdbd");
			add_location(text1, file$6, 121, 5, 3478);

			attr_dev(g0, "transform", g0_transform_value = !/*leavesChecks*/ ctx[9][/*i*/ ctx[35]][0] && /*leavesChecks*/ ctx[9][/*i*/ ctx[35]][1]
			? `translate(0,${/*rectHeight*/ ctx[32]}) rotate(-90)`
			: '');

			attr_dev(g0, "class", "svelte-bgsdbd");
			toggle_class(g0, "tooLarge", !/*leavesChecks*/ ctx[9][/*i*/ ctx[35]][0] && !/*leavesChecks*/ ctx[9][/*i*/ ctx[35]][1]);
			add_location(g0, file$6, 106, 4, 3029);
			attr_dev(g1, "role", "none");
			attr_dev(g1, "transform", g1_transform_value = "translate(" + (/*x0*/ ctx[27] || 0) + "," + (/*y0*/ ctx[29] || 0) + ")");
			add_location(g1, file$6, 88, 3, 2424);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, g1, anchor);
			append_hydration_dev(g1, rect);
			append_hydration_dev(g1, g0);
			append_hydration_dev(g0, text0);
			append_hydration_dev(text0, t0);
			append_hydration_dev(g0, text1);
			append_hydration_dev(text1, t1);
			assign_g0();

			if (!mounted) {
				dispose = [
					listen_dev(g1, "mousemove", mousemove_handler, false, false, false, false),
					listen_dev(g1, "mouseout", mouseout_handler, false, false, false, false),
					listen_dev(g1, "touchend", touchend_handler, { passive: true }, false, false, false),
					listen_dev(g1, "touchstart", prevent_default(touchstart_handler), false, true, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*keyToColorFn, keyAccessor, treemapLeaves*/ 262 && rect_fill_value !== (rect_fill_value = /*keyToColorFn*/ ctx[2](/*keyAccessor*/ ctx[1](/*data*/ ctx[31])))) {
				attr_dev(rect, "fill", rect_fill_value);
			}

			if (dirty[0] & /*treemapLeaves*/ 256 && rect_height_value !== (rect_height_value = /*rectHeight*/ ctx[32])) {
				attr_dev(rect, "height", rect_height_value);
			}

			if (dirty[0] & /*treemapLeaves*/ 256 && rect_width_value !== (rect_width_value = /*rectWidth*/ ctx[33])) {
				attr_dev(rect, "width", rect_width_value);
			}

			if (dirty[0] & /*keyAccessor, treemapLeaves*/ 258 && t0_value !== (t0_value = /*keyAccessor*/ ctx[1](/*data*/ ctx[31]) + "")) set_data_dev(t0, t0_value);

			if (dirty[0] & /*geometry*/ 1 && text0_dx_value !== (text0_dx_value = /*geometry*/ ctx[0].textPadding)) {
				attr_dev(text0, "dx", text0_dx_value);
			}

			if (dirty[0] & /*geometry*/ 1 && text0_dy_value !== (text0_dy_value = /*geometry*/ ctx[0].textPadding)) {
				attr_dev(text0, "dy", text0_dy_value);
			}

			if (dirty[0] & /*keyToColorLabelFn, keyAccessor, treemapLeaves*/ 266 && text0_fill_value !== (text0_fill_value = /*keyToColorLabelFn*/ ctx[3](/*keyAccessor*/ ctx[1](/*data*/ ctx[31])))) {
				attr_dev(text0, "fill", text0_fill_value);
			}

			if (dirty[0] & /*treemapLeaves*/ 256 && text0_maxheight_value !== (text0_maxheight_value = /*rectHeight*/ ctx[32])) {
				attr_dev(text0, "maxheight", text0_maxheight_value);
			}

			if (dirty[0] & /*treemapLeaves*/ 256 && text0_maxwidth_value !== (text0_maxwidth_value = /*rectWidth*/ ctx[33])) {
				attr_dev(text0, "maxwidth", text0_maxwidth_value);
			}

			if (dirty[0] & /*valueAccessor, treemapLeaves*/ 272 && t1_value !== (t1_value = /*valueAccessor*/ ctx[4](/*data*/ ctx[31]) + "")) set_data_dev(t1, t1_value);

			if (dirty[0] & /*geometry*/ 1 && text1_dx_value !== (text1_dx_value = /*geometry*/ ctx[0].textPadding)) {
				attr_dev(text1, "dx", text1_dx_value);
			}

			if (dirty[0] & /*geometry*/ 1 && text1_dy_value !== (text1_dy_value = /*geometry*/ ctx[0].textPadding + /*geometry*/ ctx[0].lineHeight)) {
				attr_dev(text1, "dy", text1_dy_value);
			}

			if (dirty[0] & /*keyToColorLabelFn, keyAccessor, treemapLeaves*/ 266 && text1_fill_value !== (text1_fill_value = /*keyToColorLabelFn*/ ctx[3](/*keyAccessor*/ ctx[1](/*data*/ ctx[31])))) {
				attr_dev(text1, "fill", text1_fill_value);
			}

			if (dirty[0] & /*leavesChecks, treemapLeaves*/ 768 && g0_transform_value !== (g0_transform_value = !/*leavesChecks*/ ctx[9][/*i*/ ctx[35]][0] && /*leavesChecks*/ ctx[9][/*i*/ ctx[35]][1]
			? `translate(0,${/*rectHeight*/ ctx[32]}) rotate(-90)`
			: '')) {
				attr_dev(g0, "transform", g0_transform_value);
			}

			if (i !== /*i*/ ctx[35]) {
				unassign_g0();
				i = /*i*/ ctx[35];
				assign_g0();
			}

			if (dirty[0] & /*leavesChecks*/ 512) {
				toggle_class(g0, "tooLarge", !/*leavesChecks*/ ctx[9][/*i*/ ctx[35]][0] && !/*leavesChecks*/ ctx[9][/*i*/ ctx[35]][1]);
			}

			if (dirty[0] & /*treemapLeaves*/ 256 && g1_transform_value !== (g1_transform_value = "translate(" + (/*x0*/ ctx[27] || 0) + "," + (/*y0*/ ctx[29] || 0) + ")")) {
				attr_dev(g1, "transform", g1_transform_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(g1);
			unassign_g0();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$5.name,
		type: "each",
		source: "(82:2) {#each treemapLeaves    as {x0, x1, y0, y1, data: {data}}",
		ctx
	});

	return block;
}

function create_fragment$6(ctx) {
	let div;
	let svg;
	let mounted;
	let dispose;
	let each_value = /*treemapLeaves*/ ctx[8];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div = element("div");
			svg = svg_element("svg");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			svg = claim_svg_element(div_nodes, "svg", { height: true, width: true, class: true });
			var svg_nodes = children(svg);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(svg_nodes);
			}

			svg_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(svg, "height", /*treemapHeight*/ ctx[5]);
			attr_dev(svg, "width", /*treemapWidth*/ ctx[6]);
			attr_dev(svg, "class", "svelte-bgsdbd");
			add_location(svg, file$6, 77, 1, 2146);
			attr_dev(div, "class", "Treemap svelte-bgsdbd");
			add_location(div, file$6, 73, 0, 2103);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, svg);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(svg, null);
				}
			}

			if (!mounted) {
				dispose = action_destroyer(/*sizeObserver*/ ctx[12].call(null, div));
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*treemapLeaves, dispatch, leavesChecks, textGroups, geometry, keyToColorLabelFn, keyAccessor, valueAccessor, keyToColorFn*/ 1951) {
				each_value = /*treemapLeaves*/ ctx[8];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$5(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$5(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(svg, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty[0] & /*treemapHeight*/ 32) {
				attr_dev(svg, "height", /*treemapHeight*/ ctx[5]);
			}

			if (dirty[0] & /*treemapWidth*/ 64) {
				attr_dev(svg, "width", /*treemapWidth*/ ctx[6]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$6.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$5($$self, $$props, $$invalidate) {
	let getHierarchy;
	let getTreeRoot;
	let getTreemap;
	let treeRoot;
	let treemapLeaves;
	let textBboxes;
	let leavesChecks;
	let $_size;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Treemap', slots, []);
	let { geometry } = $$props;
	let { items } = $$props;
	let { keyAccessor = getKey$1 } = $$props;
	let { keyToColorFn } = $$props;
	let { keyToColorLabelFn } = $$props;
	let { valueAccessor = getValue } = $$props;
	let treemapHeight;
	let treemapWidth;

	const defaultGeometry = {
		lineHeight: 20,
		paddingInner: 5,
		paddingOuter: 2,
		textPadding: 8
	};

	const dispatch = createEventDispatcher();
	const { _writable: _size, resizeObserver: sizeObserver } = setupResizeObserver();
	validate_store(_size, '_size');
	component_subscribe($$self, _size, value => $$invalidate(19, $_size = value));
	const stratifyData = stratify().path(identity);
	let textGroups;

	$$self.$$.on_mount.push(function () {
		if (geometry === undefined && !('geometry' in $$props || $$self.$$.bound[$$self.$$.props['geometry']])) {
			console.warn("<Treemap> was created without expected prop 'geometry'");
		}

		if (items === undefined && !('items' in $$props || $$self.$$.bound[$$self.$$.props['items']])) {
			console.warn("<Treemap> was created without expected prop 'items'");
		}

		if (keyToColorFn === undefined && !('keyToColorFn' in $$props || $$self.$$.bound[$$self.$$.props['keyToColorFn']])) {
			console.warn("<Treemap> was created without expected prop 'keyToColorFn'");
		}

		if (keyToColorLabelFn === undefined && !('keyToColorLabelFn' in $$props || $$self.$$.bound[$$self.$$.props['keyToColorLabelFn']])) {
			console.warn("<Treemap> was created without expected prop 'keyToColorLabelFn'");
		}
	});

	const writable_props = [
		'geometry',
		'items',
		'keyAccessor',
		'keyToColorFn',
		'keyToColorLabelFn',
		'valueAccessor'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Treemap> was created with unknown prop '${key}'`);
	});

	function g0_binding($$value, i) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			textGroups[i] = $$value;
			((((((((((($$invalidate(7, textGroups), $$invalidate(8, treemapLeaves)), $$invalidate(16, getTreemap)), $$invalidate(15, treeRoot)), $$invalidate(6, treemapWidth)), $$invalidate(5, treemapHeight)), $$invalidate(0, geometry)), $$invalidate(17, getTreeRoot)), $$invalidate(13, items)), $$invalidate(19, $_size)), $$invalidate(18, getHierarchy)), $$invalidate(4, valueAccessor));
		});
	}

	const mousemove_handler = (data, { x, y }) => dispatch('leafHovered', { data, x, y });
	const mouseout_handler = (data, { x, y }) => dispatch('leafExited', { data, x, y });
	const touchend_handler = data => dispatch('leafTouchEnded', { data });

	const touchstart_handler = (data, { targetTouches: [touch] }) => {
		const { clientX: x, clientY: y } = touch;
		dispatch('leafTouchStarted', { data, x, y });
	};

	$$self.$$set = $$props => {
		if ('geometry' in $$props) $$invalidate(0, geometry = $$props.geometry);
		if ('items' in $$props) $$invalidate(13, items = $$props.items);
		if ('keyAccessor' in $$props) $$invalidate(1, keyAccessor = $$props.keyAccessor);
		if ('keyToColorFn' in $$props) $$invalidate(2, keyToColorFn = $$props.keyToColorFn);
		if ('keyToColorLabelFn' in $$props) $$invalidate(3, keyToColorLabelFn = $$props.keyToColorLabelFn);
		if ('valueAccessor' in $$props) $$invalidate(4, valueAccessor = $$props.valueAccessor);
	};

	$$self.$capture_state = () => ({
		setupResizeObserver,
		getKey: getKey$1,
		getValue,
		hierarchy: hierarchy$1,
		stratify,
		treemap,
		_,
		createEventDispatcher,
		geometry,
		items,
		keyAccessor,
		keyToColorFn,
		keyToColorLabelFn,
		valueAccessor,
		treemapHeight,
		treemapWidth,
		defaultGeometry,
		dispatch,
		_size,
		sizeObserver,
		stratifyData,
		textGroups,
		treemapLeaves,
		textBboxes,
		leavesChecks,
		treeRoot,
		getTreemap,
		getTreeRoot,
		getHierarchy,
		$_size
	});

	$$self.$inject_state = $$props => {
		if ('geometry' in $$props) $$invalidate(0, geometry = $$props.geometry);
		if ('items' in $$props) $$invalidate(13, items = $$props.items);
		if ('keyAccessor' in $$props) $$invalidate(1, keyAccessor = $$props.keyAccessor);
		if ('keyToColorFn' in $$props) $$invalidate(2, keyToColorFn = $$props.keyToColorFn);
		if ('keyToColorLabelFn' in $$props) $$invalidate(3, keyToColorLabelFn = $$props.keyToColorLabelFn);
		if ('valueAccessor' in $$props) $$invalidate(4, valueAccessor = $$props.valueAccessor);
		if ('treemapHeight' in $$props) $$invalidate(5, treemapHeight = $$props.treemapHeight);
		if ('treemapWidth' in $$props) $$invalidate(6, treemapWidth = $$props.treemapWidth);
		if ('textGroups' in $$props) $$invalidate(7, textGroups = $$props.textGroups);
		if ('treemapLeaves' in $$props) $$invalidate(8, treemapLeaves = $$props.treemapLeaves);
		if ('textBboxes' in $$props) $$invalidate(14, textBboxes = $$props.textBboxes);
		if ('leavesChecks' in $$props) $$invalidate(9, leavesChecks = $$props.leavesChecks);
		if ('treeRoot' in $$props) $$invalidate(15, treeRoot = $$props.treeRoot);
		if ('getTreemap' in $$props) $$invalidate(16, getTreemap = $$props.getTreemap);
		if ('getTreeRoot' in $$props) $$invalidate(17, getTreeRoot = $$props.getTreeRoot);
		if ('getHierarchy' in $$props) $$invalidate(18, getHierarchy = $$props.getHierarchy);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*$_size*/ 524288) {
			$$invalidate(6, { inlineSize: treemapWidth, blockSize: treemapHeight } = $_size, treemapWidth, ($$invalidate(5, treemapHeight), $$invalidate(19, $_size)));
		}

		if ($$self.$$.dirty[0] & /*geometry*/ 1) {
			$$invalidate(0, geometry = geometry
			? { ...defaultGeometry, ...geometry }
			: defaultGeometry);
		}

		if ($$self.$$.dirty[0] & /*valueAccessor*/ 16) {
			$$invalidate(18, getHierarchy = stratified => hierarchy$1(stratified).sum(x => x.data ? valueAccessor(x.data) : 0)); // root.data = null
		}

		if ($$self.$$.dirty[0] & /*getHierarchy*/ 262144) {
			$$invalidate(17, getTreeRoot = pipe([stratifyData, getHierarchy]));
		}

		if ($$self.$$.dirty[0] & /*treemapWidth, treemapHeight, geometry*/ 97) {
			$$invalidate(16, getTreemap = treemap().size([treemapWidth, treemapHeight]).paddingOuter(geometry.paddingOuter).paddingInner(geometry.paddingInner));
		}

		if ($$self.$$.dirty[0] & /*getTreeRoot, items*/ 139264) {
			$$invalidate(15, treeRoot = getTreeRoot(items));
		}

		if ($$self.$$.dirty[0] & /*getTreemap, treeRoot*/ 98304) {
			$$invalidate(8, treemapLeaves = getTreemap(treeRoot).leaves());
		}

		if ($$self.$$.dirty[0] & /*textGroups, treemapLeaves*/ 384) {
			if (textGroups && treemapLeaves.length > textGroups.length) {
				$$invalidate(7, textGroups = [...textGroups, ...new Array(treemapLeaves.length - textGroups.length)]);
			} else if (!textGroups) {
				$$invalidate(7, textGroups = new Array(treemapLeaves.length));
			}
		}

		if ($$self.$$.dirty[0] & /*textGroups*/ 128) {
			$$invalidate(14, textBboxes = map(textGroups, gNode => gNode?.getBBox()));
		}

		if ($$self.$$.dirty[0] & /*textBboxes, treemapLeaves, geometry*/ 16641) {
			$$invalidate(9, leavesChecks = map(zip(textBboxes, treemapLeaves), ([textBbox, { x0, x1, y0, y1 }]) => {
				const totalPadding = geometry.textPadding * 2;
				const availableWidth = x1 - x0 - totalPadding;
				const availableHeight = y1 - y0 - totalPadding;

				return textBbox
				? [
						textBbox.width < availableWidth && textBbox.height < availableHeight,
						textBbox.width < availableHeight && textBbox.height < availableWidth
					]
				: [false, false];
			}));
		}
	};

	return [
		geometry,
		keyAccessor,
		keyToColorFn,
		keyToColorLabelFn,
		valueAccessor,
		treemapHeight,
		treemapWidth,
		textGroups,
		treemapLeaves,
		leavesChecks,
		dispatch,
		_size,
		sizeObserver,
		items,
		textBboxes,
		treeRoot,
		getTreemap,
		getTreeRoot,
		getHierarchy,
		$_size,
		g0_binding,
		mousemove_handler,
		mouseout_handler,
		touchend_handler,
		touchstart_handler
	];
}

class Treemap extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$5,
			create_fragment$6,
			safe_not_equal,
			{
				geometry: 0,
				items: 13,
				keyAccessor: 1,
				keyToColorFn: 2,
				keyToColorLabelFn: 3,
				valueAccessor: 4
			},
			null,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Treemap",
			options,
			id: create_fragment$6.name
		});
	}

	get geometry() {
		throw new Error("<Treemap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set geometry(value) {
		throw new Error("<Treemap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get items() {
		throw new Error("<Treemap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<Treemap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get keyAccessor() {
		throw new Error("<Treemap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set keyAccessor(value) {
		throw new Error("<Treemap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get keyToColorFn() {
		throw new Error("<Treemap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set keyToColorFn(value) {
		throw new Error("<Treemap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get keyToColorLabelFn() {
		throw new Error("<Treemap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set keyToColorLabelFn(value) {
		throw new Error("<Treemap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get valueAccessor() {
		throw new Error("<Treemap>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set valueAccessor(value) {
		throw new Error("<Treemap>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var Treemap$1 = Treemap;

var hierarchy = /*#__PURE__*/Object.freeze({
	__proto__: null,
	Treemap: Treemap$1
});

/* ../../components/histogram/src/HistogramG.svelte generated by Svelte v3.59.2 */
const file$5 = "../../components/histogram/src/HistogramG.svelte";

function get_each_context$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[52] = list[i].tick;
	child_ctx[53] = list[i].y;
	return child_ctx;
}

function get_each_context_1$4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[56] = list[i].barLength;
	child_ctx[57] = list[i].barThickness;
	child_ctx[58] = list[i].displayValue;
	child_ctx[59] = list[i].fill;
	child_ctx[60] = list[i].labelAnchor;
	child_ctx[61] = list[i].labelX;
	child_ctx[62] = list[i].selected;
	child_ctx[63] = list[i].x;
	child_ctx[64] = list[i].y1;
	child_ctx[66] = i;
	return child_ctx;
}

// (331:0) {#if height && width}
function create_if_block$5(ctx) {
	let g;

	function select_block_type(ctx, dirty) {
		if (/*bins*/ ctx[0].length === 0) return create_if_block_1$3;
		return create_else_block$1;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			g = svg_element("g");
			if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			g = claim_svg_element(nodes, "g", { style: true, class: true });
			var g_nodes = children(g);
			if_block.l(g_nodes);
			g_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(g, "style", /*style*/ ctx[13]);
			attr_dev(g, "class", "HistogramG svelte-1egg7b");
			toggle_class(g, "interactive", /*flags*/ ctx[1].isInteractive);
			add_location(g, file$5, 331, 1, 8028);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, g, anchor);
			if_block.m(g, null);
		},
		p: function update(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(g, null);
				}
			}

			if (dirty[0] & /*style*/ 8192) {
				attr_dev(g, "style", /*style*/ ctx[13]);
			}

			if (dirty[0] & /*flags*/ 2) {
				toggle_class(g, "interactive", /*flags*/ ctx[1].isInteractive);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(g);
			if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$5.name,
		type: "if",
		source: "(331:0) {#if height && width}",
		ctx
	});

	return block;
}

// (345:2) {:else}
function create_else_block$1(ctx) {
	let if_block0_anchor;
	let g1;
	let g0;
	let line;
	let line_y__value;
	let if_block2_anchor;
	let g0_transform_value;
	let g1_transform_value;
	let if_block0 = /*flags*/ ctx[1].withBackground && create_if_block_8$1(ctx);
	let if_block1 = /*flags*/ ctx[1].isInteractive && create_if_block_7$1(ctx);
	let each_value_1 = /*bars*/ ctx[8];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
	}

	let if_block2 = !/*flags*/ ctx[1].hideOrigin && create_if_block_4$1(ctx);
	let if_block3 = !/*flags*/ ctx[1].hideTicks && create_if_block_3$1(ctx);
	let if_block4 = /*isBrushing*/ ctx[7] && create_if_block_2$2(ctx);

	const block = {
		c: function create() {
			if (if_block0) if_block0.c();
			if_block0_anchor = empty();
			if (if_block1) if_block1.c();
			g1 = svg_element("g");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			g0 = svg_element("g");
			line = svg_element("line");
			if (if_block2) if_block2.c();
			if_block2_anchor = empty();
			if (if_block3) if_block3.c();
			if (if_block4) if_block4.c();
			this.h();
		},
		l: function claim(nodes) {
			if (if_block0) if_block0.l(nodes);
			if_block0_anchor = empty();
			if (if_block1) if_block1.l(nodes);
			g1 = claim_svg_element(nodes, "g", { transform: true });
			var g1_nodes = children(g1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(g1_nodes);
			}

			g0 = claim_svg_element(g1_nodes, "g", { class: true, transform: true });
			var g0_nodes = children(g0);
			line = claim_svg_element(g0_nodes, "line", { y2: true, class: true });
			children(line).forEach(detach_dev);
			if (if_block2) if_block2.l(g0_nodes);
			if_block2_anchor = empty();
			if (if_block3) if_block3.l(g0_nodes);
			g0_nodes.forEach(detach_dev);
			if (if_block4) if_block4.l(g1_nodes);
			g1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line, "y2", line_y__value = /*flags*/ ctx[1].isTopDown
			? /*innerHeight*/ ctx[9]
			: -/*innerHeight*/ ctx[9]);

			attr_dev(line, "class", "svelte-1egg7b");
			add_location(line, file$5, 421, 5, 9833);
			attr_dev(g0, "class", "axis svelte-1egg7b");
			attr_dev(g0, "transform", g0_transform_value = "translate(" + /*origin*/ ctx[19].x + "," + /*origin*/ ctx[19].y + ")");
			add_location(g0, file$5, 417, 4, 9753);
			attr_dev(g1, "transform", g1_transform_value = "translate(" + /*safety*/ ctx[11].left + "," + /*safety*/ ctx[11].top + ")");
			add_location(g1, file$5, 365, 3, 8626);
		},
		m: function mount(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert_hydration_dev(target, if_block0_anchor, anchor);
			if (if_block1) if_block1.m(target, anchor);
			insert_hydration_dev(target, g1, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(g1, null);
				}
			}

			append_hydration_dev(g1, g0);
			append_hydration_dev(g0, line);
			if (if_block2) if_block2.m(g0, null);
			append_hydration_dev(g0, if_block2_anchor);
			if (if_block3) if_block3.m(g0, null);
			if (if_block4) if_block4.m(g1, null);
		},
		p: function update(ctx, dirty) {
			if (/*flags*/ ctx[1].withBackground) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_8$1(ctx);
					if_block0.c();
					if_block0.m(if_block0_anchor.parentNode, if_block0_anchor);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*flags*/ ctx[1].isInteractive) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_7$1(ctx);
					if_block1.c();
					if_block1.m(g1.parentNode, g1);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*bars, innerWidth, onMousedown, onMouseenter, onMouseleave, isMousedown, onMousemove, onMouseup, flags, fontSize*/ 65049858) {
				each_value_1 = /*bars*/ ctx[8];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1$4(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(g1, g0);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}

			if (dirty[0] & /*flags, innerHeight*/ 514 && line_y__value !== (line_y__value = /*flags*/ ctx[1].isTopDown
			? /*innerHeight*/ ctx[9]
			: -/*innerHeight*/ ctx[9])) {
				attr_dev(line, "y2", line_y__value);
			}

			if (!/*flags*/ ctx[1].hideOrigin) {
				if (if_block2) {
					if_block2.p(ctx, dirty);
				} else {
					if_block2 = create_if_block_4$1(ctx);
					if_block2.c();
					if_block2.m(g0, if_block2_anchor);
				}
			} else if (if_block2) {
				if_block2.d(1);
				if_block2 = null;
			}

			if (!/*flags*/ ctx[1].hideTicks) {
				if (if_block3) {
					if_block3.p(ctx, dirty);
				} else {
					if_block3 = create_if_block_3$1(ctx);
					if_block3.c();
					if_block3.m(g0, null);
				}
			} else if (if_block3) {
				if_block3.d(1);
				if_block3 = null;
			}

			if (dirty[0] & /*origin*/ 524288 && g0_transform_value !== (g0_transform_value = "translate(" + /*origin*/ ctx[19].x + "," + /*origin*/ ctx[19].y + ")")) {
				attr_dev(g0, "transform", g0_transform_value);
			}

			if (/*isBrushing*/ ctx[7]) {
				if (if_block4) {
					if_block4.p(ctx, dirty);
				} else {
					if_block4 = create_if_block_2$2(ctx);
					if_block4.c();
					if_block4.m(g1, null);
				}
			} else if (if_block4) {
				if_block4.d(1);
				if_block4 = null;
			}

			if (dirty[0] & /*safety*/ 2048 && g1_transform_value !== (g1_transform_value = "translate(" + /*safety*/ ctx[11].left + "," + /*safety*/ ctx[11].top + ")")) {
				attr_dev(g1, "transform", g1_transform_value);
			}
		},
		d: function destroy(detaching) {
			if (if_block0) if_block0.d(detaching);
			if (detaching) detach_dev(if_block0_anchor);
			if (if_block1) if_block1.d(detaching);
			if (detaching) detach_dev(g1);
			destroy_each(each_blocks, detaching);
			if (if_block2) if_block2.d();
			if (if_block3) if_block3.d();
			if (if_block4) if_block4.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block$1.name,
		type: "else",
		source: "(345:2) {:else}",
		ctx
	});

	return block;
}

// (337:2) {#if bins.length === 0}
function create_if_block_1$3(ctx) {
	let text_1;
	let t;
	let text_1_x_value;
	let text_1_y_value;

	const block = {
		c: function create() {
			text_1 = svg_element("text");
			t = text(/*message*/ ctx[3]);
			this.h();
		},
		l: function claim(nodes) {
			text_1 = claim_svg_element(nodes, "text", { class: true, x: true, y: true });
			var text_1_nodes = children(text_1);
			t = claim_text(text_1_nodes, /*message*/ ctx[3]);
			text_1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(text_1, "class", "message svelte-1egg7b");
			attr_dev(text_1, "x", text_1_x_value = /*width*/ ctx[6] / 2);
			attr_dev(text_1, "y", text_1_y_value = /*height*/ ctx[5] / 2);
			add_location(text_1, file$5, 338, 3, 8137);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, text_1, anchor);
			append_hydration_dev(text_1, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*message*/ 8) set_data_dev(t, /*message*/ ctx[3]);

			if (dirty[0] & /*width*/ 64 && text_1_x_value !== (text_1_x_value = /*width*/ ctx[6] / 2)) {
				attr_dev(text_1, "x", text_1_x_value);
			}

			if (dirty[0] & /*height*/ 32 && text_1_y_value !== (text_1_y_value = /*height*/ ctx[5] / 2)) {
				attr_dev(text_1, "y", text_1_y_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(text_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$3.name,
		type: "if",
		source: "(337:2) {#if bins.length === 0}",
		ctx
	});

	return block;
}

// (348:3) {#if flags.withBackground}
function create_if_block_8$1(ctx) {
	let rect;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", { class: true, width: true, height: true });
			children(rect).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "class", "bkg svelte-1egg7b");
			attr_dev(rect, "width", /*width*/ ctx[6]);
			attr_dev(rect, "height", /*height*/ ctx[5]);
			add_location(rect, file$5, 348, 4, 8286);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*width*/ 64) {
				attr_dev(rect, "width", /*width*/ ctx[6]);
			}

			if (dirty[0] & /*height*/ 32) {
				attr_dev(rect, "height", /*height*/ ctx[5]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8$1.name,
		type: "if",
		source: "(348:3) {#if flags.withBackground}",
		ctx
	});

	return block;
}

// (353:3) {#if flags.isInteractive}
function create_if_block_7$1(ctx) {
	let rect;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				height: true,
				width: true,
				class: true,
				role: true,
				tabindex: true
			});

			children(rect).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "height", /*height*/ ctx[5]);
			attr_dev(rect, "width", /*width*/ ctx[6]);
			attr_dev(rect, "class", "bkgSensor svelte-1egg7b");
			attr_dev(rect, "role", "button");
			attr_dev(rect, "tabindex", "0");
			toggle_class(rect, "reset", /*selectedBins*/ ctx[4].length > 0);
			add_location(rect, file$5, 353, 4, 8411);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);

			if (!mounted) {
				dispose = [
					listen_dev(rect, "click", /*resetSelection*/ ctx[26], false, false, false, false),
					listen_dev(rect, "keydown", /*onKeyDown*/ ctx[27], false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*height*/ 32) {
				attr_dev(rect, "height", /*height*/ ctx[5]);
			}

			if (dirty[0] & /*width*/ 64) {
				attr_dev(rect, "width", /*width*/ ctx[6]);
			}

			if (dirty[0] & /*selectedBins*/ 16) {
				toggle_class(rect, "reset", /*selectedBins*/ ctx[4].length > 0);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7$1.name,
		type: "if",
		source: "(353:3) {#if flags.isInteractive}",
		ctx
	});

	return block;
}

// (382:6) {#if displayValue}
function create_if_block_6$1(ctx) {
	let rect;
	let rect_fill_value;
	let rect_x_value;
	let rect_height_value;
	let rect_width_value;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				fill: true,
				x: true,
				class: true,
				height: true,
				width: true
			});

			children(rect).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "fill", rect_fill_value = /*fill*/ ctx[59]);
			attr_dev(rect, "x", rect_x_value = /*x*/ ctx[63]);
			attr_dev(rect, "class", "bar svelte-1egg7b");
			attr_dev(rect, "height", rect_height_value = /*barThickness*/ ctx[57]);
			attr_dev(rect, "width", rect_width_value = /*barLength*/ ctx[56]);
			toggle_class(rect, "selected", /*selected*/ ctx[62]);
			add_location(rect, file$5, 382, 7, 8944);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*bars*/ 256 && rect_fill_value !== (rect_fill_value = /*fill*/ ctx[59])) {
				attr_dev(rect, "fill", rect_fill_value);
			}

			if (dirty[0] & /*bars*/ 256 && rect_x_value !== (rect_x_value = /*x*/ ctx[63])) {
				attr_dev(rect, "x", rect_x_value);
			}

			if (dirty[0] & /*bars*/ 256 && rect_height_value !== (rect_height_value = /*barThickness*/ ctx[57])) {
				attr_dev(rect, "height", rect_height_value);
			}

			if (dirty[0] & /*bars*/ 256 && rect_width_value !== (rect_width_value = /*barLength*/ ctx[56])) {
				attr_dev(rect, "width", rect_width_value);
			}

			if (dirty[0] & /*bars*/ 256) {
				toggle_class(rect, "selected", /*selected*/ ctx[62]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6$1.name,
		type: "if",
		source: "(382:6) {#if displayValue}",
		ctx
	});

	return block;
}

// (401:6) {#if flags.isInteractive}
function create_if_block_5$1(ctx) {
	let rect;
	let rect_height_value;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			rect = svg_element("rect");
			this.h();
		},
		l: function claim(nodes) {
			rect = claim_svg_element(nodes, "rect", {
				class: true,
				height: true,
				role: true,
				width: true
			});

			children(rect).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(rect, "class", "sensor svelte-1egg7b");
			attr_dev(rect, "height", rect_height_value = /*barThickness*/ ctx[57]);
			attr_dev(rect, "role", "none");
			attr_dev(rect, "width", /*innerWidth*/ ctx[10]);
			add_location(rect, file$5, 402, 7, 9374);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, rect, anchor);

			if (!mounted) {
				dispose = [
					listen_dev(rect, "mousedown", /*onMousedown*/ ctx[22], false, false, false, false),
					listen_dev(rect, "mouseenter", /*onMouseenter*/ ctx[21](/*index*/ ctx[66]), false, false, false, false),
					listen_dev(rect, "mouseleave", /*onMouseleave*/ ctx[25](/*index*/ ctx[66]), false, false, false, false),
					listen_dev(
						rect,
						"mousemove",
						function () {
							if (is_function(/*isMousedown*/ ctx[12]
							? /*onMousemove*/ ctx[23](/*index*/ ctx[66])
							: null)) (/*isMousedown*/ ctx[12]
							? /*onMousemove*/ ctx[23](/*index*/ ctx[66])
							: null).apply(this, arguments);
						},
						false,
						false,
						false,
						false
					),
					listen_dev(rect, "mouseup", /*onMouseup*/ ctx[24](/*index*/ ctx[66]), false, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*bars*/ 256 && rect_height_value !== (rect_height_value = /*barThickness*/ ctx[57])) {
				attr_dev(rect, "height", rect_height_value);
			}

			if (dirty[0] & /*innerWidth*/ 1024) {
				attr_dev(rect, "width", /*innerWidth*/ ctx[10]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(rect);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5$1.name,
		type: "if",
		source: "(401:6) {#if flags.isInteractive}",
		ctx
	});

	return block;
}

// (367:4) {#each bars as {      barLength,      barThickness,      displayValue,      fill,      labelAnchor,      labelX,      selected,      x,      y1,     }
function create_each_block_1$4(ctx) {
	let g;
	let text_1;
	let t_value = /*displayValue*/ ctx[58] + "";
	let t;
	let text_1_x_value;
	let text_1_y_value;
	let text_1_text_anchor_value;
	let g_transform_value;
	let if_block0 = /*displayValue*/ ctx[58] && create_if_block_6$1(ctx);
	let if_block1 = /*flags*/ ctx[1].isInteractive && create_if_block_5$1(ctx);

	const block = {
		c: function create() {
			g = svg_element("g");
			if (if_block0) if_block0.c();
			text_1 = svg_element("text");
			t = text(t_value);
			if (if_block1) if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			g = claim_svg_element(nodes, "g", { class: true, transform: true });
			var g_nodes = children(g);
			if (if_block0) if_block0.l(g_nodes);

			text_1 = claim_svg_element(g_nodes, "text", {
				class: true,
				x: true,
				y: true,
				"font-size": true,
				"text-anchor": true
			});

			var text_1_nodes = children(text_1);
			t = claim_text(text_1_nodes, t_value);
			text_1_nodes.forEach(detach_dev);
			if (if_block1) if_block1.l(g_nodes);
			g_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(text_1, "class", "binsize svelte-1egg7b");
			attr_dev(text_1, "x", text_1_x_value = /*labelX*/ ctx[61]);
			attr_dev(text_1, "y", text_1_y_value = /*barThickness*/ ctx[57] / 2);
			attr_dev(text_1, "font-size", /*fontSize*/ ctx[15]);
			attr_dev(text_1, "text-anchor", text_1_text_anchor_value = /*labelAnchor*/ ctx[60]);
			add_location(text_1, file$5, 392, 6, 9105);
			attr_dev(g, "class", "bin svelte-1egg7b");
			attr_dev(g, "transform", g_transform_value = "translate(0," + /*y1*/ ctx[64] + ")");
			add_location(g, file$5, 377, 5, 8848);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, g, anchor);
			if (if_block0) if_block0.m(g, null);
			append_hydration_dev(g, text_1);
			append_hydration_dev(text_1, t);
			if (if_block1) if_block1.m(g, null);
		},
		p: function update(ctx, dirty) {
			if (/*displayValue*/ ctx[58]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_6$1(ctx);
					if_block0.c();
					if_block0.m(g, text_1);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (dirty[0] & /*bars*/ 256 && t_value !== (t_value = /*displayValue*/ ctx[58] + "")) set_data_dev(t, t_value);

			if (dirty[0] & /*bars*/ 256 && text_1_x_value !== (text_1_x_value = /*labelX*/ ctx[61])) {
				attr_dev(text_1, "x", text_1_x_value);
			}

			if (dirty[0] & /*bars*/ 256 && text_1_y_value !== (text_1_y_value = /*barThickness*/ ctx[57] / 2)) {
				attr_dev(text_1, "y", text_1_y_value);
			}

			if (dirty[0] & /*fontSize*/ 32768) {
				attr_dev(text_1, "font-size", /*fontSize*/ ctx[15]);
			}

			if (dirty[0] & /*bars*/ 256 && text_1_text_anchor_value !== (text_1_text_anchor_value = /*labelAnchor*/ ctx[60])) {
				attr_dev(text_1, "text-anchor", text_1_text_anchor_value);
			}

			if (/*flags*/ ctx[1].isInteractive) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_5$1(ctx);
					if_block1.c();
					if_block1.m(g, null);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*bars*/ 256 && g_transform_value !== (g_transform_value = "translate(0," + /*y1*/ ctx[64] + ")")) {
				attr_dev(g, "transform", g_transform_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(g);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$4.name,
		type: "each",
		source: "(367:4) {#each bars as {      barLength,      barThickness,      displayValue,      fill,      labelAnchor,      labelX,      selected,      x,      y1,     }",
		ctx
	});

	return block;
}

// (426:5) {#if !flags.hideOrigin}
function create_if_block_4$1(ctx) {
	let circle;
	let circle_r_value;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", { r: true, class: true });
			children(circle).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "r", circle_r_value = /*geometry*/ ctx[2].originRadius);
			attr_dev(circle, "class", "svelte-1egg7b");
			add_location(circle, file$5, 426, 6, 9939);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*geometry*/ 4 && circle_r_value !== (circle_r_value = /*geometry*/ ctx[2].originRadius)) {
				attr_dev(circle, "r", circle_r_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4$1.name,
		type: "if",
		source: "(426:5) {#if !flags.hideOrigin}",
		ctx
	});

	return block;
}

// (430:5) {#if !flags.hideTicks}
function create_if_block_3$1(ctx) {
	let each_1_anchor;
	let each_value = /*ticks*/ ctx[16];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert_hydration_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*ticksX, ticks, fontSize, ticksAnchor*/ 491520) {
				each_value = /*ticks*/ ctx[16];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$4(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$4(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3$1.name,
		type: "if",
		source: "(430:5) {#if !flags.hideTicks}",
		ctx
	});

	return block;
}

// (431:6) {#each ticks as {tick, y}}
function create_each_block$4(ctx) {
	let text_1;
	let t_value = /*tick*/ ctx[52] + "";
	let t;
	let text_1_y_value;

	const block = {
		c: function create() {
			text_1 = svg_element("text");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			text_1 = claim_svg_element(nodes, "text", {
				class: true,
				x: true,
				y: true,
				"font-size": true,
				"text-anchor": true
			});

			var text_1_nodes = children(text_1);
			t = claim_text(text_1_nodes, t_value);
			text_1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(text_1, "class", "range svelte-1egg7b");
			attr_dev(text_1, "x", /*ticksX*/ ctx[18]);
			attr_dev(text_1, "y", text_1_y_value = /*y*/ ctx[53]);
			attr_dev(text_1, "font-size", /*fontSize*/ ctx[15]);
			attr_dev(text_1, "text-anchor", /*ticksAnchor*/ ctx[17]);
			add_location(text_1, file$5, 431, 7, 10056);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, text_1, anchor);
			append_hydration_dev(text_1, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*ticks*/ 65536 && t_value !== (t_value = /*tick*/ ctx[52] + "")) set_data_dev(t, t_value);

			if (dirty[0] & /*ticksX*/ 262144) {
				attr_dev(text_1, "x", /*ticksX*/ ctx[18]);
			}

			if (dirty[0] & /*ticks*/ 65536 && text_1_y_value !== (text_1_y_value = /*y*/ ctx[53])) {
				attr_dev(text_1, "y", text_1_y_value);
			}

			if (dirty[0] & /*fontSize*/ 32768) {
				attr_dev(text_1, "font-size", /*fontSize*/ ctx[15]);
			}

			if (dirty[0] & /*ticksAnchor*/ 131072) {
				attr_dev(text_1, "text-anchor", /*ticksAnchor*/ ctx[17]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(text_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$4.name,
		type: "each",
		source: "(431:6) {#each ticks as {tick, y}}",
		ctx
	});

	return block;
}

// (443:4) {#if isBrushing}
function create_if_block_2$2(ctx) {
	let g;
	let line;
	let line_y__value;
	let line_y__value_1;
	let g_transform_value;

	const block = {
		c: function create() {
			g = svg_element("g");
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			g = claim_svg_element(nodes, "g", { class: true, transform: true });
			var g_nodes = children(g);
			line = claim_svg_element(g_nodes, "line", { y1: true, y2: true, class: true });
			children(line).forEach(detach_dev);
			g_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line, "y1", line_y__value = /*brushLine*/ ctx[14].y1);
			attr_dev(line, "y2", line_y__value_1 = /*brushLine*/ ctx[14].y2);
			attr_dev(line, "class", "svelte-1egg7b");
			add_location(line, file$5, 447, 6, 10337);
			attr_dev(g, "class", "brush svelte-1egg7b");
			attr_dev(g, "transform", g_transform_value = "translate(" + /*origin*/ ctx[19].x + ",0)");
			add_location(g, file$5, 443, 5, 10261);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, g, anchor);
			append_hydration_dev(g, line);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*brushLine*/ 16384 && line_y__value !== (line_y__value = /*brushLine*/ ctx[14].y1)) {
				attr_dev(line, "y1", line_y__value);
			}

			if (dirty[0] & /*brushLine*/ 16384 && line_y__value_1 !== (line_y__value_1 = /*brushLine*/ ctx[14].y2)) {
				attr_dev(line, "y2", line_y__value_1);
			}

			if (dirty[0] & /*origin*/ 524288 && g_transform_value !== (g_transform_value = "translate(" + /*origin*/ ctx[19].x + ",0)")) {
				attr_dev(g, "transform", g_transform_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(g);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$2.name,
		type: "if",
		source: "(443:4) {#if isBrushing}",
		ctx
	});

	return block;
}

function create_fragment$5(ctx) {
	let if_block_anchor;
	let if_block = /*height*/ ctx[5] && /*width*/ ctx[6] && create_if_block$5(ctx);

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert_hydration_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (/*height*/ ctx[5] && /*width*/ ctx[6]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$5(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (if_block) if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$5.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$4($$self, $$props, $$invalidate) {
	let safety;
	let innerWidth;
	let innerHeight;
	let origin;
	let useValue;
	let getBinsMax;
	let valuesMax;
	let scales;
	let ticksX;
	let ticksAnchor;
	let ticks;
	let bars;
	let maxBarThickness;
	let fontSize;
	let isBrushing;
	let isPressed;
	let doesBrushAdd;
	let doesBrushRemove;
	let brushStroke;
	let brushExtent;
	let brushRange;
	let brushExtentBarYs;
	let brushLine;
	let style;
	let $_brush;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('HistogramG', slots, []);
	const dispatch = createEventDispatcher();
	const makeMaxBarThickness = arrayMaxWith(getKey('barThickness'));

	const defaultFlags = {
		hideOrigin: false,
		hideTicks: false,
		isInteractive: false,
		isRightToLeft: false,
		isTopDown: false,
		useLogScale: false,
		withBackground: false
	};

	const defaultGeometry = {
		// exposed but undocumented on the site
		brushThreshold: 10, // pixels to trigger brushing
		fontSizeFactor: 0.6,
		maxFontSize: 12,
		textPadding: 5,
		// documented on the site
		originRadius: 2,
		safetyXNoTicks: 20,
		safetyXTicks: 50,
		safetyXValues: 25,
		safetyY: 20
	};

	const defaultTheme = {
		// exposed but undocumented
		backgroundOpacity: 1,
		// exposed and documented but no example
		brushAddStroke: 'rgb(107,248,134)',
		brushRemoveStroke: 'rgb(246,97,20)',
		brushStrokeOpacity: 0.8,
		brushStrokeWidth: 8,
		// exposed but undocumented on the site
		axisStrokeWidth: 1,
		backgroundColor: 'white',
		binFill: 'white',
		binStroke: 'black',
		binStrokeWidth: 1,
		originColor: 'black',
		messageColor: 'black',
		messageFontSize: '1rem',
		selectedBinFill: 'rgb(255, 174, 0)',
		selectedBinStroke: 'black',
		selectedBinStrokeWidth: 2,
		textColor: 'black'
	};

	let { height = null } = $$props;
	let { width = null } = $$props;
	let { bins = [] } = $$props;
	let { binsFill = null } = $$props;
	let { flags = null } = $$props;
	let { geometry = null } = $$props;
	let { message = 'No data' } = $$props;
	let { selectedBins = [] } = $$props;
	let { theme = null } = $$props;
	let { ticksFormatFn = null } = $$props;
	let rangesExtent = [];

	/* brushing */
	let isMousedown = false;

	const brushOff = {
		delta: 0,
		end: null,
		origin: { x: null, y: null },
		start: null,
		modifier: null,
		state: 'Off'
	};

	const _brush = writable(brushOff);
	validate_store(_brush, '_brush');
	component_subscribe($$self, _brush, value => $$invalidate(43, $_brush = value));

	/* events */
	const getModifier = event => event.shiftKey ? 'shift' : event.altKey ? 'alt' : null;

	const onMouseenter = index => () => {
		if (isBrushing) {
			_brush.update(mergeObj({ end: index }));
		}

		dispatch('entered', index);
	};

	const onMousedown = event => {
		$$invalidate(12, isMousedown = true);

		_brush.set({
			delta: 0,
			modifier: getModifier(event),
			origin: { x: event.offsetX, y: event.offsetY },
			state: 'Pressed'
		});
	};

	const onMousemove = index => event => {
		if (isPressed) {
			const delta = vectorLength2D(event.offsetX - $_brush.origin.x, event.offsetY - $_brush.origin.y);

			if (delta > geometry.brushThreshold) {
				_brush.update(mergeObj({
					end: index,
					start: index,
					state: 'Brushing'
				}));

				dispatch('brushstart', index);
			} else {
				_brush.update(mergeObj({ delta }));
			}
		}
	};

	const onMouseup = index => () => {
		$$invalidate(12, isMousedown = false);

		if (isPressed) {
			if ($_brush.delta < geometry.brushThreshold) {
				if (doesBrushAdd) {
					$$invalidate(4, selectedBins = uniques(appendTo(selectedBins, index)));
				} else if (doesBrushRemove) {
					$$invalidate(4, selectedBins = pullFrom(selectedBins, [index]));
				} else {
					$$invalidate(4, selectedBins = [index]);
				}

				dispatch('clicked', { index, selectedBins });
			}
		} else if (isBrushing) {
			dispatch('brushend', index);
		}

		_brush.set(brushOff);
	};

	const onMouseleave = index => () => {
		dispatch('exited', index);
	};

	const resetSelection = () => {
		$$invalidate(4, selectedBins = []);
		dispatch('clicked', { selectedBins });
	};

	const onKeyDown = event => {
		if (event.key === 'Escape') {
			event.preventDefault();
			resetSelection();
		}
	};

	const writable_props = [
		'height',
		'width',
		'bins',
		'binsFill',
		'flags',
		'geometry',
		'message',
		'selectedBins',
		'theme',
		'ticksFormatFn'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<HistogramG> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('height' in $$props) $$invalidate(5, height = $$props.height);
		if ('width' in $$props) $$invalidate(6, width = $$props.width);
		if ('bins' in $$props) $$invalidate(0, bins = $$props.bins);
		if ('binsFill' in $$props) $$invalidate(30, binsFill = $$props.binsFill);
		if ('flags' in $$props) $$invalidate(1, flags = $$props.flags);
		if ('geometry' in $$props) $$invalidate(2, geometry = $$props.geometry);
		if ('message' in $$props) $$invalidate(3, message = $$props.message);
		if ('selectedBins' in $$props) $$invalidate(4, selectedBins = $$props.selectedBins);
		if ('theme' in $$props) $$invalidate(28, theme = $$props.theme);
		if ('ticksFormatFn' in $$props) $$invalidate(29, ticksFormatFn = $$props.ticksFormatFn);
	};

	$$self.$capture_state = () => ({
		makeStyleVars,
		vectorLength2D,
		arrayMaxWith,
		concat,
		getValue,
		inclusiveRange,
		mergeObj,
		scaleLinear: linear,
		scaleLog: log,
		appendTo,
		getKey,
		has,
		last,
		pullFrom,
		sort,
		uniques,
		createEventDispatcher,
		writable,
		getBinsTicks,
		getValuesLength,
		dispatch,
		makeMaxBarThickness,
		defaultFlags,
		defaultGeometry,
		defaultTheme,
		height,
		width,
		bins,
		binsFill,
		flags,
		geometry,
		message,
		selectedBins,
		theme,
		ticksFormatFn,
		rangesExtent,
		isMousedown,
		brushOff,
		_brush,
		getModifier,
		onMouseenter,
		onMousedown,
		onMousemove,
		onMouseup,
		onMouseleave,
		resetSelection,
		onKeyDown,
		isBrushing,
		doesBrushRemove,
		doesBrushAdd,
		isPressed,
		brushStroke,
		style,
		brushRange,
		brushExtentBarYs,
		brushLine,
		brushExtent,
		bars,
		maxBarThickness,
		fontSize,
		scales,
		innerHeight,
		innerWidth,
		ticks,
		ticksAnchor,
		ticksX,
		valuesMax,
		getBinsMax,
		useValue,
		origin,
		safety,
		$_brush
	});

	$$self.$inject_state = $$props => {
		if ('height' in $$props) $$invalidate(5, height = $$props.height);
		if ('width' in $$props) $$invalidate(6, width = $$props.width);
		if ('bins' in $$props) $$invalidate(0, bins = $$props.bins);
		if ('binsFill' in $$props) $$invalidate(30, binsFill = $$props.binsFill);
		if ('flags' in $$props) $$invalidate(1, flags = $$props.flags);
		if ('geometry' in $$props) $$invalidate(2, geometry = $$props.geometry);
		if ('message' in $$props) $$invalidate(3, message = $$props.message);
		if ('selectedBins' in $$props) $$invalidate(4, selectedBins = $$props.selectedBins);
		if ('theme' in $$props) $$invalidate(28, theme = $$props.theme);
		if ('ticksFormatFn' in $$props) $$invalidate(29, ticksFormatFn = $$props.ticksFormatFn);
		if ('rangesExtent' in $$props) $$invalidate(31, rangesExtent = $$props.rangesExtent);
		if ('isMousedown' in $$props) $$invalidate(12, isMousedown = $$props.isMousedown);
		if ('isBrushing' in $$props) $$invalidate(7, isBrushing = $$props.isBrushing);
		if ('doesBrushRemove' in $$props) $$invalidate(32, doesBrushRemove = $$props.doesBrushRemove);
		if ('doesBrushAdd' in $$props) $$invalidate(33, doesBrushAdd = $$props.doesBrushAdd);
		if ('isPressed' in $$props) isPressed = $$props.isPressed;
		if ('brushStroke' in $$props) $$invalidate(34, brushStroke = $$props.brushStroke);
		if ('style' in $$props) $$invalidate(13, style = $$props.style);
		if ('brushRange' in $$props) $$invalidate(35, brushRange = $$props.brushRange);
		if ('brushExtentBarYs' in $$props) $$invalidate(36, brushExtentBarYs = $$props.brushExtentBarYs);
		if ('brushLine' in $$props) $$invalidate(14, brushLine = $$props.brushLine);
		if ('brushExtent' in $$props) $$invalidate(37, brushExtent = $$props.brushExtent);
		if ('bars' in $$props) $$invalidate(8, bars = $$props.bars);
		if ('maxBarThickness' in $$props) $$invalidate(38, maxBarThickness = $$props.maxBarThickness);
		if ('fontSize' in $$props) $$invalidate(15, fontSize = $$props.fontSize);
		if ('scales' in $$props) $$invalidate(39, scales = $$props.scales);
		if ('innerHeight' in $$props) $$invalidate(9, innerHeight = $$props.innerHeight);
		if ('innerWidth' in $$props) $$invalidate(10, innerWidth = $$props.innerWidth);
		if ('ticks' in $$props) $$invalidate(16, ticks = $$props.ticks);
		if ('ticksAnchor' in $$props) $$invalidate(17, ticksAnchor = $$props.ticksAnchor);
		if ('ticksX' in $$props) $$invalidate(18, ticksX = $$props.ticksX);
		if ('valuesMax' in $$props) $$invalidate(40, valuesMax = $$props.valuesMax);
		if ('getBinsMax' in $$props) $$invalidate(41, getBinsMax = $$props.getBinsMax);
		if ('useValue' in $$props) $$invalidate(42, useValue = $$props.useValue);
		if ('origin' in $$props) $$invalidate(19, origin = $$props.origin);
		if ('safety' in $$props) $$invalidate(11, safety = $$props.safety);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*bins*/ 1) {
			// FIXME https://github.com/sveltejs/svelte/issues/4442
			$$invalidate(0, bins = bins || []);
		}

		if ($$self.$$.dirty[0] & /*flags*/ 2) {
			$$invalidate(1, flags = flags ? { ...defaultFlags, ...flags } : defaultFlags);
		}

		if ($$self.$$.dirty[0] & /*geometry*/ 4) {
			$$invalidate(2, geometry = geometry
			? { ...defaultGeometry, ...geometry }
			: defaultGeometry);
		}

		if ($$self.$$.dirty[0] & /*message*/ 8) {
			$$invalidate(3, message = message || 'No data');
		}

		if ($$self.$$.dirty[0] & /*selectedBins*/ 16) {
			$$invalidate(4, selectedBins = selectedBins || []);
		}

		if ($$self.$$.dirty[0] & /*theme*/ 268435456) {
			$$invalidate(28, theme = theme ? { ...defaultTheme, ...theme } : defaultTheme);
		}

		if ($$self.$$.dirty[0] & /*ticksFormatFn*/ 536870912) {
			$$invalidate(29, ticksFormatFn = ticksFormatFn || (x => x));
		}

		if ($$self.$$.dirty[0] & /*geometry, flags*/ 6) {
			$$invalidate(11, safety = {
				top: geometry.safetyY,
				right: flags.isRightToLeft
				? flags.hideTicks
					? geometry.safetyXNoTicks
					: geometry.safetyXTicks
				: geometry.safetyXValues,
				bottom: geometry.safetyY,
				left: flags.isRightToLeft
				? geometry.safetyXValues
				: flags.hideTicks
					? geometry.safetyXNoTicks
					: geometry.safetyXTicks
			});
		}

		if ($$self.$$.dirty[0] & /*width, safety*/ 2112) {
			$$invalidate(10, innerWidth = Math.max(0, width - safety.left - safety.right));
		}

		if ($$self.$$.dirty[0] & /*height, safety, geometry*/ 2084) {
			$$invalidate(9, innerHeight = Math.max(0, height - safety.top - safety.bottom - geometry.maxFontSize));
		}

		if ($$self.$$.dirty[0] & /*flags, innerWidth, innerHeight*/ 1538) {
			$$invalidate(19, origin = {
				x: flags.isRightToLeft ? innerWidth : 0,
				y: flags.isTopDown ? 0 : innerHeight
			});
		}

		if ($$self.$$.dirty[0] & /*bins*/ 1) {
			$$invalidate(42, useValue = bins.length && has(bins[0], 'value'));
		}

		if ($$self.$$.dirty[1] & /*useValue*/ 2048) {
			$$invalidate(41, getBinsMax = useValue
			? arrayMaxWith(getValue)
			: arrayMaxWith(getValuesLength));
		}

		if ($$self.$$.dirty[0] & /*bins*/ 1 | $$self.$$.dirty[1] & /*getBinsMax*/ 1024) {
			$$invalidate(40, valuesMax = getBinsMax(bins));
		}

		if ($$self.$$.dirty[0] & /*bins*/ 1) {
			$$invalidate(31, rangesExtent = bins.length
			? [bins[0].range[0], last(bins).range[1]]
			: []);
		}

		if ($$self.$$.dirty[0] & /*bins, flags, innerWidth, innerHeight*/ 1539 | $$self.$$.dirty[1] & /*valuesMax, rangesExtent*/ 513) {
			/* eslint-disable indent */
			$$invalidate(39, scales = bins.length && {
				x: flags.useLogScale
				? log().domain([1, valuesMax]).range([innerWidth / Math.log10(valuesMax), innerWidth])
				: linear().domain([0, valuesMax]).range([0, innerWidth]),
				y: linear().domain(rangesExtent).range([0, innerHeight])
			});
		}

		if ($$self.$$.dirty[0] & /*flags, geometry*/ 6) {
			/* eslint-enable indent */
			$$invalidate(18, ticksX = flags.isRightToLeft
			? geometry.originRadius + geometry.textPadding
			: -(geometry.originRadius + geometry.textPadding));
		}

		if ($$self.$$.dirty[0] & /*flags*/ 2) {
			$$invalidate(17, ticksAnchor = flags.isRightToLeft ? 'start' : 'end');
		}

		if ($$self.$$.dirty[0] & /*bins, ticksFormatFn, flags*/ 536870915 | $$self.$$.dirty[1] & /*scales*/ 256) {
			$$invalidate(16, ticks = getBinsTicks(bins).map(tick => ({
				tick: ticksFormatFn(tick),
				y: flags.isTopDown ? scales.y(tick) : -scales.y(tick)
			})));
		}

		if ($$self.$$.dirty[1] & /*$_brush*/ 4096) {
			$$invalidate(7, isBrushing = $_brush.state === 'Brushing');
		}

		if ($$self.$$.dirty[1] & /*$_brush*/ 4096) {
			$$invalidate(33, doesBrushAdd = $_brush.modifier === 'shift');
		}

		if ($$self.$$.dirty[0] & /*isBrushing*/ 128 | $$self.$$.dirty[1] & /*$_brush*/ 4096) {
			$$invalidate(37, brushExtent = isBrushing && sort([$_brush.start, $_brush.end]));
		}

		if ($$self.$$.dirty[0] & /*isBrushing*/ 128 | $$self.$$.dirty[1] & /*brushExtent*/ 64) {
			$$invalidate(35, brushRange = isBrushing && inclusiveRange(brushExtent));
		}

		if ($$self.$$.dirty[1] & /*$_brush*/ 4096) {
			$$invalidate(32, doesBrushRemove = $_brush.modifier === 'alt');
		}

		if ($$self.$$.dirty[0] & /*isBrushing, selectedBins*/ 144 | $$self.$$.dirty[1] & /*doesBrushAdd, brushRange, doesBrushRemove, $_brush*/ 4118) {
			if (isBrushing) {
				$$invalidate(4, selectedBins = doesBrushAdd
				? uniques(concat(selectedBins, brushRange))
				: doesBrushRemove
					? pullFrom(selectedBins, brushRange)
					: brushRange);

				dispatch('brushed', {
					end: $_brush.end,
					selectedBins,
					start: $_brush.start
				});
			}
		}

		if ($$self.$$.dirty[0] & /*bins, selectedBins, flags, innerWidth, innerHeight, geometry, binsFill, theme*/ 1342178839 | $$self.$$.dirty[1] & /*scales*/ 256) {
			$$invalidate(8, bars = bins.map((bin, index) => {
				const { range, values, value } = bin;
				const selected = selectedBins.length && selectedBins.includes(index);
				const displayValue = values ? values.length : value;
				const barLength = scales.x(displayValue);
				const barThickness = scales.y(range[1]) - scales.y(range[0]);
				const x = flags.isRightToLeft ? innerWidth - barLength : 0;

				const y1 = flags.isTopDown
				? scales.y(range[0])
				: innerHeight - scales.y(range[0]) - barThickness;

				const y2 = y1 + barThickness;

				const labelX = flags.isRightToLeft
				? x - geometry.textPadding
				: barLength + geometry.textPadding;

				const labelAnchor = flags.isRightToLeft ? 'end' : 'start';

				const fill = bin.color || (binsFill && binsFill[index]
				? binsFill[index]
				: theme.binFill);

				return {
					...bin,
					...{
						barLength,
						barThickness,
						displayValue,
						fill,
						labelAnchor,
						labelX,
						selected,
						x,
						y1,
						y2
					}
				};
			}));
		}

		if ($$self.$$.dirty[0] & /*bars*/ 256) {
			$$invalidate(38, maxBarThickness = makeMaxBarThickness(bars));
		}

		if ($$self.$$.dirty[0] & /*geometry*/ 4 | $$self.$$.dirty[1] & /*maxBarThickness*/ 128) {
			$$invalidate(15, fontSize = Math.min(geometry.maxFontSize, geometry.fontSizeFactor * maxBarThickness));
		}

		if ($$self.$$.dirty[1] & /*$_brush*/ 4096) {
			isPressed = $_brush.state === 'Pressed';
		}

		if ($$self.$$.dirty[0] & /*theme*/ 268435456 | $$self.$$.dirty[1] & /*doesBrushAdd, doesBrushRemove*/ 6) {
			$$invalidate(34, brushStroke = doesBrushAdd
			? theme.brushAddStroke
			: doesBrushRemove ? theme.brushRemoveStroke : null);
		}

		if ($$self.$$.dirty[0] & /*isBrushing, bars*/ 384 | $$self.$$.dirty[1] & /*brushExtent*/ 64) {
			$$invalidate(36, brushExtentBarYs = isBrushing && sort([
				bars[brushExtent[0]].y1,
				bars[brushExtent[0]].y2,
				bars[brushExtent[1]].y1,
				bars[brushExtent[1]].y2
			]));
		}

		if ($$self.$$.dirty[0] & /*isBrushing*/ 128 | $$self.$$.dirty[1] & /*brushExtentBarYs*/ 32) {
			$$invalidate(14, brushLine = isBrushing && {
				y1: brushExtentBarYs[0],
				y2: brushExtentBarYs[3]
			});
		}

		if ($$self.$$.dirty[0] & /*theme*/ 268435456 | $$self.$$.dirty[1] & /*brushStroke*/ 8) {
			/* style */
			$$invalidate(13, style = makeStyleVars({ ...theme, brushStroke }));
		}
	};

	return [
		bins,
		flags,
		geometry,
		message,
		selectedBins,
		height,
		width,
		isBrushing,
		bars,
		innerHeight,
		innerWidth,
		safety,
		isMousedown,
		style,
		brushLine,
		fontSize,
		ticks,
		ticksAnchor,
		ticksX,
		origin,
		_brush,
		onMouseenter,
		onMousedown,
		onMousemove,
		onMouseup,
		onMouseleave,
		resetSelection,
		onKeyDown,
		theme,
		ticksFormatFn,
		binsFill,
		rangesExtent,
		doesBrushRemove,
		doesBrushAdd,
		brushStroke,
		brushRange,
		brushExtentBarYs,
		brushExtent,
		maxBarThickness,
		scales,
		valuesMax,
		getBinsMax,
		useValue,
		$_brush
	];
}

class HistogramG extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$4,
			create_fragment$5,
			safe_not_equal,
			{
				height: 5,
				width: 6,
				bins: 0,
				binsFill: 30,
				flags: 1,
				geometry: 2,
				message: 3,
				selectedBins: 4,
				theme: 28,
				ticksFormatFn: 29
			},
			null,
			[-1, -1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "HistogramG",
			options,
			id: create_fragment$5.name
		});
	}

	get height() {
		throw new Error("<HistogramG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set height(value) {
		throw new Error("<HistogramG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get width() {
		throw new Error("<HistogramG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set width(value) {
		throw new Error("<HistogramG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bins() {
		throw new Error("<HistogramG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bins(value) {
		throw new Error("<HistogramG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get binsFill() {
		throw new Error("<HistogramG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set binsFill(value) {
		throw new Error("<HistogramG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get flags() {
		throw new Error("<HistogramG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set flags(value) {
		throw new Error("<HistogramG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get geometry() {
		throw new Error("<HistogramG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set geometry(value) {
		throw new Error("<HistogramG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get message() {
		throw new Error("<HistogramG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set message(value) {
		throw new Error("<HistogramG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selectedBins() {
		throw new Error("<HistogramG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selectedBins(value) {
		throw new Error("<HistogramG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get theme() {
		throw new Error("<HistogramG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set theme(value) {
		throw new Error("<HistogramG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ticksFormatFn() {
		throw new Error("<HistogramG>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ticksFormatFn(value) {
		throw new Error("<HistogramG>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var HistogramG$1 = HistogramG;

/* ../../components/histogram/src/HistogramDiv.svelte generated by Svelte v3.59.2 */
const file$4 = "../../components/histogram/src/HistogramDiv.svelte";

// (34:1) {#if title}
function create_if_block_1$2(ctx) {
	let header;
	let h2;
	let t;

	const block = {
		c: function create() {
			header = element("header");
			h2 = element("h2");
			t = text(/*title*/ ctx[0]);
			this.h();
		},
		l: function claim(nodes) {
			header = claim_element(nodes, "HEADER", { class: true });
			var header_nodes = children(header);
			h2 = claim_element(header_nodes, "H2", { class: true });
			var h2_nodes = children(h2);
			t = claim_text(h2_nodes, /*title*/ ctx[0]);
			h2_nodes.forEach(detach_dev);
			header_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h2, "class", "svelte-1m2zakn");
			add_location(h2, file$4, 35, 3, 781);
			attr_dev(header, "class", "svelte-1m2zakn");
			toggle_class(header, "rightToLeft", /*flags*/ ctx[3] && /*flags*/ ctx[3].isRightToLeft);
			add_location(header, file$4, 34, 2, 720);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, header, anchor);
			append_hydration_dev(header, h2);
			append_hydration_dev(h2, t);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*title*/ 1) set_data_dev(t, /*title*/ ctx[0]);

			if (dirty & /*flags*/ 8) {
				toggle_class(header, "rightToLeft", /*flags*/ ctx[3] && /*flags*/ ctx[3].isRightToLeft);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(header);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$2.name,
		type: "if",
		source: "(34:1) {#if title}",
		ctx
	});

	return block;
}

// (48:3) {#if bins}
function create_if_block$4(ctx) {
	let histogramg;
	let current;

	histogramg = new HistogramG$1({
			props: {
				bins: /*bins*/ ctx[1],
				binsFill: /*binsFill*/ ctx[2],
				flags: /*flags*/ ctx[3],
				geometry: /*geometry*/ ctx[4],
				height: /*height*/ ctx[9],
				message: /*message*/ ctx[5],
				selectedBins: /*selectedBins*/ ctx[6],
				theme: /*theme*/ ctx[7],
				ticksFormatFn: /*ticksFormatFn*/ ctx[8],
				width: /*width*/ ctx[10]
			},
			$$inline: true
		});

	histogramg.$on("brushed", /*brushed_handler*/ ctx[14]);
	histogramg.$on("brushend", /*brushend_handler*/ ctx[15]);
	histogramg.$on("brushstart", /*brushstart_handler*/ ctx[16]);
	histogramg.$on("clicked", /*clicked_handler*/ ctx[17]);
	histogramg.$on("entered", /*entered_handler*/ ctx[18]);
	histogramg.$on("exited", /*exited_handler*/ ctx[19]);

	const block = {
		c: function create() {
			create_component(histogramg.$$.fragment);
		},
		l: function claim(nodes) {
			claim_component(histogramg.$$.fragment, nodes);
		},
		m: function mount(target, anchor) {
			mount_component(histogramg, target, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const histogramg_changes = {};
			if (dirty & /*bins*/ 2) histogramg_changes.bins = /*bins*/ ctx[1];
			if (dirty & /*binsFill*/ 4) histogramg_changes.binsFill = /*binsFill*/ ctx[2];
			if (dirty & /*flags*/ 8) histogramg_changes.flags = /*flags*/ ctx[3];
			if (dirty & /*geometry*/ 16) histogramg_changes.geometry = /*geometry*/ ctx[4];
			if (dirty & /*height*/ 512) histogramg_changes.height = /*height*/ ctx[9];
			if (dirty & /*message*/ 32) histogramg_changes.message = /*message*/ ctx[5];
			if (dirty & /*selectedBins*/ 64) histogramg_changes.selectedBins = /*selectedBins*/ ctx[6];
			if (dirty & /*theme*/ 128) histogramg_changes.theme = /*theme*/ ctx[7];
			if (dirty & /*ticksFormatFn*/ 256) histogramg_changes.ticksFormatFn = /*ticksFormatFn*/ ctx[8];
			if (dirty & /*width*/ 1024) histogramg_changes.width = /*width*/ ctx[10];
			histogramg.$set(histogramg_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(histogramg.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(histogramg.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			destroy_component(histogramg, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$4.name,
		type: "if",
		source: "(48:3) {#if bins}",
		ctx
	});

	return block;
}

function create_fragment$4(ctx) {
	let div;
	let t;
	let main;
	let svg;
	let main_resize_listener;
	let current;
	let if_block0 = /*title*/ ctx[0] && create_if_block_1$2(ctx);
	let if_block1 = /*bins*/ ctx[1] && create_if_block$4(ctx);

	const block = {
		c: function create() {
			div = element("div");
			if (if_block0) if_block0.c();
			t = space();
			main = element("main");
			svg = svg_element("svg");
			if (if_block1) if_block1.c();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true, style: true });
			var div_nodes = children(div);
			if (if_block0) if_block0.l(div_nodes);
			t = claim_space(div_nodes);
			main = claim_element(div_nodes, "MAIN", { class: true });
			var main_nodes = children(main);
			svg = claim_svg_element(main_nodes, "svg", { width: true, height: true, class: true });
			var svg_nodes = children(svg);
			if (if_block1) if_block1.l(svg_nodes);
			svg_nodes.forEach(detach_dev);
			main_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(svg, "width", /*width*/ ctx[10]);
			attr_dev(svg, "height", /*height*/ ctx[9]);
			attr_dev(svg, "class", "svelte-1m2zakn");
			add_location(svg, file$4, 43, 2, 924);
			attr_dev(main, "class", "svelte-1m2zakn");
			add_render_callback(() => /*main_elementresize_handler*/ ctx[20].call(main));
			toggle_class(main, "titled", /*title*/ ctx[0] && /*title*/ ctx[0].length);
			add_location(main, file$4, 38, 1, 818);
			attr_dev(div, "class", "HistogramDiv svelte-1m2zakn");
			attr_dev(div, "style", /*style*/ ctx[11]);
			toggle_class(div, "interactive", /*flags*/ ctx[3] && /*flags*/ ctx[3].isInteractive);
			add_location(div, file$4, 28, 0, 617);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			if (if_block0) if_block0.m(div, null);
			append_hydration_dev(div, t);
			append_hydration_dev(div, main);
			append_hydration_dev(main, svg);
			if (if_block1) if_block1.m(svg, null);
			main_resize_listener = add_iframe_resize_listener(main, /*main_elementresize_handler*/ ctx[20].bind(main));
			current = true;
		},
		p: function update(ctx, [dirty]) {
			if (/*title*/ ctx[0]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_1$2(ctx);
					if_block0.c();
					if_block0.m(div, t);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*bins*/ ctx[1]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty & /*bins*/ 2) {
						transition_in(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block$4(ctx);
					if_block1.c();
					transition_in(if_block1, 1);
					if_block1.m(svg, null);
				}
			} else if (if_block1) {
				group_outros();

				transition_out(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (!current || dirty & /*width*/ 1024) {
				attr_dev(svg, "width", /*width*/ ctx[10]);
			}

			if (!current || dirty & /*height*/ 512) {
				attr_dev(svg, "height", /*height*/ ctx[9]);
			}

			if (!current || dirty & /*title*/ 1) {
				toggle_class(main, "titled", /*title*/ ctx[0] && /*title*/ ctx[0].length);
			}

			if (!current || dirty & /*style*/ 2048) {
				attr_dev(div, "style", /*style*/ ctx[11]);
			}

			if (!current || dirty & /*flags*/ 8) {
				toggle_class(div, "interactive", /*flags*/ ctx[3] && /*flags*/ ctx[3].isInteractive);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block1);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block1);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			main_resize_listener();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$4.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$3($$self, $$props, $$invalidate) {
	let style;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('HistogramDiv', slots, []);
	let { headerHeight = '2rem' } = $$props;
	let { padding = '10px' } = $$props;
	let { title = null } = $$props;
	let { bins = [] } = $$props;
	let { binsFill = null } = $$props;
	let { flags = null } = $$props;
	let { geometry = null } = $$props;
	let { message = 'No data' } = $$props;
	let { selectedBins = [] } = $$props;
	let { theme = null } = $$props;
	let { ticksFormatFn = null } = $$props;
	let height = 0;
	let width = 0;

	const writable_props = [
		'headerHeight',
		'padding',
		'title',
		'bins',
		'binsFill',
		'flags',
		'geometry',
		'message',
		'selectedBins',
		'theme',
		'ticksFormatFn'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<HistogramDiv> was created with unknown prop '${key}'`);
	});

	function brushed_handler(event) {
		bubble.call(this, $$self, event);
	}

	function brushend_handler(event) {
		bubble.call(this, $$self, event);
	}

	function brushstart_handler(event) {
		bubble.call(this, $$self, event);
	}

	function clicked_handler(event) {
		bubble.call(this, $$self, event);
	}

	function entered_handler(event) {
		bubble.call(this, $$self, event);
	}

	function exited_handler(event) {
		bubble.call(this, $$self, event);
	}

	function main_elementresize_handler() {
		height = this.clientHeight;
		width = this.clientWidth;
		$$invalidate(9, height);
		$$invalidate(10, width);
	}

	$$self.$$set = $$props => {
		if ('headerHeight' in $$props) $$invalidate(12, headerHeight = $$props.headerHeight);
		if ('padding' in $$props) $$invalidate(13, padding = $$props.padding);
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('bins' in $$props) $$invalidate(1, bins = $$props.bins);
		if ('binsFill' in $$props) $$invalidate(2, binsFill = $$props.binsFill);
		if ('flags' in $$props) $$invalidate(3, flags = $$props.flags);
		if ('geometry' in $$props) $$invalidate(4, geometry = $$props.geometry);
		if ('message' in $$props) $$invalidate(5, message = $$props.message);
		if ('selectedBins' in $$props) $$invalidate(6, selectedBins = $$props.selectedBins);
		if ('theme' in $$props) $$invalidate(7, theme = $$props.theme);
		if ('ticksFormatFn' in $$props) $$invalidate(8, ticksFormatFn = $$props.ticksFormatFn);
	};

	$$self.$capture_state = () => ({
		makeStyleVars,
		HistogramG: HistogramG$1,
		headerHeight,
		padding,
		title,
		bins,
		binsFill,
		flags,
		geometry,
		message,
		selectedBins,
		theme,
		ticksFormatFn,
		height,
		width,
		style
	});

	$$self.$inject_state = $$props => {
		if ('headerHeight' in $$props) $$invalidate(12, headerHeight = $$props.headerHeight);
		if ('padding' in $$props) $$invalidate(13, padding = $$props.padding);
		if ('title' in $$props) $$invalidate(0, title = $$props.title);
		if ('bins' in $$props) $$invalidate(1, bins = $$props.bins);
		if ('binsFill' in $$props) $$invalidate(2, binsFill = $$props.binsFill);
		if ('flags' in $$props) $$invalidate(3, flags = $$props.flags);
		if ('geometry' in $$props) $$invalidate(4, geometry = $$props.geometry);
		if ('message' in $$props) $$invalidate(5, message = $$props.message);
		if ('selectedBins' in $$props) $$invalidate(6, selectedBins = $$props.selectedBins);
		if ('theme' in $$props) $$invalidate(7, theme = $$props.theme);
		if ('ticksFormatFn' in $$props) $$invalidate(8, ticksFormatFn = $$props.ticksFormatFn);
		if ('height' in $$props) $$invalidate(9, height = $$props.height);
		if ('width' in $$props) $$invalidate(10, width = $$props.width);
		if ('style' in $$props) $$invalidate(11, style = $$props.style);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*padding*/ 8192) {
			$$invalidate(13, padding = padding || '10px');
		}

		if ($$self.$$.dirty & /*headerHeight*/ 4096) {
			$$invalidate(12, headerHeight = headerHeight || '2rem');
		}

		if ($$self.$$.dirty & /*headerHeight, padding*/ 12288) {
			$$invalidate(11, style = makeStyleVars({ headerHeight, padding }));
		}
	};

	return [
		title,
		bins,
		binsFill,
		flags,
		geometry,
		message,
		selectedBins,
		theme,
		ticksFormatFn,
		height,
		width,
		style,
		headerHeight,
		padding,
		brushed_handler,
		brushend_handler,
		brushstart_handler,
		clicked_handler,
		entered_handler,
		exited_handler,
		main_elementresize_handler
	];
}

class HistogramDiv extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance$3, create_fragment$4, safe_not_equal, {
			headerHeight: 12,
			padding: 13,
			title: 0,
			bins: 1,
			binsFill: 2,
			flags: 3,
			geometry: 4,
			message: 5,
			selectedBins: 6,
			theme: 7,
			ticksFormatFn: 8
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "HistogramDiv",
			options,
			id: create_fragment$4.name
		});
	}

	get headerHeight() {
		throw new Error("<HistogramDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set headerHeight(value) {
		throw new Error("<HistogramDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get padding() {
		throw new Error("<HistogramDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set padding(value) {
		throw new Error("<HistogramDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<HistogramDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<HistogramDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get bins() {
		throw new Error("<HistogramDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set bins(value) {
		throw new Error("<HistogramDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get binsFill() {
		throw new Error("<HistogramDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set binsFill(value) {
		throw new Error("<HistogramDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get flags() {
		throw new Error("<HistogramDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set flags(value) {
		throw new Error("<HistogramDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get geometry() {
		throw new Error("<HistogramDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set geometry(value) {
		throw new Error("<HistogramDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get message() {
		throw new Error("<HistogramDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set message(value) {
		throw new Error("<HistogramDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get selectedBins() {
		throw new Error("<HistogramDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set selectedBins(value) {
		throw new Error("<HistogramDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get theme() {
		throw new Error("<HistogramDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set theme(value) {
		throw new Error("<HistogramDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get ticksFormatFn() {
		throw new Error("<HistogramDiv>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set ticksFormatFn(value) {
		throw new Error("<HistogramDiv>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var HistogramDiv$1 = HistogramDiv;

var histogram = /*#__PURE__*/Object.freeze({
	__proto__: null,
	HistogramG: HistogramG$1,
	HistogramDiv: HistogramDiv$1,
	exactAmountBins: exactAmountBins,
	areValidBins: areValidBins,
	getBinsItems: getBinsItems,
	getValuesLength: getValuesLength,
	getBinsMax: getBinsMax,
	getBinsMin: getBinsMin,
	getBinsExtent: getBinsExtent,
	isNonEmptyBin: isNonEmptyBin,
	findFirstNonEmptyBinIndex: findFirstNonEmptyBinIndex,
	findLastNonEmptyBinIndex: findLastNonEmptyBinIndex,
	getTrimmedBinsStats: getTrimmedBinsStats,
	getBinsTicks: getBinsTicks,
	getBinsTicksExtent: getBinsTicksExtent,
	getNonEmptyBinsTicks: getNonEmptyBinsTicks
});

var legend = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ColorBinsG: ColorBinsG,
	ColorBinsDiv: ColorBinsDiv
});

function area(x0, y0, y1) {
  var x1 = null,
      defined = constant$1(true),
      context = null,
      curve = curveLinear,
      output = null,
      path = withPath(area);

  x0 = typeof x0 === "function" ? x0 : (x0 === undefined) ? x : constant$1(+x0);
  y0 = typeof y0 === "function" ? y0 : (y0 === undefined) ? constant$1(0) : constant$1(+y0);
  y1 = typeof y1 === "function" ? y1 : (y1 === undefined) ? y : constant$1(+y1);

  function area(data) {
    var i,
        j,
        k,
        n = (data = array(data)).length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return line().defined(defined).curve(curve).context(context);
  }

  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$1(+_), x1 = null, area) : x0;
  };

  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$1(+_), area) : x0;
  };

  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), area) : x1;
  };

  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$1(+_), y1 = null, area) : y0;
  };

  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$1(+_), area) : y0;
  };

  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$1(+_), area) : y1;
  };

  area.lineX0 =
  area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };

  area.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$1(!!_), area) : defined;
  };

  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}

const SECOND = 1;
const MINUTE = 60 * SECOND;
const HOUR = 60 * MINUTE;
const DAY = 24 * HOUR;
const MONTH = 28 * DAY; // shortest month
const YEAR = 365 * DAY; // shortest year

// TODO Svizzle: add formatting options for shorter time spans
const formatOptions = [
	[YEAR, {year: '2-digit'}],
	[MONTH, {year: '2-digit', month: '2-digit'}],
	[DAY, {year: '2-digit', month: '2-digit', day: '2-digit'}],
];

// TODO use a module such as `luxon` instead of `Intl.DateTimeFormat`
const timeFormats = map(
	formatOptions,
	([maxSeconds, options]) => [
		maxSeconds,
		new Intl.DateTimeFormat('fr-CA', options).format // fr-CA -> yy-mm-dd
	]
);

const getDateTimeFormat = tickDurationInSecs => {
	let timeFormat;

	if (!tickDurationInSecs) {
		// eslint-disable-next-line prefer-destructuring
		timeFormat = last(timeFormats)[1];
	} else {
		// eslint-disable-next-line prefer-destructuring
		timeFormat = find(
			timeFormats,
			([maxSeconds]) => tickDurationInSecs >= maxSeconds
		)[1];
	}

	return timeFormat;
};

const pluckKeySorted = pipe([pluckKey, sortWith([])]);

/* ../../components/trends/src/PercentilesTrends.svelte generated by Svelte v3.59.2 */
const file$3 = "../../components/trends/src/PercentilesTrends.svelte";

function get_each_context$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[45] = list[i].label;
	child_ctx[46] = list[i].gridAreas;
	return child_ctx;
}

function get_each_context_1$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[49] = list[i];
	return child_ctx;
}

function get_each_context_2$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[52] = list[i];
	return child_ctx;
}

function get_each_context_3$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[55] = list[i][0];
	return child_ctx;
}

function get_each_context_4$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[52] = list[i];
	return child_ctx;
}

function get_each_context_5$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[55] = list[i][0];
	child_ctx[45] = list[i][1];
	return child_ctx;
}

function get_each_context_6$3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[62] = list[i].generator;
	child_ctx[55] = list[i].key;
	return child_ctx;
}

function get_each_context_7$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[65] = list[i].color;
	child_ctx[62] = list[i].generator;
	child_ctx[55] = list[i].key;
	child_ctx[66] = list[i].lowKey;
	return child_ctx;
}

// (195:2) {#if doDraw}
function create_if_block$3(ctx) {
	let svg;
	let each_blocks_5 = [];
	let each0_lookup = new Map();
	let each0_anchor;
	let each_blocks_4 = [];
	let each1_lookup = new Map();
	let g0;
	let g1;
	let g4;
	let g2;
	let g3;
	let rect;
	let rect_x_value;
	let rect_y_value;
	let rect_width_value;
	let rect_height_value;
	let each_value_7 = /*areas*/ ctx[9];
	validate_each_argument(each_value_7);
	const get_key = ctx => /*lowKey*/ ctx[66];
	validate_each_keys(ctx, each_value_7, get_each_context_7$1, get_key);

	for (let i = 0; i < each_value_7.length; i += 1) {
		let child_ctx = get_each_context_7$1(ctx, each_value_7, i);
		let key = get_key(child_ctx);
		each0_lookup.set(key, each_blocks_5[i] = create_each_block_7$1(key, child_ctx));
	}

	let each_value_6 = /*lines*/ ctx[12];
	validate_each_argument(each_value_6);
	const get_key_1 = ctx => /*key*/ ctx[55];
	validate_each_keys(ctx, each_value_6, get_each_context_6$3, get_key_1);

	for (let i = 0; i < each_value_6.length; i += 1) {
		let child_ctx = get_each_context_6$3(ctx, each_value_6, i);
		let key = get_key_1(child_ctx);
		each1_lookup.set(key, each_blocks_4[i] = create_each_block_6$3(key, child_ctx));
	}

	let each_value_5 = /*keyTicks*/ ctx[11];
	validate_each_argument(each_value_5);
	let each_blocks_3 = [];

	for (let i = 0; i < each_value_5.length; i += 1) {
		each_blocks_3[i] = create_each_block_5$3(get_each_context_5$3(ctx, each_value_5, i));
	}

	let each_value_4 = /*yTicks*/ ctx[13];
	validate_each_argument(each_value_4);
	let each_blocks_2 = [];

	for (let i = 0; i < each_value_4.length; i += 1) {
		each_blocks_2[i] = create_each_block_4$3(get_each_context_4$3(ctx, each_value_4, i));
	}

	let each_value_3 = /*keyTicks*/ ctx[11];
	validate_each_argument(each_value_3);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks_1[i] = create_each_block_3$3(get_each_context_3$3(ctx, each_value_3, i));
	}

	let each_value_2 = /*yTicks*/ ctx[13];
	validate_each_argument(each_value_2);
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2$3(get_each_context_2$3(ctx, each_value_2, i));
	}

	const block = {
		c: function create() {
			svg = svg_element("svg");

			for (let i = 0; i < each_blocks_5.length; i += 1) {
				each_blocks_5[i].c();
			}

			each0_anchor = empty();

			for (let i = 0; i < each_blocks_4.length; i += 1) {
				each_blocks_4[i].c();
			}

			g0 = svg_element("g");

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].c();
			}

			g1 = svg_element("g");

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].c();
			}

			g4 = svg_element("g");
			g2 = svg_element("g");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			g3 = svg_element("g");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			rect = svg_element("rect");
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_svg_element(nodes, "svg", { height: true, width: true, class: true });
			var svg_nodes = children(svg);

			for (let i = 0; i < each_blocks_5.length; i += 1) {
				each_blocks_5[i].l(svg_nodes);
			}

			each0_anchor = empty();

			for (let i = 0; i < each_blocks_4.length; i += 1) {
				each_blocks_4[i].l(svg_nodes);
			}

			g0 = claim_svg_element(svg_nodes, "g", { class: true });
			var g0_nodes = children(g0);

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].l(g0_nodes);
			}

			g0_nodes.forEach(detach_dev);
			g1 = claim_svg_element(svg_nodes, "g", { class: true });
			var g1_nodes = children(g1);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].l(g1_nodes);
			}

			g1_nodes.forEach(detach_dev);
			g4 = claim_svg_element(svg_nodes, "g", { class: true });
			var g4_nodes = children(g4);
			g2 = claim_svg_element(g4_nodes, "g", { class: true });
			var g2_nodes = children(g2);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].l(g2_nodes);
			}

			g2_nodes.forEach(detach_dev);
			g3 = claim_svg_element(g4_nodes, "g", { class: true });
			var g3_nodes = children(g3);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(g3_nodes);
			}

			g3_nodes.forEach(detach_dev);
			g4_nodes.forEach(detach_dev);

			rect = claim_svg_element(svg_nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				class: true
			});

			children(rect).forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(g0, "class", "x-ticks");
			add_location(g0, file$3, 233, 4, 5590);
			attr_dev(g1, "class", "y-ticks");
			add_location(g1, file$3, 257, 4, 6022);
			attr_dev(g2, "class", "vertical");
			add_location(g2, file$3, 282, 5, 6491);
			attr_dev(g3, "class", "horizontal");
			add_location(g3, file$3, 292, 5, 6690);
			attr_dev(g4, "class", "grid svelte-1z0non4");
			add_location(g4, file$3, 281, 4, 6469);
			attr_dev(rect, "x", rect_x_value = /*bbox*/ ctx[6].blx);
			attr_dev(rect, "y", rect_y_value = /*bbox*/ ctx[6].try);
			attr_dev(rect, "width", rect_width_value = /*bbox*/ ctx[6].width);
			attr_dev(rect, "height", rect_height_value = /*bbox*/ ctx[6].height);
			attr_dev(rect, "class", "svelte-1z0non4");
			add_location(rect, file$3, 305, 4, 6921);
			attr_dev(svg, "height", /*height*/ ctx[4]);
			attr_dev(svg, "width", /*width*/ ctx[5]);
			attr_dev(svg, "class", "svelte-1z0non4");
			add_location(svg, file$3, 195, 3, 4651);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, svg, anchor);

			for (let i = 0; i < each_blocks_5.length; i += 1) {
				if (each_blocks_5[i]) {
					each_blocks_5[i].m(svg, null);
				}
			}

			append_hydration_dev(svg, each0_anchor);

			for (let i = 0; i < each_blocks_4.length; i += 1) {
				if (each_blocks_4[i]) {
					each_blocks_4[i].m(svg, null);
				}
			}

			append_hydration_dev(svg, g0);

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				if (each_blocks_3[i]) {
					each_blocks_3[i].m(g0, null);
				}
			}

			append_hydration_dev(svg, g1);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				if (each_blocks_2[i]) {
					each_blocks_2[i].m(g1, null);
				}
			}

			append_hydration_dev(svg, g4);
			append_hydration_dev(g4, g2);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				if (each_blocks_1[i]) {
					each_blocks_1[i].m(g2, null);
				}
			}

			append_hydration_dev(g4, g3);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(g3, null);
				}
			}

			append_hydration_dev(svg, rect);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*areas, items, dispatch*/ 66050) {
				each_value_7 = /*areas*/ ctx[9];
				validate_each_argument(each_value_7);
				validate_each_keys(ctx, each_value_7, get_each_context_7$1, get_key);
				each_blocks_5 = update_keyed_each(each_blocks_5, dirty, get_key, 1, ctx, each_value_7, each0_lookup, svg, destroy_block, create_each_block_7$1, each0_anchor, get_each_context_7$1);
			}

			if (dirty[0] & /*lines, items, keyToColorFn*/ 4106) {
				each_value_6 = /*lines*/ ctx[12];
				validate_each_argument(each_value_6);
				validate_each_keys(ctx, each_value_6, get_each_context_6$3, get_key_1);
				each_blocks_4 = update_keyed_each(each_blocks_4, dirty, get_key_1, 1, ctx, each_value_6, each1_lookup, svg, destroy_block, create_each_block_6$3, g0, get_each_context_6$3);
			}

			if (dirty[0] & /*labelsDy, xScale, keyTicks, bbox*/ 18624) {
				each_value_5 = /*keyTicks*/ ctx[11];
				validate_each_argument(each_value_5);
				let i;

				for (i = 0; i < each_value_5.length; i += 1) {
					const child_ctx = get_each_context_5$3(ctx, each_value_5, i);

					if (each_blocks_3[i]) {
						each_blocks_3[i].p(child_ctx, dirty);
					} else {
						each_blocks_3[i] = create_each_block_5$3(child_ctx);
						each_blocks_3[i].c();
						each_blocks_3[i].m(g0, null);
					}
				}

				for (; i < each_blocks_3.length; i += 1) {
					each_blocks_3[i].d(1);
				}

				each_blocks_3.length = each_value_5.length;
			}

			if (dirty[0] & /*bbox, yScale, yTicks, valueFormatFn*/ 8516) {
				each_value_4 = /*yTicks*/ ctx[13];
				validate_each_argument(each_value_4);
				let i;

				for (i = 0; i < each_value_4.length; i += 1) {
					const child_ctx = get_each_context_4$3(ctx, each_value_4, i);

					if (each_blocks_2[i]) {
						each_blocks_2[i].p(child_ctx, dirty);
					} else {
						each_blocks_2[i] = create_each_block_4$3(child_ctx);
						each_blocks_2[i].c();
						each_blocks_2[i].m(g1, null);
					}
				}

				for (; i < each_blocks_2.length; i += 1) {
					each_blocks_2[i].d(1);
				}

				each_blocks_2.length = each_value_4.length;
			}

			if (dirty[0] & /*xScale, keyTicks, bbox*/ 2240) {
				each_value_3 = /*keyTicks*/ ctx[11];
				validate_each_argument(each_value_3);
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3$3(ctx, each_value_3, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_3$3(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(g2, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_3.length;
			}

			if (dirty[0] & /*bbox, yScale, yTicks*/ 8512) {
				each_value_2 = /*yTicks*/ ctx[13];
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2$3(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2$3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(g3, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}

			if (dirty[0] & /*bbox*/ 64 && rect_x_value !== (rect_x_value = /*bbox*/ ctx[6].blx)) {
				attr_dev(rect, "x", rect_x_value);
			}

			if (dirty[0] & /*bbox*/ 64 && rect_y_value !== (rect_y_value = /*bbox*/ ctx[6].try)) {
				attr_dev(rect, "y", rect_y_value);
			}

			if (dirty[0] & /*bbox*/ 64 && rect_width_value !== (rect_width_value = /*bbox*/ ctx[6].width)) {
				attr_dev(rect, "width", rect_width_value);
			}

			if (dirty[0] & /*bbox*/ 64 && rect_height_value !== (rect_height_value = /*bbox*/ ctx[6].height)) {
				attr_dev(rect, "height", rect_height_value);
			}

			if (dirty[0] & /*height*/ 16) {
				attr_dev(svg, "height", /*height*/ ctx[4]);
			}

			if (dirty[0] & /*width*/ 32) {
				attr_dev(svg, "width", /*width*/ ctx[5]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);

			for (let i = 0; i < each_blocks_5.length; i += 1) {
				each_blocks_5[i].d();
			}

			for (let i = 0; i < each_blocks_4.length; i += 1) {
				each_blocks_4[i].d();
			}

			destroy_each(each_blocks_3, detaching);
			destroy_each(each_blocks_2, detaching);
			destroy_each(each_blocks_1, detaching);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$3.name,
		type: "if",
		source: "(195:2) {#if doDraw}",
		ctx
	});

	return block;
}

// (201:4) {#each areas as {color, generator, key, lowKey}
function create_each_block_7$1(key_1, ctx) {
	let path;
	let path_d_value;
	let path_fill_value;
	let mounted;
	let dispose;

	function mousemove_handler(...args) {
		return /*mousemove_handler*/ ctx[35](/*key*/ ctx[55], ...args);
	}

	function mouseout_handler(...args) {
		return /*mouseout_handler*/ ctx[36](/*key*/ ctx[55], ...args);
	}

	function touchstart_handler(...args) {
		return /*touchstart_handler*/ ctx[37](/*key*/ ctx[55], ...args);
	}

	function touchend_handler() {
		return /*touchend_handler*/ ctx[38](/*key*/ ctx[55]);
	}

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", {
				role: true,
				d: true,
				fill: true,
				class: true
			});

			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "role", "none");
			attr_dev(path, "d", path_d_value = /*generator*/ ctx[62](/*items*/ ctx[1]));
			attr_dev(path, "fill", path_fill_value = /*color*/ ctx[65]);
			attr_dev(path, "class", "svelte-1z0non4");
			add_location(path, file$3, 202, 5, 4834);
			this.first = path;
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);

			if (!mounted) {
				dispose = [
					listen_dev(path, "mousemove", mousemove_handler, false, false, false, false),
					listen_dev(path, "mouseout", mouseout_handler, false, false, false, false),
					listen_dev(path, "touchstart", prevent_default(touchstart_handler), false, true, false, false),
					listen_dev(path, "touchend", touchend_handler, { passive: true }, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*areas, items*/ 514 && path_d_value !== (path_d_value = /*generator*/ ctx[62](/*items*/ ctx[1]))) {
				attr_dev(path, "d", path_d_value);
			}

			if (dirty[0] & /*areas*/ 512 && path_fill_value !== (path_fill_value = /*color*/ ctx[65])) {
				attr_dev(path, "fill", path_fill_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_7$1.name,
		type: "each",
		source: "(201:4) {#each areas as {color, generator, key, lowKey}",
		ctx
	});

	return block;
}

// (224:4) {#each lines as {generator, key}
function create_each_block_6$3(key_1, ctx) {
	let path;
	let path_d_value;
	let path_stroke_value;

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", {
				class: true,
				d: true,
				fill: true,
				stroke: true
			});

			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "class", "line svelte-1z0non4");
			attr_dev(path, "d", path_d_value = /*generator*/ ctx[62](/*items*/ ctx[1]));
			attr_dev(path, "fill", "none");
			attr_dev(path, "stroke", path_stroke_value = /*keyToColorFn*/ ctx[3]?.(/*key*/ ctx[55]) ?? 'var(--curveStroke)');
			add_location(path, file$3, 224, 5, 5415);
			this.first = path;
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*lines, items*/ 4098 && path_d_value !== (path_d_value = /*generator*/ ctx[62](/*items*/ ctx[1]))) {
				attr_dev(path, "d", path_d_value);
			}

			if (dirty[0] & /*keyToColorFn, lines*/ 4104 && path_stroke_value !== (path_stroke_value = /*keyToColorFn*/ ctx[3]?.(/*key*/ ctx[55]) ?? 'var(--curveStroke)')) {
				attr_dev(path, "stroke", path_stroke_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_6$3.name,
		type: "each",
		source: "(224:4) {#each lines as {generator, key}",
		ctx
	});

	return block;
}

// (235:5) {#each keyTicks as [key, label]}
function create_each_block_5$3(ctx) {
	let g;
	let text0;
	let t0_value = /*label*/ ctx[45] + "";
	let t0;
	let text0_x_value;
	let text0_y_value;
	let text1;
	let t1_value = /*label*/ ctx[45] + "";
	let t1;
	let text1_dy_value;
	let text1_x_value;
	let text1_y_value;

	const block = {
		c: function create() {
			g = svg_element("g");
			text0 = svg_element("text");
			t0 = text(t0_value);
			text1 = svg_element("text");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			g = claim_svg_element(nodes, "g", { class: true });
			var g_nodes = children(g);
			text0 = claim_svg_element(g_nodes, "text", { class: true, dy: true, x: true, y: true });
			var text0_nodes = children(text0);
			t0 = claim_text(text0_nodes, t0_value);
			text0_nodes.forEach(detach_dev);
			text1 = claim_svg_element(g_nodes, "text", { class: true, dy: true, x: true, y: true });
			var text1_nodes = children(text1);
			t1 = claim_text(text1_nodes, t1_value);
			text1_nodes.forEach(detach_dev);
			g_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(text0, "class", "centered svelte-1z0non4");
			attr_dev(text0, "dy", /*labelsDy*/ ctx[14]);
			attr_dev(text0, "x", text0_x_value = /*xScale*/ ctx[7](/*key*/ ctx[55]));
			attr_dev(text0, "y", text0_y_value = /*bbox*/ ctx[6].bly);
			add_location(text0, file$3, 236, 7, 5679);
			attr_dev(text1, "class", "centered svelte-1z0non4");
			attr_dev(text1, "dy", text1_dy_value = -/*labelsDy*/ ctx[14]);
			attr_dev(text1, "x", text1_x_value = /*xScale*/ ctx[7](/*key*/ ctx[55]));
			attr_dev(text1, "y", text1_y_value = /*bbox*/ ctx[6].try);
			add_location(text1, file$3, 244, 7, 5824);
			attr_dev(g, "class", "ticks svelte-1z0non4");
			add_location(g, file$3, 235, 6, 5654);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, g, anchor);
			append_hydration_dev(g, text0);
			append_hydration_dev(text0, t0);
			append_hydration_dev(g, text1);
			append_hydration_dev(text1, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*keyTicks*/ 2048 && t0_value !== (t0_value = /*label*/ ctx[45] + "")) set_data_dev(t0, t0_value);

			if (dirty[0] & /*labelsDy*/ 16384) {
				attr_dev(text0, "dy", /*labelsDy*/ ctx[14]);
			}

			if (dirty[0] & /*xScale, keyTicks*/ 2176 && text0_x_value !== (text0_x_value = /*xScale*/ ctx[7](/*key*/ ctx[55]))) {
				attr_dev(text0, "x", text0_x_value);
			}

			if (dirty[0] & /*bbox*/ 64 && text0_y_value !== (text0_y_value = /*bbox*/ ctx[6].bly)) {
				attr_dev(text0, "y", text0_y_value);
			}

			if (dirty[0] & /*keyTicks*/ 2048 && t1_value !== (t1_value = /*label*/ ctx[45] + "")) set_data_dev(t1, t1_value);

			if (dirty[0] & /*labelsDy*/ 16384 && text1_dy_value !== (text1_dy_value = -/*labelsDy*/ ctx[14])) {
				attr_dev(text1, "dy", text1_dy_value);
			}

			if (dirty[0] & /*xScale, keyTicks*/ 2176 && text1_x_value !== (text1_x_value = /*xScale*/ ctx[7](/*key*/ ctx[55]))) {
				attr_dev(text1, "x", text1_x_value);
			}

			if (dirty[0] & /*bbox*/ 64 && text1_y_value !== (text1_y_value = /*bbox*/ ctx[6].try)) {
				attr_dev(text1, "y", text1_y_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(g);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_5$3.name,
		type: "each",
		source: "(235:5) {#each keyTicks as [key, label]}",
		ctx
	});

	return block;
}

// (259:5) {#each yTicks as value}
function create_each_block_4$3(ctx) {
	let g;
	let text0;
	let t0_value = /*valueFormatFn*/ ctx[2](/*value*/ ctx[52]) + "";
	let t0;
	let text0_x_value;
	let text0_y_value;
	let text1;
	let t1_value = /*valueFormatFn*/ ctx[2](/*value*/ ctx[52]) + "";
	let t1;
	let text1_x_value;
	let text1_y_value;

	const block = {
		c: function create() {
			g = svg_element("g");
			text0 = svg_element("text");
			t0 = text(t0_value);
			text1 = svg_element("text");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			g = claim_svg_element(nodes, "g", { class: true });
			var g_nodes = children(g);
			text0 = claim_svg_element(g_nodes, "text", { class: true, dx: true, x: true, y: true });
			var text0_nodes = children(text0);
			t0 = claim_text(text0_nodes, t0_value);
			text0_nodes.forEach(detach_dev);
			text1 = claim_svg_element(g_nodes, "text", { class: true, dx: true, x: true, y: true });
			var text1_nodes = children(text1);
			t1 = claim_text(text1_nodes, t1_value);
			text1_nodes.forEach(detach_dev);
			g_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(text0, "class", "left svelte-1z0non4");
			attr_dev(text0, "dx", -labelsDx$2);
			attr_dev(text0, "x", text0_x_value = /*bbox*/ ctx[6].blx);
			attr_dev(text0, "y", text0_y_value = /*yScale*/ ctx[8](/*value*/ ctx[52]));
			add_location(text0, file$3, 260, 7, 6102);
			attr_dev(text1, "class", "right svelte-1z0non4");
			attr_dev(text1, "dx", labelsDx$2);
			attr_dev(text1, "x", text1_x_value = /*bbox*/ ctx[6].trx);
			attr_dev(text1, "y", text1_y_value = /*yScale*/ ctx[8](/*value*/ ctx[52]));
			add_location(text1, file$3, 268, 7, 6261);
			attr_dev(g, "class", "ticks svelte-1z0non4");
			add_location(g, file$3, 259, 6, 6077);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, g, anchor);
			append_hydration_dev(g, text0);
			append_hydration_dev(text0, t0);
			append_hydration_dev(g, text1);
			append_hydration_dev(text1, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*valueFormatFn, yTicks*/ 8196 && t0_value !== (t0_value = /*valueFormatFn*/ ctx[2](/*value*/ ctx[52]) + "")) set_data_dev(t0, t0_value);

			if (dirty[0] & /*bbox*/ 64 && text0_x_value !== (text0_x_value = /*bbox*/ ctx[6].blx)) {
				attr_dev(text0, "x", text0_x_value);
			}

			if (dirty[0] & /*yScale, yTicks*/ 8448 && text0_y_value !== (text0_y_value = /*yScale*/ ctx[8](/*value*/ ctx[52]))) {
				attr_dev(text0, "y", text0_y_value);
			}

			if (dirty[0] & /*valueFormatFn, yTicks*/ 8196 && t1_value !== (t1_value = /*valueFormatFn*/ ctx[2](/*value*/ ctx[52]) + "")) set_data_dev(t1, t1_value);

			if (dirty[0] & /*bbox*/ 64 && text1_x_value !== (text1_x_value = /*bbox*/ ctx[6].trx)) {
				attr_dev(text1, "x", text1_x_value);
			}

			if (dirty[0] & /*yScale, yTicks*/ 8448 && text1_y_value !== (text1_y_value = /*yScale*/ ctx[8](/*value*/ ctx[52]))) {
				attr_dev(text1, "y", text1_y_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(g);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_4$3.name,
		type: "each",
		source: "(259:5) {#each yTicks as value}",
		ctx
	});

	return block;
}

// (284:6) {#each keyTicks as [key]}
function create_each_block_3$3(ctx) {
	let line_1;
	let line_1_x__value;
	let line_1_x__value_1;
	let line_1_y__value;
	let line_1_y__value_1;

	const block = {
		c: function create() {
			line_1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			line_1 = claim_svg_element(nodes, "line", {
				x1: true,
				x2: true,
				y1: true,
				y2: true,
				class: true
			});

			children(line_1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line_1, "x1", line_1_x__value = /*xScale*/ ctx[7](/*key*/ ctx[55]));
			attr_dev(line_1, "x2", line_1_x__value_1 = /*xScale*/ ctx[7](/*key*/ ctx[55]));
			attr_dev(line_1, "y1", line_1_y__value = /*bbox*/ ctx[6].bly);
			attr_dev(line_1, "y2", line_1_y__value_1 = /*bbox*/ ctx[6].try);
			attr_dev(line_1, "class", "svelte-1z0non4");
			add_location(line_1, file$3, 284, 7, 6551);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line_1, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*xScale, keyTicks*/ 2176 && line_1_x__value !== (line_1_x__value = /*xScale*/ ctx[7](/*key*/ ctx[55]))) {
				attr_dev(line_1, "x1", line_1_x__value);
			}

			if (dirty[0] & /*xScale, keyTicks*/ 2176 && line_1_x__value_1 !== (line_1_x__value_1 = /*xScale*/ ctx[7](/*key*/ ctx[55]))) {
				attr_dev(line_1, "x2", line_1_x__value_1);
			}

			if (dirty[0] & /*bbox*/ 64 && line_1_y__value !== (line_1_y__value = /*bbox*/ ctx[6].bly)) {
				attr_dev(line_1, "y1", line_1_y__value);
			}

			if (dirty[0] & /*bbox*/ 64 && line_1_y__value_1 !== (line_1_y__value_1 = /*bbox*/ ctx[6].try)) {
				attr_dev(line_1, "y2", line_1_y__value_1);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(line_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_3$3.name,
		type: "each",
		source: "(284:6) {#each keyTicks as [key]}",
		ctx
	});

	return block;
}

// (294:6) {#each yTicks as value}
function create_each_block_2$3(ctx) {
	let line_1;
	let line_1_x__value;
	let line_1_x__value_1;
	let line_1_y__value;
	let line_1_y__value_1;

	const block = {
		c: function create() {
			line_1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			line_1 = claim_svg_element(nodes, "line", {
				x1: true,
				x2: true,
				y1: true,
				y2: true,
				class: true
			});

			children(line_1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line_1, "x1", line_1_x__value = /*bbox*/ ctx[6].blx);
			attr_dev(line_1, "x2", line_1_x__value_1 = /*bbox*/ ctx[6].trx);
			attr_dev(line_1, "y1", line_1_y__value = /*yScale*/ ctx[8](/*value*/ ctx[52]));
			attr_dev(line_1, "y2", line_1_y__value_1 = /*yScale*/ ctx[8](/*value*/ ctx[52]));
			attr_dev(line_1, "class", "svelte-1z0non4");
			add_location(line_1, file$3, 294, 7, 6750);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line_1, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*bbox*/ 64 && line_1_x__value !== (line_1_x__value = /*bbox*/ ctx[6].blx)) {
				attr_dev(line_1, "x1", line_1_x__value);
			}

			if (dirty[0] & /*bbox*/ 64 && line_1_x__value_1 !== (line_1_x__value_1 = /*bbox*/ ctx[6].trx)) {
				attr_dev(line_1, "x2", line_1_x__value_1);
			}

			if (dirty[0] & /*yScale, yTicks*/ 8448 && line_1_y__value !== (line_1_y__value = /*yScale*/ ctx[8](/*value*/ ctx[52]))) {
				attr_dev(line_1, "y1", line_1_y__value);
			}

			if (dirty[0] & /*yScale, yTicks*/ 8448 && line_1_y__value_1 !== (line_1_y__value_1 = /*yScale*/ ctx[8](/*value*/ ctx[52]))) {
				attr_dev(line_1, "y2", line_1_y__value_1);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(line_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2$3.name,
		type: "each",
		source: "(294:6) {#each yTicks as value}",
		ctx
	});

	return block;
}

// (318:2) {#each gridAreas as gridArea}
function create_each_block_1$3(ctx) {
	let div;
	let t0_value = /*label*/ ctx[45] + "";
	let t0;
	let t1;
	let div_class_value;

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", div_class_value = "" + (/*gridArea*/ ctx[49] + " area" + " svelte-1z0non4"));
			add_location(div, file$3, 318, 3, 7125);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t0);
			append_hydration_dev(div, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*axesLabels*/ 1 && t0_value !== (t0_value = /*label*/ ctx[45] + "")) set_data_dev(t0, t0_value);

			if (dirty[0] & /*axesLabels*/ 1 && div_class_value !== (div_class_value = "" + (/*gridArea*/ ctx[49] + " area" + " svelte-1z0non4"))) {
				attr_dev(div, "class", div_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$3.name,
		type: "each",
		source: "(318:2) {#each gridAreas as gridArea}",
		ctx
	});

	return block;
}

// (317:1) {#each axesLabels as {label, gridAreas}}
function create_each_block$3(ctx) {
	let each_1_anchor;
	let each_value_1 = /*gridAreas*/ ctx[46];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert_hydration_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*axesLabels*/ 1) {
				each_value_1 = /*gridAreas*/ ctx[46];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1$3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$3.name,
		type: "each",
		source: "(317:1) {#each axesLabels as {label, gridAreas}}",
		ctx
	});

	return block;
}

function create_fragment$3(ctx) {
	let div1;
	let div0;
	let t;
	let mounted;
	let dispose;
	let if_block = /*doDraw*/ ctx[10] && create_if_block$3(ctx);
	let each_value = /*axesLabels*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			if (if_block) if_block.c();
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { style: true, class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (if_block) if_block.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t = claim_space(div1_nodes);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div1_nodes);
			}

			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "chart svelte-1z0non4");
			add_location(div0, file$3, 190, 1, 4590);
			attr_dev(div1, "style", /*style*/ ctx[15]);
			attr_dev(div1, "class", "StatsTrends svelte-1z0non4");
			add_location(div1, file$3, 186, 0, 4552);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div1, anchor);
			append_hydration_dev(div1, div0);
			if (if_block) if_block.m(div0, null);
			append_hydration_dev(div1, t);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div1, null);
				}
			}

			if (!mounted) {
				dispose = action_destroyer(/*sizeObserver*/ ctx[18].call(null, div0));
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*doDraw*/ ctx[10]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$3(ctx);
					if_block.c();
					if_block.m(div0, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*axesLabels*/ 1) {
				each_value = /*axesLabels*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$3(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$3(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty[0] & /*style*/ 32768) {
				attr_dev(div1, "style", /*style*/ ctx[15]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (if_block) if_block.d();
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$3.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const labelsDx$2 = 20;

function instance$2($$self, $$props, $$invalidate) {
	let style;
	let labelsDy;
	let allKeys;
	let maxValue;
	let maxValueSign;
	let minValue;
	let minValueSign;
	let yTicks;
	let $_size;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('PercentilesTrends', slots, []);
	const dispatch = createEventDispatcher();
	const { _writable: _size, resizeObserver: sizeObserver } = setupResizeObserver();
	validate_store(_size, '_size');
	component_subscribe($$self, _size, value => $$invalidate(34, $_size = value));

	const defaultGeometry = {
		safetyBottom: 20,
		safetyLeft: 20,
		safetyRight: 20,
		safetyTop: 20
	};

	const defaultTheme = {
		curveStroke: 'black',
		curveStrokeWidth: 1,
		// frame theme
		frameFill: 'none',
		frameStroke: 'black',
		gridStroke: 'lightgrey',
		gridStrokeDasharray: '4 8',
		textColor: 'black'
	};

	const defaultItems = []; // {key, values: {min, max, avg, '1.0', ...}}[]
	let { areaLowKeyToColor } = $$props;
	let { axesLabels } = $$props;
	let { config } = $$props;
	let { geometry } = $$props;
	let { items = defaultItems } = $$props;
	let { keyFilterFn = null } = $$props;
	let { keyFormatFn = identity } = $$props;
	let { keyToColorFn = null } = $$props;
	let { keyType } = $$props;
	let { theme = null } = $$props;
	let { valueFormatFn } = $$props;
	let { yTicksCount = 10 } = $$props;
	let height;
	let width;

	/* data */
	const getSortedKeys = pipe([pluckKey, uniques, sortWith()]);

	const getMaxValue = arrayMaxWith(getPath('values.max'));
	const getMinValue = arrayMinWith(getPath('values.min'));
	let yDomain;
	let yDelta;
	let areas;
	let bbox;
	let doDraw = false;
	let keyTicks;
	let lines;
	let xScale;
	let yScale;

	$$self.$$.on_mount.push(function () {
		if (areaLowKeyToColor === undefined && !('areaLowKeyToColor' in $$props || $$self.$$.bound[$$self.$$.props['areaLowKeyToColor']])) {
			console.warn("<PercentilesTrends> was created without expected prop 'areaLowKeyToColor'");
		}

		if (axesLabels === undefined && !('axesLabels' in $$props || $$self.$$.bound[$$self.$$.props['axesLabels']])) {
			console.warn("<PercentilesTrends> was created without expected prop 'axesLabels'");
		}

		if (config === undefined && !('config' in $$props || $$self.$$.bound[$$self.$$.props['config']])) {
			console.warn("<PercentilesTrends> was created without expected prop 'config'");
		}

		if (geometry === undefined && !('geometry' in $$props || $$self.$$.bound[$$self.$$.props['geometry']])) {
			console.warn("<PercentilesTrends> was created without expected prop 'geometry'");
		}

		if (keyType === undefined && !('keyType' in $$props || $$self.$$.bound[$$self.$$.props['keyType']])) {
			console.warn("<PercentilesTrends> was created without expected prop 'keyType'");
		}

		if (valueFormatFn === undefined && !('valueFormatFn' in $$props || $$self.$$.bound[$$self.$$.props['valueFormatFn']])) {
			console.warn("<PercentilesTrends> was created without expected prop 'valueFormatFn'");
		}
	});

	const writable_props = [
		'areaLowKeyToColor',
		'axesLabels',
		'config',
		'geometry',
		'items',
		'keyFilterFn',
		'keyFormatFn',
		'keyToColorFn',
		'keyType',
		'theme',
		'valueFormatFn',
		'yTicksCount'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<PercentilesTrends> was created with unknown prop '${key}'`);
	});

	const mousemove_handler = (key, { x, y }) => {
		dispatch('areaHovered', { key, x, y });
	};

	const mouseout_handler = (key, { x, y }) => {
		dispatch('areaExited', { key, x, y });
	};

	const touchstart_handler = (key, { targetTouches: [touch] }) => {
		const { clientX: x, clientY: y } = touch;
		dispatch('areaTouchStarted', { key, x, y });
	};

	const touchend_handler = key => {
		dispatch('areaTouchEnded', { key });
	};

	$$self.$$set = $$props => {
		if ('areaLowKeyToColor' in $$props) $$invalidate(23, areaLowKeyToColor = $$props.areaLowKeyToColor);
		if ('axesLabels' in $$props) $$invalidate(0, axesLabels = $$props.axesLabels);
		if ('config' in $$props) $$invalidate(24, config = $$props.config);
		if ('geometry' in $$props) $$invalidate(19, geometry = $$props.geometry);
		if ('items' in $$props) $$invalidate(1, items = $$props.items);
		if ('keyFilterFn' in $$props) $$invalidate(25, keyFilterFn = $$props.keyFilterFn);
		if ('keyFormatFn' in $$props) $$invalidate(20, keyFormatFn = $$props.keyFormatFn);
		if ('keyToColorFn' in $$props) $$invalidate(3, keyToColorFn = $$props.keyToColorFn);
		if ('keyType' in $$props) $$invalidate(26, keyType = $$props.keyType);
		if ('theme' in $$props) $$invalidate(21, theme = $$props.theme);
		if ('valueFormatFn' in $$props) $$invalidate(2, valueFormatFn = $$props.valueFormatFn);
		if ('yTicksCount' in $$props) $$invalidate(22, yTicksCount = $$props.yTicksCount);
	};

	$$self.$capture_state = () => ({
		makeStyleVars,
		setupResizeObserver,
		arrayMaxWith,
		arrayMinWith,
		getKey: getKey$1,
		getValues,
		inclusiveRange,
		pluckKey,
		scaleLinear: linear,
		scalePoint: point,
		scaleTime: time,
		area,
		line,
		curveMonotoneX: monotoneX,
		_,
		createEventDispatcher,
		getDateTimeFormat,
		dispatch,
		_size,
		sizeObserver,
		defaultGeometry,
		defaultTheme,
		defaultItems,
		areaLowKeyToColor,
		axesLabels,
		config,
		geometry,
		items,
		keyFilterFn,
		keyFormatFn,
		keyToColorFn,
		keyType,
		theme,
		valueFormatFn,
		yTicksCount,
		height,
		width,
		labelsDx: labelsDx$2,
		getSortedKeys,
		getMaxValue,
		getMinValue,
		yDomain,
		yDelta,
		areas,
		bbox,
		doDraw,
		keyTicks,
		lines,
		xScale,
		yScale,
		allKeys,
		yTicks,
		minValue,
		maxValue,
		maxValueSign,
		minValueSign,
		labelsDy,
		style,
		$_size
	});

	$$self.$inject_state = $$props => {
		if ('areaLowKeyToColor' in $$props) $$invalidate(23, areaLowKeyToColor = $$props.areaLowKeyToColor);
		if ('axesLabels' in $$props) $$invalidate(0, axesLabels = $$props.axesLabels);
		if ('config' in $$props) $$invalidate(24, config = $$props.config);
		if ('geometry' in $$props) $$invalidate(19, geometry = $$props.geometry);
		if ('items' in $$props) $$invalidate(1, items = $$props.items);
		if ('keyFilterFn' in $$props) $$invalidate(25, keyFilterFn = $$props.keyFilterFn);
		if ('keyFormatFn' in $$props) $$invalidate(20, keyFormatFn = $$props.keyFormatFn);
		if ('keyToColorFn' in $$props) $$invalidate(3, keyToColorFn = $$props.keyToColorFn);
		if ('keyType' in $$props) $$invalidate(26, keyType = $$props.keyType);
		if ('theme' in $$props) $$invalidate(21, theme = $$props.theme);
		if ('valueFormatFn' in $$props) $$invalidate(2, valueFormatFn = $$props.valueFormatFn);
		if ('yTicksCount' in $$props) $$invalidate(22, yTicksCount = $$props.yTicksCount);
		if ('height' in $$props) $$invalidate(4, height = $$props.height);
		if ('width' in $$props) $$invalidate(5, width = $$props.width);
		if ('yDomain' in $$props) $$invalidate(27, yDomain = $$props.yDomain);
		if ('yDelta' in $$props) $$invalidate(28, yDelta = $$props.yDelta);
		if ('areas' in $$props) $$invalidate(9, areas = $$props.areas);
		if ('bbox' in $$props) $$invalidate(6, bbox = $$props.bbox);
		if ('doDraw' in $$props) $$invalidate(10, doDraw = $$props.doDraw);
		if ('keyTicks' in $$props) $$invalidate(11, keyTicks = $$props.keyTicks);
		if ('lines' in $$props) $$invalidate(12, lines = $$props.lines);
		if ('xScale' in $$props) $$invalidate(7, xScale = $$props.xScale);
		if ('yScale' in $$props) $$invalidate(8, yScale = $$props.yScale);
		if ('allKeys' in $$props) $$invalidate(29, allKeys = $$props.allKeys);
		if ('yTicks' in $$props) $$invalidate(13, yTicks = $$props.yTicks);
		if ('minValue' in $$props) $$invalidate(30, minValue = $$props.minValue);
		if ('maxValue' in $$props) $$invalidate(31, maxValue = $$props.maxValue);
		if ('maxValueSign' in $$props) $$invalidate(32, maxValueSign = $$props.maxValueSign);
		if ('minValueSign' in $$props) $$invalidate(33, minValueSign = $$props.minValueSign);
		if ('labelsDy' in $$props) $$invalidate(14, labelsDy = $$props.labelsDy);
		if ('style' in $$props) $$invalidate(15, style = $$props.style);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*axesLabels*/ 1) {
			$$invalidate(0, axesLabels = axesLabels ?? []);
		}

		if ($$self.$$.dirty[0] & /*items*/ 2) {
			$$invalidate(1, items = items ?? defaultItems);
		}

		if ($$self.$$.dirty[0] & /*keyFormatFn*/ 1048576) {
			$$invalidate(20, keyFormatFn = keyFormatFn ?? identity);
		}

		if ($$self.$$.dirty[0] & /*yTicksCount*/ 4194304) {
			$$invalidate(22, yTicksCount = yTicksCount ?? 10);
		}

		if ($$self.$$.dirty[0] & /*valueFormatFn*/ 4) {
			$$invalidate(2, valueFormatFn = valueFormatFn ?? identity);
		}

		if ($$self.$$.dirty[0] & /*theme*/ 2097152) {
			/* theme */
			$$invalidate(21, theme = theme ? { ...defaultTheme, ...theme } : defaultTheme);
		}

		if ($$self.$$.dirty[0] & /*theme*/ 2097152) {
			$$invalidate(15, style = makeStyleVars(theme));
		}

		if ($$self.$$.dirty[0] & /*geometry*/ 524288) {
			$$invalidate(19, geometry = geometry
			? { ...defaultGeometry, ...geometry }
			: defaultGeometry);
		}

		if ($$self.$$.dirty[0] & /*geometry*/ 524288) {
			$$invalidate(14, labelsDy = Math.min(geometry.safetyBottom, geometry.safetyTop) / 2);
		}

		if ($$self.$$.dirty[1] & /*$_size*/ 8) {
			$$invalidate(5, { inlineSize: width, blockSize: height } = $_size, width, ($$invalidate(4, height), $$invalidate(34, $_size)));
		}

		if ($$self.$$.dirty[0] & /*items*/ 2) {
			$$invalidate(29, allKeys = getSortedKeys(items));
		}

		if ($$self.$$.dirty[0] & /*items*/ 2) {
			$$invalidate(31, maxValue = getMaxValue(items));
		}

		if ($$self.$$.dirty[1] & /*maxValue*/ 1) {
			$$invalidate(32, maxValueSign = Math.sign(maxValue));
		}

		if ($$self.$$.dirty[0] & /*items*/ 2) {
			$$invalidate(30, minValue = getMinValue(items));
		}

		if ($$self.$$.dirty[0] & /*minValue*/ 1073741824) {
			$$invalidate(33, minValueSign = Math.sign(minValue));
		}

		if ($$self.$$.dirty[0] & /*minValue*/ 1073741824 | $$self.$$.dirty[1] & /*maxValueSign, minValueSign, maxValue*/ 7) {
			{
				if (maxValueSign !== minValueSign) {
					$$invalidate(27, yDomain = [minValue, maxValue]);
					$$invalidate(28, yDelta = maxValue - minValue);
				} else if (maxValueSign === 1) {
					$$invalidate(27, yDomain = [0, maxValue]);
					$$invalidate(28, yDelta = maxValue);
				} else {
					$$invalidate(27, yDomain = [minValue, 0]);
					$$invalidate(28, yDelta = -minValue);
				}
			}
		}

		if ($$self.$$.dirty[0] & /*yDomain, yDelta, yTicksCount*/ 406847488) {
			$$invalidate(13, yTicks = inclusiveRange([...yDomain, yDelta / yTicksCount]));
		}

		if ($$self.$$.dirty[0] & /*height, width, geometry, bbox, keyType, allKeys, keyFilterFn, keyFormatFn, yDomain, xScale, config, areaLowKeyToColor, yScale*/ 798491120) {
			if (height && width) {
				$$invalidate(6, bbox = {
					blx: geometry.safetyLeft,
					bly: height - geometry.safetyBottom,
					trx: width - geometry.safetyRight,
					try: geometry.safetyTop,
					width: width - geometry.safetyRight - geometry.safetyLeft,
					height: height - geometry.safetyTop - geometry.safetyBottom
				});

				const xRange = [bbox.blx, bbox.trx];

				if (keyType === 'date') {
					const keyDomain = [head(allKeys), last(allKeys)];
					const keyRankFn = key => new Date(key).getTime();
					const timeDomain = map(keyDomain, keyRankFn);
					const timeScale = time().domain(timeDomain).range(xRange);
					const ticks = timeScale.ticks();
					const tickDurationInSecs = (timeDomain[1] - timeDomain[0]) / 1000 / (ticks.length - 1);
					const timeFormat = getDateTimeFormat(tickDurationInSecs);
					$$invalidate(11, keyTicks = map(ticks, collect([identity, timeFormat])));
					$$invalidate(7, xScale = pipe([keyRankFn, timeScale]));
				} else {
					$$invalidate(11, keyTicks = map(keyFilterFn ? filter(allKeys, keyFilterFn) : allKeys, collect([identity, keyFormatFn])));
					$$invalidate(7, xScale = point().domain(allKeys).range(xRange));
				}

				$$invalidate(8, yScale = linear().domain(yDomain).range([bbox.bly, bbox.try]));
				const getX = pipe([getKey$1, xScale]);

				$$invalidate(9, areas = map(config.areas, ([lowKey, highKey]) => ({
					color: areaLowKeyToColor(lowKey),
					generator: area().x(getX).y0(pipe([getValues, getKey(lowKey), yScale])).y1(pipe([getValues, getKey(highKey), yScale])).curve(monotoneX),
					highKey,
					key: `${lowKey} - ${highKey}`,
					lowKey
				})));

				$$invalidate(12, lines = map(config.trends, key => ({
					key,
					generator: line().x(getX).y(pipe([getValues, getKey(key), yScale])).curve(monotoneX)
				})));

				$$invalidate(10, doDraw = true);
			}
		}
	};

	return [
		axesLabels,
		items,
		valueFormatFn,
		keyToColorFn,
		height,
		width,
		bbox,
		xScale,
		yScale,
		areas,
		doDraw,
		keyTicks,
		lines,
		yTicks,
		labelsDy,
		style,
		dispatch,
		_size,
		sizeObserver,
		geometry,
		keyFormatFn,
		theme,
		yTicksCount,
		areaLowKeyToColor,
		config,
		keyFilterFn,
		keyType,
		yDomain,
		yDelta,
		allKeys,
		minValue,
		maxValue,
		maxValueSign,
		minValueSign,
		$_size,
		mousemove_handler,
		mouseout_handler,
		touchstart_handler,
		touchend_handler
	];
}

class PercentilesTrends extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$2,
			create_fragment$3,
			safe_not_equal,
			{
				areaLowKeyToColor: 23,
				axesLabels: 0,
				config: 24,
				geometry: 19,
				items: 1,
				keyFilterFn: 25,
				keyFormatFn: 20,
				keyToColorFn: 3,
				keyType: 26,
				theme: 21,
				valueFormatFn: 2,
				yTicksCount: 22
			},
			null,
			[-1, -1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "PercentilesTrends",
			options,
			id: create_fragment$3.name
		});
	}

	get areaLowKeyToColor() {
		throw new Error("<PercentilesTrends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set areaLowKeyToColor(value) {
		throw new Error("<PercentilesTrends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get axesLabels() {
		throw new Error("<PercentilesTrends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set axesLabels(value) {
		throw new Error("<PercentilesTrends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get config() {
		throw new Error("<PercentilesTrends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set config(value) {
		throw new Error("<PercentilesTrends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get geometry() {
		throw new Error("<PercentilesTrends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set geometry(value) {
		throw new Error("<PercentilesTrends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get items() {
		throw new Error("<PercentilesTrends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set items(value) {
		throw new Error("<PercentilesTrends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get keyFilterFn() {
		throw new Error("<PercentilesTrends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set keyFilterFn(value) {
		throw new Error("<PercentilesTrends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get keyFormatFn() {
		throw new Error("<PercentilesTrends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set keyFormatFn(value) {
		throw new Error("<PercentilesTrends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get keyToColorFn() {
		throw new Error("<PercentilesTrends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set keyToColorFn(value) {
		throw new Error("<PercentilesTrends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get keyType() {
		throw new Error("<PercentilesTrends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set keyType(value) {
		throw new Error("<PercentilesTrends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get theme() {
		throw new Error("<PercentilesTrends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set theme(value) {
		throw new Error("<PercentilesTrends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get valueFormatFn() {
		throw new Error("<PercentilesTrends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set valueFormatFn(value) {
		throw new Error("<PercentilesTrends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get yTicksCount() {
		throw new Error("<PercentilesTrends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set yTicksCount(value) {
		throw new Error("<PercentilesTrends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var PercentilesTrends$1 = PercentilesTrends;

/* ../../components/trends/src/StreamGraph.svelte generated by Svelte v3.59.2 */
const file$2 = "../../components/trends/src/StreamGraph.svelte";

function get_each_context$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[41] = list[i].label;
	child_ctx[42] = list[i].gridAreas;
	return child_ctx;
}

function get_each_context_1$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[45] = list[i];
	return child_ctx;
}

function get_each_context_2$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[48] = list[i];
	return child_ctx;
}

function get_each_context_3$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[51] = list[i][0];
	return child_ctx;
}

function get_each_context_4$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[54] = list[i];
	return child_ctx;
}

function get_each_context_5$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[48] = list[i];
	return child_ctx;
}

function get_each_context_6$2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[51] = list[i][0];
	child_ctx[41] = list[i][1];
	return child_ctx;
}

// (231:2) {#if doDraw}
function create_if_block$2(ctx) {
	let svg;
	let g0;
	let g1;
	let g2;
	let each_blocks_2 = [];
	let each2_lookup = new Map();
	let g3;
	let each3_anchor;
	let rect;
	let rect_x_value;
	let rect_y_value;
	let rect_width_value;
	let rect_height_value;
	let each_value_6 = /*keyTicks*/ ctx[8];
	validate_each_argument(each_value_6);
	let each_blocks_4 = [];

	for (let i = 0; i < each_value_6.length; i += 1) {
		each_blocks_4[i] = create_each_block_6$2(get_each_context_6$2(ctx, each_value_6, i));
	}

	let each_value_5 = /*yTicks*/ ctx[10];
	validate_each_argument(each_value_5);
	let each_blocks_3 = [];

	for (let i = 0; i < each_value_5.length; i += 1) {
		each_blocks_3[i] = create_each_block_5$2(get_each_context_5$2(ctx, each_value_5, i));
	}

	let each_value_4 = /*paths*/ ctx[9];
	validate_each_argument(each_value_4);
	const get_key = ctx => /*p*/ ctx[54].id;
	validate_each_keys(ctx, each_value_4, get_each_context_4$2, get_key);

	for (let i = 0; i < each_value_4.length; i += 1) {
		let child_ctx = get_each_context_4$2(ctx, each_value_4, i);
		let key = get_key(child_ctx);
		each2_lookup.set(key, each_blocks_2[i] = create_each_block_4$2(key, child_ctx));
	}

	let each_value_3 = /*keyTicks*/ ctx[8];
	validate_each_argument(each_value_3);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks_1[i] = create_each_block_3$2(get_each_context_3$2(ctx, each_value_3, i));
	}

	let each_value_2 = /*yTicks*/ ctx[10];
	validate_each_argument(each_value_2);
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i));
	}

	const block = {
		c: function create() {
			svg = svg_element("svg");
			g0 = svg_element("g");

			for (let i = 0; i < each_blocks_4.length; i += 1) {
				each_blocks_4[i].c();
			}

			g1 = svg_element("g");

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].c();
			}

			g2 = svg_element("g");

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].c();
			}

			g3 = svg_element("g");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			each3_anchor = empty();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			rect = svg_element("rect");
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_svg_element(nodes, "svg", { height: true, width: true, class: true });
			var svg_nodes = children(svg);
			g0 = claim_svg_element(svg_nodes, "g", { class: true });
			var g0_nodes = children(g0);

			for (let i = 0; i < each_blocks_4.length; i += 1) {
				each_blocks_4[i].l(g0_nodes);
			}

			g0_nodes.forEach(detach_dev);
			g1 = claim_svg_element(svg_nodes, "g", { class: true });
			var g1_nodes = children(g1);

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].l(g1_nodes);
			}

			g1_nodes.forEach(detach_dev);
			g2 = claim_svg_element(svg_nodes, "g", { class: true });
			var g2_nodes = children(g2);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].l(g2_nodes);
			}

			g2_nodes.forEach(detach_dev);
			g3 = claim_svg_element(svg_nodes, "g", { class: true });
			var g3_nodes = children(g3);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].l(g3_nodes);
			}

			each3_anchor = empty();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(g3_nodes);
			}

			g3_nodes.forEach(detach_dev);

			rect = claim_svg_element(svg_nodes, "rect", {
				x: true,
				y: true,
				width: true,
				height: true,
				class: true
			});

			children(rect).forEach(detach_dev);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(g0, "class", "x-ticks");
			add_location(g0, file$2, 236, 4, 5914);
			attr_dev(g1, "class", "y-ticks");
			add_location(g1, file$2, 260, 4, 6346);
			attr_dev(g2, "class", "path");
			add_location(g2, file$2, 284, 4, 6794);
			attr_dev(g3, "class", "grid svelte-veo88q");
			add_location(g3, file$2, 313, 4, 7553);
			attr_dev(rect, "x", rect_x_value = /*bbox*/ ctx[4].blx);
			attr_dev(rect, "y", rect_y_value = /*bbox*/ ctx[4].try);
			attr_dev(rect, "width", rect_width_value = /*bbox*/ ctx[4].width);
			attr_dev(rect, "height", rect_height_value = /*bbox*/ ctx[4].height);
			attr_dev(rect, "class", "svelte-veo88q");
			add_location(rect, file$2, 333, 4, 7915);
			attr_dev(svg, "height", /*height*/ ctx[2]);
			attr_dev(svg, "width", /*width*/ ctx[3]);
			attr_dev(svg, "class", "svelte-veo88q");
			add_location(svg, file$2, 231, 3, 5854);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, svg, anchor);
			append_hydration_dev(svg, g0);

			for (let i = 0; i < each_blocks_4.length; i += 1) {
				if (each_blocks_4[i]) {
					each_blocks_4[i].m(g0, null);
				}
			}

			append_hydration_dev(svg, g1);

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				if (each_blocks_3[i]) {
					each_blocks_3[i].m(g1, null);
				}
			}

			append_hydration_dev(svg, g2);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				if (each_blocks_2[i]) {
					each_blocks_2[i].m(g2, null);
				}
			}

			append_hydration_dev(svg, g3);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				if (each_blocks_1[i]) {
					each_blocks_1[i].m(g3, null);
				}
			}

			append_hydration_dev(g3, each3_anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(g3, null);
				}
			}

			append_hydration_dev(svg, rect);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*labelsDy, xScale, keyTicks, bbox*/ 2352) {
				each_value_6 = /*keyTicks*/ ctx[8];
				validate_each_argument(each_value_6);
				let i;

				for (i = 0; i < each_value_6.length; i += 1) {
					const child_ctx = get_each_context_6$2(ctx, each_value_6, i);

					if (each_blocks_4[i]) {
						each_blocks_4[i].p(child_ctx, dirty);
					} else {
						each_blocks_4[i] = create_each_block_6$2(child_ctx);
						each_blocks_4[i].c();
						each_blocks_4[i].m(g0, null);
					}
				}

				for (; i < each_blocks_4.length; i += 1) {
					each_blocks_4[i].d(1);
				}

				each_blocks_4.length = each_value_6.length;
			}

			if (dirty[0] & /*bbox, yScale, yTicks, valueFormatFn*/ 1106) {
				each_value_5 = /*yTicks*/ ctx[10];
				validate_each_argument(each_value_5);
				let i;

				for (i = 0; i < each_value_5.length; i += 1) {
					const child_ctx = get_each_context_5$2(ctx, each_value_5, i);

					if (each_blocks_3[i]) {
						each_blocks_3[i].p(child_ctx, dirty);
					} else {
						each_blocks_3[i] = create_each_block_5$2(child_ctx);
						each_blocks_3[i].c();
						each_blocks_3[i].m(g1, null);
					}
				}

				for (; i < each_blocks_3.length; i += 1) {
					each_blocks_3[i].d(1);
				}

				each_blocks_3.length = each_value_5.length;
			}

			if (dirty[0] & /*paths, dispatch*/ 8704) {
				each_value_4 = /*paths*/ ctx[9];
				validate_each_argument(each_value_4);
				validate_each_keys(ctx, each_value_4, get_each_context_4$2, get_key);
				each_blocks_2 = update_keyed_each(each_blocks_2, dirty, get_key, 1, ctx, each_value_4, each2_lookup, g2, destroy_block, create_each_block_4$2, null, get_each_context_4$2);
			}

			if (dirty[0] & /*xScale, keyTicks, bbox*/ 304) {
				each_value_3 = /*keyTicks*/ ctx[8];
				validate_each_argument(each_value_3);
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3$2(ctx, each_value_3, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_3$2(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(g3, each3_anchor);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_3.length;
			}

			if (dirty[0] & /*bbox, yScale, yTicks*/ 1104) {
				each_value_2 = /*yTicks*/ ctx[10];
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2$2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_2$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(g3, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_2.length;
			}

			if (dirty[0] & /*bbox*/ 16 && rect_x_value !== (rect_x_value = /*bbox*/ ctx[4].blx)) {
				attr_dev(rect, "x", rect_x_value);
			}

			if (dirty[0] & /*bbox*/ 16 && rect_y_value !== (rect_y_value = /*bbox*/ ctx[4].try)) {
				attr_dev(rect, "y", rect_y_value);
			}

			if (dirty[0] & /*bbox*/ 16 && rect_width_value !== (rect_width_value = /*bbox*/ ctx[4].width)) {
				attr_dev(rect, "width", rect_width_value);
			}

			if (dirty[0] & /*bbox*/ 16 && rect_height_value !== (rect_height_value = /*bbox*/ ctx[4].height)) {
				attr_dev(rect, "height", rect_height_value);
			}

			if (dirty[0] & /*height*/ 4) {
				attr_dev(svg, "height", /*height*/ ctx[2]);
			}

			if (dirty[0] & /*width*/ 8) {
				attr_dev(svg, "width", /*width*/ ctx[3]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
			destroy_each(each_blocks_4, detaching);
			destroy_each(each_blocks_3, detaching);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].d();
			}

			destroy_each(each_blocks_1, detaching);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$2.name,
		type: "if",
		source: "(231:2) {#if doDraw}",
		ctx
	});

	return block;
}

// (238:5) {#each keyTicks as [key, label]}
function create_each_block_6$2(ctx) {
	let g;
	let text0;
	let t0_value = /*label*/ ctx[41] + "";
	let t0;
	let text0_x_value;
	let text0_y_value;
	let text1;
	let t1_value = /*label*/ ctx[41] + "";
	let t1;
	let text1_dy_value;
	let text1_x_value;
	let text1_y_value;

	const block = {
		c: function create() {
			g = svg_element("g");
			text0 = svg_element("text");
			t0 = text(t0_value);
			text1 = svg_element("text");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			g = claim_svg_element(nodes, "g", { class: true });
			var g_nodes = children(g);
			text0 = claim_svg_element(g_nodes, "text", { class: true, dy: true, x: true, y: true });
			var text0_nodes = children(text0);
			t0 = claim_text(text0_nodes, t0_value);
			text0_nodes.forEach(detach_dev);
			text1 = claim_svg_element(g_nodes, "text", { class: true, dy: true, x: true, y: true });
			var text1_nodes = children(text1);
			t1 = claim_text(text1_nodes, t1_value);
			text1_nodes.forEach(detach_dev);
			g_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(text0, "class", "centered svelte-veo88q");
			attr_dev(text0, "dy", /*labelsDy*/ ctx[11]);
			attr_dev(text0, "x", text0_x_value = /*xScale*/ ctx[5](/*key*/ ctx[51]));
			attr_dev(text0, "y", text0_y_value = /*bbox*/ ctx[4].bly);
			add_location(text0, file$2, 239, 7, 6003);
			attr_dev(text1, "class", "centered svelte-veo88q");
			attr_dev(text1, "dy", text1_dy_value = -/*labelsDy*/ ctx[11]);
			attr_dev(text1, "x", text1_x_value = /*xScale*/ ctx[5](/*key*/ ctx[51]));
			attr_dev(text1, "y", text1_y_value = /*bbox*/ ctx[4].try);
			add_location(text1, file$2, 247, 7, 6148);
			attr_dev(g, "class", "ticks svelte-veo88q");
			add_location(g, file$2, 238, 6, 5978);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, g, anchor);
			append_hydration_dev(g, text0);
			append_hydration_dev(text0, t0);
			append_hydration_dev(g, text1);
			append_hydration_dev(text1, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*keyTicks*/ 256 && t0_value !== (t0_value = /*label*/ ctx[41] + "")) set_data_dev(t0, t0_value);

			if (dirty[0] & /*labelsDy*/ 2048) {
				attr_dev(text0, "dy", /*labelsDy*/ ctx[11]);
			}

			if (dirty[0] & /*xScale, keyTicks*/ 288 && text0_x_value !== (text0_x_value = /*xScale*/ ctx[5](/*key*/ ctx[51]))) {
				attr_dev(text0, "x", text0_x_value);
			}

			if (dirty[0] & /*bbox*/ 16 && text0_y_value !== (text0_y_value = /*bbox*/ ctx[4].bly)) {
				attr_dev(text0, "y", text0_y_value);
			}

			if (dirty[0] & /*keyTicks*/ 256 && t1_value !== (t1_value = /*label*/ ctx[41] + "")) set_data_dev(t1, t1_value);

			if (dirty[0] & /*labelsDy*/ 2048 && text1_dy_value !== (text1_dy_value = -/*labelsDy*/ ctx[11])) {
				attr_dev(text1, "dy", text1_dy_value);
			}

			if (dirty[0] & /*xScale, keyTicks*/ 288 && text1_x_value !== (text1_x_value = /*xScale*/ ctx[5](/*key*/ ctx[51]))) {
				attr_dev(text1, "x", text1_x_value);
			}

			if (dirty[0] & /*bbox*/ 16 && text1_y_value !== (text1_y_value = /*bbox*/ ctx[4].try)) {
				attr_dev(text1, "y", text1_y_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(g);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_6$2.name,
		type: "each",
		source: "(238:5) {#each keyTicks as [key, label]}",
		ctx
	});

	return block;
}

// (262:5) {#each yTicks as value}
function create_each_block_5$2(ctx) {
	let g;
	let text0;
	let t0_value = /*valueFormatFn*/ ctx[1](/*value*/ ctx[48]) + "";
	let t0;
	let text0_x_value;
	let text0_y_value;
	let text1;
	let t1_value = /*valueFormatFn*/ ctx[1](/*value*/ ctx[48]) + "";
	let t1;
	let text1_x_value;
	let text1_y_value;

	const block = {
		c: function create() {
			g = svg_element("g");
			text0 = svg_element("text");
			t0 = text(t0_value);
			text1 = svg_element("text");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			g = claim_svg_element(nodes, "g", { class: true });
			var g_nodes = children(g);
			text0 = claim_svg_element(g_nodes, "text", { class: true, dx: true, x: true, y: true });
			var text0_nodes = children(text0);
			t0 = claim_text(text0_nodes, t0_value);
			text0_nodes.forEach(detach_dev);
			text1 = claim_svg_element(g_nodes, "text", { class: true, dx: true, x: true, y: true });
			var text1_nodes = children(text1);
			t1 = claim_text(text1_nodes, t1_value);
			text1_nodes.forEach(detach_dev);
			g_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(text0, "class", "left svelte-veo88q");
			attr_dev(text0, "dx", -labelsDx$1);
			attr_dev(text0, "x", text0_x_value = /*bbox*/ ctx[4].blx);
			attr_dev(text0, "y", text0_y_value = /*yScale*/ ctx[6](/*value*/ ctx[48]));
			add_location(text0, file$2, 263, 7, 6426);
			attr_dev(text1, "class", "right svelte-veo88q");
			attr_dev(text1, "dx", labelsDx$1);
			attr_dev(text1, "x", text1_x_value = /*bbox*/ ctx[4].trx);
			attr_dev(text1, "y", text1_y_value = /*yScale*/ ctx[6](/*value*/ ctx[48]));
			add_location(text1, file$2, 271, 7, 6585);
			attr_dev(g, "class", "ticks svelte-veo88q");
			add_location(g, file$2, 262, 6, 6401);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, g, anchor);
			append_hydration_dev(g, text0);
			append_hydration_dev(text0, t0);
			append_hydration_dev(g, text1);
			append_hydration_dev(text1, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*valueFormatFn, yTicks*/ 1026 && t0_value !== (t0_value = /*valueFormatFn*/ ctx[1](/*value*/ ctx[48]) + "")) set_data_dev(t0, t0_value);

			if (dirty[0] & /*bbox*/ 16 && text0_x_value !== (text0_x_value = /*bbox*/ ctx[4].blx)) {
				attr_dev(text0, "x", text0_x_value);
			}

			if (dirty[0] & /*yScale, yTicks*/ 1088 && text0_y_value !== (text0_y_value = /*yScale*/ ctx[6](/*value*/ ctx[48]))) {
				attr_dev(text0, "y", text0_y_value);
			}

			if (dirty[0] & /*valueFormatFn, yTicks*/ 1026 && t1_value !== (t1_value = /*valueFormatFn*/ ctx[1](/*value*/ ctx[48]) + "")) set_data_dev(t1, t1_value);

			if (dirty[0] & /*bbox*/ 16 && text1_x_value !== (text1_x_value = /*bbox*/ ctx[4].trx)) {
				attr_dev(text1, "x", text1_x_value);
			}

			if (dirty[0] & /*yScale, yTicks*/ 1088 && text1_y_value !== (text1_y_value = /*yScale*/ ctx[6](/*value*/ ctx[48]))) {
				attr_dev(text1, "y", text1_y_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(g);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_5$2.name,
		type: "each",
		source: "(262:5) {#each yTicks as value}",
		ctx
	});

	return block;
}

// (286:5) {#each paths as p (p.id)}
function create_each_block_4$2(key_1, ctx) {
	let path;
	let path_d_value;
	let path_fill_value;
	let path_stroke_value;
	let mounted;
	let dispose;

	function mousemove_handler(...args) {
		return /*mousemove_handler*/ ctx[33](/*p*/ ctx[54], ...args);
	}

	function mouseout_handler(...args) {
		return /*mouseout_handler*/ ctx[34](/*p*/ ctx[54], ...args);
	}

	function touchend_handler() {
		return /*touchend_handler*/ ctx[35](/*p*/ ctx[54]);
	}

	function touchstart_handler(...args) {
		return /*touchstart_handler*/ ctx[36](/*p*/ ctx[54], ...args);
	}

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			path = svg_element("path");
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true, fill: true, stroke: true });
			children(path).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", path_d_value = /*p*/ ctx[54].path);
			attr_dev(path, "fill", path_fill_value = /*p*/ ctx[54].fill);
			attr_dev(path, "stroke", path_stroke_value = /*p*/ ctx[54].fill);
			add_location(path, file$2, 287, 6, 6911);
			this.first = path;
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);

			if (!mounted) {
				dispose = [
					listen_dev(path, "mousemove", mousemove_handler, false, false, false, false),
					listen_dev(path, "mouseout", mouseout_handler, false, false, false, false),
					listen_dev(path, "touchend", touchend_handler, { passive: true }, false, false, false),
					listen_dev(path, "touchstart", prevent_default(touchstart_handler), false, true, false, false)
				];

				mounted = true;
			}
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*paths*/ 512 && path_d_value !== (path_d_value = /*p*/ ctx[54].path)) {
				attr_dev(path, "d", path_d_value);
			}

			if (dirty[0] & /*paths*/ 512 && path_fill_value !== (path_fill_value = /*p*/ ctx[54].fill)) {
				attr_dev(path, "fill", path_fill_value);
			}

			if (dirty[0] & /*paths*/ 512 && path_stroke_value !== (path_stroke_value = /*p*/ ctx[54].fill)) {
				attr_dev(path, "stroke", path_stroke_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_4$2.name,
		type: "each",
		source: "(286:5) {#each paths as p (p.id)}",
		ctx
	});

	return block;
}

// (315:5) {#each keyTicks as [key]}
function create_each_block_3$2(ctx) {
	let line;
	let line_x__value;
	let line_x__value_1;
	let line_y__value;
	let line_y__value_1;

	const block = {
		c: function create() {
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			line = claim_svg_element(nodes, "line", {
				x1: true,
				x2: true,
				y1: true,
				y2: true,
				class: true
			});

			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line, "x1", line_x__value = /*xScale*/ ctx[5](/*key*/ ctx[51]));
			attr_dev(line, "x2", line_x__value_1 = /*xScale*/ ctx[5](/*key*/ ctx[51]));
			attr_dev(line, "y1", line_y__value = /*bbox*/ ctx[4].bly);
			attr_dev(line, "y2", line_y__value_1 = /*bbox*/ ctx[4].try);
			attr_dev(line, "class", "svelte-veo88q");
			add_location(line, file$2, 315, 6, 7607);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*xScale, keyTicks*/ 288 && line_x__value !== (line_x__value = /*xScale*/ ctx[5](/*key*/ ctx[51]))) {
				attr_dev(line, "x1", line_x__value);
			}

			if (dirty[0] & /*xScale, keyTicks*/ 288 && line_x__value_1 !== (line_x__value_1 = /*xScale*/ ctx[5](/*key*/ ctx[51]))) {
				attr_dev(line, "x2", line_x__value_1);
			}

			if (dirty[0] & /*bbox*/ 16 && line_y__value !== (line_y__value = /*bbox*/ ctx[4].bly)) {
				attr_dev(line, "y1", line_y__value);
			}

			if (dirty[0] & /*bbox*/ 16 && line_y__value_1 !== (line_y__value_1 = /*bbox*/ ctx[4].try)) {
				attr_dev(line, "y2", line_y__value_1);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_3$2.name,
		type: "each",
		source: "(315:5) {#each keyTicks as [key]}",
		ctx
	});

	return block;
}

// (323:5) {#each yTicks as value}
function create_each_block_2$2(ctx) {
	let line;
	let line_x__value;
	let line_x__value_1;
	let line_y__value;
	let line_y__value_1;

	const block = {
		c: function create() {
			line = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			line = claim_svg_element(nodes, "line", {
				x1: true,
				x2: true,
				y1: true,
				y2: true,
				class: true
			});

			children(line).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line, "x1", line_x__value = /*bbox*/ ctx[4].blx);
			attr_dev(line, "x2", line_x__value_1 = /*bbox*/ ctx[4].trx);
			attr_dev(line, "y1", line_y__value = /*yScale*/ ctx[6](/*value*/ ctx[48]));
			attr_dev(line, "y2", line_y__value_1 = /*yScale*/ ctx[6](/*value*/ ctx[48]));
			attr_dev(line, "class", "svelte-veo88q");
			add_location(line, file$2, 323, 6, 7760);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*bbox*/ 16 && line_x__value !== (line_x__value = /*bbox*/ ctx[4].blx)) {
				attr_dev(line, "x1", line_x__value);
			}

			if (dirty[0] & /*bbox*/ 16 && line_x__value_1 !== (line_x__value_1 = /*bbox*/ ctx[4].trx)) {
				attr_dev(line, "x2", line_x__value_1);
			}

			if (dirty[0] & /*yScale, yTicks*/ 1088 && line_y__value !== (line_y__value = /*yScale*/ ctx[6](/*value*/ ctx[48]))) {
				attr_dev(line, "y1", line_y__value);
			}

			if (dirty[0] & /*yScale, yTicks*/ 1088 && line_y__value_1 !== (line_y__value_1 = /*yScale*/ ctx[6](/*value*/ ctx[48]))) {
				attr_dev(line, "y2", line_y__value_1);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(line);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2$2.name,
		type: "each",
		source: "(323:5) {#each yTicks as value}",
		ctx
	});

	return block;
}

// (345:2) {#each gridAreas as gridArea}
function create_each_block_1$2(ctx) {
	let div;
	let t0_value = /*label*/ ctx[41] + "";
	let t0;
	let t1;
	let div_class_value;

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", div_class_value = "" + (/*gridArea*/ ctx[45] + " area" + " svelte-veo88q"));
			add_location(div, file$2, 345, 3, 8118);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t0);
			append_hydration_dev(div, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*axesLabels*/ 1 && t0_value !== (t0_value = /*label*/ ctx[41] + "")) set_data_dev(t0, t0_value);

			if (dirty[0] & /*axesLabels*/ 1 && div_class_value !== (div_class_value = "" + (/*gridArea*/ ctx[45] + " area" + " svelte-veo88q"))) {
				attr_dev(div, "class", div_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$2.name,
		type: "each",
		source: "(345:2) {#each gridAreas as gridArea}",
		ctx
	});

	return block;
}

// (344:1) {#each axesLabels as {label, gridAreas}}
function create_each_block$2(ctx) {
	let each_1_anchor;
	let each_value_1 = /*gridAreas*/ ctx[42];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert_hydration_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*axesLabels*/ 1) {
				each_value_1 = /*gridAreas*/ ctx[42];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$2.name,
		type: "each",
		source: "(344:1) {#each axesLabels as {label, gridAreas}}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let div1;
	let div0;
	let t;
	let mounted;
	let dispose;
	let if_block = /*doDraw*/ ctx[7] && create_if_block$2(ctx);
	let each_value = /*axesLabels*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			if (if_block) if_block.c();
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { style: true, class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (if_block) if_block.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t = claim_space(div1_nodes);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div1_nodes);
			}

			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "chart svelte-veo88q");
			add_location(div0, file$2, 226, 1, 5793);
			attr_dev(div1, "style", /*style*/ ctx[12]);
			attr_dev(div1, "class", "StreamGraph svelte-veo88q");
			add_location(div1, file$2, 222, 0, 5754);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div1, anchor);
			append_hydration_dev(div1, div0);
			if (if_block) if_block.m(div0, null);
			append_hydration_dev(div1, t);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div1, null);
				}
			}

			if (!mounted) {
				dispose = action_destroyer(/*sizeObserver*/ ctx[15].call(null, div0));
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*doDraw*/ ctx[7]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$2(ctx);
					if_block.c();
					if_block.m(div0, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*axesLabels*/ 1) {
				each_value = /*axesLabels*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$2(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$2(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty[0] & /*style*/ 4096) {
				attr_dev(div1, "style", /*style*/ ctx[12]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (if_block) if_block.d();
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const labelsDx$1 = 20;

function instance$1($$self, $$props, $$invalidate) {
	let style;
	let labelsDy;
	let allKeys;
	let zeroedGroupsMap;
	let sortingFn;
	let makeStreams;
	let streams;
	let maxSum;
	let yTicks;
	let $_size;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('StreamGraph', slots, []);
	const dispatch = createEventDispatcher();
	const { _writable: _size, resizeObserver: sizeObserver } = setupResizeObserver();
	validate_store(_size, '_size');
	component_subscribe($$self, _size, value => $$invalidate(32, $_size = value));

	const defaultGeometry = {
		safetyBottom: 20,
		safetyLeft: 20,
		safetyRight: 20,
		safetyTop: 20
	};

	const defaultTheme = {
		frameFill: 'none',
		frameStroke: 'black',
		gridStroke: 'lightgrey',
		gridStrokeDasharray: '4 8',
		textColor: 'black'
	};

	let { axesLabels } = $$props;
	let { geometry } = $$props;
	let { groups } = $$props;
	let { groupToColorFn } = $$props;
	let { keyFilterFn } = $$props;
	let { keyFormatFn = identity } = $$props;
	let { keyType } = $$props;
	let { points = [] } = $$props;
	let { sorting = 'off' } = $$props;
	let { theme } = $$props;
	let { valueFormatFn } = $$props;
	let { yTicksCount = 10 } = $$props;
	let height;
	let width;

	/* scales, axes */
	const getMaxSum = pipe([groupBy(getKey$1), values, arrayMaxWith(arraySumWith(getValue))]);

	/* paths */
	const makeGetPaths = ({ xScale, yScale }) => pipe([
		pairs,
		flatMapWith(pipe([
			flatMapWith(({ key, values }) => map(values, value => ({ key, value }))),
			groupBy(getPath('value.key')),
			mapValuesWith(pipe([
				sortWith([getKey$1]),
				([L, R]) => {
					const p1 = { x: xScale(L.key), y: yScale(L.value.end) };
					const p2 = { x: xScale(R.key), y: yScale(R.value.end) };

					const p3 = {
						x: xScale(R.key),
						y: yScale(R.value.start)
					};

					const p4 = {
						x: xScale(L.key),
						y: yScale(L.value.start)
					};

					const midX = (p1.x + p2.x) / 2;
					const c1 = { x: midX, y: p1.y };
					const c2 = { x: midX, y: p2.y };
					const c3 = { x: midX, y: p3.y };
					const c4 = { x: midX, y: p4.y };
					const M1 = `M ${p1.x} ${p1.y}`;
					const C12 = `C ${c1.x} ${c1.y} ${c2.x} ${c2.y} ${p2.x} ${p2.y}`;
					const L23 = `L ${p3.x} ${p3.y}`;
					const C34 = `C ${c3.x} ${c3.y} ${c4.x} ${c4.y} ${p4.x} ${p4.y}`;
					const path = `${M1} ${C12} ${L23} ${C34} Z`;
					const category = L.value.key;
					const fill = groupToColorFn(category);

					return {
						category,
						data: [L, R],
						fill,
						id: `${L.key}_${R.key}_${category}`,
						path,
						range: [L.key, R.key]
					};
				}
			])),
			values
		]))
	]);

	let bbox;
	let doDraw = false;
	let keyTicks;
	let paths = [];
	let xScale;
	let yScale;

	$$self.$$.on_mount.push(function () {
		if (axesLabels === undefined && !('axesLabels' in $$props || $$self.$$.bound[$$self.$$.props['axesLabels']])) {
			console.warn("<StreamGraph> was created without expected prop 'axesLabels'");
		}

		if (geometry === undefined && !('geometry' in $$props || $$self.$$.bound[$$self.$$.props['geometry']])) {
			console.warn("<StreamGraph> was created without expected prop 'geometry'");
		}

		if (groups === undefined && !('groups' in $$props || $$self.$$.bound[$$self.$$.props['groups']])) {
			console.warn("<StreamGraph> was created without expected prop 'groups'");
		}

		if (groupToColorFn === undefined && !('groupToColorFn' in $$props || $$self.$$.bound[$$self.$$.props['groupToColorFn']])) {
			console.warn("<StreamGraph> was created without expected prop 'groupToColorFn'");
		}

		if (keyFilterFn === undefined && !('keyFilterFn' in $$props || $$self.$$.bound[$$self.$$.props['keyFilterFn']])) {
			console.warn("<StreamGraph> was created without expected prop 'keyFilterFn'");
		}

		if (keyType === undefined && !('keyType' in $$props || $$self.$$.bound[$$self.$$.props['keyType']])) {
			console.warn("<StreamGraph> was created without expected prop 'keyType'");
		}

		if (theme === undefined && !('theme' in $$props || $$self.$$.bound[$$self.$$.props['theme']])) {
			console.warn("<StreamGraph> was created without expected prop 'theme'");
		}

		if (valueFormatFn === undefined && !('valueFormatFn' in $$props || $$self.$$.bound[$$self.$$.props['valueFormatFn']])) {
			console.warn("<StreamGraph> was created without expected prop 'valueFormatFn'");
		}
	});

	const writable_props = [
		'axesLabels',
		'geometry',
		'groups',
		'groupToColorFn',
		'keyFilterFn',
		'keyFormatFn',
		'keyType',
		'points',
		'sorting',
		'theme',
		'valueFormatFn',
		'yTicksCount'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<StreamGraph> was created with unknown prop '${key}'`);
	});

	const mousemove_handler = (p, { x, y }) => {
		dispatch('areaHovered', { key: p.category, x, y });
	};

	const mouseout_handler = (p, { x, y }) => {
		dispatch('areaExited', { key: p.category, x, y });
	};

	const touchend_handler = p => {
		dispatch('areaTouchEnded', { key: p.category });
	};

	const touchstart_handler = (p, { targetTouches: [touch] }) => {
		const { clientX: x, clientY: y } = touch;
		dispatch('areaTouchStarted', { key: p.category, x, y });
	};

	$$self.$$set = $$props => {
		if ('axesLabels' in $$props) $$invalidate(0, axesLabels = $$props.axesLabels);
		if ('geometry' in $$props) $$invalidate(16, geometry = $$props.geometry);
		if ('groups' in $$props) $$invalidate(22, groups = $$props.groups);
		if ('groupToColorFn' in $$props) $$invalidate(23, groupToColorFn = $$props.groupToColorFn);
		if ('keyFilterFn' in $$props) $$invalidate(24, keyFilterFn = $$props.keyFilterFn);
		if ('keyFormatFn' in $$props) $$invalidate(17, keyFormatFn = $$props.keyFormatFn);
		if ('keyType' in $$props) $$invalidate(25, keyType = $$props.keyType);
		if ('points' in $$props) $$invalidate(18, points = $$props.points);
		if ('sorting' in $$props) $$invalidate(19, sorting = $$props.sorting);
		if ('theme' in $$props) $$invalidate(20, theme = $$props.theme);
		if ('valueFormatFn' in $$props) $$invalidate(1, valueFormatFn = $$props.valueFormatFn);
		if ('yTicksCount' in $$props) $$invalidate(21, yTicksCount = $$props.yTicksCount);
	};

	$$self.$capture_state = () => ({
		makeStyleVars,
		setupResizeObserver,
		arrayMaxWith,
		arraySumWith,
		getKey: getKey$1,
		getValue,
		inclusiveRange,
		keyValueArrayToObject,
		makeKeyedZeroes,
		objectToKeyValueArray,
		objectToKeyValuesArray,
		transformValues,
		pairs,
		scaleLinear: linear,
		scalePoint: point,
		scaleTime: time,
		_,
		createEventDispatcher,
		getDateTimeFormat,
		pluckKeySorted,
		dispatch,
		_size,
		sizeObserver,
		defaultGeometry,
		defaultTheme,
		axesLabels,
		geometry,
		groups,
		groupToColorFn,
		keyFilterFn,
		keyFormatFn,
		keyType,
		points,
		sorting,
		theme,
		valueFormatFn,
		yTicksCount,
		height,
		width,
		labelsDx: labelsDx$1,
		getMaxSum,
		makeGetPaths,
		bbox,
		doDraw,
		keyTicks,
		paths,
		xScale,
		yScale,
		streams,
		maxSum,
		allKeys,
		yTicks,
		makeStreams,
		sortingFn,
		zeroedGroupsMap,
		labelsDy,
		style,
		$_size
	});

	$$self.$inject_state = $$props => {
		if ('axesLabels' in $$props) $$invalidate(0, axesLabels = $$props.axesLabels);
		if ('geometry' in $$props) $$invalidate(16, geometry = $$props.geometry);
		if ('groups' in $$props) $$invalidate(22, groups = $$props.groups);
		if ('groupToColorFn' in $$props) $$invalidate(23, groupToColorFn = $$props.groupToColorFn);
		if ('keyFilterFn' in $$props) $$invalidate(24, keyFilterFn = $$props.keyFilterFn);
		if ('keyFormatFn' in $$props) $$invalidate(17, keyFormatFn = $$props.keyFormatFn);
		if ('keyType' in $$props) $$invalidate(25, keyType = $$props.keyType);
		if ('points' in $$props) $$invalidate(18, points = $$props.points);
		if ('sorting' in $$props) $$invalidate(19, sorting = $$props.sorting);
		if ('theme' in $$props) $$invalidate(20, theme = $$props.theme);
		if ('valueFormatFn' in $$props) $$invalidate(1, valueFormatFn = $$props.valueFormatFn);
		if ('yTicksCount' in $$props) $$invalidate(21, yTicksCount = $$props.yTicksCount);
		if ('height' in $$props) $$invalidate(2, height = $$props.height);
		if ('width' in $$props) $$invalidate(3, width = $$props.width);
		if ('bbox' in $$props) $$invalidate(4, bbox = $$props.bbox);
		if ('doDraw' in $$props) $$invalidate(7, doDraw = $$props.doDraw);
		if ('keyTicks' in $$props) $$invalidate(8, keyTicks = $$props.keyTicks);
		if ('paths' in $$props) $$invalidate(9, paths = $$props.paths);
		if ('xScale' in $$props) $$invalidate(5, xScale = $$props.xScale);
		if ('yScale' in $$props) $$invalidate(6, yScale = $$props.yScale);
		if ('streams' in $$props) $$invalidate(26, streams = $$props.streams);
		if ('maxSum' in $$props) $$invalidate(27, maxSum = $$props.maxSum);
		if ('allKeys' in $$props) $$invalidate(28, allKeys = $$props.allKeys);
		if ('yTicks' in $$props) $$invalidate(10, yTicks = $$props.yTicks);
		if ('makeStreams' in $$props) $$invalidate(29, makeStreams = $$props.makeStreams);
		if ('sortingFn' in $$props) $$invalidate(30, sortingFn = $$props.sortingFn);
		if ('zeroedGroupsMap' in $$props) $$invalidate(31, zeroedGroupsMap = $$props.zeroedGroupsMap);
		if ('labelsDy' in $$props) $$invalidate(11, labelsDy = $$props.labelsDy);
		if ('style' in $$props) $$invalidate(12, style = $$props.style);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*sorting*/ 524288) {
			$$invalidate(19, sorting = sorting ?? 'off');
		}

		if ($$self.$$.dirty[0] & /*axesLabels*/ 1) {
			$$invalidate(0, axesLabels = axesLabels ?? []);
		}

		if ($$self.$$.dirty[0] & /*keyFormatFn*/ 131072) {
			$$invalidate(17, keyFormatFn = keyFormatFn ?? identity);
		}

		if ($$self.$$.dirty[0] & /*yTicksCount*/ 2097152) {
			$$invalidate(21, yTicksCount = yTicksCount ?? 10);
		}

		if ($$self.$$.dirty[0] & /*valueFormatFn*/ 2) {
			$$invalidate(1, valueFormatFn = valueFormatFn ?? identity);
		}

		if ($$self.$$.dirty[0] & /*theme*/ 1048576) {
			/* theme */
			$$invalidate(20, theme = theme ? { ...defaultTheme, ...theme } : defaultTheme);
		}

		if ($$self.$$.dirty[0] & /*theme*/ 1048576) {
			$$invalidate(12, style = makeStyleVars(theme));
		}

		if ($$self.$$.dirty[0] & /*geometry*/ 65536) {
			$$invalidate(16, geometry = geometry
			? { ...defaultGeometry, ...geometry }
			: defaultGeometry);
		}

		if ($$self.$$.dirty[0] & /*geometry*/ 65536) {
			$$invalidate(11, labelsDy = Math.min(geometry.safetyBottom, geometry.safetyTop) / 2);
		}

		if ($$self.$$.dirty[1] & /*$_size*/ 2) {
			$$invalidate(3, { inlineSize: width, blockSize: height } = $_size, width, ($$invalidate(2, height), $$invalidate(32, $_size)));
		}

		if ($$self.$$.dirty[0] & /*points*/ 262144) {
			/* streams */
			$$invalidate(18, points = points ?? []);
		}

		if ($$self.$$.dirty[0] & /*points*/ 262144) {
			$$invalidate(28, allKeys = pluckKeySorted(points));
		}

		if ($$self.$$.dirty[0] & /*groups*/ 4194304) {
			$$invalidate(31, zeroedGroupsMap = makeKeyedZeroes(groups));
		}

		if ($$self.$$.dirty[0] & /*sorting*/ 524288) {
			$$invalidate(30, sortingFn = sorting === 'off'
			? identity
			: sorting === 'asc'
				? sortWith([getValue])
				: sortWith([sorterDesc(getValue)]));
		}

		if ($$self.$$.dirty[0] & /*sortingFn*/ 1073741824 | $$self.$$.dirty[1] & /*zeroedGroupsMap*/ 1) {
			$$invalidate(29, makeStreams = pipe([
				groupBy(getKey$1),
				objectToKeyValuesArray,
				mapWith(transformValues({
					values: pipe([
						mapWith(({ group, value }) => ({
							key: group, // {key, values: {group, key, value}[]}[]
							value
						})),
						keyValueArrayToObject,
						kvObject => merge(zeroedGroupsMap, kvObject),
						objectToKeyValueArray,
						sortingFn,
						kvObjects => reduce(
							kvObjects,
							(acc, { key, value }) => {
								acc.array.push({
									key,
									value,
									start: acc.sum,
									end: acc.sum + value
								});

								acc.sum += value;
								return acc;
							},
							{ array: [], sum: 0 }
						),
						getKey('array')
					])
				}))
			]));
		}

		if ($$self.$$.dirty[0] & /*makeStreams, points*/ 537133056) {
			$$invalidate(26, streams = makeStreams(points));
		}

		if ($$self.$$.dirty[0] & /*points*/ 262144) {
			$$invalidate(27, maxSum = getMaxSum(points));
		}

		if ($$self.$$.dirty[0] & /*maxSum, yTicksCount*/ 136314880) {
			$$invalidate(10, yTicks = inclusiveRange([0, maxSum, maxSum / yTicksCount]));
		}

		if ($$self.$$.dirty[0] & /*height, width, streams, geometry, bbox, keyType, allKeys, keyFilterFn, keyFormatFn, maxSum, xScale, yScale*/ 520290428) {
			if (height && width && streams) {
				$$invalidate(4, bbox = {
					blx: geometry.safetyLeft,
					bly: height - geometry.safetyBottom,
					trx: width - geometry.safetyRight,
					try: geometry.safetyTop,
					width: width - geometry.safetyRight - geometry.safetyLeft,
					height: height - geometry.safetyTop - geometry.safetyBottom
				});

				const xRange = [bbox.blx, bbox.trx];

				if (keyType === 'date') {
					const keyDomain = [head(allKeys), last(allKeys)];
					const keyRankFn = key => new Date(key).getTime();
					const timeDomain = map(keyDomain, keyRankFn);
					const timeScale = time().domain(timeDomain).range(xRange);
					const ticks = timeScale.ticks();
					const tickDurationInSecs = (timeDomain[1] - timeDomain[0]) / 1000 / (ticks.length - 1);
					const timeFormat = getDateTimeFormat(tickDurationInSecs);
					$$invalidate(8, keyTicks = map(ticks, collect([identity, timeFormat])));
					$$invalidate(5, xScale = pipe([keyRankFn, timeScale]));
				} else {
					$$invalidate(8, keyTicks = map(keyFilterFn ? filter(allKeys, keyFilterFn) : allKeys, collect([identity, keyFormatFn])));
					$$invalidate(5, xScale = point().domain(allKeys).range(xRange));
				}

				$$invalidate(6, yScale = linear().domain([0, maxSum]).range([bbox.bly, bbox.try]));
				const getPaths = makeGetPaths({ xScale, yScale });
				$$invalidate(9, paths = getPaths(streams));
				$$invalidate(7, doDraw = true);
			}
		}
	};

	return [
		axesLabels,
		valueFormatFn,
		height,
		width,
		bbox,
		xScale,
		yScale,
		doDraw,
		keyTicks,
		paths,
		yTicks,
		labelsDy,
		style,
		dispatch,
		_size,
		sizeObserver,
		geometry,
		keyFormatFn,
		points,
		sorting,
		theme,
		yTicksCount,
		groups,
		groupToColorFn,
		keyFilterFn,
		keyType,
		streams,
		maxSum,
		allKeys,
		makeStreams,
		sortingFn,
		zeroedGroupsMap,
		$_size,
		mousemove_handler,
		mouseout_handler,
		touchend_handler,
		touchstart_handler
	];
}

class StreamGraph extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance$1,
			create_fragment$2,
			safe_not_equal,
			{
				axesLabels: 0,
				geometry: 16,
				groups: 22,
				groupToColorFn: 23,
				keyFilterFn: 24,
				keyFormatFn: 17,
				keyType: 25,
				points: 18,
				sorting: 19,
				theme: 20,
				valueFormatFn: 1,
				yTicksCount: 21
			},
			null,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "StreamGraph",
			options,
			id: create_fragment$2.name
		});
	}

	get axesLabels() {
		throw new Error("<StreamGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set axesLabels(value) {
		throw new Error("<StreamGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get geometry() {
		throw new Error("<StreamGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set geometry(value) {
		throw new Error("<StreamGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get groups() {
		throw new Error("<StreamGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set groups(value) {
		throw new Error("<StreamGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get groupToColorFn() {
		throw new Error("<StreamGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set groupToColorFn(value) {
		throw new Error("<StreamGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get keyFilterFn() {
		throw new Error("<StreamGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set keyFilterFn(value) {
		throw new Error("<StreamGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get keyFormatFn() {
		throw new Error("<StreamGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set keyFormatFn(value) {
		throw new Error("<StreamGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get keyType() {
		throw new Error("<StreamGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set keyType(value) {
		throw new Error("<StreamGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get points() {
		throw new Error("<StreamGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set points(value) {
		throw new Error("<StreamGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get sorting() {
		throw new Error("<StreamGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set sorting(value) {
		throw new Error("<StreamGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get theme() {
		throw new Error("<StreamGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set theme(value) {
		throw new Error("<StreamGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get valueFormatFn() {
		throw new Error("<StreamGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set valueFormatFn(value) {
		throw new Error("<StreamGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get yTicksCount() {
		throw new Error("<StreamGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set yTicksCount(value) {
		throw new Error("<StreamGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var StreamGraph$1 = StreamGraph;

/* ../../components/trends/src/Trends.svelte generated by Svelte v3.59.2 */
const file$1 = "../../components/trends/src/Trends.svelte";

function get_each_context$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[51] = list[i].label;
	child_ctx[52] = list[i].gridAreas;
	return child_ctx;
}

function get_each_context_1$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[55] = list[i];
	return child_ctx;
}

function get_each_context_2$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[58] = list[i].key;
	child_ctx[59] = list[i].values;
	return child_ctx;
}

function get_each_context_3$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[62] = list[i];
	return child_ctx;
}

function get_each_context_4$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[65] = list[i];
	return child_ctx;
}

function get_each_context_5$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[58] = list[i][0];
	child_ctx[51] = list[i][1];
	return child_ctx;
}

function get_each_context_6$1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[65] = list[i];
	return child_ctx;
}

function get_each_context_7(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[58] = list[i][0];
	return child_ctx;
}

// (263:2) {#if doDraw}
function create_if_block$1(ctx) {
	let svg;
	let g2;
	let g0;
	let g1;
	let g3;
	let g4;
	let rect;
	let rect_height_value;
	let rect_width_value;
	let rect_x_value;
	let rect_y_value;
	let each_blocks = [];
	let each4_lookup = new Map();
	let each4_anchor;
	let mounted;
	let dispose;
	let each_value_7 = /*keyTicks*/ ctx[13];
	validate_each_argument(each_value_7);
	let each_blocks_4 = [];

	for (let i = 0; i < each_value_7.length; i += 1) {
		each_blocks_4[i] = create_each_block_7(get_each_context_7(ctx, each_value_7, i));
	}

	let each_value_6 = /*yTicks*/ ctx[15];
	validate_each_argument(each_value_6);
	let each_blocks_3 = [];

	for (let i = 0; i < each_value_6.length; i += 1) {
		each_blocks_3[i] = create_each_block_6$1(get_each_context_6$1(ctx, each_value_6, i));
	}

	let each_value_5 = /*keyTicks*/ ctx[13];
	validate_each_argument(each_value_5);
	let each_blocks_2 = [];

	for (let i = 0; i < each_value_5.length; i += 1) {
		each_blocks_2[i] = create_each_block_5$1(get_each_context_5$1(ctx, each_value_5, i));
	}

	let each_value_4 = /*yTicks*/ ctx[15];
	validate_each_argument(each_value_4);
	let each_blocks_1 = [];

	for (let i = 0; i < each_value_4.length; i += 1) {
		each_blocks_1[i] = create_each_block_4$1(get_each_context_4$1(ctx, each_value_4, i));
	}

	let each_value_2 = /*trends*/ ctx[2];
	validate_each_argument(each_value_2);
	const get_key = ctx => /*key*/ ctx[58];
	validate_each_keys(ctx, each_value_2, get_each_context_2$1, get_key);

	for (let i = 0; i < each_value_2.length; i += 1) {
		let child_ctx = get_each_context_2$1(ctx, each_value_2, i);
		let key = get_key(child_ctx);
		each4_lookup.set(key, each_blocks[i] = create_each_block_2$1(key, child_ctx));
	}

	let if_block = /*hero*/ ctx[4] && create_if_block_1$1(ctx);

	const block = {
		c: function create() {
			svg = svg_element("svg");
			g2 = svg_element("g");
			g0 = svg_element("g");

			for (let i = 0; i < each_blocks_4.length; i += 1) {
				each_blocks_4[i].c();
			}

			g1 = svg_element("g");

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].c();
			}

			g3 = svg_element("g");

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].c();
			}

			g4 = svg_element("g");

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].c();
			}

			rect = svg_element("rect");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each4_anchor = empty();
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			svg = claim_svg_element(nodes, "svg", { height: true, width: true, class: true });
			var svg_nodes = children(svg);
			g2 = claim_svg_element(svg_nodes, "g", { class: true });
			var g2_nodes = children(g2);
			g0 = claim_svg_element(g2_nodes, "g", { class: true });
			var g0_nodes = children(g0);

			for (let i = 0; i < each_blocks_4.length; i += 1) {
				each_blocks_4[i].l(g0_nodes);
			}

			g0_nodes.forEach(detach_dev);
			g1 = claim_svg_element(g2_nodes, "g", { class: true });
			var g1_nodes = children(g1);

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				each_blocks_3[i].l(g1_nodes);
			}

			g1_nodes.forEach(detach_dev);
			g2_nodes.forEach(detach_dev);
			g3 = claim_svg_element(svg_nodes, "g", { class: true });
			var g3_nodes = children(g3);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				each_blocks_2[i].l(g3_nodes);
			}

			g3_nodes.forEach(detach_dev);
			g4 = claim_svg_element(svg_nodes, "g", { class: true });
			var g4_nodes = children(g4);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				each_blocks_1[i].l(g4_nodes);
			}

			g4_nodes.forEach(detach_dev);

			rect = claim_svg_element(svg_nodes, "rect", {
				role: true,
				class: true,
				height: true,
				width: true,
				x: true,
				y: true
			});

			children(rect).forEach(detach_dev);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(svg_nodes);
			}

			each4_anchor = empty();
			if (if_block) if_block.l(svg_nodes);
			svg_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(g0, "class", "vertical svelte-47mokc");
			add_location(g0, file$1, 270, 5, 6366);
			attr_dev(g1, "class", "horizontal svelte-47mokc");
			add_location(g1, file$1, 280, 5, 6565);
			attr_dev(g2, "class", "grid svelte-47mokc");
			add_location(g2, file$1, 269, 4, 6344);
			attr_dev(g3, "class", "x-ticks svelte-47mokc");
			add_location(g3, file$1, 293, 4, 6798);
			attr_dev(g4, "class", "y-ticks svelte-47mokc");
			add_location(g4, file$1, 317, 4, 7230);
			attr_dev(rect, "role", "none");
			attr_dev(rect, "class", "frame svelte-47mokc");
			attr_dev(rect, "height", rect_height_value = /*bbox*/ ctx[6].height);
			attr_dev(rect, "width", rect_width_value = /*bbox*/ ctx[6].width);
			attr_dev(rect, "x", rect_x_value = /*bbox*/ ctx[6].blx);
			attr_dev(rect, "y", rect_y_value = /*bbox*/ ctx[6].try);
			add_location(rect, file$1, 342, 4, 7739);
			attr_dev(svg, "height", /*height*/ ctx[7]);
			attr_dev(svg, "width", /*width*/ ctx[8]);
			attr_dev(svg, "class", "svelte-47mokc");
			add_location(svg, file$1, 264, 3, 6287);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, svg, anchor);
			append_hydration_dev(svg, g2);
			append_hydration_dev(g2, g0);

			for (let i = 0; i < each_blocks_4.length; i += 1) {
				if (each_blocks_4[i]) {
					each_blocks_4[i].m(g0, null);
				}
			}

			append_hydration_dev(g2, g1);

			for (let i = 0; i < each_blocks_3.length; i += 1) {
				if (each_blocks_3[i]) {
					each_blocks_3[i].m(g1, null);
				}
			}

			append_hydration_dev(svg, g3);

			for (let i = 0; i < each_blocks_2.length; i += 1) {
				if (each_blocks_2[i]) {
					each_blocks_2[i].m(g3, null);
				}
			}

			append_hydration_dev(svg, g4);

			for (let i = 0; i < each_blocks_1.length; i += 1) {
				if (each_blocks_1[i]) {
					each_blocks_1[i].m(g4, null);
				}
			}

			append_hydration_dev(svg, rect);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(svg, null);
				}
			}

			append_hydration_dev(svg, each4_anchor);
			if (if_block) if_block.m(svg, null);

			if (!mounted) {
				dispose = [
					listen_dev(rect, "mousemove", /*onFrameHovered*/ ctx[22], true, false, false, false),
					listen_dev(rect, "mouseout", /*onFrameExited*/ ctx[23], false, false, false, false),
					listen_dev(rect, "touchstart", /*onFrameTouchStarted*/ ctx[24], false, false, false, false),
					listen_dev(rect, "touchend", /*onFrameTouchEnded*/ ctx[25], { passive: true }, false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*xScale, keyTicks, bbox*/ 8768) {
				each_value_7 = /*keyTicks*/ ctx[13];
				validate_each_argument(each_value_7);
				let i;

				for (i = 0; i < each_value_7.length; i += 1) {
					const child_ctx = get_each_context_7(ctx, each_value_7, i);

					if (each_blocks_4[i]) {
						each_blocks_4[i].p(child_ctx, dirty);
					} else {
						each_blocks_4[i] = create_each_block_7(child_ctx);
						each_blocks_4[i].c();
						each_blocks_4[i].m(g0, null);
					}
				}

				for (; i < each_blocks_4.length; i += 1) {
					each_blocks_4[i].d(1);
				}

				each_blocks_4.length = each_value_7.length;
			}

			if (dirty[0] & /*bbox, yScale, yTicks*/ 33856) {
				each_value_6 = /*yTicks*/ ctx[15];
				validate_each_argument(each_value_6);
				let i;

				for (i = 0; i < each_value_6.length; i += 1) {
					const child_ctx = get_each_context_6$1(ctx, each_value_6, i);

					if (each_blocks_3[i]) {
						each_blocks_3[i].p(child_ctx, dirty);
					} else {
						each_blocks_3[i] = create_each_block_6$1(child_ctx);
						each_blocks_3[i].c();
						each_blocks_3[i].m(g1, null);
					}
				}

				for (; i < each_blocks_3.length; i += 1) {
					each_blocks_3[i].d(1);
				}

				each_blocks_3.length = each_value_6.length;
			}

			if (dirty[0] & /*labelsDy, xScale, keyTicks, bbox*/ 270912) {
				each_value_5 = /*keyTicks*/ ctx[13];
				validate_each_argument(each_value_5);
				let i;

				for (i = 0; i < each_value_5.length; i += 1) {
					const child_ctx = get_each_context_5$1(ctx, each_value_5, i);

					if (each_blocks_2[i]) {
						each_blocks_2[i].p(child_ctx, dirty);
					} else {
						each_blocks_2[i] = create_each_block_5$1(child_ctx);
						each_blocks_2[i].c();
						each_blocks_2[i].m(g3, null);
					}
				}

				for (; i < each_blocks_2.length; i += 1) {
					each_blocks_2[i].d(1);
				}

				each_blocks_2.length = each_value_5.length;
			}

			if (dirty[0] & /*bbox, yScale, yTicks, valueFormatFn*/ 33864) {
				each_value_4 = /*yTicks*/ ctx[15];
				validate_each_argument(each_value_4);
				let i;

				for (i = 0; i < each_value_4.length; i += 1) {
					const child_ctx = get_each_context_4$1(ctx, each_value_4, i);

					if (each_blocks_1[i]) {
						each_blocks_1[i].p(child_ctx, dirty);
					} else {
						each_blocks_1[i] = create_each_block_4$1(child_ctx);
						each_blocks_1[i].c();
						each_blocks_1[i].m(g4, null);
					}
				}

				for (; i < each_blocks_1.length; i += 1) {
					each_blocks_1[i].d(1);
				}

				each_blocks_1.length = each_value_4.length;
			}

			if (dirty[0] & /*bbox*/ 64 && rect_height_value !== (rect_height_value = /*bbox*/ ctx[6].height)) {
				attr_dev(rect, "height", rect_height_value);
			}

			if (dirty[0] & /*bbox*/ 64 && rect_width_value !== (rect_width_value = /*bbox*/ ctx[6].width)) {
				attr_dev(rect, "width", rect_width_value);
			}

			if (dirty[0] & /*bbox*/ 64 && rect_x_value !== (rect_x_value = /*bbox*/ ctx[6].blx)) {
				attr_dev(rect, "x", rect_x_value);
			}

			if (dirty[0] & /*bbox*/ 64 && rect_y_value !== (rect_y_value = /*bbox*/ ctx[6].try)) {
				attr_dev(rect, "y", rect_y_value);
			}

			if (dirty[0] & /*trends, xScale, yScale, keyToColorFn, dotRadius, lineGenerator*/ 22052) {
				each_value_2 = /*trends*/ ctx[2];
				validate_each_argument(each_value_2);
				validate_each_keys(ctx, each_value_2, get_each_context_2$1, get_key);
				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_2, each4_lookup, svg, destroy_block, create_each_block_2$1, each4_anchor, get_each_context_2$1);
			}

			if (/*hero*/ ctx[4]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1$1(ctx);
					if_block.c();
					if_block.m(svg, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*height*/ 128) {
				attr_dev(svg, "height", /*height*/ ctx[7]);
			}

			if (dirty[0] & /*width*/ 256) {
				attr_dev(svg, "width", /*width*/ ctx[8]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svg);
			destroy_each(each_blocks_4, detaching);
			destroy_each(each_blocks_3, detaching);
			destroy_each(each_blocks_2, detaching);
			destroy_each(each_blocks_1, detaching);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].d();
			}

			if (if_block) if_block.d();
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block$1.name,
		type: "if",
		source: "(263:2) {#if doDraw}",
		ctx
	});

	return block;
}

// (272:6) {#each keyTicks as [key]}
function create_each_block_7(ctx) {
	let line_1;
	let line_1_x__value;
	let line_1_x__value_1;
	let line_1_y__value;
	let line_1_y__value_1;

	const block = {
		c: function create() {
			line_1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			line_1 = claim_svg_element(nodes, "line", {
				x1: true,
				x2: true,
				y1: true,
				y2: true,
				class: true
			});

			children(line_1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line_1, "x1", line_1_x__value = /*xScale*/ ctx[9](/*key*/ ctx[58]));
			attr_dev(line_1, "x2", line_1_x__value_1 = /*xScale*/ ctx[9](/*key*/ ctx[58]));
			attr_dev(line_1, "y1", line_1_y__value = /*bbox*/ ctx[6].bly);
			attr_dev(line_1, "y2", line_1_y__value_1 = /*bbox*/ ctx[6].try);
			attr_dev(line_1, "class", "svelte-47mokc");
			add_location(line_1, file$1, 272, 7, 6426);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line_1, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*xScale, keyTicks*/ 8704 && line_1_x__value !== (line_1_x__value = /*xScale*/ ctx[9](/*key*/ ctx[58]))) {
				attr_dev(line_1, "x1", line_1_x__value);
			}

			if (dirty[0] & /*xScale, keyTicks*/ 8704 && line_1_x__value_1 !== (line_1_x__value_1 = /*xScale*/ ctx[9](/*key*/ ctx[58]))) {
				attr_dev(line_1, "x2", line_1_x__value_1);
			}

			if (dirty[0] & /*bbox*/ 64 && line_1_y__value !== (line_1_y__value = /*bbox*/ ctx[6].bly)) {
				attr_dev(line_1, "y1", line_1_y__value);
			}

			if (dirty[0] & /*bbox*/ 64 && line_1_y__value_1 !== (line_1_y__value_1 = /*bbox*/ ctx[6].try)) {
				attr_dev(line_1, "y2", line_1_y__value_1);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(line_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_7.name,
		type: "each",
		source: "(272:6) {#each keyTicks as [key]}",
		ctx
	});

	return block;
}

// (282:6) {#each yTicks as value}
function create_each_block_6$1(ctx) {
	let line_1;
	let line_1_x__value;
	let line_1_x__value_1;
	let line_1_y__value;
	let line_1_y__value_1;

	const block = {
		c: function create() {
			line_1 = svg_element("line");
			this.h();
		},
		l: function claim(nodes) {
			line_1 = claim_svg_element(nodes, "line", {
				x1: true,
				x2: true,
				y1: true,
				y2: true,
				class: true
			});

			children(line_1).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(line_1, "x1", line_1_x__value = /*bbox*/ ctx[6].blx);
			attr_dev(line_1, "x2", line_1_x__value_1 = /*bbox*/ ctx[6].trx);
			attr_dev(line_1, "y1", line_1_y__value = /*yScale*/ ctx[10](/*value*/ ctx[65]));
			attr_dev(line_1, "y2", line_1_y__value_1 = /*yScale*/ ctx[10](/*value*/ ctx[65]));
			attr_dev(line_1, "class", "svelte-47mokc");
			add_location(line_1, file$1, 282, 7, 6625);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, line_1, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*bbox*/ 64 && line_1_x__value !== (line_1_x__value = /*bbox*/ ctx[6].blx)) {
				attr_dev(line_1, "x1", line_1_x__value);
			}

			if (dirty[0] & /*bbox*/ 64 && line_1_x__value_1 !== (line_1_x__value_1 = /*bbox*/ ctx[6].trx)) {
				attr_dev(line_1, "x2", line_1_x__value_1);
			}

			if (dirty[0] & /*yScale, yTicks*/ 33792 && line_1_y__value !== (line_1_y__value = /*yScale*/ ctx[10](/*value*/ ctx[65]))) {
				attr_dev(line_1, "y1", line_1_y__value);
			}

			if (dirty[0] & /*yScale, yTicks*/ 33792 && line_1_y__value_1 !== (line_1_y__value_1 = /*yScale*/ ctx[10](/*value*/ ctx[65]))) {
				attr_dev(line_1, "y2", line_1_y__value_1);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(line_1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_6$1.name,
		type: "each",
		source: "(282:6) {#each yTicks as value}",
		ctx
	});

	return block;
}

// (295:5) {#each keyTicks as [key, label]}
function create_each_block_5$1(ctx) {
	let g;
	let text0;
	let t0_value = /*label*/ ctx[51] + "";
	let t0;
	let text0_x_value;
	let text0_y_value;
	let text1;
	let t1_value = /*label*/ ctx[51] + "";
	let t1;
	let text1_dy_value;
	let text1_x_value;
	let text1_y_value;

	const block = {
		c: function create() {
			g = svg_element("g");
			text0 = svg_element("text");
			t0 = text(t0_value);
			text1 = svg_element("text");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			g = claim_svg_element(nodes, "g", { class: true });
			var g_nodes = children(g);
			text0 = claim_svg_element(g_nodes, "text", { class: true, dy: true, x: true, y: true });
			var text0_nodes = children(text0);
			t0 = claim_text(text0_nodes, t0_value);
			text0_nodes.forEach(detach_dev);
			text1 = claim_svg_element(g_nodes, "text", { class: true, dy: true, x: true, y: true });
			var text1_nodes = children(text1);
			t1 = claim_text(text1_nodes, t1_value);
			text1_nodes.forEach(detach_dev);
			g_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(text0, "class", "centered svelte-47mokc");
			attr_dev(text0, "dy", /*labelsDy*/ ctx[18]);
			attr_dev(text0, "x", text0_x_value = /*xScale*/ ctx[9](/*key*/ ctx[58]));
			attr_dev(text0, "y", text0_y_value = /*bbox*/ ctx[6].bly);
			add_location(text0, file$1, 296, 7, 6887);
			attr_dev(text1, "class", "centered svelte-47mokc");
			attr_dev(text1, "dy", text1_dy_value = -/*labelsDy*/ ctx[18]);
			attr_dev(text1, "x", text1_x_value = /*xScale*/ ctx[9](/*key*/ ctx[58]));
			attr_dev(text1, "y", text1_y_value = /*bbox*/ ctx[6].try);
			add_location(text1, file$1, 304, 7, 7032);
			attr_dev(g, "class", "ticks svelte-47mokc");
			add_location(g, file$1, 295, 6, 6862);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, g, anchor);
			append_hydration_dev(g, text0);
			append_hydration_dev(text0, t0);
			append_hydration_dev(g, text1);
			append_hydration_dev(text1, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*keyTicks*/ 8192 && t0_value !== (t0_value = /*label*/ ctx[51] + "")) set_data_dev(t0, t0_value);

			if (dirty[0] & /*labelsDy*/ 262144) {
				attr_dev(text0, "dy", /*labelsDy*/ ctx[18]);
			}

			if (dirty[0] & /*xScale, keyTicks*/ 8704 && text0_x_value !== (text0_x_value = /*xScale*/ ctx[9](/*key*/ ctx[58]))) {
				attr_dev(text0, "x", text0_x_value);
			}

			if (dirty[0] & /*bbox*/ 64 && text0_y_value !== (text0_y_value = /*bbox*/ ctx[6].bly)) {
				attr_dev(text0, "y", text0_y_value);
			}

			if (dirty[0] & /*keyTicks*/ 8192 && t1_value !== (t1_value = /*label*/ ctx[51] + "")) set_data_dev(t1, t1_value);

			if (dirty[0] & /*labelsDy*/ 262144 && text1_dy_value !== (text1_dy_value = -/*labelsDy*/ ctx[18])) {
				attr_dev(text1, "dy", text1_dy_value);
			}

			if (dirty[0] & /*xScale, keyTicks*/ 8704 && text1_x_value !== (text1_x_value = /*xScale*/ ctx[9](/*key*/ ctx[58]))) {
				attr_dev(text1, "x", text1_x_value);
			}

			if (dirty[0] & /*bbox*/ 64 && text1_y_value !== (text1_y_value = /*bbox*/ ctx[6].try)) {
				attr_dev(text1, "y", text1_y_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(g);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_5$1.name,
		type: "each",
		source: "(295:5) {#each keyTicks as [key, label]}",
		ctx
	});

	return block;
}

// (319:5) {#each yTicks as value}
function create_each_block_4$1(ctx) {
	let g;
	let text0;
	let t0_value = /*valueFormatFn*/ ctx[3](/*value*/ ctx[65]) + "";
	let t0;
	let text0_x_value;
	let text0_y_value;
	let text1;
	let t1_value = /*valueFormatFn*/ ctx[3](/*value*/ ctx[65]) + "";
	let t1;
	let text1_x_value;
	let text1_y_value;

	const block = {
		c: function create() {
			g = svg_element("g");
			text0 = svg_element("text");
			t0 = text(t0_value);
			text1 = svg_element("text");
			t1 = text(t1_value);
			this.h();
		},
		l: function claim(nodes) {
			g = claim_svg_element(nodes, "g", { class: true });
			var g_nodes = children(g);
			text0 = claim_svg_element(g_nodes, "text", { class: true, dx: true, x: true, y: true });
			var text0_nodes = children(text0);
			t0 = claim_text(text0_nodes, t0_value);
			text0_nodes.forEach(detach_dev);
			text1 = claim_svg_element(g_nodes, "text", { class: true, dx: true, x: true, y: true });
			var text1_nodes = children(text1);
			t1 = claim_text(text1_nodes, t1_value);
			text1_nodes.forEach(detach_dev);
			g_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(text0, "class", "left svelte-47mokc");
			attr_dev(text0, "dx", -labelsDx);
			attr_dev(text0, "x", text0_x_value = /*bbox*/ ctx[6].blx);
			attr_dev(text0, "y", text0_y_value = /*yScale*/ ctx[10](/*value*/ ctx[65]));
			add_location(text0, file$1, 320, 7, 7310);
			attr_dev(text1, "class", "right svelte-47mokc");
			attr_dev(text1, "dx", labelsDx);
			attr_dev(text1, "x", text1_x_value = /*bbox*/ ctx[6].trx);
			attr_dev(text1, "y", text1_y_value = /*yScale*/ ctx[10](/*value*/ ctx[65]));
			add_location(text1, file$1, 328, 7, 7469);
			attr_dev(g, "class", "ticks svelte-47mokc");
			add_location(g, file$1, 319, 6, 7285);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, g, anchor);
			append_hydration_dev(g, text0);
			append_hydration_dev(text0, t0);
			append_hydration_dev(g, text1);
			append_hydration_dev(text1, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*valueFormatFn, yTicks*/ 32776 && t0_value !== (t0_value = /*valueFormatFn*/ ctx[3](/*value*/ ctx[65]) + "")) set_data_dev(t0, t0_value);

			if (dirty[0] & /*bbox*/ 64 && text0_x_value !== (text0_x_value = /*bbox*/ ctx[6].blx)) {
				attr_dev(text0, "x", text0_x_value);
			}

			if (dirty[0] & /*yScale, yTicks*/ 33792 && text0_y_value !== (text0_y_value = /*yScale*/ ctx[10](/*value*/ ctx[65]))) {
				attr_dev(text0, "y", text0_y_value);
			}

			if (dirty[0] & /*valueFormatFn, yTicks*/ 32776 && t1_value !== (t1_value = /*valueFormatFn*/ ctx[3](/*value*/ ctx[65]) + "")) set_data_dev(t1, t1_value);

			if (dirty[0] & /*bbox*/ 64 && text1_x_value !== (text1_x_value = /*bbox*/ ctx[6].trx)) {
				attr_dev(text1, "x", text1_x_value);
			}

			if (dirty[0] & /*yScale, yTicks*/ 33792 && text1_y_value !== (text1_y_value = /*yScale*/ ctx[10](/*value*/ ctx[65]))) {
				attr_dev(text1, "y", text1_y_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(g);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_4$1.name,
		type: "each",
		source: "(319:5) {#each yTicks as value}",
		ctx
	});

	return block;
}

// (362:5) {#each values as data}
function create_each_block_3$1(ctx) {
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_fill_value;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", {
				cx: true,
				cy: true,
				fill: true,
				r: true,
				class: true
			});

			children(circle).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", circle_cx_value = /*xScale*/ ctx[9](getKey$1(/*data*/ ctx[62])));
			attr_dev(circle, "cy", circle_cy_value = /*yScale*/ ctx[10](getValue(/*data*/ ctx[62])));
			attr_dev(circle, "fill", circle_fill_value = /*keyToColorFn*/ ctx[5]?.(/*key*/ ctx[58]) ?? 'var(--curveStroke)');
			attr_dev(circle, "r", /*dotRadius*/ ctx[12]);
			attr_dev(circle, "class", "svelte-47mokc");
			add_location(circle, file$1, 362, 6, 8216);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*xScale, trends*/ 516 && circle_cx_value !== (circle_cx_value = /*xScale*/ ctx[9](getKey$1(/*data*/ ctx[62])))) {
				attr_dev(circle, "cx", circle_cx_value);
			}

			if (dirty[0] & /*yScale, trends*/ 1028 && circle_cy_value !== (circle_cy_value = /*yScale*/ ctx[10](getValue(/*data*/ ctx[62])))) {
				attr_dev(circle, "cy", circle_cy_value);
			}

			if (dirty[0] & /*keyToColorFn, trends*/ 36 && circle_fill_value !== (circle_fill_value = /*keyToColorFn*/ ctx[5]?.(/*key*/ ctx[58]) ?? 'var(--curveStroke)')) {
				attr_dev(circle, "fill", circle_fill_value);
			}

			if (dirty[0] & /*dotRadius*/ 4096) {
				attr_dev(circle, "r", /*dotRadius*/ ctx[12]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_3$1.name,
		type: "each",
		source: "(362:5) {#each values as data}",
		ctx
	});

	return block;
}

// (356:4) {#each trends as {key, values}
function create_each_block_2$1(key_1, ctx) {
	let path;
	let path_d_value;
	let path_stroke_value;
	let each_1_anchor;
	let each_value_3 = /*values*/ ctx[59];
	validate_each_argument(each_value_3);
	let each_blocks = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks[i] = create_each_block_3$1(get_each_context_3$1(ctx, each_value_3, i));
	}

	const block = {
		key: key_1,
		first: null,
		c: function create() {
			path = svg_element("path");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			path = claim_svg_element(nodes, "path", { d: true, stroke: true, class: true });
			children(path).forEach(detach_dev);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", path_d_value = /*lineGenerator*/ ctx[14](/*values*/ ctx[59]));
			attr_dev(path, "stroke", path_stroke_value = /*keyToColorFn*/ ctx[5]?.(/*key*/ ctx[58]) ?? 'var(--curveStroke)');
			attr_dev(path, "class", "svelte-47mokc");
			add_location(path, file$1, 356, 5, 8076);
			this.first = path;
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, path, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert_hydration_dev(target, each_1_anchor, anchor);
		},
		p: function update(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*lineGenerator, trends*/ 16388 && path_d_value !== (path_d_value = /*lineGenerator*/ ctx[14](/*values*/ ctx[59]))) {
				attr_dev(path, "d", path_d_value);
			}

			if (dirty[0] & /*keyToColorFn, trends*/ 36 && path_stroke_value !== (path_stroke_value = /*keyToColorFn*/ ctx[5]?.(/*key*/ ctx[58]) ?? 'var(--curveStroke)')) {
				attr_dev(path, "stroke", path_stroke_value);
			}

			if (dirty[0] & /*xScale, trends, yScale, keyToColorFn, dotRadius*/ 5668) {
				each_value_3 = /*values*/ ctx[59];
				validate_each_argument(each_value_3);
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3$1(ctx, each_value_3, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_3$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_3.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(path);
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2$1.name,
		type: "each",
		source: "(356:4) {#each trends as {key, values}",
		ctx
	});

	return block;
}

// (372:4) {#if hero}
function create_if_block_1$1(ctx) {
	let g;
	let path;
	let path_d_value;
	let path_stroke_value;
	let show_if = getKey$1(/*hero*/ ctx[4]);
	let if_block = show_if && create_if_block_2$1(ctx);

	const block = {
		c: function create() {
			g = svg_element("g");
			path = svg_element("path");
			if (if_block) if_block.c();
			this.h();
		},
		l: function claim(nodes) {
			g = claim_svg_element(nodes, "g", { class: true });
			var g_nodes = children(g);
			path = claim_svg_element(g_nodes, "path", { d: true, stroke: true, class: true });
			children(path).forEach(detach_dev);
			if (if_block) if_block.l(g_nodes);
			g_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(path, "d", path_d_value = /*lineGenerator*/ ctx[14](/*heroCurveValues*/ ctx[16]));
			attr_dev(path, "stroke", path_stroke_value = /*keyToColorFn*/ ctx[5]?.(/*hero*/ ctx[4].trendKey) ?? 'var(--curveStroke)');
			attr_dev(path, "class", "svelte-47mokc");
			toggle_class(path, "highlighted", /*doHighlightHeroCurve*/ ctx[17]);
			add_location(path, file$1, 373, 6, 8449);
			attr_dev(g, "class", "hero svelte-47mokc");
			add_location(g, file$1, 372, 5, 8426);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, g, anchor);
			append_hydration_dev(g, path);
			if (if_block) if_block.m(g, null);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*lineGenerator, heroCurveValues*/ 81920 && path_d_value !== (path_d_value = /*lineGenerator*/ ctx[14](/*heroCurveValues*/ ctx[16]))) {
				attr_dev(path, "d", path_d_value);
			}

			if (dirty[0] & /*keyToColorFn, hero*/ 48 && path_stroke_value !== (path_stroke_value = /*keyToColorFn*/ ctx[5]?.(/*hero*/ ctx[4].trendKey) ?? 'var(--curveStroke)')) {
				attr_dev(path, "stroke", path_stroke_value);
			}

			if (dirty[0] & /*doHighlightHeroCurve*/ 131072) {
				toggle_class(path, "highlighted", /*doHighlightHeroCurve*/ ctx[17]);
			}

			if (dirty[0] & /*hero*/ 16) show_if = getKey$1(/*hero*/ ctx[4]);

			if (show_if) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_2$1(ctx);
					if_block.c();
					if_block.m(g, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(g);
			if (if_block) if_block.d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1$1.name,
		type: "if",
		source: "(372:4) {#if hero}",
		ctx
	});

	return block;
}

// (380:6) {#if getKey(hero)}
function create_if_block_2$1(ctx) {
	let circle;
	let circle_cx_value;
	let circle_cy_value;
	let circle_fill_value;
	let circle_r_value;

	const block = {
		c: function create() {
			circle = svg_element("circle");
			this.h();
		},
		l: function claim(nodes) {
			circle = claim_svg_element(nodes, "circle", {
				cx: true,
				cy: true,
				fill: true,
				r: true,
				class: true
			});

			children(circle).forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(circle, "cx", circle_cx_value = /*xScale*/ ctx[9](getKey$1(/*hero*/ ctx[4])));
			attr_dev(circle, "cy", circle_cy_value = /*yScale*/ ctx[10](getValue(/*hero*/ ctx[4])));
			attr_dev(circle, "fill", circle_fill_value = /*keyToColorFn*/ ctx[5]?.(/*hero*/ ctx[4].trendKey) ?? 'var(--curveStroke)');
			attr_dev(circle, "r", circle_r_value = /*geometry*/ ctx[1].heroDotRadius);
			attr_dev(circle, "class", "svelte-47mokc");
			add_location(circle, file$1, 380, 7, 8657);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, circle, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*xScale, hero*/ 528 && circle_cx_value !== (circle_cx_value = /*xScale*/ ctx[9](getKey$1(/*hero*/ ctx[4])))) {
				attr_dev(circle, "cx", circle_cx_value);
			}

			if (dirty[0] & /*yScale, hero*/ 1040 && circle_cy_value !== (circle_cy_value = /*yScale*/ ctx[10](getValue(/*hero*/ ctx[4])))) {
				attr_dev(circle, "cy", circle_cy_value);
			}

			if (dirty[0] & /*keyToColorFn, hero*/ 48 && circle_fill_value !== (circle_fill_value = /*keyToColorFn*/ ctx[5]?.(/*hero*/ ctx[4].trendKey) ?? 'var(--curveStroke)')) {
				attr_dev(circle, "fill", circle_fill_value);
			}

			if (dirty[0] & /*geometry*/ 2 && circle_r_value !== (circle_r_value = /*geometry*/ ctx[1].heroDotRadius)) {
				attr_dev(circle, "r", circle_r_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(circle);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2$1.name,
		type: "if",
		source: "(380:6) {#if getKey(hero)}",
		ctx
	});

	return block;
}

// (396:2) {#each gridAreas as gridArea}
function create_each_block_1$1(ctx) {
	let div;
	let t0_value = /*label*/ ctx[51] + "";
	let t0;
	let t1;
	let div_class_value;

	const block = {
		c: function create() {
			div = element("div");
			t0 = text(t0_value);
			t1 = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			t0 = claim_text(div_nodes, t0_value);
			t1 = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div, "class", div_class_value = "" + (/*gridArea*/ ctx[55] + " area" + " svelte-47mokc"));
			add_location(div, file$1, 396, 3, 8986);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, t0);
			append_hydration_dev(div, t1);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*axesLabels*/ 1 && t0_value !== (t0_value = /*label*/ ctx[51] + "")) set_data_dev(t0, t0_value);

			if (dirty[0] & /*axesLabels*/ 1 && div_class_value !== (div_class_value = "" + (/*gridArea*/ ctx[55] + " area" + " svelte-47mokc"))) {
				attr_dev(div, "class", div_class_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1$1.name,
		type: "each",
		source: "(396:2) {#each gridAreas as gridArea}",
		ctx
	});

	return block;
}

// (395:1) {#each axesLabels as {label, gridAreas}}
function create_each_block$1(ctx) {
	let each_1_anchor;
	let each_value_1 = /*gridAreas*/ ctx[52];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
	}

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert_hydration_dev(target, each_1_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*axesLabels*/ 1) {
				each_value_1 = /*gridAreas*/ ctx[52];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block$1.name,
		type: "each",
		source: "(395:1) {#each axesLabels as {label, gridAreas}}",
		ctx
	});

	return block;
}

function create_fragment$1(ctx) {
	let div1;
	let div0;
	let t;
	let mounted;
	let dispose;
	let if_block = /*doDraw*/ ctx[11] && create_if_block$1(ctx);
	let each_value = /*axesLabels*/ ctx[0];
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
	}

	const block = {
		c: function create() {
			div1 = element("div");
			div0 = element("div");
			if (if_block) if_block.c();
			t = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { style: true, class: true });
			var div1_nodes = children(div1);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			if (if_block) if_block.l(div0_nodes);
			div0_nodes.forEach(detach_dev);
			t = claim_space(div1_nodes);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div1_nodes);
			}

			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(div0, "class", "chart svelte-47mokc");
			add_location(div0, file$1, 258, 1, 6225);
			attr_dev(div1, "style", /*style*/ ctx[19]);
			attr_dev(div1, "class", "Trends svelte-47mokc");
			add_location(div1, file$1, 254, 0, 6192);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div1, anchor);
			append_hydration_dev(div1, div0);
			if (if_block) if_block.m(div0, null);
			append_hydration_dev(div1, t);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div1, null);
				}
			}

			if (!mounted) {
				dispose = action_destroyer(/*sizeObserver*/ ctx[21].call(null, div0));
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (/*doDraw*/ ctx[11]) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block$1(ctx);
					if_block.c();
					if_block.m(div0, null);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*axesLabels*/ 1) {
				each_value = /*axesLabels*/ ctx[0];
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context$1(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block$1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (dirty[0] & /*style*/ 524288) {
				attr_dev(div1, "style", /*style*/ ctx[19]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if (if_block) if_block.d();
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

const labelsDx = 20;

function instance($$self, $$props, $$invalidate) {
	let style;
	let labelsDy;
	let allKeys;
	let allData;
	let maxValue;
	let maxValueSign;
	let minValue;
	let minValueSign;
	let doHighlightHeroCurve;
	let heroCurveValues;
	let $_size;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Trends', slots, []);
	const dispatch = createEventDispatcher();
	const { _writable: _size, resizeObserver: sizeObserver } = setupResizeObserver();
	validate_store(_size, '_size');
	component_subscribe($$self, _size, value => $$invalidate(41, $_size = value));

	const defaultGeometry = {
		dotRadius: 2,
		heroDotRadius: 4,
		safetyBottom: 20,
		safetyLeft: 20,
		safetyRight: 20,
		safetyTop: 20
	};

	const defaultTheme = {
		curveStroke: 'black',
		curveStrokeWidth: 1,
		// frame theme
		frameFill: 'none',
		frameStroke: 'black',
		gridStroke: 'lightgrey',
		gridStrokeDasharray: '4 8',
		heroStrokeWidth: 2,
		textColor: 'black'
	};

	// {key, values: {key, value}[]}[]
	// outer key is the trend name, inner key is the x key
	const defaultTrends = [{ key: 'trend', values: [] }];

	let { axesLabels } = $$props;
	let { geometry } = $$props;
	let { hero } = $$props;
	let { keyFilterFn = null } = $$props;
	let { keyFormatFn = identity } = $$props;
	let { keyToColorFn = null } = $$props;
	let { keyType } = $$props;
	let { preformatDate = identity } = $$props;
	let { theme = null } = $$props;
	let { trends } = $$props;
	let { trendType = 'progressive' } = $$props;
	let { valueFormatFn } = $$props;
	let { yTicksCount = 10 } = $$props;
	let bbox;
	let doDraw = false;
	let dotRadius;
	let height;
	let keyTicks;
	let lineGenerator;
	let quadTree;
	let width;
	let xScale;
	let yDelta;
	let yDomain;
	let yScale;
	let yTicks;

	/* quadtree */
	const selectNearestDot = ({ target, x, y }) => {
		const { left, top } = target.parentElement.getBoundingClientRect();
		const x1 = x - left;
		const y1 = y - top;
		const data = quadTree.find(x1, y1);

		return {
			data,
			x: left + xScale(getKey$1(data)),
			y: top + yScale(getValue(data))
		};
	};

	/* frame event handlers */
	const onFrameHovered = ({ target, x, y }) => {
		const payload = selectNearestDot({ target, x, y });
		dispatch('dotHovered', payload);
	};

	const onFrameExited = () => {
		dispatch('dotExited');
	};

	const onFrameTouchStarted = ({ target, targetTouches: [touch] }) => {
		const { clientX: x, clientY: y } = touch;
		const payload = selectNearestDot({ target, x, y });
		dispatch('dotTouchStarted', payload);
	};

	const onFrameTouchEnded = () => {
		dispatch('dotTouchEnded');
	};

	const getSortedKeys = pipe([flatMapWith(getValues), pluckKey, uniques, sortWith()]);
	const getMaxValue = arrayMaxWith(getValue);
	const getMinValue = arrayMinWith(getValue);

	$$self.$$.on_mount.push(function () {
		if (axesLabels === undefined && !('axesLabels' in $$props || $$self.$$.bound[$$self.$$.props['axesLabels']])) {
			console.warn("<Trends> was created without expected prop 'axesLabels'");
		}

		if (geometry === undefined && !('geometry' in $$props || $$self.$$.bound[$$self.$$.props['geometry']])) {
			console.warn("<Trends> was created without expected prop 'geometry'");
		}

		if (hero === undefined && !('hero' in $$props || $$self.$$.bound[$$self.$$.props['hero']])) {
			console.warn("<Trends> was created without expected prop 'hero'");
		}

		if (keyType === undefined && !('keyType' in $$props || $$self.$$.bound[$$self.$$.props['keyType']])) {
			console.warn("<Trends> was created without expected prop 'keyType'");
		}

		if (trends === undefined && !('trends' in $$props || $$self.$$.bound[$$self.$$.props['trends']])) {
			console.warn("<Trends> was created without expected prop 'trends'");
		}

		if (valueFormatFn === undefined && !('valueFormatFn' in $$props || $$self.$$.bound[$$self.$$.props['valueFormatFn']])) {
			console.warn("<Trends> was created without expected prop 'valueFormatFn'");
		}
	});

	const writable_props = [
		'axesLabels',
		'geometry',
		'hero',
		'keyFilterFn',
		'keyFormatFn',
		'keyToColorFn',
		'keyType',
		'preformatDate',
		'theme',
		'trends',
		'trendType',
		'valueFormatFn',
		'yTicksCount'
	];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Trends> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('axesLabels' in $$props) $$invalidate(0, axesLabels = $$props.axesLabels);
		if ('geometry' in $$props) $$invalidate(1, geometry = $$props.geometry);
		if ('hero' in $$props) $$invalidate(4, hero = $$props.hero);
		if ('keyFilterFn' in $$props) $$invalidate(30, keyFilterFn = $$props.keyFilterFn);
		if ('keyFormatFn' in $$props) $$invalidate(26, keyFormatFn = $$props.keyFormatFn);
		if ('keyToColorFn' in $$props) $$invalidate(5, keyToColorFn = $$props.keyToColorFn);
		if ('keyType' in $$props) $$invalidate(31, keyType = $$props.keyType);
		if ('preformatDate' in $$props) $$invalidate(27, preformatDate = $$props.preformatDate);
		if ('theme' in $$props) $$invalidate(28, theme = $$props.theme);
		if ('trends' in $$props) $$invalidate(2, trends = $$props.trends);
		if ('trendType' in $$props) $$invalidate(32, trendType = $$props.trendType);
		if ('valueFormatFn' in $$props) $$invalidate(3, valueFormatFn = $$props.valueFormatFn);
		if ('yTicksCount' in $$props) $$invalidate(29, yTicksCount = $$props.yTicksCount);
	};

	$$self.$capture_state = () => ({
		makeStyleVars,
		setupResizeObserver,
		arrayMaxWith,
		arrayMinWith,
		getKey: getKey$1,
		getValue,
		getValues,
		inclusiveRange,
		isIterableLongerThan1,
		pluckKey,
		scaleLinear: linear,
		scalePoint: point,
		scaleTime: time,
		line,
		curveMonotoneX: monotoneX,
		quadtree,
		_,
		createEventDispatcher,
		getDateTimeFormat,
		dispatch,
		_size,
		sizeObserver,
		defaultGeometry,
		defaultTheme,
		defaultTrends,
		axesLabels,
		geometry,
		hero,
		keyFilterFn,
		keyFormatFn,
		keyToColorFn,
		keyType,
		preformatDate,
		theme,
		trends,
		trendType,
		valueFormatFn,
		yTicksCount,
		bbox,
		doDraw,
		dotRadius,
		height,
		keyTicks,
		lineGenerator,
		quadTree,
		width,
		xScale,
		yDelta,
		yDomain,
		yScale,
		yTicks,
		labelsDx,
		selectNearestDot,
		onFrameHovered,
		onFrameExited,
		onFrameTouchStarted,
		onFrameTouchEnded,
		getSortedKeys,
		getMaxValue,
		getMinValue,
		allData,
		allKeys,
		minValue,
		maxValue,
		maxValueSign,
		minValueSign,
		heroCurveValues,
		doHighlightHeroCurve,
		labelsDy,
		style,
		$_size
	});

	$$self.$inject_state = $$props => {
		if ('axesLabels' in $$props) $$invalidate(0, axesLabels = $$props.axesLabels);
		if ('geometry' in $$props) $$invalidate(1, geometry = $$props.geometry);
		if ('hero' in $$props) $$invalidate(4, hero = $$props.hero);
		if ('keyFilterFn' in $$props) $$invalidate(30, keyFilterFn = $$props.keyFilterFn);
		if ('keyFormatFn' in $$props) $$invalidate(26, keyFormatFn = $$props.keyFormatFn);
		if ('keyToColorFn' in $$props) $$invalidate(5, keyToColorFn = $$props.keyToColorFn);
		if ('keyType' in $$props) $$invalidate(31, keyType = $$props.keyType);
		if ('preformatDate' in $$props) $$invalidate(27, preformatDate = $$props.preformatDate);
		if ('theme' in $$props) $$invalidate(28, theme = $$props.theme);
		if ('trends' in $$props) $$invalidate(2, trends = $$props.trends);
		if ('trendType' in $$props) $$invalidate(32, trendType = $$props.trendType);
		if ('valueFormatFn' in $$props) $$invalidate(3, valueFormatFn = $$props.valueFormatFn);
		if ('yTicksCount' in $$props) $$invalidate(29, yTicksCount = $$props.yTicksCount);
		if ('bbox' in $$props) $$invalidate(6, bbox = $$props.bbox);
		if ('doDraw' in $$props) $$invalidate(11, doDraw = $$props.doDraw);
		if ('dotRadius' in $$props) $$invalidate(12, dotRadius = $$props.dotRadius);
		if ('height' in $$props) $$invalidate(7, height = $$props.height);
		if ('keyTicks' in $$props) $$invalidate(13, keyTicks = $$props.keyTicks);
		if ('lineGenerator' in $$props) $$invalidate(14, lineGenerator = $$props.lineGenerator);
		if ('quadTree' in $$props) quadTree = $$props.quadTree;
		if ('width' in $$props) $$invalidate(8, width = $$props.width);
		if ('xScale' in $$props) $$invalidate(9, xScale = $$props.xScale);
		if ('yDelta' in $$props) $$invalidate(33, yDelta = $$props.yDelta);
		if ('yDomain' in $$props) $$invalidate(34, yDomain = $$props.yDomain);
		if ('yScale' in $$props) $$invalidate(10, yScale = $$props.yScale);
		if ('yTicks' in $$props) $$invalidate(15, yTicks = $$props.yTicks);
		if ('allData' in $$props) $$invalidate(35, allData = $$props.allData);
		if ('allKeys' in $$props) $$invalidate(36, allKeys = $$props.allKeys);
		if ('minValue' in $$props) $$invalidate(37, minValue = $$props.minValue);
		if ('maxValue' in $$props) $$invalidate(38, maxValue = $$props.maxValue);
		if ('maxValueSign' in $$props) $$invalidate(39, maxValueSign = $$props.maxValueSign);
		if ('minValueSign' in $$props) $$invalidate(40, minValueSign = $$props.minValueSign);
		if ('heroCurveValues' in $$props) $$invalidate(16, heroCurveValues = $$props.heroCurveValues);
		if ('doHighlightHeroCurve' in $$props) $$invalidate(17, doHighlightHeroCurve = $$props.doHighlightHeroCurve);
		if ('labelsDy' in $$props) $$invalidate(18, labelsDy = $$props.labelsDy);
		if ('style' in $$props) $$invalidate(19, style = $$props.style);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*axesLabels*/ 1) {
			$$invalidate(0, axesLabels = axesLabels ?? []);
		}

		if ($$self.$$.dirty[0] & /*keyFormatFn*/ 67108864) {
			$$invalidate(26, keyFormatFn = keyFormatFn ?? identity);
		}

		if ($$self.$$.dirty[0] & /*preformatDate*/ 134217728) {
			$$invalidate(27, preformatDate = preformatDate ?? identity);
		}

		if ($$self.$$.dirty[0] & /*valueFormatFn*/ 8) {
			$$invalidate(3, valueFormatFn = valueFormatFn ?? identity);
		}

		if ($$self.$$.dirty[0] & /*yTicksCount*/ 536870912) {
			$$invalidate(29, yTicksCount = yTicksCount ?? 10);
		}

		if ($$self.$$.dirty[0] & /*theme*/ 268435456) {
			/* theme */
			$$invalidate(28, theme = theme ? { ...defaultTheme, ...theme } : defaultTheme);
		}

		if ($$self.$$.dirty[0] & /*theme*/ 268435456) {
			$$invalidate(19, style = makeStyleVars(theme));
		}

		if ($$self.$$.dirty[0] & /*geometry*/ 2) {
			$$invalidate(1, geometry = geometry
			? { ...defaultGeometry, ...geometry }
			: defaultGeometry);
		}

		if ($$self.$$.dirty[0] & /*geometry*/ 2) {
			$$invalidate(18, labelsDy = Math.min(geometry.safetyBottom, geometry.safetyTop) / 2);
		}

		if ($$self.$$.dirty[1] & /*$_size*/ 1024) {
			$$invalidate(8, { inlineSize: width, blockSize: height } = $_size, width, ($$invalidate(7, height), $$invalidate(41, $_size)));
		}

		if ($$self.$$.dirty[0] & /*trends*/ 4) {
			/* data */
			$$invalidate(2, trends = trends ?? defaultTrends);
		}

		if ($$self.$$.dirty[0] & /*trends*/ 4 | $$self.$$.dirty[1] & /*trendType*/ 2) {
			if (trendType === 'cumulative') {
				$$invalidate(2, trends = map(trends, ({ key, values }) => {
					const cumulativeValues = reduce(
						values,
						(acc, { key: subKey, value }) => {
							acc.sum += value;
							acc.array.push({ key: subKey, value: acc.sum });
							return acc;
						},
						{ sum: 0, array: [] }
					).array;

					return { key, values: cumulativeValues };
				}));
			}
		}

		if ($$self.$$.dirty[0] & /*trends*/ 4) {
			$$invalidate(2, trends = map(trends, ({ key, values }) => ({
				key,
				values: map(values, setKey('trendKey', key))
			})));
		}

		if ($$self.$$.dirty[0] & /*trends*/ 4) {
			$$invalidate(36, allKeys = getSortedKeys(trends));
		}

		if ($$self.$$.dirty[0] & /*trends*/ 4) {
			$$invalidate(35, allData = flatMap(trends, getValues));
		}

		if ($$self.$$.dirty[1] & /*allData*/ 16) {
			$$invalidate(38, maxValue = getMaxValue(allData));
		}

		if ($$self.$$.dirty[1] & /*maxValue*/ 128) {
			$$invalidate(39, maxValueSign = Math.sign(maxValue));
		}

		if ($$self.$$.dirty[1] & /*allData*/ 16) {
			$$invalidate(37, minValue = getMinValue(allData));
		}

		if ($$self.$$.dirty[1] & /*minValue*/ 64) {
			$$invalidate(40, minValueSign = Math.sign(minValue));
		}

		if ($$self.$$.dirty[0] & /*trends*/ 4) {
			$$invalidate(17, doHighlightHeroCurve = isIterableLongerThan1(trends));
		}

		if ($$self.$$.dirty[0] & /*hero, trends*/ 20) {
			$$invalidate(16, heroCurveValues = hero
			? find(trends, pipe([getKey$1, is(hero.trendKey)]))?.values
			: []);
		}

		if ($$self.$$.dirty[0] & /*yTicksCount*/ 536870912 | $$self.$$.dirty[1] & /*maxValueSign, minValueSign, minValue, maxValue, yDomain, yDelta*/ 972) {
			{
				if (maxValueSign !== minValueSign) {
					$$invalidate(34, yDomain = [minValue, maxValue]);
					$$invalidate(33, yDelta = maxValue - minValue);
				} else if (maxValueSign === 1) {
					$$invalidate(34, yDomain = [0, maxValue]);
					$$invalidate(33, yDelta = maxValue);
				} else {
					$$invalidate(34, yDomain = [minValue, 0]);
					$$invalidate(33, yDelta = -minValue);
				}

				$$invalidate(15, yTicks = inclusiveRange([...yDomain, yDelta / yTicksCount]));
			}
		}

		if ($$self.$$.dirty[0] & /*height, width, geometry, bbox, keyFilterFn, keyFormatFn, xScale, yScale*/ 1140852674 | $$self.$$.dirty[1] & /*keyType, allKeys, yDomain, allData*/ 57) {
			if (height && width) {
				$$invalidate(6, bbox = {
					blx: geometry.safetyLeft,
					bly: height - geometry.safetyBottom,
					height: height - geometry.safetyTop - geometry.safetyBottom,
					trx: width - geometry.safetyRight,
					try: geometry.safetyTop,
					width: width - geometry.safetyRight - geometry.safetyLeft
				});

				const xRange = [bbox.blx, bbox.trx];

				if (keyType === 'date') {
					const keyDomain = [head(allKeys), last(allKeys)];
					const keyRankFn = key => new Date(key).getTime();
					const timeDomain = map(keyDomain, keyRankFn);
					const timeScale = time().domain(timeDomain).range(xRange);
					const ticks = timeScale.ticks();
					const tickDurationInSecs = (timeDomain[1] - timeDomain[0]) / 1000 / (ticks.length - 1);
					const timeFormat = getDateTimeFormat(tickDurationInSecs);
					$$invalidate(13, keyTicks = map(ticks, collect([identity, timeFormat])));
					$$invalidate(9, xScale = pipe([keyRankFn, timeScale]));
				} else {
					$$invalidate(13, keyTicks = map(keyFilterFn ? filter(allKeys, keyFilterFn) : allKeys, collect([identity, keyFormatFn])));
					$$invalidate(9, xScale = point().domain(allKeys).range(xRange));
				}

				$$invalidate(12, dotRadius = allKeys.length === 1
				? geometry.dotRadius
				: Math.min((xScale(allKeys[1]) - xScale(allKeys[0])) / 3, geometry.dotRadius));

				$$invalidate(10, yScale = linear().domain(yDomain).range([bbox.bly, bbox.try]));
				$$invalidate(14, lineGenerator = line().x(d => xScale(getKey$1(d))).y(d => yScale(getValue(d))).curve(monotoneX));
				quadTree = quadtree().x(d => xScale(getKey$1(d))).y(d => yScale(getValue(d))).addAll(allData);
				$$invalidate(11, doDraw = true);
			}
		}
	};

	return [
		axesLabels,
		geometry,
		trends,
		valueFormatFn,
		hero,
		keyToColorFn,
		bbox,
		height,
		width,
		xScale,
		yScale,
		doDraw,
		dotRadius,
		keyTicks,
		lineGenerator,
		yTicks,
		heroCurveValues,
		doHighlightHeroCurve,
		labelsDy,
		style,
		_size,
		sizeObserver,
		onFrameHovered,
		onFrameExited,
		onFrameTouchStarted,
		onFrameTouchEnded,
		keyFormatFn,
		preformatDate,
		theme,
		yTicksCount,
		keyFilterFn,
		keyType,
		trendType,
		yDelta,
		yDomain,
		allData,
		allKeys,
		minValue,
		maxValue,
		maxValueSign,
		minValueSign,
		$_size
	];
}

class Trends extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance,
			create_fragment$1,
			safe_not_equal,
			{
				axesLabels: 0,
				geometry: 1,
				hero: 4,
				keyFilterFn: 30,
				keyFormatFn: 26,
				keyToColorFn: 5,
				keyType: 31,
				preformatDate: 27,
				theme: 28,
				trends: 2,
				trendType: 32,
				valueFormatFn: 3,
				yTicksCount: 29
			},
			null,
			[-1, -1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Trends",
			options,
			id: create_fragment$1.name
		});
	}

	get axesLabels() {
		throw new Error("<Trends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set axesLabels(value) {
		throw new Error("<Trends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get geometry() {
		throw new Error("<Trends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set geometry(value) {
		throw new Error("<Trends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get hero() {
		throw new Error("<Trends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set hero(value) {
		throw new Error("<Trends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get keyFilterFn() {
		throw new Error("<Trends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set keyFilterFn(value) {
		throw new Error("<Trends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get keyFormatFn() {
		throw new Error("<Trends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set keyFormatFn(value) {
		throw new Error("<Trends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get keyToColorFn() {
		throw new Error("<Trends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set keyToColorFn(value) {
		throw new Error("<Trends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get keyType() {
		throw new Error("<Trends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set keyType(value) {
		throw new Error("<Trends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get preformatDate() {
		throw new Error("<Trends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set preformatDate(value) {
		throw new Error("<Trends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get theme() {
		throw new Error("<Trends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set theme(value) {
		throw new Error("<Trends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get trends() {
		throw new Error("<Trends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set trends(value) {
		throw new Error("<Trends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get trendType() {
		throw new Error("<Trends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set trendType(value) {
		throw new Error("<Trends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get valueFormatFn() {
		throw new Error("<Trends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set valueFormatFn(value) {
		throw new Error("<Trends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get yTicksCount() {
		throw new Error("<Trends>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set yTicksCount(value) {
		throw new Error("<Trends>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

var Trends$1 = Trends;

var trends = /*#__PURE__*/Object.freeze({
	__proto__: null,
	PercentilesTrends: PercentilesTrends$1,
	StreamGraph: StreamGraph$1,
	Trends: Trends$1
});

var components = {
	...barchart,
	...choropleth,
	...hierarchy,
	...histogram,
	...legend,
	...trends,
	...ui,
};

/* src/routes/components/[slug].svelte generated by Svelte v3.59.2 */
const file = "src/routes/components/[slug].svelte";

function get_each_context_2(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[22] = list[i].items;
	return child_ctx;
}

function get_each_context_3(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[25] = list[i].componentName;
	child_ctx[26] = list[i].content;
	child_ctx[27] = list[i].elementName;
	child_ctx[28] = list[i].props;
	return child_ctx;
}

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[22] = list[i].items;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[25] = list[i].componentName;
	child_ctx[26] = list[i].content;
	child_ctx[27] = list[i].elementName;
	child_ctx[28] = list[i].props;
	return child_ctx;
}

function get_each_context_4(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[35] = list[i][0];
	child_ctx[36] = list[i][1];
	return child_ctx;
}

function get_each_context_5(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[39] = list[i][0];
	child_ctx[40] = list[i][1];
	return child_ctx;
}

function get_each_context_6(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[39] = list[i].key;
	child_ctx[44] = i;
	return child_ctx;
}

// (74:2) {#if data.length > 1}
function create_if_block_10(ctx) {
	let div1;
	let h2;
	let t0;
	let t1;
	let div0;
	let select;
	let select_size_value;
	let mounted;
	let dispose;
	let each_value_6 = /*data*/ ctx[0];
	validate_each_argument(each_value_6);
	let each_blocks = [];

	for (let i = 0; i < each_value_6.length; i += 1) {
		each_blocks[i] = create_each_block_6(get_each_context_6(ctx, each_value_6, i));
	}

	const block = {
		c: function create() {
			div1 = element("div");
			h2 = element("h2");
			t0 = text("Choose an example");
			t1 = space();
			div0 = element("div");
			select = element("select");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			h2 = claim_element(div1_nodes, "H2", {});
			var h2_nodes = children(h2);
			t0 = claim_text(h2_nodes, "Choose an example");
			h2_nodes.forEach(detach_dev);
			t1 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			select = claim_element(div0_nodes, "SELECT", { size: true, class: true });
			var select_nodes = children(select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(select_nodes);
			}

			select_nodes.forEach(detach_dev);
			div0_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h2, file, 75, 4, 1717);
			attr_dev(select, "size", select_size_value = /*data*/ ctx[0].length);
			attr_dev(select, "class", "svelte-u3jyjr");
			add_location(select, file, 77, 5, 1777);
			attr_dev(div0, "class", "distancer svelte-u3jyjr");
			add_location(div0, file, 76, 4, 1748);
			attr_dev(div1, "class", "distancer svelte-u3jyjr");
			add_location(div1, file, 74, 3, 1689);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div1, anchor);
			append_hydration_dev(div1, h2);
			append_hydration_dev(h2, t0);
			append_hydration_dev(div1, t1);
			append_hydration_dev(div1, div0);
			append_hydration_dev(div0, select);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(select, null);
				}
			}

			if (!mounted) {
				dispose = listen_dev(select, "change", /*change_handler*/ ctx[16], false, false, false, false);
				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*selected, data*/ 65) {
				each_value_6 = /*data*/ ctx[0];
				validate_each_argument(each_value_6);
				let i;

				for (i = 0; i < each_value_6.length; i += 1) {
					const child_ctx = get_each_context_6(ctx, each_value_6, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_6(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(select, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_6.length;
			}

			if (dirty[0] & /*data*/ 1 && select_size_value !== (select_size_value = /*data*/ ctx[0].length)) {
				attr_dev(select, "size", select_size_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			destroy_each(each_blocks, detaching);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_10.name,
		type: "if",
		source: "(74:2) {#if data.length > 1}",
		ctx
	});

	return block;
}

// (82:6) {#each data as {key}
function create_each_block_6(ctx) {
	let option;
	let t_value = /*key*/ ctx[39] + "";
	let t;
	let option_selected_value;

	const block = {
		c: function create() {
			option = element("option");
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			option = claim_element(nodes, "OPTION", { class: true });
			var option_nodes = children(option);
			t = claim_text(option_nodes, t_value);
			option_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			option.__value = /*index*/ ctx[44];
			option.value = option.__value;
			option.selected = option_selected_value = /*index*/ ctx[44] === /*selected*/ ctx[6];
			attr_dev(option, "class", "svelte-u3jyjr");
			add_location(option, file, 82, 7, 1926);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, option, anchor);
			append_hydration_dev(option, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*data*/ 1 && t_value !== (t_value = /*key*/ ctx[39] + "")) set_data_dev(t, t_value);

			if (dirty[0] & /*selected*/ 64 && option_selected_value !== (option_selected_value = /*index*/ ctx[44] === /*selected*/ ctx[6])) {
				prop_dev(option, "selected", option_selected_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(option);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_6.name,
		type: "each",
		source: "(82:6) {#each data as {key}",
		ctx
	});

	return block;
}

// (94:2) {#if payloads}
function create_if_block_9(ctx) {
	let h2;
	let t0;
	let t1;
	let div;
	let each_value_5 = pairs$1(/*payloads*/ ctx[9]);
	validate_each_argument(each_value_5);
	let each_blocks = [];

	for (let i = 0; i < each_value_5.length; i += 1) {
		each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
	}

	const block = {
		c: function create() {
			h2 = element("h2");
			t0 = text("Events");
			t1 = space();
			div = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			this.h();
		},
		l: function claim(nodes) {
			h2 = claim_element(nodes, "H2", {});
			var h2_nodes = children(h2);
			t0 = claim_text(h2_nodes, "Events");
			h2_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div_nodes);
			}

			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h2, file, 94, 3, 2114);
			attr_dev(div, "class", "distancer svelte-u3jyjr");
			add_location(div, file, 95, 3, 2133);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, h2, anchor);
			append_hydration_dev(h2, t0);
			insert_hydration_dev(target, t1, anchor);
			insert_hydration_dev(target, div, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div, null);
				}
			}
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*payloads*/ 512) {
				each_value_5 = pairs$1(/*payloads*/ ctx[9]);
				validate_each_argument(each_value_5);
				let i;

				for (i = 0; i < each_value_5.length; i += 1) {
					const child_ctx = get_each_context_5(ctx, each_value_5, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_5(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_5.length;
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h2);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div);
			destroy_each(each_blocks, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_9.name,
		type: "if",
		source: "(94:2) {#if payloads}",
		ctx
	});

	return block;
}

// (97:4) {#each _.pairs(payloads) as [key, value]}
function create_each_block_5(ctx) {
	let div;
	let span;
	let t0_value = /*key*/ ctx[39] + "";
	let t0;
	let t1;
	let pre;
	let t2_value = (/*value*/ ctx[40] || '[payload]') + "";
	let t2;
	let t3;

	const block = {
		c: function create() {
			div = element("div");
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			pre = element("pre");
			t2 = text(t2_value);
			t3 = space();
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			span = claim_element(div_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, t0_value);
			span_nodes.forEach(detach_dev);
			t1 = claim_space(div_nodes);
			pre = claim_element(div_nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t2 = claim_text(pre_nodes, t2_value);
			pre_nodes.forEach(detach_dev);
			t3 = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "svelte-u3jyjr");
			add_location(span, file, 98, 6, 2232);
			attr_dev(pre, "class", "svelte-u3jyjr");
			add_location(pre, file, 99, 6, 2257);
			attr_dev(div, "class", "row svelte-u3jyjr");
			add_location(div, file, 97, 5, 2208);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, span);
			append_hydration_dev(span, t0);
			append_hydration_dev(div, t1);
			append_hydration_dev(div, pre);
			append_hydration_dev(pre, t2);
			append_hydration_dev(div, t3);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*payloads*/ 512 && t0_value !== (t0_value = /*key*/ ctx[39] + "")) set_data_dev(t0, t0_value);
			if (dirty[0] & /*payloads*/ 512 && t2_value !== (t2_value = (/*value*/ ctx[40] || '[payload]') + "")) set_data_dev(t2, t2_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_5.name,
		type: "each",
		source: "(97:4) {#each _.pairs(payloads) as [key, value]}",
		ctx
	});

	return block;
}

// (115:3) {#each displayProps as [propName, propValue]}
function create_each_block_4(ctx) {
	let h3;
	let code;
	let t0_value = /*propName*/ ctx[35] + "";
	let t0;
	let t1;
	let div;
	let jsontree;
	let t2;
	let current;

	jsontree = new Root({
			props: { value: /*propValue*/ ctx[36] },
			$$inline: true
		});

	const block = {
		c: function create() {
			h3 = element("h3");
			code = element("code");
			t0 = text(t0_value);
			t1 = space();
			div = element("div");
			create_component(jsontree.$$.fragment);
			t2 = space();
			this.h();
		},
		l: function claim(nodes) {
			h3 = claim_element(nodes, "H3", {});
			var h3_nodes = children(h3);
			code = claim_element(h3_nodes, "CODE", {});
			var code_nodes = children(code);
			t0 = claim_text(code_nodes, t0_value);
			code_nodes.forEach(detach_dev);
			h3_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			claim_component(jsontree.$$.fragment, div_nodes);
			t2 = claim_space(div_nodes);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(code, file, 115, 8, 2557);
			add_location(h3, file, 115, 4, 2553);
			attr_dev(div, "class", "distancer svelte-u3jyjr");
			add_location(div, file, 116, 4, 2590);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, h3, anchor);
			append_hydration_dev(h3, code);
			append_hydration_dev(code, t0);
			insert_hydration_dev(target, t1, anchor);
			insert_hydration_dev(target, div, anchor);
			mount_component(jsontree, div, null);
			append_hydration_dev(div, t2);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*displayProps*/ 1024) && t0_value !== (t0_value = /*propName*/ ctx[35] + "")) set_data_dev(t0, t0_value);
			const jsontree_changes = {};
			if (dirty[0] & /*displayProps*/ 1024) jsontree_changes.value = /*propValue*/ ctx[36];
			jsontree.$set(jsontree_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(jsontree.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(jsontree.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(h3);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(div);
			destroy_component(jsontree);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_4.name,
		type: "each",
		source: "(115:3) {#each displayProps as [propName, propValue]}",
		ctx
	});

	return block;
}

// (160:2) {:else}
function create_else_block(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*currentData*/ ctx[5].props];
	var switch_value = /*component*/ ctx[11];

	function switch_props(ctx) {
		let switch_instance_props = {
			$$slots: { default: [create_default_slot_2] },
			$$scope: { ctx }
		};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
		/*switch_instance_binding_1*/ ctx[19](switch_instance);
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l: function claim(nodes) {
			if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) mount_component(switch_instance, target, anchor);
			insert_hydration_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = (dirty[0] & /*currentData*/ 32)
			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*currentData*/ ctx[5].props)])
			: {};

			if (dirty[0] & /*currentData*/ 32 | dirty[1] & /*$$scope*/ 16384) {
				switch_instance_changes.$$scope = { dirty, ctx };
			}

			if (dirty[0] & /*component*/ 2048 && switch_value !== (switch_value = /*component*/ ctx[11])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
					/*switch_instance_binding_1*/ ctx[19](switch_instance);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			/*switch_instance_binding_1*/ ctx[19](null);
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(160:2) {:else}",
		ctx
	});

	return block;
}

// (126:2) {#if isSVG}
function create_if_block(ctx) {
	let div;
	let svg;
	let switch_instance;
	let div_resize_listener;
	let current;

	const switch_instance_spread_levels = [
		{
			.../*currentData*/ ctx[5].props,
			width: /*width*/ ctx[7],
			height: /*height*/ ctx[8]
		}
	];

	var switch_value = /*component*/ ctx[11];

	function switch_props(ctx) {
		let switch_instance_props = {
			$$slots: { default: [create_default_slot] },
			$$scope: { ctx }
		};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
		/*switch_instance_binding*/ ctx[17](switch_instance);
	}

	const block = {
		c: function create() {
			div = element("div");
			svg = svg_element("svg");
			if (switch_instance) create_component(switch_instance.$$.fragment);
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { class: true });
			var div_nodes = children(div);
			svg = claim_svg_element(div_nodes, "svg", { width: true, height: true, class: true });
			var svg_nodes = children(svg);
			if (switch_instance) claim_component(switch_instance.$$.fragment, svg_nodes);
			svg_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(svg, "width", /*width*/ ctx[7]);
			attr_dev(svg, "height", /*height*/ ctx[8]);
			attr_dev(svg, "class", "svelte-u3jyjr");
			add_location(svg, file, 130, 4, 2829);
			attr_dev(div, "class", "svgwrapper svelte-u3jyjr");
			add_render_callback(() => /*div_elementresize_handler*/ ctx[18].call(div));
			add_location(div, file, 126, 3, 2732);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, svg);
			if (switch_instance) mount_component(switch_instance, svg, null);
			div_resize_listener = add_iframe_resize_listener(div, /*div_elementresize_handler*/ ctx[18].bind(div));
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = (dirty[0] & /*currentData, width, height*/ 416)
			? get_spread_update(switch_instance_spread_levels, [
					{
						.../*currentData*/ ctx[5].props,
						width: /*width*/ ctx[7],
						height: /*height*/ ctx[8]
					}
				])
			: {};

			if (dirty[0] & /*currentData*/ 32 | dirty[1] & /*$$scope*/ 16384) {
				switch_instance_changes.$$scope = { dirty, ctx };
			}

			if (dirty[0] & /*component*/ 2048 && switch_value !== (switch_value = /*component*/ ctx[11])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
					/*switch_instance_binding*/ ctx[17](switch_instance);
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, svg, null);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}

			if (!current || dirty[0] & /*width*/ 128) {
				attr_dev(svg, "width", /*width*/ ctx[7]);
			}

			if (!current || dirty[0] & /*height*/ 256) {
				attr_dev(svg, "height", /*height*/ ctx[8]);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			/*switch_instance_binding*/ ctx[17](null);
			if (switch_instance) destroy_component(switch_instance);
			div_resize_listener();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(126:2) {#if isSVG}",
		ctx
	});

	return block;
}

// (168:32) 
function create_if_block_6(ctx) {
	let each_1_anchor;
	let current;
	let each_value_2 = /*currentData*/ ctx[5].slots;
	validate_each_argument(each_value_2);
	let each_blocks = [];

	for (let i = 0; i < each_value_2.length; i += 1) {
		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert_hydration_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*currentData*/ 32) {
				each_value_2 = /*currentData*/ ctx[5].slots;
				validate_each_argument(each_value_2);
				let i;

				for (i = 0; i < each_value_2.length; i += 1) {
					const child_ctx = get_each_context_2(ctx, each_value_2, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_2(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value_2.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_2.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_6.name,
		type: "if",
		source: "(168:32) ",
		ctx
	});

	return block;
}

// (166:4) {#if currentData.content}
function create_if_block_5(ctx) {
	let t_value = /*currentData*/ ctx[5].content + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*currentData*/ 32 && t_value !== (t_value = /*currentData*/ ctx[5].content + "")) set_data_dev(t, t_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_5.name,
		type: "if",
		source: "(166:4) {#if currentData.content}",
		ctx
	});

	return block;
}

// (177:31) 
function create_if_block_8(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*props*/ ctx[28]];
	var switch_value = components[/*componentName*/ ctx[25]];

	function switch_props(ctx) {
		let switch_instance_props = {
			$$slots: { default: [create_default_slot_3] },
			$$scope: { ctx }
		};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l: function claim(nodes) {
			if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) mount_component(switch_instance, target, anchor);
			insert_hydration_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = (dirty[0] & /*currentData*/ 32)
			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*props*/ ctx[28])])
			: {};

			if (dirty[0] & /*currentData*/ 32 | dirty[1] & /*$$scope*/ 16384) {
				switch_instance_changes.$$scope = { dirty, ctx };
			}

			if (dirty[0] & /*currentData*/ 32 && switch_value !== (switch_value = components[/*componentName*/ ctx[25]])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_8.name,
		type: "if",
		source: "(177:31) ",
		ctx
	});

	return block;
}

// (172:7) {#if elementName}
function create_if_block_7(ctx) {
	let previous_tag = /*elementName*/ ctx[27];
	let svelte_element_anchor;
	validate_dynamic_element(/*elementName*/ ctx[27]);
	validate_void_dynamic_element(/*elementName*/ ctx[27]);
	let svelte_element = /*elementName*/ ctx[27] && create_dynamic_element_1(ctx);

	const block = {
		c: function create() {
			if (svelte_element) svelte_element.c();
			svelte_element_anchor = empty();
		},
		l: function claim(nodes) {
			if (svelte_element) svelte_element.l(nodes);
			svelte_element_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (svelte_element) svelte_element.m(target, anchor);
			insert_hydration_dev(target, svelte_element_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (/*elementName*/ ctx[27]) {
				if (!previous_tag) {
					svelte_element = create_dynamic_element_1(ctx);
					previous_tag = /*elementName*/ ctx[27];
					svelte_element.c();
					svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
				} else if (safe_not_equal(previous_tag, /*elementName*/ ctx[27])) {
					svelte_element.d(1);
					validate_dynamic_element(/*elementName*/ ctx[27]);
					validate_void_dynamic_element(/*elementName*/ ctx[27]);
					svelte_element = create_dynamic_element_1(ctx);
					previous_tag = /*elementName*/ ctx[27];
					svelte_element.c();
					svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
				} else {
					svelte_element.p(ctx, dirty);
				}
			} else if (previous_tag) {
				svelte_element.d(1);
				svelte_element = null;
				previous_tag = /*elementName*/ ctx[27];
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svelte_element_anchor);
			if (svelte_element) svelte_element.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_7.name,
		type: "if",
		source: "(172:7) {#if elementName}",
		ctx
	});

	return block;
}

// (178:8) <svelte:component          {...props}          this={components[componentName]}         >
function create_default_slot_3(ctx) {
	let t_value = /*content*/ ctx[26] + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*currentData*/ 32 && t_value !== (t_value = /*content*/ ctx[26] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_3.name,
		type: "slot",
		source: "(178:8) <svelte:component          {...props}          this={components[componentName]}         >",
		ctx
	});

	return block;
}

// (173:8) <svelte:element          {...props}          this={elementName}         >
function create_dynamic_element_1(ctx) {
	let svelte_element;
	let t_value = /*content*/ ctx[26] + "";
	let t;
	let svelte_element_levels = [/*props*/ ctx[28]];
	let svelte_element_data = {};

	for (let i = 0; i < svelte_element_levels.length; i += 1) {
		svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
	}

	const block = {
		c: function create() {
			svelte_element = element(/*elementName*/ ctx[27]);
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			svelte_element = claim_element(nodes, (/*elementName*/ ctx[27] || 'null').toUpperCase(), {});
			var svelte_element_nodes = children(svelte_element);
			t = claim_text(svelte_element_nodes, t_value);
			svelte_element_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_dynamic_element_data(/*elementName*/ ctx[27])(svelte_element, svelte_element_data);
			toggle_class(svelte_element, "svelte-u3jyjr", true);
			add_location(svelte_element, file, 172, 8, 4098);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, svelte_element, anchor);
			append_hydration_dev(svelte_element, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*currentData*/ 32 && t_value !== (t_value = /*content*/ ctx[26] + "")) set_data_maybe_contenteditable_dev(t, t_value, svelte_element_data['contenteditable']);
			set_dynamic_element_data(/*elementName*/ ctx[27])(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [dirty[0] & /*currentData*/ 32 && /*props*/ ctx[28]]));
			toggle_class(svelte_element, "svelte-u3jyjr", true);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svelte_element);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_dynamic_element_1.name,
		type: "child_dynamic_element",
		source: "(173:8) <svelte:element          {...props}          this={elementName}         >",
		ctx
	});

	return block;
}

// (171:6) {#each items as {componentName, content, elementName, props}}
function create_each_block_3(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_7, create_if_block_8];
	const if_blocks = [];

	function select_block_type_4(ctx, dirty) {
		if (/*elementName*/ ctx[27]) return 0;
		if (/*componentName*/ ctx[25]) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_4(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_hydration_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_4(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_3.name,
		type: "each",
		source: "(171:6) {#each items as {componentName, content, elementName, props}}",
		ctx
	});

	return block;
}

// (169:5) {#each currentData.slots as {items}}
function create_each_block_2(ctx) {
	let each_1_anchor;
	let current;
	let each_value_3 = /*items*/ ctx[22];
	validate_each_argument(each_value_3);
	let each_blocks = [];

	for (let i = 0; i < each_value_3.length; i += 1) {
		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert_hydration_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*currentData*/ 32) {
				each_value_3 = /*items*/ ctx[22];
				validate_each_argument(each_value_3);
				let i;

				for (i = 0; i < each_value_3.length; i += 1) {
					const child_ctx = get_each_context_3(ctx, each_value_3, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_3(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value_3.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_3.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_2.name,
		type: "each",
		source: "(169:5) {#each currentData.slots as {items}}",
		ctx
	});

	return block;
}

// (161:3) <svelte:component     {...currentData.props}     bind:this={instance}     this={component}    >
function create_default_slot_2(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_5, create_if_block_6];
	const if_blocks = [];

	function select_block_type_3(ctx, dirty) {
		if (/*currentData*/ ctx[5].content) return 0;
		if (/*currentData*/ ctx[5].slots) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_3(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_hydration_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_3(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_2.name,
		type: "slot",
		source: "(161:3) <svelte:component     {...currentData.props}     bind:this={instance}     this={component}    >",
		ctx
	});

	return block;
}

// (139:34) 
function create_if_block_2(ctx) {
	let each_1_anchor;
	let current;
	let each_value = /*currentData*/ ctx[5].slots;
	validate_each_argument(each_value);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert_hydration_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*currentData*/ 32) {
				each_value = /*currentData*/ ctx[5].slots;
				validate_each_argument(each_value);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_2.name,
		type: "if",
		source: "(139:34) ",
		ctx
	});

	return block;
}

// (137:6) {#if currentData.content}
function create_if_block_1(ctx) {
	let t_value = /*currentData*/ ctx[5].content + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*currentData*/ 32 && t_value !== (t_value = /*currentData*/ ctx[5].content + "")) set_data_dev(t, t_value);
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_1.name,
		type: "if",
		source: "(137:6) {#if currentData.content}",
		ctx
	});

	return block;
}

// (148:33) 
function create_if_block_4(ctx) {
	let switch_instance;
	let switch_instance_anchor;
	let current;
	const switch_instance_spread_levels = [/*props*/ ctx[28]];
	var switch_value = components[/*componentName*/ ctx[25]];

	function switch_props(ctx) {
		let switch_instance_props = {
			$$slots: { default: [create_default_slot_1] },
			$$scope: { ctx }
		};

		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
		}

		return {
			props: switch_instance_props,
			$$inline: true
		};
	}

	if (switch_value) {
		switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
	}

	const block = {
		c: function create() {
			if (switch_instance) create_component(switch_instance.$$.fragment);
			switch_instance_anchor = empty();
		},
		l: function claim(nodes) {
			if (switch_instance) claim_component(switch_instance.$$.fragment, nodes);
			switch_instance_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (switch_instance) mount_component(switch_instance, target, anchor);
			insert_hydration_dev(target, switch_instance_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			const switch_instance_changes = (dirty[0] & /*currentData*/ 32)
			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*props*/ ctx[28])])
			: {};

			if (dirty[0] & /*currentData*/ 32 | dirty[1] & /*$$scope*/ 16384) {
				switch_instance_changes.$$scope = { dirty, ctx };
			}

			if (dirty[0] & /*currentData*/ 32 && switch_value !== (switch_value = components[/*componentName*/ ctx[25]])) {
				if (switch_instance) {
					group_outros();
					const old_component = switch_instance;

					transition_out(old_component.$$.fragment, 1, 0, () => {
						destroy_component(old_component, 1);
					});

					check_outros();
				}

				if (switch_value) {
					switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
					create_component(switch_instance.$$.fragment);
					transition_in(switch_instance.$$.fragment, 1);
					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
				} else {
					switch_instance = null;
				}
			} else if (switch_value) {
				switch_instance.$set(switch_instance_changes);
			}
		},
		i: function intro(local) {
			if (current) return;
			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(switch_instance_anchor);
			if (switch_instance) destroy_component(switch_instance, detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_4.name,
		type: "if",
		source: "(148:33) ",
		ctx
	});

	return block;
}

// (143:9) {#if elementName}
function create_if_block_3(ctx) {
	let previous_tag = /*elementName*/ ctx[27];
	let svelte_element_anchor;
	validate_dynamic_element(/*elementName*/ ctx[27]);
	validate_void_dynamic_element(/*elementName*/ ctx[27]);
	let svelte_element = /*elementName*/ ctx[27] && create_dynamic_element(ctx);

	const block = {
		c: function create() {
			if (svelte_element) svelte_element.c();
			svelte_element_anchor = empty();
		},
		l: function claim(nodes) {
			if (svelte_element) svelte_element.l(nodes);
			svelte_element_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (svelte_element) svelte_element.m(target, anchor);
			insert_hydration_dev(target, svelte_element_anchor, anchor);
		},
		p: function update(ctx, dirty) {
			if (/*elementName*/ ctx[27]) {
				if (!previous_tag) {
					svelte_element = create_dynamic_element(ctx);
					previous_tag = /*elementName*/ ctx[27];
					svelte_element.c();
					svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
				} else if (safe_not_equal(previous_tag, /*elementName*/ ctx[27])) {
					svelte_element.d(1);
					validate_dynamic_element(/*elementName*/ ctx[27]);
					validate_void_dynamic_element(/*elementName*/ ctx[27]);
					svelte_element = create_dynamic_element(ctx);
					previous_tag = /*elementName*/ ctx[27];
					svelte_element.c();
					svelte_element.m(svelte_element_anchor.parentNode, svelte_element_anchor);
				} else {
					svelte_element.p(ctx, dirty);
				}
			} else if (previous_tag) {
				svelte_element.d(1);
				svelte_element = null;
				previous_tag = /*elementName*/ ctx[27];
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(svelte_element_anchor);
			if (svelte_element) svelte_element.d(detaching);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block_3.name,
		type: "if",
		source: "(143:9) {#if elementName}",
		ctx
	});

	return block;
}

// (149:10) <svelte:component            {...props}            this={components[componentName]}           >
function create_default_slot_1(ctx) {
	let t_value = /*content*/ ctx[26] + "";
	let t;

	const block = {
		c: function create() {
			t = text(t_value);
		},
		l: function claim(nodes) {
			t = claim_text(nodes, t_value);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*currentData*/ 32 && t_value !== (t_value = /*content*/ ctx[26] + "")) set_data_dev(t, t_value);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot_1.name,
		type: "slot",
		source: "(149:10) <svelte:component            {...props}            this={components[componentName]}           >",
		ctx
	});

	return block;
}

// (144:10) <svelte:element            {...props}            this={elementName}           >
function create_dynamic_element(ctx) {
	let svelte_element;
	let t_value = /*content*/ ctx[26] + "";
	let t;
	let svelte_element_levels = [/*props*/ ctx[28]];
	let svelte_element_data = {};

	for (let i = 0; i < svelte_element_levels.length; i += 1) {
		svelte_element_data = assign(svelte_element_data, svelte_element_levels[i]);
	}

	const block = {
		c: function create() {
			svelte_element = svg_element(/*elementName*/ ctx[27]);
			t = text(t_value);
			this.h();
		},
		l: function claim(nodes) {
			svelte_element = claim_svg_element(nodes, /*elementName*/ ctx[27], {});
			var svelte_element_nodes = children(svelte_element);
			t = claim_text(svelte_element_nodes, t_value);
			svelte_element_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			set_svg_attributes(svelte_element, svelte_element_data);
			toggle_class(svelte_element, "svelte-u3jyjr", true);
			add_location(svelte_element, file, 143, 10, 3304);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, svelte_element, anchor);
			append_hydration_dev(svelte_element, t);
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*currentData*/ 32 && t_value !== (t_value = /*content*/ ctx[26] + "")) set_data_maybe_contenteditable_dev(t, t_value, svelte_element_data['contenteditable']);
			set_svg_attributes(svelte_element, svelte_element_data = get_spread_update(svelte_element_levels, [dirty[0] & /*currentData*/ 32 && /*props*/ ctx[28]]));
			toggle_class(svelte_element, "svelte-u3jyjr", true);
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(svelte_element);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_dynamic_element.name,
		type: "child_dynamic_element",
		source: "(144:10) <svelte:element            {...props}            this={elementName}           >",
		ctx
	});

	return block;
}

// (142:8) {#each items as {componentName, content, elementName, props}}
function create_each_block_1(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_3, create_if_block_4];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*elementName*/ ctx[27]) return 0;
		if (/*componentName*/ ctx[25]) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_2(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_hydration_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block_1.name,
		type: "each",
		source: "(142:8) {#each items as {componentName, content, elementName, props}}",
		ctx
	});

	return block;
}

// (140:7) {#each currentData.slots as {items}}
function create_each_block(ctx) {
	let each_1_anchor;
	let current;
	let each_value_1 = /*items*/ ctx[22];
	validate_each_argument(each_value_1);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const block = {
		c: function create() {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			each_1_anchor = empty();
		},
		l: function claim(nodes) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(nodes);
			}

			each_1_anchor = empty();
		},
		m: function mount(target, anchor) {
			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(target, anchor);
				}
			}

			insert_hydration_dev(target, each_1_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			if (dirty[0] & /*currentData*/ 32) {
				each_value_1 = /*items*/ ctx[22];
				validate_each_argument(each_value_1);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
					}
				}

				group_outros();

				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}
		},
		i: function intro(local) {
			if (current) return;

			for (let i = 0; i < each_value_1.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			current = true;
		},
		o: function outro(local) {
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			current = false;
		},
		d: function destroy(detaching) {
			destroy_each(each_blocks, detaching);
			if (detaching) detach_dev(each_1_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_each_block.name,
		type: "each",
		source: "(140:7) {#each currentData.slots as {items}}",
		ctx
	});

	return block;
}

// (132:5) <svelte:component       bind:this={instance}       this={component}       {...{...currentData.props, width, height}}      >
function create_default_slot(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_1, create_if_block_2];
	const if_blocks = [];

	function select_block_type_1(ctx, dirty) {
		if (/*currentData*/ ctx[5].content) return 0;
		if (/*currentData*/ ctx[5].slots) return 1;
		return -1;
	}

	if (~(current_block_type_index = select_block_type_1(ctx))) {
		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
	}

	const block = {
		c: function create() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		l: function claim(nodes) {
			if (if_block) if_block.l(nodes);
			if_block_anchor = empty();
		},
		m: function mount(target, anchor) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].m(target, anchor);
			}

			insert_hydration_dev(target, if_block_anchor, anchor);
			current = true;
		},
		p: function update(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_1(ctx);

			if (current_block_type_index === previous_block_index) {
				if (~current_block_type_index) {
					if_blocks[current_block_type_index].p(ctx, dirty);
				}
			} else {
				if (if_block) {
					group_outros();

					transition_out(if_blocks[previous_block_index], 1, 1, () => {
						if_blocks[previous_block_index] = null;
					});

					check_outros();
				}

				if (~current_block_type_index) {
					if_block = if_blocks[current_block_type_index];

					if (!if_block) {
						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
						if_block.c();
					} else {
						if_block.p(ctx, dirty);
					}

					transition_in(if_block, 1);
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				} else {
					if_block = null;
				}
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o: function outro(local) {
			transition_out(if_block);
			current = false;
		},
		d: function destroy(detaching) {
			if (~current_block_type_index) {
				if_blocks[current_block_type_index].d(detaching);
			}

			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_default_slot.name,
		type: "slot",
		source: "(132:5) <svelte:component       bind:this={instance}       this={component}       {...{...currentData.props, width, height}}      >",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let title_value;
	let t0;
	let main;
	let h1;
	let t1;
	let t2;
	let div3;
	let div0;
	let elements;
	let t3;
	let t4;
	let t5;
	let div1;
	let h20;
	let t6;
	let t7;
	let pre;
	let t8_value = /*currentData*/ ctx[5].usage + "";
	let t8;
	let t9;
	let div2;
	let h21;
	let t10;
	let t11;
	let t12;
	let div4;
	let current_block_type_index;
	let if_block2;
	let current;
	document.title = title_value = "" + (/*name*/ ctx[2] + ": " + /*title*/ ctx[3] + " - Svizzle");

	elements = new Elements({
			props: { elements: /*doc*/ ctx[1] },
			$$inline: true
		});

	let if_block0 = /*data*/ ctx[0].length > 1 && create_if_block_10(ctx);
	let if_block1 = /*payloads*/ ctx[9] && create_if_block_9(ctx);
	let each_value_4 = /*displayProps*/ ctx[10];
	validate_each_argument(each_value_4);
	let each_blocks = [];

	for (let i = 0; i < each_value_4.length; i += 1) {
		each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
	}

	const out = i => transition_out(each_blocks[i], 1, 1, () => {
		each_blocks[i] = null;
	});

	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*isSVG*/ ctx[12]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	const block = {
		c: function create() {
			t0 = space();
			main = element("main");
			h1 = element("h1");
			t1 = text(/*title*/ ctx[3]);
			t2 = space();
			div3 = element("div");
			div0 = element("div");
			create_component(elements.$$.fragment);
			t3 = space();
			if (if_block0) if_block0.c();
			t4 = space();
			if (if_block1) if_block1.c();
			t5 = space();
			div1 = element("div");
			h20 = element("h2");
			t6 = text("Usage");
			t7 = space();
			pre = element("pre");
			t8 = text(t8_value);
			t9 = space();
			div2 = element("div");
			h21 = element("h2");
			t10 = text("Props");
			t11 = space();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t12 = space();
			div4 = element("div");
			if_block2.c();
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = head_selector('svelte-1sqseen', document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			main = claim_element(nodes, "MAIN", { class: true });
			var main_nodes = children(main);
			h1 = claim_element(main_nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t1 = claim_text(h1_nodes, /*title*/ ctx[3]);
			h1_nodes.forEach(detach_dev);
			t2 = claim_space(main_nodes);
			div3 = claim_element(main_nodes, "DIV", { class: true });
			var div3_nodes = children(div3);
			div0 = claim_element(div3_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			claim_component(elements.$$.fragment, div0_nodes);
			div0_nodes.forEach(detach_dev);
			t3 = claim_space(div3_nodes);
			if (if_block0) if_block0.l(div3_nodes);
			t4 = claim_space(div3_nodes);
			if (if_block1) if_block1.l(div3_nodes);
			t5 = claim_space(div3_nodes);
			div1 = claim_element(div3_nodes, "DIV", { class: true });
			var div1_nodes = children(div1);
			h20 = claim_element(div1_nodes, "H2", {});
			var h20_nodes = children(h20);
			t6 = claim_text(h20_nodes, "Usage");
			h20_nodes.forEach(detach_dev);
			t7 = claim_space(div1_nodes);
			pre = claim_element(div1_nodes, "PRE", { class: true });
			var pre_nodes = children(pre);
			t8 = claim_text(pre_nodes, t8_value);
			pre_nodes.forEach(detach_dev);
			div1_nodes.forEach(detach_dev);
			t9 = claim_space(div3_nodes);
			div2 = claim_element(div3_nodes, "DIV", { class: true });
			var div2_nodes = children(div2);
			h21 = claim_element(div2_nodes, "H2", {});
			var h21_nodes = children(h21);
			t10 = claim_text(h21_nodes, "Props");
			h21_nodes.forEach(detach_dev);
			t11 = claim_space(div2_nodes);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].l(div2_nodes);
			}

			div2_nodes.forEach(detach_dev);
			div3_nodes.forEach(detach_dev);
			t12 = claim_space(main_nodes);
			div4 = claim_element(main_nodes, "DIV", { class: true });
			var div4_nodes = children(div4);
			if_block2.l(div4_nodes);
			div4_nodes.forEach(detach_dev);
			main_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(h1, "class", "svelte-u3jyjr");
			add_location(h1, file, 64, 1, 1520);
			attr_dev(div0, "class", "distancer svelte-u3jyjr");
			add_location(div0, file, 68, 2, 1579);
			add_location(h20, file, 107, 3, 2380);
			attr_dev(pre, "class", "svelte-u3jyjr");
			add_location(pre, file, 108, 3, 2398);
			attr_dev(div1, "class", "distancer svelte-u3jyjr");
			add_location(div1, file, 106, 2, 2353);
			add_location(h21, file, 113, 3, 2485);
			attr_dev(div2, "class", "distancer svelte-u3jyjr");
			add_location(div2, file, 112, 2, 2458);
			attr_dev(div3, "class", "col col1 svelte-u3jyjr");
			add_location(div3, file, 65, 1, 1538);
			attr_dev(div4, "class", "col col2 svelte-u3jyjr");
			add_location(div4, file, 124, 1, 2692);
			attr_dev(main, "class", "svelte-u3jyjr");
			add_location(main, file, 63, 0, 1512);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t0, anchor);
			insert_hydration_dev(target, main, anchor);
			append_hydration_dev(main, h1);
			append_hydration_dev(h1, t1);
			append_hydration_dev(main, t2);
			append_hydration_dev(main, div3);
			append_hydration_dev(div3, div0);
			mount_component(elements, div0, null);
			append_hydration_dev(div3, t3);
			if (if_block0) if_block0.m(div3, null);
			append_hydration_dev(div3, t4);
			if (if_block1) if_block1.m(div3, null);
			append_hydration_dev(div3, t5);
			append_hydration_dev(div3, div1);
			append_hydration_dev(div1, h20);
			append_hydration_dev(h20, t6);
			append_hydration_dev(div1, t7);
			append_hydration_dev(div1, pre);
			append_hydration_dev(pre, t8);
			append_hydration_dev(div3, t9);
			append_hydration_dev(div3, div2);
			append_hydration_dev(div2, h21);
			append_hydration_dev(h21, t10);
			append_hydration_dev(div2, t11);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div2, null);
				}
			}

			append_hydration_dev(main, t12);
			append_hydration_dev(main, div4);
			if_blocks[current_block_type_index].m(div4, null);
			current = true;
		},
		p: function update(ctx, dirty) {
			if ((!current || dirty[0] & /*name, title*/ 12) && title_value !== (title_value = "" + (/*name*/ ctx[2] + ": " + /*title*/ ctx[3] + " - Svizzle"))) {
				document.title = title_value;
			}

			if (!current || dirty[0] & /*title*/ 8) set_data_dev(t1, /*title*/ ctx[3]);
			const elements_changes = {};
			if (dirty[0] & /*doc*/ 2) elements_changes.elements = /*doc*/ ctx[1];
			elements.$set(elements_changes);

			if (/*data*/ ctx[0].length > 1) {
				if (if_block0) {
					if_block0.p(ctx, dirty);
				} else {
					if_block0 = create_if_block_10(ctx);
					if_block0.c();
					if_block0.m(div3, t4);
				}
			} else if (if_block0) {
				if_block0.d(1);
				if_block0 = null;
			}

			if (/*payloads*/ ctx[9]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_9(ctx);
					if_block1.c();
					if_block1.m(div3, t5);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if ((!current || dirty[0] & /*currentData*/ 32) && t8_value !== (t8_value = /*currentData*/ ctx[5].usage + "")) set_data_dev(t8, t8_value);

			if (dirty[0] & /*displayProps*/ 1024) {
				each_value_4 = /*displayProps*/ ctx[10];
				validate_each_argument(each_value_4);
				let i;

				for (i = 0; i < each_value_4.length; i += 1) {
					const child_ctx = get_each_context_4(ctx, each_value_4, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
						transition_in(each_blocks[i], 1);
					} else {
						each_blocks[i] = create_each_block_4(child_ctx);
						each_blocks[i].c();
						transition_in(each_blocks[i], 1);
						each_blocks[i].m(div2, null);
					}
				}

				group_outros();

				for (i = each_value_4.length; i < each_blocks.length; i += 1) {
					out(i);
				}

				check_outros();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block2 = if_blocks[current_block_type_index];

				if (!if_block2) {
					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block2.c();
				} else {
					if_block2.p(ctx, dirty);
				}

				transition_in(if_block2, 1);
				if_block2.m(div4, null);
			}
		},
		i: function intro(local) {
			if (current) return;
			transition_in(elements.$$.fragment, local);

			for (let i = 0; i < each_value_4.length; i += 1) {
				transition_in(each_blocks[i]);
			}

			transition_in(if_block2);
			current = true;
		},
		o: function outro(local) {
			transition_out(elements.$$.fragment, local);
			each_blocks = each_blocks.filter(Boolean);

			for (let i = 0; i < each_blocks.length; i += 1) {
				transition_out(each_blocks[i]);
			}

			transition_out(if_block2);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(main);
			destroy_component(elements);
			if (if_block0) if_block0.d();
			if (if_block1) if_block1.d();
			destroy_each(each_blocks, detaching);
			if_blocks[current_block_type_index].d();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function preload({ params, query }) {
	return lookup[params.slug];
}

function instance_1($$self, $$props, $$invalidate) {
	let isSVG;
	let component;
	let selected;
	let currentData;
	let payloads;
	let displayProps;
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('U5Bslugu5D', slots, []);
	const makeKeyedEmptyString = makeKeyed('');
	let { data } = $$props;
	let { doc } = $$props;
	let { events } = $$props;
	let { name } = $$props;
	let { namespace } = $$props;
	let { title } = $$props;
	let instance;
	let width;
	let height;

	const makeEventHandler = eventName => event => {
		$$invalidate(9, payloads = setIn(payloads, eventName, JSON.stringify(event.detail)));
	};

	let eventRemovers = [];

	$$self.$$.on_mount.push(function () {
		if (data === undefined && !('data' in $$props || $$self.$$.bound[$$self.$$.props['data']])) {
			console.warn("<U5Bslugu5D> was created without expected prop 'data'");
		}

		if (doc === undefined && !('doc' in $$props || $$self.$$.bound[$$self.$$.props['doc']])) {
			console.warn("<U5Bslugu5D> was created without expected prop 'doc'");
		}

		if (events === undefined && !('events' in $$props || $$self.$$.bound[$$self.$$.props['events']])) {
			console.warn("<U5Bslugu5D> was created without expected prop 'events'");
		}

		if (name === undefined && !('name' in $$props || $$self.$$.bound[$$self.$$.props['name']])) {
			console.warn("<U5Bslugu5D> was created without expected prop 'name'");
		}

		if (namespace === undefined && !('namespace' in $$props || $$self.$$.bound[$$self.$$.props['namespace']])) {
			console.warn("<U5Bslugu5D> was created without expected prop 'namespace'");
		}

		if (title === undefined && !('title' in $$props || $$self.$$.bound[$$self.$$.props['title']])) {
			console.warn("<U5Bslugu5D> was created without expected prop 'title'");
		}
	});

	const writable_props = ['data', 'doc', 'events', 'name', 'namespace', 'title'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<U5Bslugu5D> was created with unknown prop '${key}'`);
	});

	const change_handler = event => {
		$$invalidate(6, selected = Number(event.target.value));
	};

	function switch_instance_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			instance = $$value;
			$$invalidate(4, instance);
		});
	}

	function div_elementresize_handler() {
		width = this.clientWidth;
		height = this.clientHeight;
		$$invalidate(7, width);
		$$invalidate(8, height);
	}

	function switch_instance_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			instance = $$value;
			$$invalidate(4, instance);
		});
	}

	$$self.$$set = $$props => {
		if ('data' in $$props) $$invalidate(0, data = $$props.data);
		if ('doc' in $$props) $$invalidate(1, doc = $$props.doc);
		if ('events' in $$props) $$invalidate(14, events = $$props.events);
		if ('name' in $$props) $$invalidate(2, name = $$props.name);
		if ('namespace' in $$props) $$invalidate(13, namespace = $$props.namespace);
		if ('title' in $$props) $$invalidate(3, title = $$props.title);
	};

	$$self.$capture_state = () => ({
		lookup,
		preload,
		makeKeyed,
		_,
		JSONTree: Root,
		Elements,
		components,
		makeKeyedEmptyString,
		data,
		doc,
		events,
		name,
		namespace,
		title,
		instance,
		width,
		height,
		makeEventHandler,
		eventRemovers,
		payloads,
		currentData,
		displayProps,
		selected,
		component,
		isSVG
	});

	$$self.$inject_state = $$props => {
		if ('data' in $$props) $$invalidate(0, data = $$props.data);
		if ('doc' in $$props) $$invalidate(1, doc = $$props.doc);
		if ('events' in $$props) $$invalidate(14, events = $$props.events);
		if ('name' in $$props) $$invalidate(2, name = $$props.name);
		if ('namespace' in $$props) $$invalidate(13, namespace = $$props.namespace);
		if ('title' in $$props) $$invalidate(3, title = $$props.title);
		if ('instance' in $$props) $$invalidate(4, instance = $$props.instance);
		if ('width' in $$props) $$invalidate(7, width = $$props.width);
		if ('height' in $$props) $$invalidate(8, height = $$props.height);
		if ('eventRemovers' in $$props) $$invalidate(15, eventRemovers = $$props.eventRemovers);
		if ('payloads' in $$props) $$invalidate(9, payloads = $$props.payloads);
		if ('currentData' in $$props) $$invalidate(5, currentData = $$props.currentData);
		if ('displayProps' in $$props) $$invalidate(10, displayProps = $$props.displayProps);
		if ('selected' in $$props) $$invalidate(6, selected = $$props.selected);
		if ('component' in $$props) $$invalidate(11, component = $$props.component);
		if ('isSVG' in $$props) $$invalidate(12, isSVG = $$props.isSVG);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*namespace*/ 8192) {
			// FIXME https://github.com/sveltejs/svelte/issues/4442
			$$invalidate(13, namespace = namespace || 'html');
		}

		if ($$self.$$.dirty[0] & /*namespace*/ 8192) {
			$$invalidate(12, isSVG = namespace === 'svg');
		}

		if ($$self.$$.dirty[0] & /*name*/ 4) {
			$$invalidate(11, component = components[name]);
		}

		if ($$self.$$.dirty[0] & /*data*/ 1) {
			$$invalidate(6, selected = data && 0);
		}

		if ($$self.$$.dirty[0] & /*data, selected*/ 65) {
			$$invalidate(5, currentData = data[selected]);
		}

		if ($$self.$$.dirty[0] & /*currentData, events*/ 16416) {
			$$invalidate(9, payloads = currentData && events
			? makeKeyedEmptyString(events)
			: null);
		}

		if ($$self.$$.dirty[0] & /*currentData*/ 32) {
			$$invalidate(10, displayProps = pairs$1(currentData.props));
		}

		if ($$self.$$.dirty[0] & /*data, instance, eventRemovers, events*/ 49169) {
			if (data && instance) {
				eventRemovers.forEach(remove => remove());
				$$invalidate(15, eventRemovers = []);

				events && events.forEach(eventName => {
					const eventHandler = makeEventHandler(eventName);
					const eventRemover = instance.$on(eventName, eventHandler);
					eventRemovers.push(eventRemover);
				});
			}
		}
	};

	return [
		data,
		doc,
		name,
		title,
		instance,
		currentData,
		selected,
		width,
		height,
		payloads,
		displayProps,
		component,
		isSVG,
		namespace,
		events,
		eventRemovers,
		change_handler,
		switch_instance_binding,
		div_elementresize_handler,
		switch_instance_binding_1
	];
}

class U5Bslugu5D extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(
			this,
			options,
			instance_1,
			create_fragment,
			safe_not_equal,
			{
				data: 0,
				doc: 1,
				events: 14,
				name: 2,
				namespace: 13,
				title: 3
			},
			null,
			[-1, -1]
		);

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "U5Bslugu5D",
			options,
			id: create_fragment.name
		});
	}

	get data() {
		throw new Error("<U5Bslugu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set data(value) {
		throw new Error("<U5Bslugu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get doc() {
		throw new Error("<U5Bslugu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set doc(value) {
		throw new Error("<U5Bslugu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get events() {
		throw new Error("<U5Bslugu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set events(value) {
		throw new Error("<U5Bslugu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<U5Bslugu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<U5Bslugu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get namespace() {
		throw new Error("<U5Bslugu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set namespace(value) {
		throw new Error("<U5Bslugu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get title() {
		throw new Error("<U5Bslugu5D>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set title(value) {
		throw new Error("<U5Bslugu5D>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export { U5Bslugu5D as default, preload };
